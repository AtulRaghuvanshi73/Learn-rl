"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@liveblocks";
exports.ids = ["vendor-chunks/@liveblocks"];
exports.modules = {

/***/ "(ssr)/./node_modules/@liveblocks/core/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@liveblocks/core/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientMsgCode: () => (/* binding */ ClientMsgCode),\n/* harmony export */   CommentsApiError: () => (/* binding */ CommentsApiError),\n/* harmony export */   CrdtType: () => (/* binding */ CrdtType),\n/* harmony export */   DefaultMap: () => (/* binding */ DefaultMap),\n/* harmony export */   DerivedSignal: () => (/* binding */ DerivedSignal),\n/* harmony export */   HttpError: () => (/* binding */ HttpError),\n/* harmony export */   LiveList: () => (/* binding */ LiveList),\n/* harmony export */   LiveMap: () => (/* binding */ LiveMap),\n/* harmony export */   LiveObject: () => (/* binding */ LiveObject),\n/* harmony export */   LiveblocksError: () => (/* binding */ LiveblocksError),\n/* harmony export */   MutableSignal: () => (/* binding */ MutableSignal),\n/* harmony export */   NotificationsApiError: () => (/* binding */ NotificationsApiError),\n/* harmony export */   OpCode: () => (/* binding */ OpCode),\n/* harmony export */   Permission: () => (/* binding */ Permission),\n/* harmony export */   Promise_withResolvers: () => (/* binding */ Promise_withResolvers),\n/* harmony export */   ServerMsgCode: () => (/* binding */ ServerMsgCode),\n/* harmony export */   Signal: () => (/* binding */ Signal),\n/* harmony export */   SortedList: () => (/* binding */ SortedList),\n/* harmony export */   TextEditorType: () => (/* binding */ TextEditorType),\n/* harmony export */   WebsocketCloseCodes: () => (/* binding */ WebsocketCloseCodes),\n/* harmony export */   ackOp: () => (/* binding */ ackOp),\n/* harmony export */   asPos: () => (/* binding */ asPos),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertNever: () => (/* binding */ assertNever),\n/* harmony export */   autoRetry: () => (/* binding */ autoRetry),\n/* harmony export */   b64decode: () => (/* binding */ b64decode),\n/* harmony export */   batch: () => (/* binding */ batch),\n/* harmony export */   checkBounds: () => (/* binding */ checkBounds),\n/* harmony export */   chunk: () => (/* binding */ chunk),\n/* harmony export */   cloneLson: () => (/* binding */ cloneLson),\n/* harmony export */   compactObject: () => (/* binding */ compactObject),\n/* harmony export */   console: () => (/* binding */ fancy_console_exports),\n/* harmony export */   convertToCommentData: () => (/* binding */ convertToCommentData),\n/* harmony export */   convertToCommentUserReaction: () => (/* binding */ convertToCommentUserReaction),\n/* harmony export */   convertToInboxNotificationData: () => (/* binding */ convertToInboxNotificationData),\n/* harmony export */   convertToThreadData: () => (/* binding */ convertToThreadData),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   createCommentAttachmentId: () => (/* binding */ createCommentAttachmentId),\n/* harmony export */   createCommentId: () => (/* binding */ createCommentId),\n/* harmony export */   createInboxNotificationId: () => (/* binding */ createInboxNotificationId),\n/* harmony export */   createManagedPool: () => (/* binding */ createManagedPool),\n/* harmony export */   createThreadId: () => (/* binding */ createThreadId),\n/* harmony export */   createUserNotificationSettings: () => (/* binding */ createUserNotificationSettings),\n/* harmony export */   deprecate: () => (/* binding */ deprecate),\n/* harmony export */   deprecateIf: () => (/* binding */ deprecateIf),\n/* harmony export */   detectDupes: () => (/* binding */ detectDupes),\n/* harmony export */   entries: () => (/* binding */ entries),\n/* harmony export */   errorIf: () => (/* binding */ errorIf),\n/* harmony export */   freeze: () => (/* binding */ freeze),\n/* harmony export */   generateCommentUrl: () => (/* binding */ generateCommentUrl),\n/* harmony export */   getMentionedIdsFromCommentBody: () => (/* binding */ getMentionedIdsFromCommentBody),\n/* harmony export */   html: () => (/* binding */ html),\n/* harmony export */   htmlSafe: () => (/* binding */ htmlSafe),\n/* harmony export */   isChildCrdt: () => (/* binding */ isChildCrdt),\n/* harmony export */   isCommentBodyLink: () => (/* binding */ isCommentBodyLink),\n/* harmony export */   isCommentBodyMention: () => (/* binding */ isCommentBodyMention),\n/* harmony export */   isCommentBodyText: () => (/* binding */ isCommentBodyText),\n/* harmony export */   isJsonArray: () => (/* binding */ isJsonArray),\n/* harmony export */   isJsonObject: () => (/* binding */ isJsonObject),\n/* harmony export */   isJsonScalar: () => (/* binding */ isJsonScalar),\n/* harmony export */   isLiveNode: () => (/* binding */ isLiveNode),\n/* harmony export */   isNotificationChannelEnabled: () => (/* binding */ isNotificationChannelEnabled),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRootCrdt: () => (/* binding */ isRootCrdt),\n/* harmony export */   isStartsWithOperator: () => (/* binding */ isStartsWithOperator),\n/* harmony export */   kInternal: () => (/* binding */ kInternal),\n/* harmony export */   keys: () => (/* binding */ keys),\n/* harmony export */   legacy_patchImmutableObject: () => (/* binding */ legacy_patchImmutableObject),\n/* harmony export */   lsonToJson: () => (/* binding */ lsonToJson),\n/* harmony export */   makeAbortController: () => (/* binding */ makeAbortController),\n/* harmony export */   makeEventSource: () => (/* binding */ makeEventSource),\n/* harmony export */   makePoller: () => (/* binding */ makePoller),\n/* harmony export */   makePosition: () => (/* binding */ makePosition),\n/* harmony export */   mapValues: () => (/* binding */ mapValues),\n/* harmony export */   memoizeOnSuccess: () => (/* binding */ memoizeOnSuccess),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   nn: () => (/* binding */ nn),\n/* harmony export */   objectToQuery: () => (/* binding */ objectToQuery),\n/* harmony export */   patchLiveObjectKey: () => (/* binding */ patchLiveObjectKey),\n/* harmony export */   patchUserNotificationSettings: () => (/* binding */ patchUserNotificationSettings),\n/* harmony export */   raise: () => (/* binding */ raise),\n/* harmony export */   resolveUsersInCommentBody: () => (/* binding */ resolveUsersInCommentBody),\n/* harmony export */   shallow: () => (/* binding */ shallow),\n/* harmony export */   stableStringify: () => (/* binding */ stableStringify),\n/* harmony export */   stringifyCommentBody: () => (/* binding */ stringifyCommentBody),\n/* harmony export */   throwUsageError: () => (/* binding */ throwUsageError),\n/* harmony export */   toAbsoluteUrl: () => (/* binding */ toAbsoluteUrl),\n/* harmony export */   toPlainLson: () => (/* binding */ toPlainLson),\n/* harmony export */   tryParseJson: () => (/* binding */ tryParseJson),\n/* harmony export */   url: () => (/* binding */ url),\n/* harmony export */   urljoin: () => (/* binding */ urljoin),\n/* harmony export */   wait: () => (/* binding */ wait),\n/* harmony export */   withTimeout: () => (/* binding */ withTimeout)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/core\";\nvar PKG_VERSION = \"2.22.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/dupe-detection.ts\nvar g = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {};\nvar crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nvar dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nvar SPACE = \" \";\nfunction error(msg) {\n  if (false) {} else {\n    throw new Error(msg);\n  }\n}\nfunction detectDupes(pkgName, pkgVersion, pkgFormat) {\n  const pkgId = Symbol.for(pkgName);\n  const pkgBuildInfo = pkgFormat ? `${pkgVersion || \"dev\"} (${pkgFormat})` : pkgVersion || \"dev\";\n  if (!g[pkgId]) {\n    g[pkgId] = pkgBuildInfo;\n  } else if (g[pkgId] === pkgBuildInfo) {\n  } else {\n    const msg = [\n      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${dupesDocs + SPACE}`,\n      \"\",\n      \"Conflicts:\",\n      `- ${pkgName} ${g[pkgId]} (already loaded)`,\n      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`\n    ].join(\"\\n\");\n    error(msg);\n  }\n  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n    error(\n      [\n        `Cross-linked versions of Liveblocks found, which will cause issues! See ${crossLinkedDocs + SPACE}`,\n        \"\",\n        \"Conflicts:\",\n        `- ${PKG_NAME} is at ${PKG_VERSION}`,\n        `- ${pkgName} is at ${pkgVersion}`,\n        \"\",\n        \"Always upgrade all Liveblocks packages to the same version number.\"\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// src/convert-plain-data.ts\nfunction convertToCommentData(data) {\n  const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const reactions = data.reactions.map((reaction) => ({\n    ...reaction,\n    createdAt: new Date(reaction.createdAt)\n  }));\n  if (data.body) {\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt\n    };\n  } else {\n    const deletedAt = new Date(data.deletedAt);\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n      deletedAt\n    };\n  }\n}\nfunction convertToThreadData(data) {\n  const createdAt = new Date(data.createdAt);\n  const updatedAt = new Date(data.updatedAt);\n  const comments = data.comments.map(\n    (comment) => convertToCommentData(comment)\n  );\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    comments\n  };\n}\nfunction convertToCommentUserReaction(data) {\n  return {\n    ...data,\n    createdAt: new Date(data.createdAt)\n  };\n}\nfunction convertToInboxNotificationData(data) {\n  const notifiedAt = new Date(data.notifiedAt);\n  const readAt = data.readAt ? new Date(data.readAt) : null;\n  if (\"activities\" in data) {\n    const activities = data.activities.map((activity) => ({\n      ...activity,\n      createdAt: new Date(activity.createdAt)\n    }));\n    return {\n      ...data,\n      notifiedAt,\n      readAt,\n      activities\n    };\n  }\n  return {\n    ...data,\n    notifiedAt,\n    readAt\n  };\n}\nfunction convertToThreadDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\nfunction convertToInboxNotificationDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\n\n// src/lib/fancy-console.ts\nvar fancy_console_exports = {};\n__export(fancy_console_exports, {\n  error: () => error2,\n  errorWithTitle: () => errorWithTitle,\n  warn: () => warn,\n  warnWithTitle: () => warnWithTitle\n});\nvar badge = \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nvar bold = \"font-weight:600\";\nfunction wrap(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (message, ...args) => console[method](\"%cLiveblocks\", badge, message, ...args)\n  );\n}\nvar warn = wrap(\"warn\");\nvar error2 = wrap(\"error\");\nfunction wrapWithTitle(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (title, message, ...args) => console[method](\n      `%cLiveblocks%c ${title}`,\n      badge,\n      bold,\n      message,\n      ...args\n    )\n  );\n}\nvar warnWithTitle = wrapWithTitle(\"warn\");\nvar errorWithTitle = wrapWithTitle(\"error\");\n\n// src/lib/guards.ts\nfunction isPlainObject(blob) {\n  return blob !== null && typeof blob === \"object\" && Object.prototype.toString.call(blob) === \"[object Object]\";\n}\nfunction isStartsWithOperator(blob) {\n  return isPlainObject(blob) && typeof blob.startsWith === \"string\";\n}\n\n// src/lib/utils.ts\nfunction raise(msg) {\n  throw new Error(msg);\n}\nfunction entries(obj) {\n  return Object.entries(obj);\n}\nfunction keys(obj) {\n  return Object.keys(obj);\n}\nfunction values(obj) {\n  return Object.values(obj);\n}\nfunction create(obj, descriptors) {\n  if (typeof descriptors !== \"undefined\") {\n    return Object.create(obj, descriptors);\n  }\n  return Object.create(obj);\n}\nfunction mapValues(obj, mapFn) {\n  const result = {};\n  for (const pair of Object.entries(obj)) {\n    const key = pair[0];\n    if (key === \"__proto__\") {\n      continue;\n    }\n    const value = pair[1];\n    result[key] = mapFn(value, key);\n  }\n  return result;\n}\nfunction tryParseJson(rawMessage) {\n  try {\n    return JSON.parse(rawMessage);\n  } catch (e) {\n    return void 0;\n  }\n}\nfunction deepClone(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nfunction b64decode(b64value) {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(\n      atob(formattedValue).split(\"\").map(function(c) {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(\"\")\n    );\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n}\nfunction compact(items) {\n  return items.filter(\n    (item) => item !== null && item !== void 0\n  );\n}\nfunction compactObject(obj) {\n  const newObj = { ...obj };\n  Object.keys(obj).forEach((k) => {\n    const key = k;\n    if (newObj[key] === void 0) {\n      delete newObj[key];\n    }\n  });\n  return newObj;\n}\nfunction wait(millis) {\n  return new Promise((res) => setTimeout(res, millis));\n}\nasync function withTimeout(promise, millis, errmsg) {\n  let timerID;\n  const timer$ = new Promise((_, reject) => {\n    timerID = setTimeout(() => {\n      reject(new Error(errmsg));\n    }, millis);\n  });\n  return Promise.race([promise, timer$]).finally(() => clearTimeout(timerID));\n}\nfunction memoizeOnSuccess(factoryFn) {\n  let cached = null;\n  return () => {\n    if (cached === null) {\n      cached = factoryFn().catch((err) => {\n        setTimeout(() => {\n          cached = null;\n        }, 5e3);\n        throw err;\n      });\n    }\n    return cached;\n  };\n}\n\n// src/lib/autoRetry.ts\nvar HttpError = class _HttpError extends Error {\n  response;\n  details;\n  constructor(message, response, details) {\n    super(message);\n    this.name = \"HttpError\";\n    this.response = response;\n    this.details = details;\n  }\n  static async fromResponse(response) {\n    let bodyAsText;\n    try {\n      bodyAsText = await response.text();\n    } catch {\n    }\n    const bodyAsJson = bodyAsText ? tryParseJson(bodyAsText) : void 0;\n    let bodyAsJsonObject;\n    if (isPlainObject(bodyAsJson)) {\n      bodyAsJsonObject = bodyAsJson;\n    }\n    let message = \"\";\n    message ||= typeof bodyAsJsonObject?.message === \"string\" ? bodyAsJsonObject.message : \"\";\n    message ||= typeof bodyAsJsonObject?.error === \"string\" ? bodyAsJsonObject.error : \"\";\n    if (bodyAsJson === void 0) {\n      message ||= bodyAsText || \"\";\n    }\n    message ||= response.statusText;\n    let path;\n    try {\n      path = new URL(response.url).pathname;\n    } catch {\n    }\n    message += path !== void 0 ? ` (got status ${response.status} from ${path})` : ` (got status ${response.status})`;\n    const details = bodyAsJsonObject;\n    return new _HttpError(message, response, details);\n  }\n  /**\n   * Convenience accessor for response.status.\n   */\n  get status() {\n    return this.response.status;\n  }\n};\nvar DONT_RETRY_4XX = (x) => x instanceof HttpError && x.status >= 400 && x.status < 500;\nasync function autoRetry(promiseFn, maxTries, backoff, shouldStopRetrying = DONT_RETRY_4XX) {\n  const fallbackBackoff = backoff.length > 0 ? backoff[backoff.length - 1] : 0;\n  let attempt = 0;\n  while (true) {\n    attempt++;\n    try {\n      return await promiseFn();\n    } catch (err) {\n      if (shouldStopRetrying(err)) {\n        throw err;\n      }\n      if (attempt >= maxTries) {\n        throw new Error(`Failed after ${maxTries} attempts: ${String(err)}`);\n      }\n    }\n    const delay = backoff[attempt - 1] ?? fallbackBackoff;\n    warn(\n      `Attempt ${attempt} was unsuccessful. Retrying in ${delay} milliseconds.`\n    );\n    await wait(delay);\n  }\n}\n\n// src/lib/controlledPromise.ts\nfunction controlledPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return [promise, resolve, reject];\n}\nfunction Promise_withResolvers() {\n  const [promise, resolve, reject] = controlledPromise();\n  return { promise, resolve, reject };\n}\n\n// src/lib/EventSource.ts\nfunction makeEventSource() {\n  const _observers = /* @__PURE__ */ new Set();\n  function subscribe(callback) {\n    _observers.add(callback);\n    return () => _observers.delete(callback);\n  }\n  function subscribeOnce(callback) {\n    const unsub = subscribe((event) => {\n      unsub();\n      return callback(event);\n    });\n    return unsub;\n  }\n  async function waitUntil(predicate) {\n    let unsub;\n    return new Promise((res) => {\n      unsub = subscribe((event) => {\n        if (predicate === void 0 || predicate(event)) {\n          res(event);\n        }\n      });\n    }).finally(() => unsub?.());\n  }\n  function notify(event) {\n    let called = false;\n    for (const callback of _observers) {\n      callback(event);\n      called = true;\n    }\n    return called;\n  }\n  function count() {\n    return _observers.size;\n  }\n  return {\n    // Private/internal control over event emission\n    notify,\n    subscribe,\n    subscribeOnce,\n    count,\n    waitUntil,\n    [Symbol.dispose]: () => {\n      _observers.clear();\n    },\n    // Publicly exposable subscription API\n    observable: {\n      subscribe,\n      subscribeOnce,\n      waitUntil\n    }\n  };\n}\nfunction makeBufferableEventSource() {\n  const eventSource2 = makeEventSource();\n  let _buffer = null;\n  function pause() {\n    _buffer = [];\n  }\n  function unpause() {\n    if (_buffer === null) {\n      return;\n    }\n    for (const event of _buffer) {\n      eventSource2.notify(event);\n    }\n    _buffer = null;\n  }\n  function notifyOrBuffer(event) {\n    if (_buffer !== null) {\n      _buffer.push(event);\n      return false;\n    } else {\n      return eventSource2.notify(event);\n    }\n  }\n  return {\n    ...eventSource2,\n    notify: notifyOrBuffer,\n    pause,\n    unpause,\n    [Symbol.dispose]: () => {\n      eventSource2[Symbol.dispose]();\n      if (_buffer !== null) {\n        _buffer.length = 0;\n      }\n    }\n  };\n}\n\n// src/lib/freeze.ts\nvar freeze =  false ? (\n  /* istanbul ignore next */\n  0\n) : Object.freeze;\n\n// src/lib/signals.ts\nvar kSinks = Symbol(\"kSinks\");\nvar kTrigger = Symbol(\"kTrigger\");\nvar signalsToTrigger = null;\nvar trackedReads = null;\nfunction batch(callback) {\n  if (signalsToTrigger !== null) {\n    callback();\n    return;\n  }\n  signalsToTrigger = /* @__PURE__ */ new Set();\n  try {\n    callback();\n  } finally {\n    for (const signal of signalsToTrigger) {\n      signal[kTrigger]();\n    }\n    signalsToTrigger = null;\n  }\n}\nfunction enqueueTrigger(signal) {\n  if (!signalsToTrigger) raise(\"Expected to be in an active batch\");\n  signalsToTrigger.add(signal);\n}\nfunction merge(target, patch) {\n  let updated = false;\n  const newValue = { ...target };\n  Object.keys(patch).forEach((k) => {\n    const key = k;\n    const val = patch[key];\n    if (newValue[key] !== val) {\n      if (val === void 0) {\n        delete newValue[key];\n      } else {\n        newValue[key] = val;\n      }\n      updated = true;\n    }\n  });\n  return updated ? newValue : target;\n}\nvar AbstractSignal = class {\n  /** @internal */\n  equals;\n  #eventSource;\n  /** @internal */\n  [kSinks];\n  constructor(equals) {\n    this.equals = equals ?? Object.is;\n    this.#eventSource = makeEventSource();\n    this[kSinks] = /* @__PURE__ */ new Set();\n    this.get = this.get.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n    this.subscribeOnce = this.subscribeOnce.bind(this);\n  }\n  [Symbol.dispose]() {\n    this.#eventSource[Symbol.dispose]();\n    this.#eventSource = \"(disposed)\";\n    this.equals = \"(disposed)\";\n  }\n  get hasWatchers() {\n    if (this.#eventSource.count() > 0) return true;\n    for (const sink of this[kSinks]) {\n      if (sink.hasWatchers) {\n        return true;\n      }\n    }\n    return false;\n  }\n  [kTrigger]() {\n    this.#eventSource.notify();\n    for (const sink of this[kSinks]) {\n      enqueueTrigger(sink);\n    }\n  }\n  subscribe(callback) {\n    if (this.#eventSource.count() === 0) {\n      this.get();\n    }\n    return this.#eventSource.subscribe(callback);\n  }\n  subscribeOnce(callback) {\n    const unsub = this.subscribe(() => {\n      unsub();\n      return callback();\n    });\n    return unsub;\n  }\n  waitUntil() {\n    throw new Error(\"waitUntil not supported on Signals\");\n  }\n  markSinksDirty() {\n    for (const sink of this[kSinks]) {\n      sink.markDirty();\n    }\n  }\n  addSink(sink) {\n    this[kSinks].add(sink);\n  }\n  removeSink(sink) {\n    this[kSinks].delete(sink);\n  }\n  asReadonly() {\n    return this;\n  }\n};\nvar Signal = class extends AbstractSignal {\n  #value;\n  constructor(value, equals) {\n    super(equals);\n    this.#value = freeze(value);\n  }\n  [Symbol.dispose]() {\n    super[Symbol.dispose]();\n    this.#value = \"(disposed)\";\n  }\n  get() {\n    trackedReads?.add(this);\n    return this.#value;\n  }\n  set(newValue) {\n    batch(() => {\n      if (typeof newValue === \"function\") {\n        newValue = newValue(this.#value);\n      }\n      if (!this.equals(this.#value, newValue)) {\n        this.#value = freeze(newValue);\n        this.markSinksDirty();\n        enqueueTrigger(this);\n      }\n    });\n  }\n};\nvar PatchableSignal = class extends Signal {\n  constructor(data) {\n    super(freeze(compactObject(data)));\n  }\n  set() {\n    throw new Error(\"Don't call .set() directly, use .patch()\");\n  }\n  /**\n   * Patches the current object.\n   */\n  patch(patch) {\n    super.set((old) => merge(old, patch));\n  }\n};\nvar INITIAL = Symbol();\nvar DerivedSignal = class _DerivedSignal extends AbstractSignal {\n  #prevValue;\n  #dirty;\n  // When true, the value in #value may not be up-to-date and needs re-checking\n  #sources;\n  #deps;\n  #transform;\n  // prettier-ignore\n  static from(...args) {\n    const last = args.pop();\n    if (typeof last !== \"function\")\n      raise(\"Invalid .from() call, last argument expected to be a function\");\n    if (typeof args[args.length - 1] === \"function\") {\n      const equals = last;\n      const transform = args.pop();\n      return new _DerivedSignal(args, transform, equals);\n    } else {\n      const transform = last;\n      return new _DerivedSignal(args, transform);\n    }\n  }\n  constructor(deps, transform, equals) {\n    super(equals);\n    this.#dirty = true;\n    this.#prevValue = INITIAL;\n    this.#deps = deps;\n    this.#sources = /* @__PURE__ */ new Set();\n    this.#transform = transform;\n  }\n  [Symbol.dispose]() {\n    for (const src of this.#sources) {\n      src.removeSink(this);\n    }\n    this.#prevValue = \"(disposed)\";\n    this.#sources = \"(disposed)\";\n    this.#deps = \"(disposed)\";\n    this.#transform = \"(disposed)\";\n  }\n  get isDirty() {\n    return this.#dirty;\n  }\n  #recompute() {\n    const oldTrackedReads = trackedReads;\n    let derived;\n    trackedReads = /* @__PURE__ */ new Set();\n    try {\n      derived = this.#transform(...this.#deps.map((p) => p.get()));\n    } finally {\n      const oldSources = this.#sources;\n      this.#sources = /* @__PURE__ */ new Set();\n      for (const sig of trackedReads) {\n        this.#sources.add(sig);\n        oldSources.delete(sig);\n      }\n      for (const oldSource of oldSources) {\n        oldSource.removeSink(this);\n      }\n      for (const newSource of this.#sources) {\n        newSource.addSink(this);\n      }\n      trackedReads = oldTrackedReads;\n    }\n    this.#dirty = false;\n    if (!this.equals(this.#prevValue, derived)) {\n      this.#prevValue = derived;\n      return true;\n    }\n    return false;\n  }\n  markDirty() {\n    if (!this.#dirty) {\n      this.#dirty = true;\n      this.markSinksDirty();\n    }\n  }\n  get() {\n    if (this.#dirty) {\n      this.#recompute();\n    }\n    trackedReads?.add(this);\n    return this.#prevValue;\n  }\n  /**\n   * Called by the Signal system if one or more of the dependent signals have\n   * changed. In the case of a DerivedSignal, we'll only want to re-evaluate\n   * the actual value if it's being watched, or any of their sinks are being\n   * watched actively.\n   */\n  [kTrigger]() {\n    if (!this.hasWatchers) {\n      return;\n    }\n    const updated = this.#recompute();\n    if (updated) {\n      super[kTrigger]();\n    }\n  }\n};\nvar MutableSignal = class extends AbstractSignal {\n  #state;\n  constructor(initialState) {\n    super();\n    this.#state = initialState;\n  }\n  [Symbol.dispose]() {\n    super[Symbol.dispose]();\n    this.#state = \"(disposed)\";\n  }\n  get() {\n    trackedReads?.add(this);\n    return this.#state;\n  }\n  /**\n   * Invokes a callback function that is allowed to mutate the given state\n   * value. Do not change the value outside of the callback.\n   *\n   * If the callback explicitly returns `false`, it's assumed that the state\n   * was not changed.\n   */\n  mutate(callback) {\n    batch(() => {\n      const result = callback ? callback(this.#state) : true;\n      if (result !== null && typeof result === \"object\" && \"then\" in result) {\n        raise(\"MutableSignal.mutate() does not support async callbacks\");\n      }\n      if (result !== false) {\n        this.markSinksDirty();\n        enqueueTrigger(this);\n      }\n    });\n  }\n};\n\n// src/lib/stringify.ts\nfunction replacer(_key, value) {\n  return value !== null && typeof value === \"object\" && !Array.isArray(value) ? Object.keys(value).sort().reduce((sorted, key) => {\n    sorted[key] = value[key];\n    return sorted;\n  }, {}) : value;\n}\nfunction stableStringify(value) {\n  return JSON.stringify(value, replacer);\n}\nfunction stringifyOrLog(value) {\n  try {\n    return JSON.stringify(value);\n  } catch (err) {\n    console.error(`Could not stringify: ${err.message}`);\n    console.error(value);\n    throw err;\n  }\n}\n\n// src/lib/batch.ts\nvar DEFAULT_SIZE = 50;\nvar BatchCall = class {\n  input;\n  resolve;\n  reject;\n  promise;\n  constructor(input) {\n    this.input = input;\n    const { promise, resolve, reject } = Promise_withResolvers();\n    this.promise = promise;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n};\nvar Batch = class {\n  #queue = [];\n  #callback;\n  #size;\n  #delay;\n  #delayTimeoutId;\n  error = false;\n  constructor(callback, options) {\n    this.#callback = callback;\n    this.#size = options.size ?? DEFAULT_SIZE;\n    this.#delay = options.delay;\n  }\n  #clearDelayTimeout() {\n    if (this.#delayTimeoutId !== void 0) {\n      clearTimeout(this.#delayTimeoutId);\n      this.#delayTimeoutId = void 0;\n    }\n  }\n  #schedule() {\n    if (this.#queue.length === this.#size) {\n      void this.#flush();\n    } else if (this.#queue.length === 1) {\n      this.#clearDelayTimeout();\n      this.#delayTimeoutId = setTimeout(() => void this.#flush(), this.#delay);\n    }\n  }\n  async #flush() {\n    if (this.#queue.length === 0) {\n      return;\n    }\n    const calls = this.#queue.splice(0);\n    const inputs = calls.map((call) => call.input);\n    try {\n      const results = await this.#callback(inputs);\n      this.error = false;\n      calls.forEach((call, index) => {\n        const result = results?.[index];\n        if (!Array.isArray(results)) {\n          call.reject(new Error(\"Callback must return an array.\"));\n        } else if (calls.length !== results.length) {\n          call.reject(\n            new Error(\n              `Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`\n            )\n          );\n        } else if (result instanceof Error) {\n          call.reject(result);\n        } else {\n          call.resolve(result);\n        }\n      });\n    } catch (error3) {\n      this.error = true;\n      calls.forEach((call) => {\n        call.reject(error3);\n      });\n    }\n  }\n  get(input) {\n    const existingCall = this.#queue.find(\n      (call2) => stableStringify(call2.input) === stableStringify(input)\n    );\n    if (existingCall) {\n      return existingCall.promise;\n    }\n    const call = new BatchCall(input);\n    this.#queue.push(call);\n    this.#schedule();\n    return call.promise;\n  }\n  clear() {\n    this.#queue = [];\n    this.error = false;\n    this.#clearDelayTimeout();\n  }\n};\nfunction createBatchStore(batch2) {\n  const signal = new MutableSignal(/* @__PURE__ */ new Map());\n  function getCacheKey(args) {\n    return stableStringify(args);\n  }\n  function update(cacheKey, state) {\n    signal.mutate((cache) => {\n      cache.set(cacheKey, state);\n    });\n  }\n  function invalidate(inputs) {\n    signal.mutate((cache) => {\n      if (Array.isArray(inputs)) {\n        for (const input of inputs) {\n          cache.delete(getCacheKey(input));\n        }\n      } else {\n        cache.clear();\n      }\n    });\n  }\n  async function enqueue(input) {\n    const cacheKey = getCacheKey(input);\n    const cache = signal.get();\n    if (cache.has(cacheKey)) {\n      return;\n    }\n    try {\n      update(cacheKey, { isLoading: true });\n      const result = await batch2.get(input);\n      update(cacheKey, { isLoading: false, data: result });\n    } catch (error3) {\n      update(cacheKey, {\n        isLoading: false,\n        error: error3\n      });\n    }\n  }\n  function getItemState(input) {\n    const cacheKey = getCacheKey(input);\n    const cache = signal.get();\n    return cache.get(cacheKey);\n  }\n  function _cacheKeys() {\n    const cache = signal.get();\n    return [...cache.keys()];\n  }\n  return {\n    subscribe: signal.subscribe,\n    enqueue,\n    getItemState,\n    invalidate,\n    batch: batch2,\n    _cacheKeys\n  };\n}\n\n// src/lib/chunk.ts\nfunction chunk(array, size) {\n  const chunks = [];\n  for (let i = 0, j = array.length; i < j; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\n\n// src/lib/nanoid.ts\nvar nanoid = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce(\n  (t2, e) => t2 += (e &= 63) < 36 ? e.toString(36) : e < 62 ? (e - 26).toString(36).toUpperCase() : e < 63 ? \"_\" : \"-\",\n  \"\"\n);\n\n// src/lib/createIds.ts\nvar THREAD_ID_PREFIX = \"th\";\nvar COMMENT_ID_PREFIX = \"cm\";\nvar COMMENT_ATTACHMENT_ID_PREFIX = \"at\";\nvar INBOX_NOTIFICATION_ID_PREFIX = \"in\";\nfunction createOptimisticId(prefix) {\n  return `${prefix}_${nanoid()}`;\n}\nfunction createThreadId() {\n  return createOptimisticId(THREAD_ID_PREFIX);\n}\nfunction createCommentId() {\n  return createOptimisticId(COMMENT_ID_PREFIX);\n}\nfunction createCommentAttachmentId() {\n  return createOptimisticId(COMMENT_ATTACHMENT_ID_PREFIX);\n}\nfunction createInboxNotificationId() {\n  return createOptimisticId(INBOX_NOTIFICATION_ID_PREFIX);\n}\n\n// src/lib/DefaultMap.ts\nvar DefaultMap = class extends Map {\n  #defaultFn;\n  /**\n   * If the default function is not provided to the constructor, it has to be\n   * provided in each .getOrCreate() call individually.\n   */\n  constructor(defaultFn, entries2) {\n    super(entries2);\n    this.#defaultFn = defaultFn;\n  }\n  /**\n   * Gets the value at the given key, or creates it.\n   *\n   * Difference from normal Map: if the key does not exist, it will be created\n   * on the fly using the factory function, and that value will get returned\n   * instead of `undefined`.\n   */\n  getOrCreate(key, defaultFn) {\n    if (super.has(key)) {\n      return super.get(key);\n    } else {\n      const fn = defaultFn ?? this.#defaultFn ?? raise(\"DefaultMap used without a factory function\");\n      const value = fn(key);\n      this.set(key, value);\n      return value;\n    }\n  }\n};\n\n// src/lib/objectToQuery.ts\nvar identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\nfunction objectToQuery(obj) {\n  let filterList = [];\n  const entries2 = Object.entries(obj);\n  const keyValuePairs = [];\n  const keyValuePairsWithOperator = [];\n  const indexedKeys = [];\n  entries2.forEach(([key, value]) => {\n    if (!identifierRegex.test(key)) {\n      throw new Error(\"Key must only contain letters, numbers, _\");\n    }\n    if (isSimpleValue(value)) {\n      keyValuePairs.push([key, value]);\n    } else if (isPlainObject(value)) {\n      if (isStartsWithOperator(value)) {\n        keyValuePairsWithOperator.push([key, value]);\n      } else {\n        indexedKeys.push([key, value]);\n      }\n    }\n  });\n  filterList = [\n    ...getFiltersFromKeyValuePairs(keyValuePairs),\n    ...getFiltersFromKeyValuePairsWithOperator(keyValuePairsWithOperator)\n  ];\n  indexedKeys.forEach(([key, value]) => {\n    const nestedEntries = Object.entries(value);\n    const nKeyValuePairs = [];\n    const nKeyValuePairsWithOperator = [];\n    nestedEntries.forEach(([nestedKey, nestedValue]) => {\n      if (isStringEmpty(nestedKey)) {\n        throw new Error(\"Key cannot be empty\");\n      }\n      if (isSimpleValue(nestedValue)) {\n        nKeyValuePairs.push([formatFilterKey(key, nestedKey), nestedValue]);\n      } else if (isStartsWithOperator(nestedValue)) {\n        nKeyValuePairsWithOperator.push([\n          formatFilterKey(key, nestedKey),\n          nestedValue\n        ]);\n      }\n    });\n    filterList = [\n      ...filterList,\n      ...getFiltersFromKeyValuePairs(nKeyValuePairs),\n      ...getFiltersFromKeyValuePairsWithOperator(nKeyValuePairsWithOperator)\n    ];\n  });\n  return filterList.map(({ key, operator, value }) => `${key}${operator}${quote(value)}`).join(\" \");\n}\nvar getFiltersFromKeyValuePairs = (keyValuePairs) => {\n  const filters = [];\n  keyValuePairs.forEach(([key, value]) => {\n    filters.push({\n      key,\n      operator: \":\",\n      value\n    });\n  });\n  return filters;\n};\nvar getFiltersFromKeyValuePairsWithOperator = (keyValuePairsWithOperator) => {\n  const filters = [];\n  keyValuePairsWithOperator.forEach(([key, value]) => {\n    if (\"startsWith\" in value && typeof value.startsWith === \"string\") {\n      filters.push({\n        key,\n        operator: \"^\",\n        value: value.startsWith\n      });\n    }\n  });\n  return filters;\n};\nvar isSimpleValue = (value) => {\n  return typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\" || value === null;\n};\nvar formatFilterKey = (key, nestedKey) => {\n  if (nestedKey) {\n    return `${key}[${quote(nestedKey)}]`;\n  }\n  return key;\n};\nvar isStringEmpty = (value) => {\n  return !value || value.toString().trim() === \"\";\n};\nfunction quote(input) {\n  const result = JSON.stringify(input);\n  if (typeof input !== \"string\") {\n    return result;\n  }\n  if (result.includes(\"'\")) {\n    return result;\n  }\n  return `'${result.slice(1, -1).replace(/\\\\\"/g, '\"')}'`;\n}\n\n// src/lib/url.ts\nfunction toURLSearchParams(params) {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\nfunction urljoin(baseUrl, path, params) {\n  const url2 = new URL(path, baseUrl);\n  if (params !== void 0) {\n    url2.search = (params instanceof URLSearchParams ? params : toURLSearchParams(params)).toString();\n  }\n  return url2.toString();\n}\nfunction url(strings, ...values2) {\n  return strings.reduce(\n    (result, str, i) => result + encodeURIComponent(values2[i - 1] ?? \"\") + str\n  );\n}\n\n// src/api-client.ts\nfunction createApiClient({\n  baseUrl,\n  authManager,\n  fetchPolyfill\n}) {\n  const httpClient = new HttpClient(baseUrl, fetchPolyfill);\n  async function getThreadsSince(options) {\n    const result = await httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/threads/delta`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        since: options.since.toISOString()\n      },\n      { signal: options.signal }\n    );\n    return {\n      threads: {\n        updated: result.data.map(convertToThreadData),\n        deleted: result.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      inboxNotifications: {\n        updated: result.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: result.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      requestedAt: new Date(result.meta.requestedAt),\n      permissionHints: result.meta.permissionHints\n    };\n  }\n  async function getThreads(options) {\n    let query;\n    if (options.query) {\n      query = objectToQuery(options.query);\n    }\n    const PAGE_SIZE = 50;\n    try {\n      const result = await httpClient.get(\n        url`/v2/c/rooms/${options.roomId}/threads`,\n        await authManager.getAuthValue({\n          requestedScope: \"comments:read\",\n          roomId: options.roomId\n        }),\n        {\n          cursor: options.cursor,\n          query,\n          limit: PAGE_SIZE\n        }\n      );\n      return {\n        threads: result.data.map(convertToThreadData),\n        inboxNotifications: result.inboxNotifications.map(\n          convertToInboxNotificationData\n        ),\n        nextCursor: result.meta.nextCursor,\n        requestedAt: new Date(result.meta.requestedAt),\n        permissionHints: result.meta.permissionHints\n      };\n    } catch (err) {\n      if (err instanceof HttpError && err.status === 404) {\n        return {\n          threads: [],\n          inboxNotifications: [],\n          nextCursor: null,\n          //\n          // HACK\n          // requestedAt needs to be a *server* timestamp here. However, on\n          // this 404 error response, there is no such timestamp. So out of\n          // pure necessity we'll fall back to a local timestamp instead (and\n          // allow for a possible 6 hour clock difference between client and\n          // server).\n          //\n          requestedAt: new Date(Date.now() - 6 * 60 * 60 * 1e3),\n          permissionHints: {}\n        };\n      }\n      throw err;\n    }\n  }\n  async function createThread(options) {\n    const commentId = options.commentId ?? createCommentId();\n    const threadId = options.threadId ?? createThreadId();\n    const thread = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        id: threadId,\n        comment: {\n          id: commentId,\n          body: options.body,\n          attachmentIds: options.attachmentIds\n        },\n        metadata: options.metadata\n      }\n    );\n    return convertToThreadData(thread);\n  }\n  async function deleteThread(options) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function getThread(options) {\n    const response = await httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/thread-with-notification/${options.threadId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        thread: convertToThreadData(json.thread),\n        inboxNotification: json.inboxNotification ? convertToInboxNotificationData(json.inboxNotification) : void 0\n      };\n    } else if (response.status === 404) {\n      return {\n        thread: void 0,\n        inboxNotification: void 0\n      };\n    } else {\n      throw new Error(\n        `There was an error while getting thread ${options.threadId}.`\n      );\n    }\n  }\n  async function editThreadMetadata(options) {\n    return await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/metadata`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      options.metadata\n    );\n  }\n  async function createComment(options) {\n    const commentId = options.commentId ?? createCommentId();\n    const comment = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        id: commentId,\n        body: options.body,\n        attachmentIds: options.attachmentIds\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function editComment(options) {\n    const comment = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        body: options.body,\n        attachmentIds: options.attachmentIds\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function deleteComment(options) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function addReaction(options) {\n    const reaction = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/reactions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      { emoji: options.emoji }\n    );\n    return convertToCommentUserReaction(reaction);\n  }\n  async function removeReaction(options) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/reactions/${options.emoji}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function markThreadAsResolved(options) {\n    await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/mark-as-resolved`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function markThreadAsUnresolved(options) {\n    await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/mark-as-unresolved`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function uploadAttachment(options) {\n    const roomId = options.roomId;\n    const abortSignal = options.signal;\n    const attachment = options.attachment;\n    const abortError = abortSignal ? new DOMException(\n      `Upload of attachment ${options.attachment.id} was aborted.`,\n      \"AbortError\"\n    ) : void 0;\n    if (abortSignal?.aborted) {\n      throw abortError;\n    }\n    const handleRetryError = (err) => {\n      if (abortSignal?.aborted) {\n        throw abortError;\n      }\n      if (err instanceof HttpError && err.status === 413) {\n        throw err;\n      }\n      return false;\n    };\n    const ATTACHMENT_PART_SIZE = 5 * 1024 * 1024;\n    const RETRY_ATTEMPTS = 10;\n    const RETRY_DELAYS = [\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3\n    ];\n    function splitFileIntoParts(file) {\n      const parts = [];\n      let start = 0;\n      while (start < file.size) {\n        const end = Math.min(start + ATTACHMENT_PART_SIZE, file.size);\n        parts.push({\n          partNumber: parts.length + 1,\n          part: file.slice(start, end)\n        });\n        start = end;\n      }\n      return parts;\n    }\n    if (attachment.size <= ATTACHMENT_PART_SIZE) {\n      return autoRetry(\n        async () => httpClient.putBlob(\n          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.name)}`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          attachment.file,\n          { fileSize: attachment.size },\n          { signal: abortSignal }\n        ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n    } else {\n      let uploadId;\n      const uploadedParts = [];\n      const createMultiPartUpload = await autoRetry(\n        async () => httpClient.post(\n          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.name)}`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          void 0,\n          { signal: abortSignal },\n          { fileSize: attachment.size }\n        ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n      try {\n        uploadId = createMultiPartUpload.uploadId;\n        const parts = splitFileIntoParts(attachment.file);\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n        const batches = chunk(parts, 5);\n        for (const parts2 of batches) {\n          const uploadedPartsPromises = [];\n          for (const { part, partNumber } of parts2) {\n            uploadedPartsPromises.push(\n              autoRetry(\n                async () => httpClient.putBlob(\n                  url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${createMultiPartUpload.uploadId}/${String(partNumber)}`,\n                  await authManager.getAuthValue({\n                    requestedScope: \"comments:read\",\n                    roomId\n                  }),\n                  part,\n                  void 0,\n                  { signal: abortSignal }\n                ),\n                RETRY_ATTEMPTS,\n                RETRY_DELAYS,\n                handleRetryError\n              )\n            );\n          }\n          uploadedParts.push(...await Promise.all(uploadedPartsPromises));\n        }\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n        const sortedUploadedParts = uploadedParts.sort(\n          (a, b) => a.partNumber - b.partNumber\n        );\n        return httpClient.post(\n          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${uploadId}/complete`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          { parts: sortedUploadedParts },\n          { signal: abortSignal }\n        );\n      } catch (error3) {\n        if (uploadId && error3?.name && (error3.name === \"AbortError\" || error3.name === \"TimeoutError\")) {\n          try {\n            await httpClient.rawDelete(\n              url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${uploadId}`,\n              await authManager.getAuthValue({\n                requestedScope: \"comments:read\",\n                roomId\n              })\n            );\n          } catch (error4) {\n          }\n        }\n        throw error3;\n      }\n    }\n  }\n  const attachmentUrlsBatchStoresByRoom = new DefaultMap((roomId) => {\n    const batch2 = new Batch(\n      async (batchedAttachmentIds) => {\n        const attachmentIds = batchedAttachmentIds.flat();\n        const { urls } = await httpClient.post(\n          url`/v2/c/rooms/${roomId}/attachments/presigned-urls`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          { attachmentIds }\n        );\n        return urls.map(\n          (url2) => url2 ?? new Error(\"There was an error while getting this attachment's URL\")\n        );\n      },\n      { delay: 50 }\n    );\n    return createBatchStore(batch2);\n  });\n  function getOrCreateAttachmentUrlsStore(roomId) {\n    return attachmentUrlsBatchStoresByRoom.getOrCreate(roomId);\n  }\n  function getAttachmentUrl(options) {\n    const batch2 = getOrCreateAttachmentUrlsStore(options.roomId).batch;\n    return batch2.get(options.attachmentId);\n  }\n  async function getNotificationSettings(options) {\n    return httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/notification-settings`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      void 0,\n      {\n        signal: options.signal\n      }\n    );\n  }\n  async function updateNotificationSettings(options) {\n    return httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/notification-settings`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      options.settings\n    );\n  }\n  const markAsReadBatchesByRoom = new DefaultMap(\n    (roomId) => new Batch(\n      async (batchedInboxNotificationIds) => {\n        const inboxNotificationIds = batchedInboxNotificationIds.flat();\n        await httpClient.post(\n          url`/v2/c/rooms/${roomId}/inbox-notifications/read`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          { inboxNotificationIds }\n        );\n        return inboxNotificationIds;\n      },\n      { delay: 50 }\n    )\n  );\n  async function markRoomInboxNotificationAsRead(options) {\n    const batch2 = markAsReadBatchesByRoom.getOrCreate(options.roomId);\n    return batch2.get(options.inboxNotificationId);\n  }\n  async function createTextMention(options) {\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/text-mentions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        userId: options.userId,\n        mentionId: options.mentionId\n      }\n    );\n  }\n  async function deleteTextMention(options) {\n    await httpClient.rawDelete(\n      url`/v2/c/rooms/${options.roomId}/text-mentions/${options.mentionId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function getTextVersion(options) {\n    return httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/y-version/${options.versionId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function createTextVersion(options) {\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/version`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function reportTextEditor(options) {\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/text-metadata`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        type: options.type,\n        rootKey: options.rootKey\n      }\n    );\n  }\n  async function executeContextualPrompt(options) {\n    const result = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/ai/contextual-prompt`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId\n      }),\n      {\n        prompt: options.prompt,\n        context: {\n          beforeSelection: options.context.beforeSelection,\n          selection: options.context.selection,\n          afterSelection: options.context.afterSelection\n        },\n        previous: options.previous\n      },\n      { signal: options.signal }\n    );\n    if (!result || result.content.length === 0) {\n      throw new Error(\"No content returned from server\");\n    }\n    return result.content[0].text;\n  }\n  async function listTextVersions(options) {\n    const result = await httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/versions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n    return {\n      versions: result.versions.map(({ createdAt, ...version }) => {\n        return {\n          createdAt: new Date(createdAt),\n          ...version\n        };\n      }),\n      requestedAt: new Date(result.meta.requestedAt)\n    };\n  }\n  async function listTextVersionsSince(options) {\n    const result = await httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/versions/delta`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n    return {\n      versions: result.versions.map(({ createdAt, ...version }) => {\n        return {\n          createdAt: new Date(createdAt),\n          ...version\n        };\n      }),\n      requestedAt: new Date(result.meta.requestedAt)\n    };\n  }\n  async function streamStorage(options) {\n    const result = await httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/storage`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId\n      })\n    );\n    return await result.json();\n  }\n  async function sendMessages(options) {\n    return httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/send-message`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId\n      }),\n      {\n        nonce: options.nonce,\n        messages: options.messages\n      }\n    );\n  }\n  async function getInboxNotifications(options) {\n    const PAGE_SIZE = 50;\n    const json = await httpClient.get(\n      url`/v2/c/inbox-notifications`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        cursor: options?.cursor,\n        limit: PAGE_SIZE\n      }\n    );\n    return {\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      threads: json.threads.map(convertToThreadData),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getInboxNotificationsSince(options) {\n    const json = await httpClient.get(\n      url`/v2/c/inbox-notifications/delta`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n    return {\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getUnreadInboxNotificationsCount() {\n    const { count } = await httpClient.get(\n      url`/v2/c/inbox-notifications/count`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n    return count;\n  }\n  async function markAllInboxNotificationsAsRead() {\n    await httpClient.post(\n      url`/v2/c/inbox-notifications/read`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        inboxNotificationIds: \"all\"\n      }\n    );\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await httpClient.post(\n      url`/v2/c/inbox-notifications/read`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        inboxNotificationIds\n      }\n    );\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: 50 }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  async function deleteAllInboxNotifications() {\n    await httpClient.delete(\n      url`/v2/c/inbox-notifications`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n  }\n  async function deleteInboxNotification(inboxNotificationId) {\n    await httpClient.delete(\n      url`/v2/c/inbox-notifications/${inboxNotificationId}`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n  }\n  async function getUserNotificationSettings(options) {\n    return httpClient.get(\n      url`/v2/c/notification-settings`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      void 0,\n      { signal: options?.signal }\n    );\n  }\n  async function updateUserNotificationSettings(settings) {\n    return httpClient.post(\n      url`/v2/c/notification-settings`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      settings\n    );\n  }\n  async function getUserThreads_experimental(options) {\n    let query;\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n    const PAGE_SIZE = 50;\n    const json = await httpClient.get(\n      url`/v2/c/threads`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        cursor: options?.cursor,\n        query,\n        limit: PAGE_SIZE\n      }\n    );\n    return {\n      threads: json.threads.map(convertToThreadData),\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt),\n      permissionHints: json.meta.permissionHints\n    };\n  }\n  async function getUserThreadsSince_experimental(options) {\n    const json = await httpClient.get(\n      url`/v2/c/threads/delta`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n    return {\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      requestedAt: new Date(json.meta.requestedAt),\n      permissionHints: json.meta.permissionHints\n    };\n  }\n  return {\n    // Room threads\n    getThreads,\n    getThreadsSince,\n    createThread,\n    getThread,\n    deleteThread,\n    editThreadMetadata,\n    createComment,\n    editComment,\n    deleteComment,\n    addReaction,\n    removeReaction,\n    markThreadAsResolved,\n    markThreadAsUnresolved,\n    markRoomInboxNotificationAsRead,\n    // Room notifications\n    getNotificationSettings,\n    updateNotificationSettings,\n    // Room text editor\n    createTextMention,\n    deleteTextMention,\n    getTextVersion,\n    createTextVersion,\n    reportTextEditor,\n    listTextVersions,\n    listTextVersionsSince,\n    // Room attachments\n    getAttachmentUrl,\n    uploadAttachment,\n    getOrCreateAttachmentUrlsStore,\n    // Room storage\n    streamStorage,\n    sendMessages,\n    // Notification\n    getInboxNotifications,\n    getInboxNotificationsSince,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead,\n    deleteAllInboxNotifications,\n    deleteInboxNotification,\n    getUserNotificationSettings,\n    updateUserNotificationSettings,\n    // User threads\n    getUserThreads_experimental,\n    getUserThreadsSince_experimental,\n    // AI\n    executeContextualPrompt\n  };\n}\nfunction getBearerTokenFromAuthValue(authValue) {\n  if (authValue.type === \"public\") {\n    return authValue.publicApiKey;\n  } else {\n    return authValue.token.raw;\n  }\n}\nvar HttpClient = class {\n  #baseUrl;\n  #fetchPolyfill;\n  constructor(baseUrl, fetchPolyfill) {\n    this.#baseUrl = baseUrl;\n    this.#fetchPolyfill = fetchPolyfill;\n  }\n  // ------------------------------------------------------------------\n  // Public methods\n  // ------------------------------------------------------------------\n  /**\n   * Constructs and makes the HTTP request, but does not handle the response.\n   *\n   * This is what .rawFetch() does:     This method!\n   *   1. Set Content-Type header\n   *   2. Set Authorization header\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\n   *\n   * This is what .fetch() does ON TOP of that:\n   *   4. Parse response body as Json\n   *   5. ...but silently return `{}` if that parsing fails\n   *   6. Throw HttpError if response is an error\n   */\n  async #rawFetch(endpoint, authValue, options, params) {\n    if (!endpoint.startsWith(\"/v2/c/\")) {\n      raise(\"This client can only be used to make /v2/c/* requests\");\n    }\n    const url2 = urljoin(this.#baseUrl, endpoint, params);\n    return await this.#fetchPolyfill(url2, {\n      ...options,\n      headers: {\n        // These headers are default, but can be overriden by custom headers\n        \"Content-Type\": \"application/json; charset=utf-8\",\n        // Possible header overrides\n        ...options?.headers,\n        // Cannot be overriden by custom headers\n        Authorization: `Bearer ${getBearerTokenFromAuthValue(authValue)}`,\n        \"X-LB-Client\": PKG_VERSION || \"dev\"\n      }\n    });\n  }\n  /**\n   * Constructs, makes the HTTP request, and handles the response by parsing\n   * JSON and/or throwing an HttpError if it failed.\n   *\n   * This is what .rawFetch() does:\n   *   1. Set Content-Type header\n   *   2. Set Authorization header\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\n   *\n   * This is what .fetch() does ON TOP of that:    This method!\n   *   4. Parse response body as Json\n   *   5. ...but silently return `{}` if that parsing fails ()\n   *   6. Throw HttpError if response is an error\n   */\n  async #fetch(endpoint, authValue, options, params) {\n    const response = await this.#rawFetch(endpoint, authValue, options, params);\n    if (!response.ok) {\n      throw await HttpError.fromResponse(response);\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  /**\n   * Makes a GET request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .get() instead.\n   */\n  async rawGet(endpoint, authValue, params, options) {\n    return await this.#rawFetch(endpoint, authValue, options, params);\n  }\n  /**\n   * Makes a POST request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .post() instead.\n   */\n  async rawPost(endpoint, authValue, body) {\n    return await this.#rawFetch(endpoint, authValue, {\n      method: \"POST\",\n      body: stringifyOrLog(body)\n    });\n  }\n  /**\n   * Makes a DELETE request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .delete() instead.\n   */\n  async rawDelete(endpoint, authValue) {\n    return await this.#rawFetch(endpoint, authValue, { method: \"DELETE\" });\n  }\n  /**\n   * Makes a GET request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async get(endpoint, authValue, params, options) {\n    return await this.#fetch(endpoint, authValue, options, params);\n  }\n  /**\n   * Makes a POST request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async post(endpoint, authValue, body, options, params) {\n    return await this.#fetch(\n      endpoint,\n      authValue,\n      {\n        ...options,\n        method: \"POST\",\n        body: stringifyOrLog(body)\n      },\n      params\n    );\n  }\n  /**\n   * Makes a DELETE request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async delete(endpoint, authValue) {\n    return await this.#fetch(endpoint, authValue, { method: \"DELETE\" });\n  }\n  /**\n   * Makes a PUT request for a Blob body, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async putBlob(endpoint, authValue, blob, params, options) {\n    return await this.#fetch(\n      endpoint,\n      authValue,\n      {\n        ...options,\n        method: \"PUT\",\n        headers: {\n          \"Content-Type\": \"application/octet-stream\"\n        },\n        body: blob\n      },\n      params\n    );\n  }\n};\n\n// src/lib/assert.ts\nfunction assertNever(_value, errmsg) {\n  throw new Error(errmsg);\n}\nfunction assert(condition, errmsg) {\n  if (true) {\n    if (!condition) {\n      const err = new Error(errmsg);\n      err.name = \"Assertion failure\";\n      throw err;\n    }\n  }\n}\nfunction nn(value, errmsg = \"Expected value to be non-nullable\") {\n  assert(value !== null && value !== void 0, errmsg);\n  return value;\n}\n\n// src/lib/fsm.ts\nfunction distance(state1, state2) {\n  if (state1 === state2) {\n    return [0, 0];\n  }\n  const chunks1 = state1.split(\".\");\n  const chunks2 = state2.split(\".\");\n  const minLen = Math.min(chunks1.length, chunks2.length);\n  let shared = 0;\n  for (; shared < minLen; shared++) {\n    if (chunks1[shared] !== chunks2[shared]) {\n      break;\n    }\n  }\n  const up = chunks1.length - shared;\n  const down = chunks2.length - shared;\n  return [up, down];\n}\nfunction patterns(targetState, levels) {\n  const parts = targetState.split(\".\");\n  if (levels < 1 || levels > parts.length + 1) {\n    throw new Error(\"Invalid number of levels\");\n  }\n  const result = [];\n  if (levels > parts.length) {\n    result.push(\"*\");\n  }\n  for (let i = parts.length - levels + 1; i < parts.length; i++) {\n    const slice = parts.slice(0, i);\n    if (slice.length > 0) {\n      result.push(slice.join(\".\") + \".*\");\n    }\n  }\n  result.push(targetState);\n  return result;\n}\nvar SafeContext = class {\n  #curr;\n  constructor(initialContext) {\n    this.#curr = initialContext;\n  }\n  get current() {\n    return this.#curr;\n  }\n  /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */\n  allowPatching(callback) {\n    const self = this;\n    let allowed = true;\n    const patchableContext = {\n      ...this.#curr,\n      patch(patch) {\n        if (allowed) {\n          self.#curr = Object.assign({}, self.#curr, patch);\n          for (const pair of Object.entries(patch)) {\n            const [key, value] = pair;\n            if (key !== \"patch\") {\n              this[key] = value;\n            }\n          }\n        } else {\n          throw new Error(\"Can no longer patch stale context\");\n        }\n      }\n    };\n    callback(patchableContext);\n    allowed = false;\n    return;\n  }\n};\nvar nextId = 1;\nvar FSM = class {\n  id;\n  // Indicates whether this state machine is still being configured, has\n  // started, or has terminated\n  #runningState;\n  #currentContext;\n  #states;\n  #currentStateOrNull;\n  #allowedTransitions;\n  #eventHub;\n  events;\n  //\n  // The cleanup stack is a stack of (optional) callback functions that will\n  // be run when exiting the current state. If a state (or state group) does\n  // not have an exit handler, then the entry for that level may be\n  // `undefined`, but there will be an explicit entry in the stack for it.\n  //\n  // This will always be true:\n  //\n  //   cleanupStack.length == currentState.split('.').length + 1\n  //\n  // Each stack level represents a different state \"group\".\n  //\n  // For example, if you are in a state named `foo.bar.qux`, then the stack\n  // will contain the exit handler for `foo.bar.qux` (at the top), then\n  // `foo.bar.*`, then `foo.*`, and finally, `*`.\n  //\n  #cleanupStack;\n  #enterFns;\n  // Used to provide better error messages\n  #knownEventTypes;\n  /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */\n  get #initialState() {\n    const result = this.#states.values()[Symbol.iterator]().next();\n    if (result.done) {\n      throw new Error(\"No states defined yet\");\n    } else {\n      return result.value;\n    }\n  }\n  get currentState() {\n    if (this.#currentStateOrNull === null) {\n      if (this.#runningState === 0 /* NOT_STARTED_YET */) {\n        throw new Error(\"Not started yet\");\n      } else {\n        throw new Error(\"Already stopped\");\n      }\n    }\n    return this.#currentStateOrNull;\n  }\n  /**\n   * Starts the machine by entering the initial state.\n   */\n  start() {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"State machine has already started\");\n    }\n    this.#runningState = 1 /* STARTED */;\n    this.#currentStateOrNull = this.#initialState;\n    this.#enter(null);\n    return this;\n  }\n  /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */\n  stop() {\n    if (this.#runningState !== 1 /* STARTED */) {\n      throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n    }\n    this.#exit(null);\n    this.#runningState = 2 /* STOPPED */;\n    this.#currentStateOrNull = null;\n  }\n  constructor(initialContext) {\n    this.id = nextId++;\n    this.#runningState = 0 /* NOT_STARTED_YET */;\n    this.#currentStateOrNull = null;\n    this.#states = /* @__PURE__ */ new Set();\n    this.#enterFns = /* @__PURE__ */ new Map();\n    this.#cleanupStack = [];\n    this.#knownEventTypes = /* @__PURE__ */ new Set();\n    this.#allowedTransitions = /* @__PURE__ */ new Map();\n    this.#currentContext = new SafeContext(initialContext);\n    this.#eventHub = {\n      didReceiveEvent: makeEventSource(),\n      willTransition: makeEventSource(),\n      didIgnoreEvent: makeEventSource(),\n      willExitState: makeEventSource(),\n      didEnterState: makeEventSource()\n    };\n    this.events = {\n      didReceiveEvent: this.#eventHub.didReceiveEvent.observable,\n      willTransition: this.#eventHub.willTransition.observable,\n      didIgnoreEvent: this.#eventHub.didIgnoreEvent.observable,\n      willExitState: this.#eventHub.willExitState.observable,\n      didEnterState: this.#eventHub.didEnterState.observable\n    };\n  }\n  get context() {\n    return this.#currentContext.current;\n  }\n  /**\n   * Define an explicit finite state in the state machine.\n   */\n  addState(state) {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    this.#states.add(state);\n    return this;\n  }\n  onEnter(nameOrPattern, enterFn) {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    } else if (this.#enterFns.has(nameOrPattern)) {\n      throw new Error(\n        // TODO We _currently_ don't support multiple .onEnters() for the same\n        // state, but this is not a fundamental limitation. Just not\n        // implemented yet. If we wanted to, we could make this an array.\n        `enter/exit function for ${nameOrPattern} already exists`\n      );\n    }\n    this.#enterFns.set(nameOrPattern, enterFn);\n    return this;\n  }\n  /**\n   * Defines a promise-based state. When the state is entered, the promise is\n   * created. When the promise resolves, the machine will transition to the\n   * provided `onOK` target state. When the promise rejects, the machine will\n   * transition to the `onError` target state.\n   *\n   * Optionally, a `maxTimeout` can be set. If the timeout happens before the\n   * promise is settled, then the machine will also transition to the `onError`\n   * target state.\n   *\n   * @param stateOrPattern  The state name, or state group pattern name.\n   * @param promiseFn       The callback to be invoked when the state is entered.\n   * @param onOK            The state to transition to when the promise resolves.\n   * @param onError         The state to transition to when the promise\n   *                        rejects, or when the timeout happens before the\n   *                        promise has been settled.\n   * @param maxTimeout      Optional timeout in milliseconds.\n   *\n   * When the promise callback function is invoked, it's provided with an\n   * AbortSignal (2nd argument).\n   * If a state transition happens while the promise is pending (for example,\n   * an event, or a timeout happens), then an abort signal will be used to\n   * indicate this. Implementers can use this abort signal to terminate the\n   * in-flight promise, or ignore its results, etc.\n   */\n  onEnterAsync(nameOrPattern, promiseFn, onOK, onError, maxTimeout) {\n    return this.onEnter(nameOrPattern, () => {\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n      const timeoutId = maxTimeout ? setTimeout(() => {\n        const reason = new Error(\"Timed out\");\n        this.#transition({ type: \"ASYNC_ERROR\", reason }, onError);\n      }, maxTimeout) : void 0;\n      let done = false;\n      void promiseFn(this.#currentContext.current, signal).then(\n        // On OK\n        (data) => {\n          if (!signal.aborted) {\n            done = true;\n            this.#transition({ type: \"ASYNC_OK\", data }, onOK);\n          }\n        },\n        // On Error\n        (reason) => {\n          if (!signal.aborted) {\n            done = true;\n            this.#transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }\n        }\n      );\n      return () => {\n        clearTimeout(timeoutId);\n        if (!done) {\n          abortController.abort();\n        }\n      };\n    });\n  }\n  #getStatesMatching(nameOrPattern) {\n    const matches = [];\n    if (nameOrPattern === \"*\") {\n      for (const state of this.#states) {\n        matches.push(state);\n      }\n    } else if (nameOrPattern.endsWith(\".*\")) {\n      const prefix = nameOrPattern.slice(0, -1);\n      for (const state of this.#states) {\n        if (state.startsWith(prefix)) {\n          matches.push(state);\n        }\n      }\n    } else {\n      const name = nameOrPattern;\n      if (this.#states.has(name)) {\n        matches.push(name);\n      }\n    }\n    if (matches.length === 0) {\n      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n    }\n    return matches;\n  }\n  /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */\n  addTransitions(nameOrPattern, mapping) {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    for (const srcState of this.#getStatesMatching(nameOrPattern)) {\n      let map = this.#allowedTransitions.get(srcState);\n      if (map === void 0) {\n        map = /* @__PURE__ */ new Map();\n        this.#allowedTransitions.set(srcState, map);\n      }\n      for (const [type, target_] of Object.entries(mapping)) {\n        if (map.has(type)) {\n          throw new Error(\n            `Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`\n          );\n        }\n        const target = target_;\n        this.#knownEventTypes.add(type);\n        if (target !== void 0) {\n          const targetFn = typeof target === \"function\" ? target : () => target;\n          map.set(type, targetFn);\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern  The state name, or state group pattern name.\n   * @param after           Number of milliseconds after which to take the\n   *                        transition. If in the mean time, another transition\n   *                        is taken, the timer will get cancelled.\n   * @param target          The target state to go to.\n   */\n  addTimedTransition(stateOrPattern, after2, target) {\n    return this.onEnter(stateOrPattern, () => {\n      const ms = typeof after2 === \"function\" ? after2(this.#currentContext.current) : after2;\n      const timeoutID = setTimeout(() => {\n        this.#transition({ type: \"TIMER\" }, target);\n      }, ms);\n      return () => {\n        clearTimeout(timeoutID);\n      };\n    });\n  }\n  #getTargetFn(eventName) {\n    return this.#allowedTransitions.get(this.currentState)?.get(eventName);\n  }\n  /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */\n  #exit(levels) {\n    this.#eventHub.willExitState.notify(this.currentState);\n    this.#currentContext.allowPatching((patchableContext) => {\n      levels = levels ?? this.#cleanupStack.length;\n      for (let i = 0; i < levels; i++) {\n        this.#cleanupStack.pop()?.(patchableContext);\n      }\n    });\n  }\n  /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */\n  #enter(levels) {\n    const enterPatterns = patterns(\n      this.currentState,\n      levels ?? this.currentState.split(\".\").length + 1\n    );\n    this.#currentContext.allowPatching((patchableContext) => {\n      for (const pattern of enterPatterns) {\n        const enterFn = this.#enterFns.get(pattern);\n        const cleanupFn = enterFn?.(patchableContext);\n        if (typeof cleanupFn === \"function\") {\n          this.#cleanupStack.push(cleanupFn);\n        } else {\n          this.#cleanupStack.push(null);\n        }\n      }\n    });\n    this.#eventHub.didEnterState.notify(this.currentState);\n  }\n  /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */\n  send(event) {\n    if (!this.#knownEventTypes.has(event.type)) {\n      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n    }\n    if (this.#runningState === 2 /* STOPPED */) {\n      return;\n    }\n    const targetFn = this.#getTargetFn(event.type);\n    if (targetFn !== void 0) {\n      return this.#transition(event, targetFn);\n    } else {\n      this.#eventHub.didIgnoreEvent.notify(event);\n    }\n  }\n  #transition(event, target) {\n    this.#eventHub.didReceiveEvent.notify(event);\n    const oldState = this.currentState;\n    const targetFn = typeof target === \"function\" ? target : () => target;\n    const nextTarget = targetFn(event, this.#currentContext.current);\n    let nextState;\n    let effects = void 0;\n    if (nextTarget === null) {\n      this.#eventHub.didIgnoreEvent.notify(event);\n      return;\n    }\n    if (typeof nextTarget === \"string\") {\n      nextState = nextTarget;\n    } else {\n      nextState = nextTarget.target;\n      effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [nextTarget.effect];\n    }\n    if (!this.#states.has(nextState)) {\n      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n    }\n    this.#eventHub.willTransition.notify({ from: oldState, to: nextState });\n    const [up, down] = distance(this.currentState, nextState);\n    if (up > 0) {\n      this.#exit(up);\n    }\n    this.#currentStateOrNull = nextState;\n    if (effects !== void 0) {\n      const effectsToRun = effects;\n      this.#currentContext.allowPatching((patchableContext) => {\n        for (const effect of effectsToRun) {\n          if (typeof effect === \"function\") {\n            effect(patchableContext, event);\n          } else {\n            patchableContext.patch(effect);\n          }\n        }\n      });\n    }\n    if (down > 0) {\n      this.#enter(down);\n    }\n  }\n};\n\n// src/protocol/ServerMsg.ts\nvar ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2) => {\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_JOINED\"] = 101] = \"USER_JOINED\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_LEFT\"] = 102] = \"USER_LEFT\";\n  ServerMsgCode2[ServerMsgCode2[\"BROADCASTED_EVENT\"] = 103] = \"BROADCASTED_EVENT\";\n  ServerMsgCode2[ServerMsgCode2[\"ROOM_STATE\"] = 104] = \"ROOM_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"INITIAL_STORAGE_STATE\"] = 200] = \"INITIAL_STORAGE_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ServerMsgCode2[ServerMsgCode2[\"REJECT_STORAGE_OP\"] = 299] = \"REJECT_STORAGE_OP\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_YDOC\"] = 300] = \"UPDATE_YDOC\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_CREATED\"] = 400] = \"THREAD_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_DELETED\"] = 407] = \"THREAD_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_METADATA_UPDATED\"] = 401] = \"THREAD_METADATA_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_UPDATED\"] = 408] = \"THREAD_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_CREATED\"] = 402] = \"COMMENT_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_EDITED\"] = 403] = \"COMMENT_EDITED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_DELETED\"] = 404] = \"COMMENT_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_ADDED\"] = 405] = \"COMMENT_REACTION_ADDED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_REMOVED\"] = 406] = \"COMMENT_REACTION_REMOVED\";\n  return ServerMsgCode2;\n})(ServerMsgCode || {});\n\n// src/types/IWebSocket.ts\nvar WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2) => {\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_NORMAL\"] = 1e3] = \"CLOSE_NORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"UNEXPECTED_CONDITION\"] = 1011] = \"UNEXPECTED_CONDITION\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TRY_AGAIN_LATER\"] = 1013] = \"TRY_AGAIN_LATER\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"INVALID_MESSAGE_FORMAT\"] = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"ROOM_ID_UPDATED\"] = 4006] = \"ROOM_ID_UPDATED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"KICKED\"] = 4100] = \"KICKED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TOKEN_EXPIRED\"] = 4109] = \"TOKEN_EXPIRED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_WITHOUT_RETRY\"] = 4999] = \"CLOSE_WITHOUT_RETRY\";\n  return WebsocketCloseCodes2;\n})(WebsocketCloseCodes || {});\nfunction shouldDisconnect(code) {\n  return code === 4999 /* CLOSE_WITHOUT_RETRY */ || code >= 4e3 && code < 4100;\n}\nfunction shouldReauth(code) {\n  return code >= 4100 && code < 4200;\n}\nfunction shouldRetryWithoutReauth(code) {\n  return code === 1013 /* TRY_AGAIN_LATER */ || code >= 4200 && code < 4300;\n}\n\n// src/connection.ts\nfunction isIdle(status) {\n  return status === \"initial\" || status === \"disconnected\";\n}\nfunction toNewConnectionStatus(machine) {\n  const state = machine.currentState;\n  switch (state) {\n    case \"@ok.connected\":\n    case \"@ok.awaiting-pong\":\n      return \"connected\";\n    case \"@idle.initial\":\n      return \"initial\";\n    case \"@auth.busy\":\n    case \"@auth.backoff\":\n    case \"@connecting.busy\":\n    case \"@connecting.backoff\":\n    case \"@idle.zombie\":\n      return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n    case \"@idle.failed\":\n      return \"disconnected\";\n    // istanbul ignore next\n    default:\n      return assertNever(state, \"Unknown state\");\n  }\n}\nvar BACKOFF_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];\nvar RESET_DELAY = BACKOFF_DELAYS[0] - 1;\nvar BACKOFF_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];\nvar HEARTBEAT_INTERVAL = 3e4;\nvar PONG_TIMEOUT = 2e3;\nvar AUTH_TIMEOUT = 1e4;\nvar SOCKET_CONNECT_TIMEOUT = 1e4;\nvar StopRetrying = class extends Error {\n  constructor(reason) {\n    super(reason);\n  }\n};\nfunction nextBackoffDelay(currentDelay, delays) {\n  return delays.find((delay) => delay > currentDelay) ?? delays[delays.length - 1];\n}\nfunction increaseBackoffDelay(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS)\n  });\n}\nfunction increaseBackoffDelayAggressively(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)\n  });\n}\nfunction resetSuccessCount(context) {\n  context.patch({ successCount: 0 });\n}\nfunction log(level, message) {\n  const logger = level === 2 /* ERROR */ ? error2 : level === 1 /* WARN */ ? warn : (\n    /* black hole */\n    () => {\n    }\n  );\n  return () => {\n    logger(message);\n  };\n}\nfunction logPrematureErrorOrCloseEvent(e) {\n  const conn = \"Connection to Liveblocks websocket server\";\n  return (ctx) => {\n    if (e instanceof Error) {\n      warn(`${conn} could not be established. ${String(e)}`);\n    } else {\n      warn(\n        isCloseEvent(e) ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.` : `${conn} could not be established.`\n      );\n    }\n  };\n}\nfunction logCloseEvent(event) {\n  const details = [`code: ${event.code}`];\n  if (event.reason) {\n    details.push(`reason: ${event.reason}`);\n  }\n  return (ctx) => {\n    warn(\n      `Connection to Liveblocks websocket server closed (${details.join(\", \")}). Retrying in ${ctx.backoffDelay}ms.`\n    );\n  };\n}\nvar logPermanentClose = log(\n  1 /* WARN */,\n  \"Connection to WebSocket closed permanently. Won't retry.\"\n);\nfunction isCloseEvent(error3) {\n  return !(error3 instanceof Error) && error3.type === \"close\";\n}\nfunction enableTracing(machine) {\n  const start = (/* @__PURE__ */ new Date()).getTime();\n  function log2(...args) {\n    warn(\n      `${(((/* @__PURE__ */ new Date()).getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`,\n      ...args\n    );\n  }\n  const unsubs = [\n    machine.events.didReceiveEvent.subscribe((e) => log2(`Event ${e.type}`)),\n    machine.events.willTransition.subscribe(\n      ({ from, to }) => log2(\"Transitioning\", from, \"\\u2192\", to)\n    ),\n    machine.events.didIgnoreEvent.subscribe(\n      (e) => log2(\"Ignored event\", e.type, e, \"(current state won't handle it)\")\n    )\n    // machine.events.willExitState.subscribe((s) => log(\"Exiting state\", s)),\n    // machine.events.didEnterState.subscribe((s) => log(\"Entering state\", s)),\n  ];\n  return () => {\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  };\n}\nfunction defineConnectivityEvents(machine) {\n  const statusDidChange = makeEventSource();\n  const didConnect = makeEventSource();\n  const didDisconnect = makeEventSource();\n  let lastStatus = null;\n  const unsubscribe = machine.events.didEnterState.subscribe(() => {\n    const currStatus = toNewConnectionStatus(machine);\n    if (currStatus !== lastStatus) {\n      statusDidChange.notify(currStatus);\n    }\n    if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n      didDisconnect.notify();\n    } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n      didConnect.notify();\n    }\n    lastStatus = currStatus;\n  });\n  return {\n    statusDidChange: statusDidChange.observable,\n    didConnect: didConnect.observable,\n    didDisconnect: didDisconnect.observable,\n    unsubscribe\n  };\n}\nvar assign = (patch) => (ctx) => ctx.patch(patch);\nfunction createConnectionStateMachine(delegates, options) {\n  const onMessage = makeBufferableEventSource();\n  onMessage.pause();\n  const onConnectionError = makeEventSource();\n  function fireErrorEvent(message, code) {\n    return () => {\n      onConnectionError.notify({ message, code });\n    };\n  }\n  const initialContext = {\n    successCount: 0,\n    authValue: null,\n    socket: null,\n    backoffDelay: RESET_DELAY\n  };\n  const machine = new FSM(initialContext).addState(\"@idle.initial\").addState(\"@idle.failed\").addState(\"@idle.zombie\").addState(\"@auth.busy\").addState(\"@auth.backoff\").addState(\"@connecting.busy\").addState(\"@connecting.backoff\").addState(\"@ok.connected\").addState(\"@ok.awaiting-pong\");\n  machine.addTransitions(\"*\", {\n    RECONNECT: {\n      target: \"@auth.backoff\",\n      effect: [increaseBackoffDelay, resetSuccessCount]\n    },\n    DISCONNECT: \"@idle.initial\"\n  });\n  machine.onEnter(\"@idle.*\", resetSuccessCount).addTransitions(\"@idle.*\", {\n    CONNECT: (_, ctx) => (\n      // If we still have a known authValue, try to reconnect to the socket directly,\n      // otherwise, try to obtain a new authValue\n      ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\"\n    )\n  });\n  machine.addTransitions(\"@auth.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@auth.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@auth.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@auth.busy\"\n  ).onEnterAsync(\n    \"@auth.busy\",\n    () => withTimeout(\n      delegates.authenticate(),\n      AUTH_TIMEOUT,\n      \"Timed out during auth\"\n    ),\n    // On successful authentication\n    (okEvent) => ({\n      target: \"@connecting.busy\",\n      effect: assign({\n        authValue: okEvent.data\n      })\n    }),\n    // Auth failed\n    (failedEvent) => {\n      if (failedEvent.reason instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, failedEvent.reason.message),\n            fireErrorEvent(failedEvent.reason.message, -1)\n          ]\n        };\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [\n          increaseBackoffDelay,\n          log(\n            2 /* ERROR */,\n            `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`\n          )\n        ]\n      };\n    }\n  );\n  const onSocketError = (event) => machine.send({ type: \"EXPLICIT_SOCKET_ERROR\", event });\n  const onSocketClose = (event) => machine.send({ type: \"EXPLICIT_SOCKET_CLOSE\", event });\n  const onSocketMessage = (event) => event.data === \"pong\" ? machine.send({ type: \"PONG\" }) : onMessage.notify(event);\n  function teardownSocket(socket) {\n    if (socket) {\n      socket.removeEventListener(\"error\", onSocketError);\n      socket.removeEventListener(\"close\", onSocketClose);\n      socket.removeEventListener(\"message\", onSocketMessage);\n      socket.close();\n    }\n  }\n  machine.addTransitions(\"@connecting.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@connecting.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@connecting.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@connecting.busy\"\n  ).onEnterAsync(\n    \"@connecting.busy\",\n    //\n    // Use the \"createSocket\" delegate function (provided to the\n    // ManagedSocket) to create the actual WebSocket connection instance.\n    // Then, set up all the necessary event listeners, and wait for the\n    // \"open\" event to occur.\n    //\n    // When the \"open\" event happens, we're ready to transition to the\n    // OK state. This is done by resolving the Promise.\n    //\n    async (ctx, signal) => {\n      let capturedPrematureEvent = null;\n      let unconfirmedSocket = null;\n      const connect$ = new Promise(\n        (resolve, rej) => {\n          if (ctx.authValue === null) {\n            throw new Error(\"No auth authValue\");\n          }\n          const socket = delegates.createSocket(ctx.authValue);\n          unconfirmedSocket = socket;\n          function reject(event) {\n            capturedPrematureEvent = event;\n            socket.removeEventListener(\"message\", onSocketMessage);\n            rej(event);\n          }\n          const [actor$, didReceiveActor] = controlledPromise();\n          if (!options.waitForActorId) {\n            didReceiveActor();\n          }\n          function waitForActorId(event) {\n            const serverMsg = tryParseJson(event.data);\n            if (serverMsg?.type === 104 /* ROOM_STATE */) {\n              didReceiveActor();\n            }\n          }\n          socket.addEventListener(\"message\", onSocketMessage);\n          if (options.waitForActorId) {\n            socket.addEventListener(\"message\", waitForActorId);\n          }\n          socket.addEventListener(\"error\", reject);\n          socket.addEventListener(\"close\", reject);\n          socket.addEventListener(\"open\", () => {\n            socket.addEventListener(\"error\", onSocketError);\n            socket.addEventListener(\"close\", onSocketClose);\n            const unsub = () => {\n              socket.removeEventListener(\"error\", reject);\n              socket.removeEventListener(\"close\", reject);\n              socket.removeEventListener(\"message\", waitForActorId);\n            };\n            void actor$.then(() => {\n              resolve([socket, unsub]);\n            });\n          });\n        }\n      );\n      return withTimeout(\n        connect$,\n        SOCKET_CONNECT_TIMEOUT,\n        \"Timed out during websocket connection\"\n      ).then(\n        //\n        // Part 3:\n        // By now, our \"open\" event has fired, and the promise has been\n        // resolved. Two possible scenarios:\n        //\n        // 1. The happy path. Most likely.\n        // 2. Uh-oh. A premature close/error event has been observed. Let's\n        //    reject the promise after all.\n        //\n        // Any close/error event that will get scheduled after this point\n        // onwards, will be caught in the OK state, and dealt with\n        // accordingly.\n        //\n        ([socket, unsub]) => {\n          unsub();\n          if (signal.aborted) {\n            throw new Error(\"Aborted\");\n          }\n          if (capturedPrematureEvent) {\n            throw capturedPrematureEvent;\n          }\n          return socket;\n        }\n      ).catch((e) => {\n        teardownSocket(unconfirmedSocket);\n        throw e;\n      });\n    },\n    // Only transition to OK state after a successfully opened WebSocket connection\n    (okEvent) => ({\n      target: \"@ok.connected\",\n      effect: assign({\n        socket: okEvent.data,\n        backoffDelay: RESET_DELAY\n      })\n    }),\n    // If the WebSocket connection cannot be established\n    (failure) => {\n      const err = failure.reason;\n      if (err instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, err.message),\n            fireErrorEvent(err.message, -1)\n          ]\n        };\n      }\n      if (isCloseEvent(err)) {\n        if (err.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        }\n        if (shouldRetryWithoutReauth(err.code)) {\n          return {\n            target: \"@connecting.backoff\",\n            effect: [\n              increaseBackoffDelayAggressively,\n              logPrematureErrorOrCloseEvent(err)\n            ]\n          };\n        }\n        if (shouldDisconnect(err.code)) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(2 /* ERROR */, err.reason),\n              fireErrorEvent(err.reason, err.code)\n            ]\n          };\n        }\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)]\n      };\n    }\n  );\n  const sendHeartbeat = {\n    target: \"@ok.awaiting-pong\",\n    effect: (ctx) => {\n      ctx.socket?.send(\"ping\");\n    }\n  };\n  const maybeHeartbeat = () => {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const canZombie = doc?.visibilityState === \"hidden\" && delegates.canZombie();\n    return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n  };\n  machine.addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions(\"@ok.connected\", {\n    NAVIGATOR_OFFLINE: maybeHeartbeat,\n    // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n    WINDOW_GOT_FOCUS: sendHeartbeat\n  });\n  machine.addTransitions(\"@idle.zombie\", {\n    WINDOW_GOT_FOCUS: \"@connecting.backoff\"\n    // When in zombie state, the client will try to wake up automatically when the window regains focus\n  });\n  machine.onEnter(\"@ok.*\", (ctx) => {\n    ctx.patch({ successCount: ctx.successCount + 1 });\n    const timerID = setTimeout(\n      // On the next tick, start delivering all messages that have already\n      // been received, and continue synchronous delivery of all future\n      // incoming messages.\n      onMessage.unpause,\n      0\n    );\n    return (ctx2) => {\n      teardownSocket(ctx2.socket);\n      ctx2.patch({ socket: null });\n      clearTimeout(timerID);\n      onMessage.pause();\n    };\n  }).addTransitions(\"@ok.awaiting-pong\", { PONG: \"@ok.connected\" }).addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n    target: \"@connecting.busy\",\n    // Log implicit connection loss and drop the current open socket\n    effect: log(\n      1 /* WARN */,\n      \"Received no pong from server, assume implicit connection loss.\"\n    )\n  }).addTransitions(\"@ok.*\", {\n    // When a socket receives an error, this can cause the closing of the\n    // socket, or not. So always check to see if the socket is still OPEN or\n    // not. When still OPEN, don't transition.\n    EXPLICIT_SOCKET_ERROR: (_, context) => {\n      if (context.socket?.readyState === 1) {\n        return null;\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: increaseBackoffDelay\n      };\n    },\n    EXPLICIT_SOCKET_CLOSE: (e) => {\n      if (shouldDisconnect(e.event.code)) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            logPermanentClose,\n            fireErrorEvent(e.event.reason, e.event.code)\n          ]\n        };\n      }\n      if (shouldReauth(e.event.code)) {\n        if (e.event.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        } else {\n          return {\n            target: \"@auth.backoff\",\n            effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n          };\n        }\n      }\n      if (shouldRetryWithoutReauth(e.event.code)) {\n        return {\n          target: \"@connecting.backoff\",\n          effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)]\n        };\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n      };\n    }\n  });\n  if (typeof document !== \"undefined\") {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    const root = win ?? doc;\n    machine.onEnter(\"*\", (ctx) => {\n      function onNetworkOffline() {\n        machine.send({ type: \"NAVIGATOR_OFFLINE\" });\n      }\n      function onNetworkBackOnline() {\n        machine.send({ type: \"NAVIGATOR_ONLINE\" });\n      }\n      function onVisibilityChange() {\n        if (doc?.visibilityState === \"visible\") {\n          machine.send({ type: \"WINDOW_GOT_FOCUS\" });\n        }\n      }\n      win?.addEventListener(\"online\", onNetworkBackOnline);\n      win?.addEventListener(\"offline\", onNetworkOffline);\n      root?.addEventListener(\"visibilitychange\", onVisibilityChange);\n      return () => {\n        root?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        win?.removeEventListener(\"online\", onNetworkBackOnline);\n        win?.removeEventListener(\"offline\", onNetworkOffline);\n        teardownSocket(ctx.socket);\n      };\n    });\n  }\n  const cleanups = [];\n  const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);\n  cleanups.push(unsubscribe);\n  if (options.enableDebugLogging) {\n    cleanups.push(enableTracing(machine));\n  }\n  machine.start();\n  return {\n    machine,\n    cleanups,\n    // Observable events that will be emitted by this machine\n    events: {\n      statusDidChange,\n      didConnect,\n      didDisconnect,\n      onMessage: onMessage.observable,\n      onConnectionError: onConnectionError.observable\n    }\n  };\n}\nvar ManagedSocket = class {\n  #machine;\n  #cleanups;\n  events;\n  constructor(delegates, enableDebugLogging = false, waitForActorId = true) {\n    const { machine, events, cleanups } = createConnectionStateMachine(\n      delegates,\n      { waitForActorId, enableDebugLogging }\n    );\n    this.#machine = machine;\n    this.events = events;\n    this.#cleanups = cleanups;\n  }\n  getStatus() {\n    try {\n      return toNewConnectionStatus(this.#machine);\n    } catch {\n      return \"initial\";\n    }\n  }\n  /**\n   * Returns the current auth authValue.\n   */\n  get authValue() {\n    return this.#machine.context.authValue;\n  }\n  /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */\n  connect() {\n    this.#machine.send({ type: \"CONNECT\" });\n  }\n  /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */\n  reconnect() {\n    this.#machine.send({ type: \"RECONNECT\" });\n  }\n  /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */\n  disconnect() {\n    this.#machine.send({ type: \"DISCONNECT\" });\n  }\n  /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */\n  destroy() {\n    this.#machine.stop();\n    let cleanup;\n    while (cleanup = this.#cleanups.pop()) {\n      cleanup();\n    }\n  }\n  /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */\n  send(data) {\n    const socket = this.#machine.context?.socket;\n    if (socket === null) {\n      warn(\"Cannot send: not connected yet\", data);\n    } else if (socket.readyState !== 1) {\n      warn(\"Cannot send: WebSocket no longer open\", data);\n    } else {\n      socket.send(data);\n    }\n  }\n  /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */\n  _privateSendMachineEvent(event) {\n    this.#machine.send(event);\n  }\n};\n\n// src/protocol/AuthToken.ts\nvar Permission = /* @__PURE__ */ ((Permission2) => {\n  Permission2[\"Read\"] = \"room:read\";\n  Permission2[\"Write\"] = \"room:write\";\n  Permission2[\"PresenceWrite\"] = \"room:presence:write\";\n  Permission2[\"CommentsWrite\"] = \"comments:write\";\n  Permission2[\"CommentsRead\"] = \"comments:read\";\n  return Permission2;\n})(Permission || {});\nfunction canWriteStorage(scopes) {\n  return scopes.includes(\"room:write\" /* Write */);\n}\nfunction canComment(scopes) {\n  return scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:write\" /* Write */);\n}\nfunction isValidAuthTokenPayload(data) {\n  return isPlainObject(data) && (data.k === \"acc\" /* ACCESS_TOKEN */ || data.k === \"id\" /* ID_TOKEN */ || data.k === \"sec-legacy\" /* SECRET_LEGACY */);\n}\nfunction parseAuthToken(rawTokenString) {\n  const tokenParts = rawTokenString.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n  const payload = tryParseJson(b64decode(tokenParts[1]));\n  if (!(payload && isValidAuthTokenPayload(payload))) {\n    throw new Error(\n      \"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n    );\n  }\n  return {\n    raw: rawTokenString,\n    parsed: payload\n  };\n}\n\n// src/auth-manager.ts\nfunction createAuthManager(authOptions, onAuthenticate) {\n  const authentication = prepareAuthentication(authOptions);\n  const seenTokens = /* @__PURE__ */ new Set();\n  const tokens = [];\n  const expiryTimes = [];\n  const requestPromises = /* @__PURE__ */ new Map();\n  function reset() {\n    seenTokens.clear();\n    tokens.length = 0;\n    expiryTimes.length = 0;\n    requestPromises.clear();\n  }\n  function hasCorrespondingScopes(requestedScope, scopes) {\n    if (requestedScope === \"comments:read\") {\n      return scopes.includes(\"comments:read\" /* CommentsRead */) || scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    } else if (requestedScope === \"room:read\") {\n      return scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    }\n    return false;\n  }\n  function getCachedToken(requestOptions) {\n    const now = Math.ceil(Date.now() / 1e3);\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      const expiresAt = expiryTimes[i];\n      if (expiresAt <= now) {\n        tokens.splice(i, 1);\n        expiryTimes.splice(i, 1);\n        continue;\n      }\n      if (token.parsed.k === \"id\" /* ID_TOKEN */) {\n        return token;\n      } else if (token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n        if (!requestOptions.roomId && Object.entries(token.parsed.perms).length === 0) {\n          return token;\n        }\n        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\n          if (!requestOptions.roomId) {\n            if (resource.includes(\"*\") && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n              return token;\n            }\n          } else if (resource.includes(\"*\") && requestOptions.roomId.startsWith(resource.replace(\"*\", \"\")) || requestOptions.roomId === resource && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n            return token;\n          }\n        }\n      }\n    }\n    return void 0;\n  }\n  async function makeAuthRequest(options) {\n    const fetcher = authOptions.polyfills?.fetch ?? (typeof window === \"undefined\" ? void 0 : window.fetch);\n    if (authentication.type === \"private\") {\n      if (fetcher === void 0) {\n        throw new StopRetrying(\n          \"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\"\n        );\n      }\n      const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n        room: options.roomId\n      });\n      const parsed = parseAuthToken(response.token);\n      if (seenTokens.has(parsed.raw)) {\n        throw new StopRetrying(\n          \"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\"\n        );\n      }\n      onAuthenticate?.(parsed.parsed);\n      return parsed;\n    }\n    if (authentication.type === \"custom\") {\n      const response = await authentication.callback(options.roomId);\n      if (response && typeof response === \"object\") {\n        if (typeof response.token === \"string\") {\n          const parsed = parseAuthToken(response.token);\n          onAuthenticate?.(parsed.parsed);\n          return parsed;\n        } else if (typeof response.error === \"string\") {\n          const reason = `Authentication failed: ${\"reason\" in response && typeof response.reason === \"string\" ? response.reason : \"Forbidden\"}`;\n          if (response.error === \"forbidden\") {\n            throw new StopRetrying(reason);\n          } else {\n            throw new Error(reason);\n          }\n        }\n      }\n      throw new Error(\n        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }'\n      );\n    }\n    throw new Error(\n      \"Unexpected authentication type. Must be private or custom.\"\n    );\n  }\n  async function getAuthValue(requestOptions) {\n    if (authentication.type === \"public\") {\n      return { type: \"public\", publicApiKey: authentication.publicApiKey };\n    }\n    const cachedToken = getCachedToken(requestOptions);\n    if (cachedToken !== void 0) {\n      return { type: \"secret\", token: cachedToken };\n    }\n    let currentPromise;\n    if (requestOptions.roomId) {\n      currentPromise = requestPromises.get(requestOptions.roomId);\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(requestOptions.roomId, currentPromise);\n      }\n    } else {\n      currentPromise = requestPromises.get(\"liveblocks-user-token\");\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(\"liveblocks-user-token\", currentPromise);\n      }\n    }\n    try {\n      const token = await currentPromise;\n      const BUFFER = 30;\n      const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;\n      seenTokens.add(token.raw);\n      if (token.parsed.k !== \"sec-legacy\" /* SECRET_LEGACY */) {\n        tokens.push(token);\n        expiryTimes.push(expiresAt);\n      }\n      return { type: \"secret\", token };\n    } finally {\n      if (requestOptions.roomId) {\n        requestPromises.delete(requestOptions.roomId);\n      } else {\n        requestPromises.delete(\"liveblocks-user-token\");\n      }\n    }\n  }\n  return {\n    reset,\n    getAuthValue\n  };\n}\nfunction prepareAuthentication(authOptions) {\n  const { publicApiKey, authEndpoint } = authOptions;\n  if (authEndpoint !== void 0 && publicApiKey !== void 0) {\n    throw new Error(\n      \"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n    );\n  }\n  if (typeof publicApiKey === \"string\") {\n    if (publicApiKey.startsWith(\"sk_\")) {\n      throw new Error(\n        \"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    } else if (!publicApiKey.startsWith(\"pk_\")) {\n      throw new Error(\n        \"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    }\n    return {\n      type: \"public\",\n      publicApiKey\n    };\n  }\n  if (typeof authEndpoint === \"string\") {\n    return {\n      type: \"private\",\n      url: authEndpoint\n    };\n  } else if (typeof authEndpoint === \"function\") {\n    return {\n      type: \"custom\",\n      callback: authEndpoint\n    };\n  } else if (authEndpoint !== void 0) {\n    throw new Error(\n      \"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\"\n    );\n  }\n  throw new Error(\n    \"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n  );\n}\nasync function fetchAuthEndpoint(fetch, endpoint, body) {\n  const res = await fetch(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: stringifyOrLog(body)\n  });\n  if (!res.ok) {\n    const reason = `${(await res.text()).trim() || \"reason not provided in auth response\"} (${res.status} returned by POST ${endpoint})`;\n    if (res.status === 401 || res.status === 403) {\n      throw new StopRetrying(`Unauthorized: ${reason}`);\n    } else {\n      throw new Error(`Failed to authenticate: ${reason}`);\n    }\n  }\n  let data;\n  try {\n    data = await res.json();\n  } catch (er) {\n    throw new Error(\n      `Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(\n        er\n      )}`\n    );\n  }\n  if (!isPlainObject(data) || typeof data.token !== \"string\") {\n    throw new Error(\n      `Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${stringifyOrLog(\n        data\n      )}`\n    );\n  }\n  const { token } = data;\n  return { token };\n}\n\n// src/constants.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\n\n// src/internal.ts\nvar kInternal = Symbol();\n\n// src/devtools/bridge.ts\nvar _bridgeActive = false;\nfunction activateBridge(allowed) {\n  _bridgeActive = allowed;\n}\nfunction sendToPanel(message, options) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  const fullMsg = {\n    ...message,\n    source: \"liveblocks-devtools-client\"\n  };\n  if (!(options?.force || _bridgeActive)) {\n    return;\n  }\n  window.postMessage(fullMsg, \"*\");\n}\nvar eventSource = makeEventSource();\nif ( true && typeof window !== \"undefined\") {\n  window.addEventListener(\"message\", (event) => {\n    if (event.source === window && event.data?.source === \"liveblocks-devtools-panel\") {\n      eventSource.notify(event.data);\n    } else {\n    }\n  });\n}\nvar onMessageFromPanel = eventSource.observable;\n\n// src/devtools/index.ts\nvar VERSION = PKG_VERSION || \"dev\";\nvar _devtoolsSetupHasRun = false;\nfunction setupDevTools(getAllRooms) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  if (_devtoolsSetupHasRun) {\n    return;\n  }\n  _devtoolsSetupHasRun = true;\n  onMessageFromPanel.subscribe((msg) => {\n    switch (msg.msg) {\n      // When a devtool panel sends an explicit \"connect\" message back to this\n      // live running client (in response to the \"wake-up-devtools\" message,\n      // or when the devtool panel is opened for the first time), it means that it's okay to\n      // start emitting messages.\n      // Before this explicit acknowledgement, any call to sendToPanel() will\n      // be a no-op.\n      case \"connect\": {\n        activateBridge(true);\n        for (const roomId of getAllRooms()) {\n          sendToPanel({\n            msg: \"room::available\",\n            roomId,\n            clientVersion: VERSION\n          });\n        }\n        break;\n      }\n    }\n  });\n  sendToPanel({ msg: \"wake-up-devtools\" }, { force: true });\n}\nvar unsubsByRoomId = /* @__PURE__ */ new Map();\nfunction stopSyncStream(roomId) {\n  const unsubs = unsubsByRoomId.get(roomId) ?? [];\n  unsubsByRoomId.delete(roomId);\n  for (const unsub of unsubs) {\n    unsub();\n  }\n}\nfunction startSyncStream(room) {\n  stopSyncStream(room.id);\n  fullSync(room);\n  unsubsByRoomId.set(room.id, [\n    // When the connection status changes\n    room.events.status.subscribe(() => partialSyncConnection(room)),\n    // When storage initializes, send the update\n    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),\n    // Any time storage updates, send the new storage root\n    room.events.storageBatch.subscribe(() => partialSyncStorage(room)),\n    // Any time \"me\" or \"others\" updates, send the new values accordingly\n    room.events.self.subscribe(() => partialSyncMe(room)),\n    room.events.others.subscribe(() => partialSyncOthers(room)),\n    // Any time ydoc is updated, forward the update\n    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),\n    // Any time a custom room event is received, forward it\n    room.events.customEvent.subscribe(\n      (eventData) => forwardEvent(room, eventData)\n    )\n  ]);\n}\nfunction syncYdocUpdate(room, update) {\n  sendToPanel({\n    msg: \"room::sync::ydoc\",\n    roomId: room.id,\n    update\n  });\n}\nvar loadedAt = Date.now();\nvar eventCounter = 0;\nfunction nextEventId() {\n  return `event-${loadedAt}-${eventCounter++}`;\n}\nfunction forwardEvent(room, eventData) {\n  sendToPanel({\n    msg: \"room::events::custom-event\",\n    roomId: room.id,\n    event: {\n      type: \"CustomEvent\",\n      id: nextEventId(),\n      key: \"Event\",\n      connectionId: eventData.connectionId,\n      payload: eventData.event\n    }\n  });\n}\nfunction partialSyncConnection(room) {\n  sendToPanel({\n    msg: \"room::sync::partial\",\n    roomId: room.id,\n    status: room.getStatus()\n  });\n}\nfunction partialSyncStorage(room) {\n  const root = room.getStorageSnapshot();\n  if (root) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      storage: root.toTreeNode(\"root\").payload\n    });\n  }\n}\nfunction partialSyncMe(room) {\n  const me = room[kInternal].getSelf_forDevTools();\n  if (me) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      me\n    });\n  }\n}\nfunction partialSyncOthers(room) {\n  const others = room[kInternal].getOthers_forDevTools();\n  if (others) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      others\n    });\n  }\n}\nfunction fullSync(room) {\n  const root = room.getStorageSnapshot();\n  const me = room[kInternal].getSelf_forDevTools();\n  const others = room[kInternal].getOthers_forDevTools();\n  room.fetchYDoc(\"\");\n  sendToPanel({\n    msg: \"room::sync::full\",\n    roomId: room.id,\n    status: room.getStatus(),\n    storage: root?.toTreeNode(\"root\").payload ?? null,\n    me,\n    others\n  });\n}\nvar roomChannelListeners = /* @__PURE__ */ new Map();\nfunction stopRoomChannelListener(roomId) {\n  const listener = roomChannelListeners.get(roomId);\n  roomChannelListeners.delete(roomId);\n  if (listener) {\n    listener();\n  }\n}\nfunction linkDevTools(roomId, room) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  sendToPanel({ msg: \"room::available\", roomId, clientVersion: VERSION });\n  stopRoomChannelListener(roomId);\n  roomChannelListeners.set(\n    roomId,\n    // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg) => {\n      switch (msg.msg) {\n        // Sent by the devtool panel when it wants to receive the sync stream\n        // for a room\n        case \"room::subscribe\": {\n          if (msg.roomId === roomId) {\n            startSyncStream(room);\n          }\n          break;\n        }\n        case \"room::unsubscribe\": {\n          if (msg.roomId === roomId) {\n            stopSyncStream(roomId);\n          }\n          break;\n        }\n      }\n    })\n  );\n}\nfunction unlinkDevTools(roomId) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  stopSyncStream(roomId);\n  stopRoomChannelListener(roomId);\n  sendToPanel({\n    msg: \"room::unavailable\",\n    roomId\n  });\n}\n\n// src/protocol/UserNotificationSettings.ts\nvar kPlain = Symbol(\"user-notification-settings-plain\");\nfunction createUserNotificationSettings(plain) {\n  const channels = [\n    \"email\",\n    \"slack\",\n    \"teams\",\n    \"webPush\"\n  ];\n  const descriptors = {\n    [kPlain]: {\n      value: plain,\n      enumerable: false\n    }\n  };\n  for (const channel of channels) {\n    descriptors[channel] = {\n      enumerable: true,\n      /**\n       * In the TypeScript standard library definitions, the built-in interface for a property descriptor\n       * does not include a specialized type for the this context in the getter or setter functions.\n       * As a result, both the get and set methods implicitly have this: any.\n       * The reason is that property descriptors in JavaScript are used across various objects with\n       * no enforced shape for this. And so the standard library definitions have to remain as broad as possible\n       * to support any valid JavaScript usage (e.g `Object.defineProperty`).\n       *\n       * So we can safely tells that this getter is typed as `this: UserNotificationSettings` because we're\n       * creating a well known shaped object  `UserNotificationSettings`.\n       */\n      get() {\n        const value = this[kPlain][channel];\n        if (typeof value === \"undefined\") {\n          error2(\n            `In order to use the '${channel}' channel, please set up your project first. For more information: https://liveblocks.io/docs/errors/enable-a-notification-channel`\n          );\n          return null;\n        }\n        return value;\n      }\n    };\n  }\n  return create(null, descriptors);\n}\nfunction patchUserNotificationSettings(existing, patch) {\n  const outcoming = createUserNotificationSettings({\n    ...existing[kPlain]\n  });\n  for (const channel of keys(patch)) {\n    const updates = patch[channel];\n    if (updates !== void 0) {\n      const kindUpdates = Object.fromEntries(\n        entries(updates).filter(([, value]) => value !== void 0)\n      );\n      outcoming[kPlain][channel] = {\n        ...outcoming[kPlain][channel],\n        ...kindUpdates\n      };\n    }\n  }\n  return outcoming;\n}\nfunction isNotificationChannelEnabled(settings) {\n  return settings !== null ? values(settings).every((enabled) => enabled === true) : false;\n}\n\n// src/lib/position.ts\nvar MIN_CODE = 32;\nvar MAX_CODE = 126;\nvar NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\nvar ZERO = nthDigit(0);\nvar ONE = nthDigit(1);\nvar ZERO_NINE = ZERO + nthDigit(-1);\nfunction nthDigit(n) {\n  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n  if (code < MIN_CODE || code > MAX_CODE) {\n    throw new Error(`Invalid n value: ${n}`);\n  }\n  return String.fromCharCode(code);\n}\nfunction makePosition(x, y) {\n  if (x !== void 0 && y !== void 0) {\n    return between(x, y);\n  } else if (x !== void 0) {\n    return after(x);\n  } else if (y !== void 0) {\n    return before(y);\n  } else {\n    return ONE;\n  }\n}\nfunction before(pos) {\n  const lastIndex = pos.length - 1;\n  for (let i = 0; i <= lastIndex; i++) {\n    const code = pos.charCodeAt(i);\n    if (code <= MIN_CODE) {\n      continue;\n    }\n    if (i === lastIndex) {\n      if (code === MIN_CODE + 1) {\n        return pos.substring(0, i) + ZERO_NINE;\n      } else {\n        return pos.substring(0, i) + String.fromCharCode(code - 1);\n      }\n    } else {\n      return pos.substring(0, i + 1);\n    }\n  }\n  return ONE;\n}\nfunction after(pos) {\n  for (let i = 0; i <= pos.length - 1; i++) {\n    const code = pos.charCodeAt(i);\n    if (code >= MAX_CODE) {\n      continue;\n    }\n    return pos.substring(0, i) + String.fromCharCode(code + 1);\n  }\n  return pos + ONE;\n}\nfunction between(lo, hi) {\n  if (lo < hi) {\n    return _between(lo, hi);\n  } else if (lo > hi) {\n    return _between(hi, lo);\n  } else {\n    throw new Error(\"Cannot compute value between two equal positions\");\n  }\n}\nfunction _between(lo, hi) {\n  let index = 0;\n  const loLen = lo.length;\n  const hiLen = hi.length;\n  while (true) {\n    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n    if (loCode === hiCode) {\n      index++;\n      continue;\n    }\n    if (hiCode - loCode === 1) {\n      const size = index + 1;\n      let prefix = lo.substring(0, size);\n      if (prefix.length < size) {\n        prefix += ZERO.repeat(size - prefix.length);\n      }\n      const suffix = lo.substring(size);\n      const nines = \"\";\n      return prefix + _between(suffix, nines);\n    } else {\n      return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);\n    }\n  }\n}\nfunction takeN(pos, n) {\n  return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);\n}\nvar MIN_NON_ZERO_CODE = MIN_CODE + 1;\nfunction isPos(str) {\n  if (str === \"\") {\n    return false;\n  }\n  const lastIdx = str.length - 1;\n  const last = str.charCodeAt(lastIdx);\n  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n    return false;\n  }\n  for (let i = 0; i < lastIdx; i++) {\n    const code = str.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction convertToPos(str) {\n  const codes = [];\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n  }\n  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {\n    codes.length--;\n  }\n  return codes.length > 0 ? String.fromCharCode(...codes) : (\n    // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n    ONE\n  );\n}\nfunction asPos(str) {\n  return isPos(str) ? str : convertToPos(str);\n}\n\n// src/protocol/Op.ts\nvar OpCode = /* @__PURE__ */ ((OpCode2) => {\n  OpCode2[OpCode2[\"INIT\"] = 0] = \"INIT\";\n  OpCode2[OpCode2[\"SET_PARENT_KEY\"] = 1] = \"SET_PARENT_KEY\";\n  OpCode2[OpCode2[\"CREATE_LIST\"] = 2] = \"CREATE_LIST\";\n  OpCode2[OpCode2[\"UPDATE_OBJECT\"] = 3] = \"UPDATE_OBJECT\";\n  OpCode2[OpCode2[\"CREATE_OBJECT\"] = 4] = \"CREATE_OBJECT\";\n  OpCode2[OpCode2[\"DELETE_CRDT\"] = 5] = \"DELETE_CRDT\";\n  OpCode2[OpCode2[\"DELETE_OBJECT_KEY\"] = 6] = \"DELETE_OBJECT_KEY\";\n  OpCode2[OpCode2[\"CREATE_MAP\"] = 7] = \"CREATE_MAP\";\n  OpCode2[OpCode2[\"CREATE_REGISTER\"] = 8] = \"CREATE_REGISTER\";\n  return OpCode2;\n})(OpCode || {});\nfunction ackOp(opId) {\n  return {\n    type: 5 /* DELETE_CRDT */,\n    id: \"ACK\",\n    // (H)ACK\n    opId\n  };\n}\nfunction isAckOp(op) {\n  return op.type === 5 /* DELETE_CRDT */ && op.id === \"ACK\";\n}\n\n// src/crdts/AbstractCrdt.ts\nfunction createManagedPool(roomId, options) {\n  const {\n    getCurrentConnectionId,\n    onDispatch,\n    isStorageWritable = () => true\n  } = options;\n  let clock = 0;\n  let opClock = 0;\n  const nodes = /* @__PURE__ */ new Map();\n  return {\n    roomId,\n    nodes,\n    getNode: (id) => nodes.get(id),\n    addNode: (id, node) => void nodes.set(id, node),\n    deleteNode: (id) => void nodes.delete(id),\n    generateId: () => `${getCurrentConnectionId()}:${clock++}`,\n    generateOpId: () => `${getCurrentConnectionId()}:${opClock++}`,\n    dispatch(ops, reverse, storageUpdates) {\n      onDispatch?.(ops, reverse, storageUpdates);\n    },\n    assertStorageIsWritable: () => {\n      if (!isStorageWritable()) {\n        throw new Error(\n          \"Cannot write to storage with a read only user, please ensure the user has write permissions\"\n        );\n      }\n    }\n  };\n}\nfunction crdtAsLiveNode(value) {\n  return value;\n}\nfunction HasParent(node, key, pos = asPos(key)) {\n  return Object.freeze({ type: \"HasParent\", node, key, pos });\n}\nvar NoParent = Object.freeze({ type: \"NoParent\" });\nfunction Orphaned(oldKey, oldPos = asPos(oldKey)) {\n  return Object.freeze({ type: \"Orphaned\", oldKey, oldPos });\n}\nvar AbstractCrdt = class {\n  //                  ^^^^^^^^^^^^ TODO: Make this an interface\n  #pool;\n  #id;\n  #parent = NoParent;\n  /** @internal */\n  _getParentKeyOrThrow() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _parentPos() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.pos;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldPos;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _pool() {\n    return this.#pool;\n  }\n  get roomId() {\n    return this.#pool ? this.#pool.roomId : null;\n  }\n  /** @internal */\n  get _id() {\n    return this.#id;\n  }\n  /** @internal */\n  get parent() {\n    return this.#parent;\n  }\n  /** @internal */\n  get _parentKey() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        return null;\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _apply(op, _isLocal) {\n    switch (op.type) {\n      case 5 /* DELETE_CRDT */: {\n        if (this.parent.type === \"HasParent\") {\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\n        }\n        return { modified: false };\n      }\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _setParentLink(newParentNode, newParentKey) {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          this.#parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n      case \"Orphaned\":\n      case \"NoParent\": {\n        this.#parent = HasParent(newParentNode, newParentKey);\n        return;\n      }\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _attach(id, pool) {\n    if (this.#id || this.#pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n    pool.addNode(id, crdtAsLiveNode(this));\n    this.#id = id;\n    this.#pool = pool;\n  }\n  /** @internal */\n  _detach() {\n    if (this.#pool && this.#id) {\n      this.#pool.deleteNode(this.#id);\n    }\n    switch (this.parent.type) {\n      case \"HasParent\": {\n        this.#parent = Orphaned(this.parent.key, this.parent.pos);\n        break;\n      }\n      case \"NoParent\": {\n        this.#parent = NoParent;\n        break;\n      }\n      case \"Orphaned\": {\n        break;\n      }\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n    this.#pool = void 0;\n  }\n  /** This caches the result of the last .toImmutable() call for this Live node. */\n  #cachedImmutable;\n  #cachedTreeNodeKey;\n  /** This caches the result of the last .toTreeNode() call for this Live node. */\n  #cachedTreeNode;\n  /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */\n  invalidate() {\n    if (this.#cachedImmutable !== void 0 || this.#cachedTreeNode !== void 0) {\n      this.#cachedImmutable = void 0;\n      this.#cachedTreeNode = void 0;\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n  /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */\n  toTreeNode(key) {\n    if (this.#cachedTreeNode === void 0 || this.#cachedTreeNodeKey !== key) {\n      this.#cachedTreeNodeKey = key;\n      this.#cachedTreeNode = this._toTreeNode(key);\n    }\n    return this.#cachedTreeNode;\n  }\n  /**\n   * Return an immutable snapshot of this Live node and its children.\n   */\n  toImmutable() {\n    if (this.#cachedImmutable === void 0) {\n      this.#cachedImmutable = this._toImmutable();\n    }\n    return this.#cachedImmutable;\n  }\n};\n\n// src/protocol/SerializedCrdt.ts\nvar CrdtType = /* @__PURE__ */ ((CrdtType2) => {\n  CrdtType2[CrdtType2[\"OBJECT\"] = 0] = \"OBJECT\";\n  CrdtType2[CrdtType2[\"LIST\"] = 1] = \"LIST\";\n  CrdtType2[CrdtType2[\"MAP\"] = 2] = \"MAP\";\n  CrdtType2[CrdtType2[\"REGISTER\"] = 3] = \"REGISTER\";\n  return CrdtType2;\n})(CrdtType || {});\nfunction isRootCrdt(crdt) {\n  return crdt.type === 0 /* OBJECT */ && !isChildCrdt(crdt);\n}\nfunction isChildCrdt(crdt) {\n  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;\n}\n\n// src/crdts/LiveRegister.ts\nvar LiveRegister = class _LiveRegister extends AbstractCrdt {\n  #data;\n  constructor(data) {\n    super();\n    this.#data = data;\n  }\n  get data() {\n    return this.#data;\n  }\n  /** @internal */\n  static _deserialize([id, item], _parentToChildren, pool) {\n    const register = new _LiveRegister(item.data);\n    register._attach(id, pool);\n    return register;\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    }\n    return [\n      {\n        type: 8 /* CREATE_REGISTER */,\n        opId: pool?.generateOpId(),\n        id: this._id,\n        parentId,\n        parentKey,\n        data: this.data\n      }\n    ];\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n    return {\n      type: 3 /* REGISTER */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data\n    };\n  }\n  /** @internal */\n  _attachChild(_op) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _detachChild(_crdt) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"Json\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this.#data\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    return this.#data;\n  }\n  clone() {\n    return deepClone(this.data);\n  }\n};\n\n// src/crdts/LiveList.ts\nfunction compareNodePosition(itemA, itemB) {\n  const posA = itemA._parentPos;\n  const posB = itemB._parentPos;\n  return posA === posB ? 0 : posA < posB ? -1 : 1;\n}\nvar LiveList = class _LiveList extends AbstractCrdt {\n  // TODO: Naive array at first, find a better data structure. Maybe an Order statistics tree?\n  #items;\n  #implicitlyDeletedItems;\n  #unacknowledgedSets;\n  constructor(items) {\n    super();\n    this.#items = [];\n    this.#implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();\n    this.#unacknowledgedSets = /* @__PURE__ */ new Map();\n    let position = void 0;\n    for (const item of items) {\n      const newPosition = makePosition(position);\n      const node = lsonToLiveNode(item);\n      node._setParentLink(this, newPosition);\n      this.#items.push(node);\n      position = newPosition;\n    }\n  }\n  /** @internal */\n  static _deserialize([id], parentToChildren, pool) {\n    const list = new _LiveList([]);\n    list._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return list;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(list, crdt.parentKey);\n      list._insertAndSort(child);\n    }\n    return list;\n  }\n  /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 2 /* CREATE_LIST */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const item of this.#items) {\n      const parentKey2 = item._getParentKeyOrThrow();\n      const childOps = HACK_addIntentAndDeletedIdToOperation(\n        item._toOps(this._id, parentKey2, pool),\n        void 0\n      );\n      const childOpId = childOps[0].opId;\n      if (childOpId !== void 0) {\n        this.#unacknowledgedSets.set(parentKey2, childOpId);\n      }\n      ops.push(...childOps);\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   *\n   * Adds a new item into the sorted list, in the correct position.\n   */\n  _insertAndSort(item) {\n    this.#items.push(item);\n    this._sortItems();\n  }\n  /** @internal */\n  _sortItems() {\n    this.#items.sort(compareNodePosition);\n    this.invalidate();\n  }\n  /** @internal */\n  _indexOfPosition(position) {\n    return this.#items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const item of this.#items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this.#items) {\n      item._detach();\n    }\n  }\n  #applySetRemote(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    child._attach(id, this._pool);\n    child._setParentLink(this, key);\n    const deletedId = op.deletedId;\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = this.#items[indexOfItemWithSamePosition];\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n        this.#items[indexOfItemWithSamePosition] = child;\n        return {\n          modified: makeUpdate(this, [\n            setDelta(indexOfItemWithSamePosition, child)\n          ]),\n          reverse: []\n        };\n      } else {\n        this.#implicitlyDeletedItems.add(itemWithSamePosition);\n        this.#items[indexOfItemWithSamePosition] = child;\n        const delta = [\n          setDelta(indexOfItemWithSamePosition, child)\n        ];\n        const deleteDelta2 = this.#detachItemAssociatedToSetOperation(\n          op.deletedId\n        );\n        if (deleteDelta2) {\n          delta.push(deleteDelta2);\n        }\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: []\n        };\n      }\n    } else {\n      const updates = [];\n      const deleteDelta2 = this.#detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deleteDelta2) {\n        updates.push(deleteDelta2);\n      }\n      this._insertAndSort(child);\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates)\n      };\n    }\n  }\n  #applySetAck(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const delta = [];\n    const deletedDelta = this.#detachItemAssociatedToSetOperation(op.deletedId);\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n    const unacknowledgedOpId = this.#unacknowledgedSets.get(op.parentKey);\n    if (unacknowledgedOpId !== void 0) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };\n      } else {\n        this.#unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n    const existingItem = this.#items.find((item) => item._id === op.id);\n    if (existingItem !== void 0) {\n      if (existingItem._parentKey === op.parentKey) {\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: []\n        };\n      }\n      if (indexOfItemWithSamePosition !== -1) {\n        this.#implicitlyDeletedItems.add(\n          this.#items[indexOfItemWithSamePosition]\n        );\n        const [prevNode] = this.#items.splice(indexOfItemWithSamePosition, 1);\n        delta.push(deleteDelta(indexOfItemWithSamePosition, prevNode));\n      }\n      const prevIndex = this.#items.indexOf(existingItem);\n      existingItem._setParentLink(this, op.parentKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(existingItem);\n      if (newIndex !== prevIndex) {\n        delta.push(moveDelta(prevIndex, newIndex, existingItem));\n      }\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: []\n      };\n    } else {\n      const orphan = this._pool.getNode(op.id);\n      if (orphan && this.#implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, op.parentKey);\n        this.#implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const recreatedItemIndex = this.#items.indexOf(orphan);\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),\n            ...delta\n          ]),\n          reverse: []\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          this.#items.splice(indexOfItemWithSamePosition, 1);\n        }\n        const { newItem, newIndex } = this.#createAttachItemAndSort(\n          op,\n          op.parentKey\n        );\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),\n            ...delta\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /**\n   * Returns the update delta of the deletion or null\n   */\n  #detachItemAssociatedToSetOperation(deletedId) {\n    if (deletedId === void 0 || this._pool === void 0) {\n      return null;\n    }\n    const deletedItem = this._pool.getNode(deletedId);\n    if (deletedItem === void 0) {\n      return null;\n    }\n    const result = this._detachChild(deletedItem);\n    if (result.modified === false) {\n      return null;\n    }\n    return result.modified.updates[0];\n  }\n  #applyRemoteInsert(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const key = asPos(op.parentKey);\n    const existingItemIndex = this._indexOfPosition(key);\n    if (existingItemIndex !== -1) {\n      this.#shiftItemPosition(existingItemIndex, key);\n    }\n    const { newItem, newIndex } = this.#createAttachItemAndSort(op, key);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: []\n    };\n  }\n  #applyInsertAck(op) {\n    const existingItem = this.#items.find((item) => item._id === op.id);\n    const key = asPos(op.parentKey);\n    const itemIndexAtPosition = this._indexOfPosition(key);\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        return {\n          modified: false\n        };\n      } else {\n        const oldPositionIndex = this.#items.indexOf(existingItem);\n        if (itemIndexAtPosition !== -1) {\n          this.#shiftItemPosition(itemIndexAtPosition, key);\n        }\n        existingItem._setParentLink(this, key);\n        this._sortItems();\n        const newIndex = this._indexOfPosition(key);\n        if (newIndex === oldPositionIndex) {\n          return { modified: false };\n        }\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(oldPositionIndex, newIndex, existingItem)\n          ]),\n          reverse: []\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n      if (orphan && this.#implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, key);\n        this.#implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const newIndex = this._indexOfPosition(key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: []\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this.#shiftItemPosition(itemIndexAtPosition, key);\n        }\n        const { newItem, newIndex } = this.#createAttachItemAndSort(op, key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: []\n        };\n      }\n    }\n  }\n  #applyInsertUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const existingItemIndex = this._indexOfPosition(key);\n    let newKey = key;\n    if (existingItemIndex !== -1) {\n      const before2 = this.#items[existingItemIndex]?._parentPos;\n      const after2 = this.#items[existingItemIndex + 1]?._parentPos;\n      newKey = makePosition(before2, after2);\n      child._setParentLink(this, newKey);\n    }\n    this._insertAndSort(child);\n    const newIndex = this._indexOfPosition(newKey);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{ type: 5 /* DELETE_CRDT */, id }]\n    };\n  }\n  #applySetUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    this.#unacknowledgedSets.set(key, nn(op.opId));\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const newKey = key;\n    if (indexOfItemWithSameKey !== -1) {\n      const existingItem = this.#items[indexOfItemWithSameKey];\n      existingItem._detach();\n      this.#items[indexOfItemWithSameKey] = child;\n      const reverse = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(nn(this._id), key, this._pool),\n        op.id\n      );\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n      const deletedDelta = this.#detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n      return {\n        modified: makeUpdate(this, delta),\n        reverse\n      };\n    } else {\n      this._insertAndSort(child);\n      this.#detachItemAssociatedToSetOperation(op.deletedId);\n      const newIndex = this._indexOfPosition(newKey);\n      return {\n        reverse: [{ type: 5 /* DELETE_CRDT */, id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)])\n      };\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    let result;\n    if (op.intent === \"set\") {\n      if (source === 1 /* REMOTE */) {\n        result = this.#applySetRemote(op);\n      } else if (source === 2 /* ACK */) {\n        result = this.#applySetAck(op);\n      } else {\n        result = this.#applySetUndoRedo(op);\n      }\n    } else {\n      if (source === 1 /* REMOTE */) {\n        result = this.#applyRemoteInsert(op);\n      } else if (source === 2 /* ACK */) {\n        result = this.#applyInsertAck(op);\n      } else {\n        result = this.#applyInsertUndoRedo(op);\n      }\n    }\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n    return result;\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n      const indexToDelete = this.#items.indexOf(child);\n      if (indexToDelete === -1) {\n        return {\n          modified: false\n        };\n      }\n      const [previousNode] = this.#items.splice(indexToDelete, 1);\n      this.invalidate();\n      child._detach();\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete, previousNode)]),\n        reverse\n      };\n    }\n    return { modified: false };\n  }\n  #applySetChildKeyRemote(newKey, child) {\n    if (this.#implicitlyDeletedItems.has(child)) {\n      this.#implicitlyDeletedItems.delete(child);\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      const newIndex = this.#items.indexOf(child);\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: []\n      };\n    }\n    const previousKey = child._parentKey;\n    if (newKey === previousKey) {\n      return {\n        modified: false\n      };\n    }\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex === -1) {\n      const previousIndex = this.#items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    } else {\n      this.#items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n      );\n      const previousIndex = this.#items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    }\n  }\n  #applySetChildKeyAck(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    if (this.#implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n      this.#implicitlyDeletedItems.delete(child);\n      if (existingItemIndex !== -1) {\n        this.#items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      return {\n        modified: false\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false\n        };\n      }\n      const previousIndex = this.#items.indexOf(child);\n      const existingItemIndex = this._indexOfPosition(newKey);\n      if (existingItemIndex !== -1) {\n        this.#items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(child);\n      if (previousIndex === newIndex) {\n        return {\n          modified: false\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child)\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  #applySetChildKeyUndoRedo(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    const previousIndex = this.#items.indexOf(child);\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex !== -1) {\n      this.#items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n      );\n    }\n    child._setParentLink(this, newKey);\n    this._sortItems();\n    const newIndex = this.#items.indexOf(child);\n    if (previousIndex === newIndex) {\n      return {\n        modified: false\n      };\n    }\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [\n        {\n          type: 1 /* SET_PARENT_KEY */,\n          id: nn(child._id),\n          parentKey: previousKey\n        }\n      ]\n    };\n  }\n  /** @internal */\n  _setChildKey(newKey, child, source) {\n    if (source === 1 /* REMOTE */) {\n      return this.#applySetChildKeyRemote(newKey, child);\n    } else if (source === 2 /* ACK */) {\n      return this.#applySetChildKeyAck(newKey, child);\n    } else {\n      return this.#applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n    return {\n      type: 1 /* LIST */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns the number of elements.\n   */\n  get length() {\n    return this.#items.length;\n  }\n  /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */\n  push(element) {\n    this._pool?.assertStorageIsWritable();\n    return this.insert(element, this.length);\n  }\n  /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */\n  insert(element, index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index > this.#items.length) {\n      throw new Error(\n        `Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this.#items.length}`\n      );\n    }\n    const before2 = this.#items[index - 1] ? this.#items[index - 1]._parentPos : void 0;\n    const after2 = this.#items[index] ? this.#items[index]._parentPos : void 0;\n    const position = makePosition(before2, after2);\n    const value = lsonToLiveNode(element);\n    value._setParentLink(this, position);\n    this._insertAndSort(value);\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      this._pool.dispatch(\n        value._toOps(this._id, position, this._pool),\n        [{ type: 5 /* DELETE_CRDT */, id }],\n        /* @__PURE__ */ new Map([\n          [this._id, makeUpdate(this, [insertDelta(index, value)])]\n        ])\n      );\n    }\n  }\n  /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */\n  move(index, targetIndex) {\n    this._pool?.assertStorageIsWritable();\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n    if (targetIndex >= this.#items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n    if (index >= this.#items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n    let beforePosition = null;\n    let afterPosition = null;\n    if (index < targetIndex) {\n      afterPosition = targetIndex === this.#items.length - 1 ? void 0 : this.#items[targetIndex + 1]._parentPos;\n      beforePosition = this.#items[targetIndex]._parentPos;\n    } else {\n      afterPosition = this.#items[targetIndex]._parentPos;\n      beforePosition = targetIndex === 0 ? void 0 : this.#items[targetIndex - 1]._parentPos;\n    }\n    const position = makePosition(beforePosition, afterPosition);\n    const item = this.#items[index];\n    const previousPosition = item._getParentKeyOrThrow();\n    item._setParentLink(this, position);\n    this._sortItems();\n    if (this._pool && this._id) {\n      const storageUpdates = /* @__PURE__ */ new Map([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]\n      ]);\n      this._pool.dispatch(\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            opId: this._pool.generateOpId(),\n            parentKey: position\n          }\n        ],\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            parentKey: previousPosition\n          }\n        ],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */\n  delete(index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this.#items.length) {\n      throw new Error(\n        `Cannot delete list item at index \"${index}\". index should be between 0 and ${this.#items.length - 1}`\n      );\n    }\n    const item = this.#items[index];\n    item._detach();\n    const [prev] = this.#items.splice(index, 1);\n    this.invalidate();\n    if (this._pool) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index, prev)])\n        );\n        this._pool.dispatch(\n          [\n            {\n              id: childRecordId,\n              opId: this._pool.generateOpId(),\n              type: 5 /* DELETE_CRDT */\n            }\n          ],\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\n          storageUpdates\n        );\n      }\n    }\n  }\n  clear() {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool) {\n      const ops = [];\n      const reverseOps = [];\n      const updateDelta = [];\n      for (const item of this.#items) {\n        item._detach();\n        const childId = item._id;\n        if (childId) {\n          ops.push({\n            type: 5 /* DELETE_CRDT */,\n            id: childId,\n            opId: this._pool.generateOpId()\n          });\n          reverseOps.push(\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\n          );\n          updateDelta.push(deleteDelta(0, item));\n        }\n      }\n      this.#items = [];\n      this.invalidate();\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this.#items) {\n        item._detach();\n      }\n      this.#items = [];\n      this.invalidate();\n    }\n  }\n  set(index, item) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this.#items.length) {\n      throw new Error(\n        `Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${this.#items.length - 1}`\n      );\n    }\n    const existingItem = this.#items[index];\n    const position = existingItem._getParentKeyOrThrow();\n    const existingId = existingItem._id;\n    existingItem._detach();\n    const value = lsonToLiveNode(item);\n    value._setParentLink(this, position);\n    this.#items[index] = value;\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n      const ops = HACK_addIntentAndDeletedIdToOperation(\n        value._toOps(this._id, position, this._pool),\n        existingId\n      );\n      this.#unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(this._id, position, void 0),\n        id\n      );\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n  /**\n   * Returns an Array of all the elements in the LiveList.\n   */\n  toArray() {\n    return this.#items.map(\n      (entry) => liveNodeToLson(entry)\n      //                               ^^^^^^^^\n      //                               FIXME! This isn't safe.\n    );\n  }\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */\n  every(predicate) {\n    return this.toArray().every(predicate);\n  }\n  /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */\n  filter(predicate) {\n    return this.toArray().filter(predicate);\n  }\n  /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */\n  find(predicate) {\n    return this.toArray().find(predicate);\n  }\n  /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */\n  findIndex(predicate) {\n    return this.toArray().findIndex(predicate);\n  }\n  /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */\n  forEach(callbackfn) {\n    return this.toArray().forEach(callbackfn);\n  }\n  /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */\n  get(index) {\n    if (index < 0 || index >= this.#items.length) {\n      return void 0;\n    }\n    return liveNodeToLson(this.#items[index]);\n  }\n  /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */\n  indexOf(searchElement, fromIndex) {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n  /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */\n  lastIndexOf(searchElement, fromIndex) {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n  /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */\n  map(callback) {\n    return this.#items.map(\n      (entry, i) => callback(\n        liveNodeToLson(entry),\n        //                    ^^^^^^^^\n        //                    FIXME! This isn't safe.\n        i\n      )\n    );\n  }\n  /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */\n  some(predicate) {\n    return this.toArray().some(predicate);\n  }\n  [Symbol.iterator]() {\n    return new LiveListIterator(this.#items);\n  }\n  #createAttachItemAndSort(op, key) {\n    const newItem = creationOpToLiveNode(op);\n    newItem._attach(op.id, nn(this._pool));\n    newItem._setParentLink(this, key);\n    this._insertAndSort(newItem);\n    const newIndex = this._indexOfPosition(key);\n    return { newItem, newIndex };\n  }\n  #shiftItemPosition(index, key) {\n    const shiftedPosition = makePosition(\n      key,\n      this.#items.length > index + 1 ? this.#items[index + 1]?._parentPos : void 0\n    );\n    this.#items[index]._setParentLink(this, shiftedPosition);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveList\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this.#items.map(\n        (item, index) => item.toTreeNode(index.toString())\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = this.#items.map((node) => node.toImmutable());\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveList(this.#items.map((item) => item.clone()));\n  }\n};\nvar LiveListIterator = class {\n  #innerIterator;\n  constructor(items) {\n    this.#innerIterator = items[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const result = this.#innerIterator.next();\n    if (result.done) {\n      return {\n        done: true,\n        value: void 0\n      };\n    }\n    const value = liveNodeToLson(result.value);\n    return { value };\n  }\n};\nfunction makeUpdate(liveList, deltaUpdates) {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates\n  };\n}\nfunction setDelta(index, item) {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction deleteDelta(index, deletedNode) {\n  return {\n    type: \"delete\",\n    index,\n    deletedItem: deletedNode instanceof LiveRegister ? deletedNode.data : deletedNode\n  };\n}\nfunction insertDelta(index, item) {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction moveDelta(previousIndex, index, item) {\n  return {\n    type: \"move\",\n    index,\n    item: item instanceof LiveRegister ? item.data : item,\n    previousIndex\n  };\n}\nfunction HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {\n  return ops.map((op, index) => {\n    if (index === 0) {\n      const firstOp = op;\n      return {\n        ...firstOp,\n        intent: \"set\",\n        deletedId\n      };\n    } else {\n      return op;\n    }\n  });\n}\n\n// src/crdts/LiveMap.ts\nvar LiveMap = class _LiveMap extends AbstractCrdt {\n  #map;\n  #unacknowledgedSet;\n  constructor(entries2) {\n    super();\n    this.#unacknowledgedSet = /* @__PURE__ */ new Map();\n    if (entries2) {\n      const mappedEntries = [];\n      for (const [key, value] of entries2) {\n        const node = lsonToLiveNode(value);\n        node._setParentLink(this, key);\n        mappedEntries.push([key, node]);\n      }\n      this.#map = new Map(mappedEntries);\n    } else {\n      this.#map = /* @__PURE__ */ new Map();\n    }\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 7 /* CREATE_MAP */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const [key, value] of this.#map) {\n      ops.push(...value._toOps(this._id, key, pool));\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, _item], parentToChildren, pool) {\n    const map = new _LiveMap();\n    map._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return map;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(map, crdt.parentKey);\n      map.#map.set(crdt.parentKey, child);\n      map.invalidate();\n    }\n    return map;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey, opId } = op;\n    const key = parentKey;\n    const child = creationOpToLiveNode(op);\n    if (this._pool.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    if (source === 2 /* ACK */) {\n      const lastUpdateOpId = this.#unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId) {\n        this.#unacknowledgedSet.delete(key);\n        return { modified: false };\n      } else if (lastUpdateOpId !== void 0) {\n        return { modified: false };\n      }\n    } else if (source === 1 /* REMOTE */) {\n      this.#unacknowledgedSet.delete(key);\n    }\n    const previousValue = this.#map.get(key);\n    let reverse;\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else {\n      reverse = [{ type: 5 /* DELETE_CRDT */, id }];\n    }\n    child._setParentLink(this, key);\n    child._attach(id, this._pool);\n    this.#map.set(key, child);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      },\n      reverse\n    };\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this.#map.values()) {\n      item._detach();\n    }\n  }\n  /** @internal */\n  _detachChild(child) {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n    const reverse = child._toOps(id, parentKey, this._pool);\n    for (const [key, value] of this.#map) {\n      if (value === child) {\n        this.#map.delete(key);\n        this.invalidate();\n      }\n    }\n    child._detach();\n    const storageUpdate = {\n      node: this,\n      type: \"LiveMap\",\n      updates: { [parentKey]: { type: \"delete\" } }\n    };\n    return { modified: storageUpdate, reverse };\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n    return {\n      type: 2 /* MAP */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */\n  get(key) {\n    const value = this.#map.get(key);\n    if (value === void 0) {\n      return void 0;\n    }\n    return liveNodeToLson(value);\n  }\n  /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    const oldValue = this.#map.get(key);\n    if (oldValue) {\n      oldValue._detach();\n    }\n    const item = lsonToLiveNode(value);\n    item._setParentLink(this, key);\n    this.#map.set(key, item);\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      item._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      });\n      const ops = item._toOps(this._id, key, this._pool);\n      this.#unacknowledgedSet.set(key, nn(ops[0].opId));\n      this._pool.dispatch(\n        item._toOps(this._id, key, this._pool),\n        oldValue ? oldValue._toOps(this._id, key) : [{ type: 5 /* DELETE_CRDT */, id }],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Returns the number of elements in the LiveMap.\n   */\n  get size() {\n    return this.#map.size;\n  }\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */\n  has(key) {\n    return this.#map.has(key);\n  }\n  /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const item = this.#map.get(key);\n    if (item === void 0) {\n      return false;\n    }\n    item._detach();\n    this.#map.delete(key);\n    this.invalidate();\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"delete\" } }\n      });\n      this._pool.dispatch(\n        [\n          {\n            type: 5 /* DELETE_CRDT */,\n            id: item._id,\n            opId: this._pool.generateOpId()\n          }\n        ],\n        item._toOps(thisId, key),\n        storageUpdates\n      );\n    }\n    return true;\n  }\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */\n  entries() {\n    const innerIterator = this.#map.entries();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const entry = iteratorValue.value;\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]);\n        return {\n          value: [key, value]\n        };\n      }\n    };\n  }\n  /**\n   * Same function object as the initial value of the entries method.\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */\n  keys() {\n    return this.#map.keys();\n  }\n  /**\n   * Returns a new Iterator object that contains the values for each element.\n   */\n  values() {\n    const innerIterator = this.#map.values();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const value = liveNodeToLson(iteratorValue.value);\n        return { value };\n      }\n    };\n  }\n  /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */\n  forEach(callback) {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveMap\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: Array.from(this.#map.entries()).map(\n        ([key2, val]) => val.toTreeNode(key2)\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = /* @__PURE__ */ new Map();\n    for (const [key, value] of this.#map) {\n      result.set(key, value.toImmutable());\n    }\n    return freeze(result);\n  }\n  clone() {\n    return new _LiveMap(\n      Array.from(this.#map).map(([key, node]) => [key, node.clone()])\n    );\n  }\n};\n\n// src/crdts/LiveObject.ts\nvar LiveObject = class _LiveObject extends AbstractCrdt {\n  #map;\n  #propToLastUpdate;\n  static #buildRootAndParentToChildren(items) {\n    const parentToChildren = /* @__PURE__ */ new Map();\n    let root = null;\n    for (const [id, crdt] of items) {\n      if (isRootCrdt(crdt)) {\n        root = [id, crdt];\n      } else {\n        const tuple = [id, crdt];\n        const children = parentToChildren.get(crdt.parentId);\n        if (children !== void 0) {\n          children.push(tuple);\n        } else {\n          parentToChildren.set(crdt.parentId, [tuple]);\n        }\n      }\n    }\n    if (root === null) {\n      throw new Error(\"Root can't be null\");\n    }\n    return [root, parentToChildren];\n  }\n  /** @private Do not use this API directly */\n  static _fromItems(items, pool) {\n    const [root, parentToChildren] = _LiveObject.#buildRootAndParentToChildren(items);\n    return _LiveObject._deserialize(\n      root,\n      parentToChildren,\n      pool\n    );\n  }\n  constructor(obj = {}) {\n    super();\n    this.#propToLastUpdate = /* @__PURE__ */ new Map();\n    const o = compactObject(obj);\n    for (const key of Object.keys(o)) {\n      const value = o[key];\n      if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n    this.#map = new Map(Object.entries(o));\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const opId = pool?.generateOpId();\n    const ops = [];\n    const op = {\n      type: 4 /* CREATE_OBJECT */,\n      id: this._id,\n      opId,\n      parentId,\n      parentKey,\n      data: {}\n    };\n    ops.push(op);\n    for (const [key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        ops.push(...value._toOps(this._id, key, pool));\n      } else {\n        op.data[key] = value;\n      }\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, item], parentToChildren, pool) {\n    const liveObj = new _LiveObject(item.data);\n    liveObj._attach(id, pool);\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n  /** @internal */\n  static _deserializeChildren(liveObj, parentToChildren, pool) {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (children === void 0) {\n      return liveObj;\n    }\n    for (const [id, crdt] of children) {\n      const child = deserializeToLson([id, crdt], parentToChildren, pool);\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n      liveObj.#map.set(crdt.parentKey, child);\n      liveObj.invalidate();\n    }\n    return liveObj;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, opId, parentKey: key } = op;\n    const child = creationOpToLson(op);\n    if (this._pool.getNode(id) !== void 0) {\n      if (this.#propToLastUpdate.get(key) === opId) {\n        this.#propToLastUpdate.delete(key);\n      }\n      return { modified: false };\n    }\n    if (source === 0 /* UNDOREDO_RECONNECT */) {\n      this.#propToLastUpdate.set(key, nn(opId));\n    } else if (this.#propToLastUpdate.get(key) === void 0) {\n    } else if (this.#propToLastUpdate.get(key) === opId) {\n      this.#propToLastUpdate.delete(key);\n      return { modified: false };\n    } else {\n      return { modified: false };\n    }\n    const thisId = nn(this._id);\n    const previousValue = this.#map.get(key);\n    let reverse;\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else if (previousValue === void 0) {\n      reverse = [{ type: 6 /* DELETE_OBJECT_KEY */, id: thisId, key }];\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id: thisId,\n          data: { [key]: previousValue }\n        }\n      ];\n    }\n    this.#map.set(key, child);\n    this.invalidate();\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n      child._attach(id, this._pool);\n    }\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [key]: { type: \"update\" } }\n      }\n    };\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(id, parentKey, this._pool);\n      for (const [key, value] of this.#map) {\n        if (value === child) {\n          this.#map.delete(key);\n          this.invalidate();\n        }\n      }\n      child._detach();\n      const storageUpdate = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: { type: \"delete\" }\n        }\n      };\n      return { modified: storageUpdate, reverse };\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const value of this.#map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    if (op.type === 3 /* UPDATE_OBJECT */) {\n      return this.#applyUpdate(op, isLocal);\n    } else if (op.type === 6 /* DELETE_OBJECT_KEY */) {\n      return this.#applyDeleteObjectKey(op, isLocal);\n    }\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    const data = {};\n    for (const [key, value] of this.#map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: 0 /* OBJECT */,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data\n      };\n    } else {\n      return {\n        type: 0 /* OBJECT */,\n        data\n      };\n    }\n  }\n  #applyUpdate(op, isLocal) {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse = [];\n    const reverseUpdate = {\n      type: 3 /* UPDATE_OBJECT */,\n      id,\n      data: {}\n    };\n    for (const key in op.data) {\n      const oldValue = this.#map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverse.push(...oldValue._toOps(id, key));\n        oldValue._detach();\n      } else if (oldValue !== void 0) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === void 0) {\n        reverse.push({ type: 6 /* DELETE_OBJECT_KEY */, id, key });\n      }\n    }\n    const updateDelta = {};\n    for (const key in op.data) {\n      const value = op.data[key];\n      if (value === void 0) {\n        continue;\n      }\n      if (isLocal) {\n        this.#propToLastUpdate.set(key, nn(op.opId));\n      } else if (this.#propToLastUpdate.get(key) === void 0) {\n        isModified = true;\n      } else if (this.#propToLastUpdate.get(key) === op.opId) {\n        this.#propToLastUpdate.delete(key);\n        continue;\n      } else {\n        continue;\n      }\n      const oldValue = this.#map.get(key);\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      isModified = true;\n      updateDelta[key] = { type: \"update\" };\n      this.#map.set(key, value);\n      this.invalidate();\n    }\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n    return isModified ? {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: updateDelta\n      },\n      reverse\n    } : { modified: false };\n  }\n  #applyDeleteObjectKey(op, isLocal) {\n    const key = op.key;\n    if (this.#map.has(key) === false) {\n      return { modified: false };\n    }\n    if (!isLocal && this.#propToLastUpdate.get(key) !== void 0) {\n      return { modified: false };\n    }\n    const oldValue = this.#map.get(key);\n    const id = nn(this._id);\n    let reverse = [];\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n      oldValue._detach();\n    } else if (oldValue !== void 0) {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id,\n          data: { [key]: oldValue }\n        }\n      ];\n    }\n    this.#map.delete(key);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [op.key]: { type: \"delete\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * Transform the LiveObject into a javascript object\n   */\n  toObject() {\n    return Object.fromEntries(this.#map);\n  }\n  /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    this.update({ [key]: value });\n  }\n  /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */\n  get(key) {\n    return this.#map.get(key);\n  }\n  /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const keyAsString = key;\n    const oldValue = this.#map.get(keyAsString);\n    if (oldValue === void 0) {\n      return;\n    }\n    if (this._pool === void 0 || this._id === void 0) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      this.#map.delete(keyAsString);\n      this.invalidate();\n      return;\n    }\n    let reverse;\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          data: { [keyAsString]: oldValue },\n          id: this._id\n        }\n      ];\n    }\n    this.#map.delete(keyAsString);\n    this.invalidate();\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: { [key]: { type: \"delete\" } }\n    });\n    this._pool.dispatch(\n      [\n        {\n          type: 6 /* DELETE_OBJECT_KEY */,\n          key: keyAsString,\n          id: this._id,\n          opId: this._pool.generateOpId()\n        }\n      ],\n      reverse,\n      storageUpdates\n    );\n  }\n  /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */\n  update(patch) {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool === void 0 || this._id === void 0) {\n      for (const key in patch) {\n        const newValue = patch[key];\n        if (newValue === void 0) {\n          continue;\n        }\n        const oldValue = this.#map.get(key);\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n        this.#map.set(key, newValue);\n        this.invalidate();\n      }\n      return;\n    }\n    const ops = [];\n    const reverseOps = [];\n    const opId = this._pool.generateOpId();\n    const updatedProps = {};\n    const reverseUpdateOp = {\n      id: this._id,\n      type: 3 /* UPDATE_OBJECT */,\n      data: {}\n    };\n    const updateDelta = {};\n    for (const key in patch) {\n      const newValue = patch[key];\n      if (newValue === void 0) {\n        continue;\n      }\n      const oldValue = this.#map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverseOps.push(...oldValue._toOps(this._id, key));\n        oldValue._detach();\n      } else if (oldValue === void 0) {\n        reverseOps.push({ type: 6 /* DELETE_OBJECT_KEY */, id: this._id, key });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n        newValue._attach(this._pool.generateId(), this._pool);\n        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n        const createCrdtOp = newAttachChildOps.find(\n          (op) => op.parentId === this._id\n        );\n        if (createCrdtOp) {\n          this.#propToLastUpdate.set(key, nn(createCrdtOp.opId));\n        }\n        ops.push(...newAttachChildOps);\n      } else {\n        updatedProps[key] = newValue;\n        this.#propToLastUpdate.set(key, opId);\n      }\n      this.#map.set(key, newValue);\n      this.invalidate();\n      updateDelta[key] = { type: \"update\" };\n    }\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: 3 /* UPDATE_OBJECT */,\n        data: updatedProps\n      });\n    }\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta\n    });\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  toTreeNode(key) {\n    return super.toTreeNode(key);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    const nodeId = this._id ?? nanoid();\n    return {\n      type: \"LiveObject\",\n      id: nodeId,\n      key,\n      payload: Array.from(this.#map.entries()).map(\n        ([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : { type: \"Json\", id: `${nodeId}:${key2}`, key: key2, payload: value }\n      )\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = {};\n    for (const [key, val] of this.#map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveObject(\n      Object.fromEntries(\n        Array.from(this.#map).map(([key, value]) => [\n          key,\n          isLiveStructure(value) ? value.clone() : deepClone(value)\n        ])\n      )\n    );\n  }\n};\n\n// src/crdts/liveblocks-helpers.ts\nfunction creationOpToLiveNode(op) {\n  return lsonToLiveNode(creationOpToLson(op));\n}\nfunction creationOpToLson(op) {\n  switch (op.type) {\n    case 8 /* CREATE_REGISTER */:\n      return op.data;\n    case 4 /* CREATE_OBJECT */:\n      return new LiveObject(op.data);\n    case 7 /* CREATE_MAP */:\n      return new LiveMap();\n    case 2 /* CREATE_LIST */:\n      return new LiveList([]);\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\nfunction isSameNodeOrChildOf(node, parent) {\n  if (node === parent) {\n    return true;\n  }\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n  return false;\n}\nfunction deserialize([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction deserializeToLson([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return crdt.data;\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction isLiveStructure(value) {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\nfunction isLiveNode(value) {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\nfunction isLiveList(value) {\n  return value instanceof LiveList;\n}\nfunction isLiveMap(value) {\n  return value instanceof LiveMap;\n}\nfunction isLiveObject(value) {\n  return value instanceof LiveObject;\n}\nfunction isLiveRegister(value) {\n  return value instanceof LiveRegister;\n}\nfunction cloneLson(value) {\n  return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);\n}\nfunction liveNodeToLson(obj) {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\nfunction lsonToLiveNode(value) {\n  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\nfunction getTreesDiffOperations(currentItems, newItems) {\n  const ops = [];\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      ops.push({\n        type: 5 /* DELETE_CRDT */,\n        id\n      });\n    }\n  });\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n    if (currentCrdt) {\n      if (crdt.type === 0 /* OBJECT */) {\n        if (currentCrdt.type !== 0 /* OBJECT */ || stringifyOrLog(crdt.data) !== stringifyOrLog(currentCrdt.data)) {\n          ops.push({\n            type: 3 /* UPDATE_OBJECT */,\n            id,\n            data: crdt.data\n          });\n        }\n      }\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: 1 /* SET_PARENT_KEY */,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\")\n        });\n      }\n    } else {\n      switch (crdt.type) {\n        case 3 /* REGISTER */:\n          ops.push({\n            type: 8 /* CREATE_REGISTER */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 1 /* LIST */:\n          ops.push({\n            type: 2 /* CREATE_LIST */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n        case 0 /* OBJECT */:\n          if (crdt.parentId === void 0 || crdt.parentKey === void 0) {\n            throw new Error(\n              \"Internal error. Cannot serialize storage root into an operation\"\n            );\n          }\n          ops.push({\n            type: 4 /* CREATE_OBJECT */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 2 /* MAP */:\n          ops.push({\n            type: 7 /* CREATE_MAP */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n      }\n    }\n  });\n  return ops;\n}\nfunction mergeObjectStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeMapStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeListStorageUpdates(first, second) {\n  const updates = first.updates;\n  return {\n    ...second,\n    updates: updates.concat(second.updates)\n  };\n}\nfunction mergeStorageUpdates(first, second) {\n  if (first === void 0) {\n    return second;\n  }\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {\n  }\n  return second;\n}\nfunction isPlain(value) {\n  const type = typeof value;\n  return value === void 0 || value === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(value) || isPlainObject(value);\n}\nfunction findNonSerializableValue(value, path = \"\") {\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n  return false;\n}\n\n// src/lib/debug.ts\nfunction captureStackTrace(msg, traceRoot) {\n  const errorLike = { name: msg };\n  if (typeof Error.captureStackTrace !== \"function\") {\n    return void 0;\n  }\n  Error.captureStackTrace(errorLike, traceRoot);\n  return errorLike.stack;\n}\n\n// src/lib/Deque.ts\nvar Deque = class {\n  #data;\n  #front;\n  #back;\n  #size;\n  constructor() {\n    this.#data = {};\n    this.#front = 0;\n    this.#back = 1;\n    this.#size = 0;\n  }\n  get length() {\n    return this.#size;\n  }\n  *[Symbol.iterator]() {\n    const size = this.#size;\n    const front = this.#front;\n    for (let i = 0; i < size; i++) {\n      yield this.#data[front + i];\n    }\n  }\n  push(value) {\n    const values2 = Array.isArray(value) ? value : [value];\n    if (this.#back > Number.MAX_SAFE_INTEGER - values2.length - 1)\n      raise(\"Deque full\");\n    for (const value2 of values2) {\n      this.#data[this.#back++ - 1] = value2;\n    }\n    this.#size += values2.length;\n  }\n  pop() {\n    if (this.#size < 1) return void 0;\n    this.#back--;\n    const value = this.#data[this.#back - 1];\n    delete this.#data[this.#back - 1];\n    this.#size--;\n    return value;\n  }\n  pushLeft(value) {\n    const values2 = Array.isArray(value) ? value : [value];\n    if (this.#front < Number.MIN_SAFE_INTEGER + values2.length)\n      raise(\"Deque full\");\n    for (let i = values2.length - 1; i >= 0; i--) {\n      this.#data[--this.#front] = values2[i];\n    }\n    this.#size += values2.length;\n  }\n  popLeft() {\n    if (this.#size < 1) return void 0;\n    const value = this.#data[this.#front];\n    delete this.#data[this.#front];\n    this.#front++;\n    this.#size--;\n    return value;\n  }\n};\n\n// src/lib/Json.ts\nfunction isJsonScalar(data) {\n  return data === null || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\";\n}\nfunction isJsonArray(data) {\n  return Array.isArray(data);\n}\nfunction isJsonObject(data) {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n\n// src/protocol/ClientMsg.ts\nvar ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2) => {\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ClientMsgCode2[ClientMsgCode2[\"BROADCAST_EVENT\"] = 103] = \"BROADCAST_EVENT\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_STORAGE\"] = 200] = \"FETCH_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_YDOC\"] = 300] = \"FETCH_YDOC\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_YDOC\"] = 301] = \"UPDATE_YDOC\";\n  return ClientMsgCode2;\n})(ClientMsgCode || {});\n\n// src/refs/ManagedOthers.ts\nfunction makeUser(conn, presence) {\n  const { connectionId, id, info } = conn;\n  const canWrite = canWriteStorage(conn.scopes);\n  return freeze(\n    compactObject({\n      connectionId,\n      id,\n      info,\n      canWrite,\n      canComment: canComment(conn.scopes),\n      isReadOnly: !canWrite,\n      // Deprecated, kept for backward-compatibility\n      presence\n    })\n  );\n}\nvar ManagedOthers = class {\n  // Track mutable state internally, but signal to the outside when the\n  // observable derived state changes only\n  #internal;\n  #userCache;\n  // The \"clean\" signal that is exposed to the outside world\n  signal;\n  constructor() {\n    this.#internal = new MutableSignal({\n      connections: /* @__PURE__ */ new Map(),\n      presences: /* @__PURE__ */ new Map()\n    });\n    this.signal = DerivedSignal.from(\n      this.#internal,\n      (_ignore) => compact(\n        Array.from(this.#internal.get().presences.keys()).map(\n          (connectionId) => this.getUser(Number(connectionId))\n        )\n      )\n    );\n    this.#userCache = /* @__PURE__ */ new Map();\n  }\n  // Shorthand for .signal.get()\n  get() {\n    return this.signal.get();\n  }\n  connectionIds() {\n    return this.#internal.get().connections.keys();\n  }\n  clearOthers() {\n    this.#internal.mutate((state) => {\n      state.connections.clear();\n      state.presences.clear();\n      this.#userCache.clear();\n    });\n  }\n  #_getUser(connectionId) {\n    const state = this.#internal.get();\n    const conn = state.connections.get(connectionId);\n    const presence = state.presences.get(connectionId);\n    if (conn !== void 0 && presence !== void 0) {\n      return makeUser(conn, presence);\n    }\n    return void 0;\n  }\n  getUser(connectionId) {\n    const cachedUser = this.#userCache.get(connectionId);\n    if (cachedUser) {\n      return cachedUser;\n    }\n    const computedUser = this.#_getUser(connectionId);\n    if (computedUser) {\n      this.#userCache.set(connectionId, computedUser);\n      return computedUser;\n    }\n    return void 0;\n  }\n  #invalidateUser(connectionId) {\n    this.#userCache.delete(connectionId);\n  }\n  /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */\n  setConnection(connectionId, metaUserId, metaUserInfo, scopes) {\n    this.#internal.mutate((state) => {\n      state.connections.set(\n        connectionId,\n        freeze({\n          connectionId,\n          id: metaUserId,\n          info: metaUserInfo,\n          scopes\n        })\n      );\n      if (!state.presences.has(connectionId)) {\n        return false;\n      }\n      return this.#invalidateUser(connectionId);\n    });\n  }\n  /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */\n  removeConnection(connectionId) {\n    this.#internal.mutate((state) => {\n      state.connections.delete(connectionId);\n      state.presences.delete(connectionId);\n      this.#invalidateUser(connectionId);\n    });\n  }\n  /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */\n  setOther(connectionId, presence) {\n    this.#internal.mutate((state) => {\n      state.presences.set(connectionId, freeze(compactObject(presence)));\n      if (!state.connections.has(connectionId)) {\n        return false;\n      }\n      return this.#invalidateUser(connectionId);\n    });\n  }\n  /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */\n  patchOther(connectionId, patch) {\n    this.#internal.mutate((state) => {\n      const oldPresence = state.presences.get(connectionId);\n      if (oldPresence === void 0) {\n        return false;\n      }\n      const newPresence = merge(oldPresence, patch);\n      if (oldPresence === newPresence) {\n        return false;\n      }\n      state.presences.set(connectionId, freeze(newPresence));\n      return this.#invalidateUser(connectionId);\n    });\n  }\n};\n\n// src/types/LiveblocksError.ts\nvar LiveblocksError = class _LiveblocksError extends Error {\n  context;\n  constructor(message, context, cause) {\n    super(message, { cause });\n    this.context = context;\n    this.name = \"LiveblocksError\";\n  }\n  /** Convenience accessor for error.context.roomId (if available) */\n  get roomId() {\n    return this.context.roomId;\n  }\n  /** @deprecated Prefer using `context.code` instead, to enable type narrowing */\n  get code() {\n    return this.context.code;\n  }\n  /**\n   * Creates a LiveblocksError from a generic error, by attaching Liveblocks\n   * contextual information like room ID, thread ID, etc.\n   */\n  static from(context, cause) {\n    return new _LiveblocksError(\n      defaultMessageFromContext(context),\n      context,\n      cause\n    );\n  }\n};\nfunction defaultMessageFromContext(context) {\n  switch (context.type) {\n    case \"ROOM_CONNECTION_ERROR\": {\n      switch (context.code) {\n        case 4001:\n          return \"Not allowed to connect to the room\";\n        case 4005:\n          return \"Room is already full\";\n        case 4006:\n          return \"Kicked out of the room, because the room ID changed\";\n        default:\n          return \"Could not connect to the room\";\n      }\n    }\n    case \"CREATE_THREAD_ERROR\":\n      return \"Could not create new thread\";\n    case \"DELETE_THREAD_ERROR\":\n      return \"Could not delete thread\";\n    case \"EDIT_THREAD_METADATA_ERROR\":\n      return \"Could not edit thread metadata\";\n    case \"MARK_THREAD_AS_RESOLVED_ERROR\":\n      return \"Could not mark thread as resolved\";\n    case \"MARK_THREAD_AS_UNRESOLVED_ERROR\":\n      return \"Could not mark thread as unresolved\";\n    case \"CREATE_COMMENT_ERROR\":\n      return \"Could not create new comment\";\n    case \"EDIT_COMMENT_ERROR\":\n      return \"Could not edit comment\";\n    case \"DELETE_COMMENT_ERROR\":\n      return \"Could not delete comment\";\n    case \"ADD_REACTION_ERROR\":\n      return \"Could not add reaction\";\n    case \"REMOVE_REACTION_ERROR\":\n      return \"Could not remove reaction\";\n    case \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\":\n      return \"Could not mark inbox notification as read\";\n    case \"DELETE_INBOX_NOTIFICATION_ERROR\":\n      return \"Could not delete inbox notification\";\n    case \"MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR\":\n      return \"Could not mark all inbox notifications as read\";\n    case \"DELETE_ALL_INBOX_NOTIFICATIONS_ERROR\":\n      return \"Could not delete all inbox notifications\";\n    case \"UPDATE_NOTIFICATION_SETTINGS_ERROR\":\n      return \"Could not update notification settings\";\n    case \"UPDATE_USER_NOTIFICATION_SETTINGS_ERROR\":\n      return \"Could not update user notification settings\";\n    default:\n      return assertNever(context, \"Unhandled case\");\n  }\n}\n\n// src/room.ts\nvar MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 512;\nfunction makeIdFactory(connectionId) {\n  let count = 0;\n  return () => `${connectionId}:${count++}`;\n}\nfunction userToTreeNode(key, user) {\n  return {\n    type: \"User\",\n    id: `${user.connectionId}`,\n    key,\n    payload: {\n      connectionId: user.connectionId,\n      id: user.id,\n      info: user.info,\n      presence: user.presence,\n      isReadOnly: !user.canWrite\n    }\n  };\n}\nfunction installBackgroundTabSpy() {\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const inBackgroundSince = { current: null };\n  function onVisibilityChange() {\n    if (doc?.visibilityState === \"hidden\") {\n      inBackgroundSince.current = inBackgroundSince.current ?? Date.now();\n    } else {\n      inBackgroundSince.current = null;\n    }\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  const unsub = () => {\n    doc?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n  return [inBackgroundSince, unsub];\n}\nfunction createRoom(options, config) {\n  const roomId = config.roomId;\n  const initialPresence = options.initialPresence;\n  const initialStorage = options.initialStorage;\n  const httpClient = config.roomHttpClient;\n  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n  const delegates = {\n    ...config.delegates,\n    // A connection is allowed to go into \"zombie state\" only if all of the\n    // following conditions apply:\n    //\n    // - The `backgroundKeepAliveTimeout` client option is configured\n    // - The browser window has been in the background for at least\n    //   `backgroundKeepAliveTimeout` milliseconds\n    // - There are no pending changes\n    //\n    canZombie() {\n      return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== \"synchronizing\";\n    }\n  };\n  const managedSocket = new ManagedSocket(\n    delegates,\n    config.enableDebugLogging\n  );\n  const context = {\n    buffer: {\n      flushTimerID: void 0,\n      lastFlushedAt: 0,\n      presenceUpdates: (\n        // Queue up the initial presence message as a Full Presence update\n        {\n          type: \"full\",\n          data: initialPresence\n        }\n      ),\n      messages: [],\n      storageOperations: []\n    },\n    staticSessionInfoSig: new Signal(null),\n    dynamicSessionInfoSig: new Signal(null),\n    myPresence: new PatchableSignal(initialPresence),\n    others: new ManagedOthers(),\n    initialStorage,\n    idFactory: null,\n    // The Yjs provider associated to this room\n    yjsProvider: void 0,\n    yjsProviderDidChange: makeEventSource(),\n    // Storage\n    pool: createManagedPool(roomId, {\n      getCurrentConnectionId,\n      onDispatch,\n      isStorageWritable\n    }),\n    root: void 0,\n    undoStack: [],\n    redoStack: [],\n    pausedHistory: null,\n    activeBatch: null,\n    unacknowledgedOps: /* @__PURE__ */ new Map(),\n    // Debug\n    opStackTraces:  true ? /* @__PURE__ */ new Map() : 0\n  };\n  let lastTokenKey;\n  function onStatusDidChange(newStatus) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getBearerTokenFromAuthValue(authValue);\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfoSig.set({\n            userId: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.id : token.uid,\n            userInfo: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.info : token.ui\n          });\n        } else {\n          context.staticSessionInfoSig.set({\n            userId: void 0,\n            userInfo: void 0\n          });\n        }\n      }\n    }\n    eventHub.status.notify(newStatus);\n    notifySelfChanged();\n  }\n  let _connectionLossTimerId;\n  let _hasLostConnection = false;\n  function handleConnectionLossEvent(newStatus) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        eventHub.lostConnection.notify(\"lost\");\n        _hasLostConnection = true;\n        context.others.clearOthers();\n        notify({ others: [{ type: \"reset\" }] });\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n      if (_hasLostConnection) {\n        if (newStatus === \"disconnected\") {\n          eventHub.lostConnection.notify(\"failed\");\n        } else {\n          eventHub.lostConnection.notify(\"restored\");\n        }\n        _hasLostConnection = false;\n      }\n    }\n  }\n  function onDidConnect() {\n    context.buffer.presenceUpdates = {\n      type: \"full\",\n      data: (\n        // Because context.me.current is a readonly object, we'll have to\n        // make a copy here. Otherwise, type errors happen later when\n        // \"patching\" my presence.\n        { ...context.myPresence.get() }\n      )\n    };\n    if (_getStorage$ !== null) {\n      refreshStorage({ flush: false });\n    }\n    flushNowOrSoon();\n  }\n  function onDidDisconnect() {\n    clearTimeout(context.buffer.flushTimerID);\n  }\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onConnectionError.subscribe(({ message, code }) => {\n    const type = \"ROOM_CONNECTION_ERROR\";\n    const err = new LiveblocksError(message, { type, code, roomId });\n    const didNotify = config.errorEventSource.notify(err);\n    if (!didNotify) {\n      if (true) {\n        error2(\n          `Connection to websocket server closed. Reason: ${message} (code: ${code}).`\n        );\n      }\n    }\n  });\n  function onDispatch(ops, reverse, storageUpdates) {\n    if (true) {\n      const stackTrace = captureStackTrace(\"Storage mutation\", onDispatch);\n      if (stackTrace) {\n        for (const op of ops) {\n          if (op.opId) {\n            nn(context.opStackTraces).set(op.opId, stackTrace);\n          }\n        }\n      }\n    }\n    if (context.activeBatch) {\n      for (const op of ops) {\n        context.activeBatch.ops.push(op);\n      }\n      for (const [key, value] of storageUpdates) {\n        context.activeBatch.updates.storageUpdates.set(\n          key,\n          mergeStorageUpdates(\n            context.activeBatch.updates.storageUpdates.get(key),\n            value\n          )\n        );\n      }\n      context.activeBatch.reverseOps.pushLeft(reverse);\n    } else {\n      addToUndoStack(reverse);\n      context.redoStack.length = 0;\n      dispatchOps(ops);\n      notify({ storageUpdates });\n    }\n  }\n  function isStorageWritable() {\n    const scopes = context.dynamicSessionInfoSig.get()?.scopes;\n    return scopes !== void 0 ? canWriteStorage(scopes) : true;\n  }\n  const eventHub = {\n    status: makeEventSource(),\n    // New/recommended API\n    lostConnection: makeEventSource(),\n    customEvent: makeEventSource(),\n    self: makeEventSource(),\n    myPresence: makeEventSource(),\n    others: makeEventSource(),\n    storageBatch: makeEventSource(),\n    history: makeEventSource(),\n    storageDidLoad: makeEventSource(),\n    storageStatus: makeEventSource(),\n    ydoc: makeEventSource(),\n    comments: makeEventSource(),\n    roomWillDestroy: makeEventSource()\n  };\n  async function createTextMention(userId, mentionId) {\n    return httpClient.createTextMention({ roomId, userId, mentionId });\n  }\n  async function deleteTextMention(mentionId) {\n    return httpClient.deleteTextMention({ roomId, mentionId });\n  }\n  async function reportTextEditor(type, rootKey) {\n    await httpClient.reportTextEditor({ roomId, type, rootKey });\n  }\n  async function listTextVersions() {\n    return httpClient.listTextVersions({ roomId });\n  }\n  async function listTextVersionsSince(options2) {\n    return httpClient.listTextVersionsSince({\n      roomId,\n      since: options2.since,\n      signal: options2.signal\n    });\n  }\n  async function getTextVersion(versionId) {\n    return httpClient.getTextVersion({ roomId, versionId });\n  }\n  async function createTextVersion() {\n    return httpClient.createTextVersion({ roomId });\n  }\n  async function executeContextualPrompt(options2) {\n    return httpClient.executeContextualPrompt({\n      roomId,\n      ...options2\n    });\n  }\n  function* chunkOps(msg) {\n    const { ops, ...rest } = msg;\n    if (ops.length < 2) {\n      throw new Error(\"Cannot split ops into smaller chunks\");\n    }\n    const mid = Math.floor(ops.length / 2);\n    const firstHalf = ops.slice(0, mid);\n    const secondHalf = ops.slice(mid);\n    for (const halfOps of [firstHalf, secondHalf]) {\n      const half = { ops: halfOps, ...rest };\n      const text = stringifyOrLog([half]);\n      if (!isTooBigForWebSocket(text)) {\n        yield text;\n      } else {\n        yield* chunkOps(half);\n      }\n    }\n  }\n  function* chunkMessages(messages) {\n    if (messages.length < 2) {\n      if (messages[0].type === 201 /* UPDATE_STORAGE */) {\n        yield* chunkOps(messages[0]);\n        return;\n      } else {\n        throw new Error(\n          \"Cannot split into chunks smaller than the allowed message size\"\n        );\n      }\n    }\n    const mid = Math.floor(messages.length / 2);\n    const firstHalf = messages.slice(0, mid);\n    const secondHalf = messages.slice(mid);\n    for (const half of [firstHalf, secondHalf]) {\n      const text = stringifyOrLog(half);\n      if (!isTooBigForWebSocket(text)) {\n        yield text;\n      } else {\n        yield* chunkMessages(half);\n      }\n    }\n  }\n  function isTooBigForWebSocket(text) {\n    if (text.length * 4 < MAX_SOCKET_MESSAGE_SIZE) {\n      return false;\n    }\n    return new TextEncoder().encode(text).length >= MAX_SOCKET_MESSAGE_SIZE;\n  }\n  function sendMessages(messages) {\n    const strategy = config.largeMessageStrategy ?? \"default\";\n    const text = stringifyOrLog(messages);\n    if (!isTooBigForWebSocket(text)) {\n      return managedSocket.send(text);\n    }\n    switch (strategy) {\n      case \"default\": {\n        error2(\"Message is too large for websockets, not sending. Configure largeMessageStrategy option to deal with this.\");\n        return;\n      }\n      case \"split\": {\n        warn(\"Message is too large for websockets, splitting into smaller chunks\");\n        for (const chunk2 of chunkMessages(messages)) {\n          managedSocket.send(chunk2);\n        }\n        return;\n      }\n      case \"experimental-fallback-to-http\": {\n        warn(\"Message is too large for websockets, so sending over HTTP instead\");\n        const nonce = context.dynamicSessionInfoSig.get()?.nonce ?? raise(\"Session is not authorized to send message over HTTP\");\n        void httpClient.sendMessages({ roomId, nonce, messages }).then((resp) => {\n          if (!resp.ok && resp.status === 403) {\n            managedSocket.reconnect();\n          }\n        });\n        return;\n      }\n    }\n  }\n  const self = DerivedSignal.from(\n    context.staticSessionInfoSig,\n    context.dynamicSessionInfoSig,\n    context.myPresence,\n    (staticSession, dynamicSession, myPresence) => {\n      if (staticSession === null || dynamicSession === null) {\n        return null;\n      } else {\n        const canWrite = canWriteStorage(dynamicSession.scopes);\n        return {\n          connectionId: dynamicSession.actor,\n          id: staticSession.userId,\n          info: staticSession.userInfo,\n          presence: myPresence,\n          canWrite,\n          canComment: canComment(dynamicSession.scopes)\n        };\n      }\n    }\n  );\n  let _lastSelf;\n  function notifySelfChanged() {\n    const currSelf = self.get();\n    if (currSelf !== null && currSelf !== _lastSelf) {\n      eventHub.self.notify(currSelf);\n      _lastSelf = currSelf;\n    }\n  }\n  const selfAsTreeNode = DerivedSignal.from(\n    self,\n    (me) => me !== null ? userToTreeNode(\"Me\", me) : null\n  );\n  function createOrUpdateRootFromMessage(message) {\n    if (message.items.length === 0) {\n      throw new Error(\"Internal error: cannot load storage without items\");\n    }\n    if (context.root !== void 0) {\n      updateRoot(message.items);\n    } else {\n      context.root = LiveObject._fromItems(message.items, context.pool);\n    }\n    const canWrite = self.get()?.canWrite ?? true;\n    const stackSizeBefore = context.undoStack.length;\n    for (const key in context.initialStorage) {\n      if (context.root.get(key) === void 0) {\n        if (canWrite) {\n          context.root.set(key, cloneLson(context.initialStorage[key]));\n        } else {\n          warn(\n            `Attempted to populate missing storage key '${key}', but current user has no write access`\n          );\n        }\n      }\n    }\n    context.undoStack.length = stackSizeBefore;\n  }\n  function updateRoot(items) {\n    if (context.root === void 0) {\n      return;\n    }\n    const currentItems = /* @__PURE__ */ new Map();\n    for (const [id, node] of context.pool.nodes) {\n      currentItems.set(id, node._serialize());\n    }\n    const ops = getTreesDiffOperations(currentItems, new Map(items));\n    const result = applyOps(ops, false);\n    notify(result.updates);\n  }\n  function _addToRealUndoStack(historyOps) {\n    if (context.undoStack.length >= 50) {\n      context.undoStack.shift();\n    }\n    context.undoStack.push(historyOps);\n    onHistoryChange();\n  }\n  function addToUndoStack(historyOps) {\n    if (context.pausedHistory !== null) {\n      context.pausedHistory.pushLeft(historyOps);\n    } else {\n      _addToRealUndoStack(historyOps);\n    }\n  }\n  function notify(updates) {\n    const storageUpdates = updates.storageUpdates;\n    const othersUpdates = updates.others;\n    if (othersUpdates !== void 0 && othersUpdates.length > 0) {\n      const others = context.others.get();\n      for (const event of othersUpdates) {\n        eventHub.others.notify({ ...event, others });\n      }\n    }\n    if (updates.presence ?? false) {\n      notifySelfChanged();\n      eventHub.myPresence.notify(context.myPresence.get());\n    }\n    if (storageUpdates !== void 0 && storageUpdates.size > 0) {\n      const updates2 = Array.from(storageUpdates.values());\n      eventHub.storageBatch.notify(updates2);\n    }\n    notifyStorageStatus();\n  }\n  function getCurrentConnectionId() {\n    const info = context.dynamicSessionInfoSig.get();\n    if (info) {\n      return info.actor;\n    }\n    throw new Error(\n      \"Internal. Tried to get connection id but connection was never open\"\n    );\n  }\n  function applyOps(rawOps, isLocal) {\n    const output = {\n      reverse: new Deque(),\n      storageUpdates: /* @__PURE__ */ new Map(),\n      presence: false\n    };\n    const createdNodeIds = /* @__PURE__ */ new Set();\n    const ops = rawOps.map((op) => {\n      if (op.type !== \"presence\" && !op.opId) {\n        return { ...op, opId: context.pool.generateOpId() };\n      } else {\n        return op;\n      }\n    });\n    for (const op of ops) {\n      if (op.type === \"presence\") {\n        const reverse = {\n          type: \"presence\",\n          data: {}\n        };\n        for (const key in op.data) {\n          reverse.data[key] = context.myPresence.get()[key];\n        }\n        context.myPresence.patch(op.data);\n        if (context.buffer.presenceUpdates === null) {\n          context.buffer.presenceUpdates = { type: \"partial\", data: op.data };\n        } else {\n          for (const key in op.data) {\n            context.buffer.presenceUpdates.data[key] = op.data[key];\n          }\n        }\n        output.reverse.pushLeft(reverse);\n        output.presence = true;\n      } else {\n        let source;\n        if (isLocal) {\n          source = 0 /* UNDOREDO_RECONNECT */;\n        } else {\n          const opId = nn(op.opId);\n          if (true) {\n            nn(context.opStackTraces).delete(opId);\n          }\n          const deleted = context.unacknowledgedOps.delete(opId);\n          source = deleted ? 2 /* ACK */ : 1 /* REMOTE */;\n        }\n        const applyOpResult = applyOp(op, source);\n        if (applyOpResult.modified) {\n          const nodeId = applyOpResult.modified.node._id;\n          if (!(nodeId && createdNodeIds.has(nodeId))) {\n            output.storageUpdates.set(\n              nn(applyOpResult.modified.node._id),\n              mergeStorageUpdates(\n                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),\n                applyOpResult.modified\n              )\n            );\n            output.reverse.pushLeft(applyOpResult.reverse);\n          }\n          if (op.type === 2 /* CREATE_LIST */ || op.type === 7 /* CREATE_MAP */ || op.type === 4 /* CREATE_OBJECT */) {\n            createdNodeIds.add(nn(op.id));\n          }\n        }\n      }\n    }\n    return {\n      ops,\n      reverse: Array.from(output.reverse),\n      updates: {\n        storageUpdates: output.storageUpdates,\n        presence: output.presence\n      }\n    };\n  }\n  function applyOp(op, source) {\n    if (isAckOp(op)) {\n      return { modified: false };\n    }\n    switch (op.type) {\n      case 6 /* DELETE_OBJECT_KEY */:\n      case 3 /* UPDATE_OBJECT */:\n      case 5 /* DELETE_CRDT */: {\n        const node = context.pool.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */);\n      }\n      case 1 /* SET_PARENT_KEY */: {\n        const node = context.pool.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n          return node.parent.node._setChildKey(\n            asPos(op.parentKey),\n            node,\n            source\n          );\n        }\n        return { modified: false };\n      }\n      case 4 /* CREATE_OBJECT */:\n      case 2 /* CREATE_LIST */:\n      case 7 /* CREATE_MAP */:\n      case 8 /* CREATE_REGISTER */: {\n        if (op.parentId === void 0) {\n          return { modified: false };\n        }\n        const parentNode = context.pool.nodes.get(op.parentId);\n        if (parentNode === void 0) {\n          return { modified: false };\n        }\n        return parentNode._attachChild(op, source);\n      }\n    }\n  }\n  function updatePresence(patch, options2) {\n    const oldValues = {};\n    if (context.buffer.presenceUpdates === null) {\n      context.buffer.presenceUpdates = {\n        type: \"partial\",\n        data: {}\n      };\n    }\n    for (const key in patch) {\n      const overrideValue = patch[key];\n      if (overrideValue === void 0) {\n        continue;\n      }\n      context.buffer.presenceUpdates.data[key] = overrideValue;\n      oldValues[key] = context.myPresence.get()[key];\n    }\n    context.myPresence.patch(patch);\n    if (context.activeBatch) {\n      if (options2?.addToHistory) {\n        context.activeBatch.reverseOps.pushLeft({\n          type: \"presence\",\n          data: oldValues\n        });\n      }\n      context.activeBatch.updates.presence = true;\n    } else {\n      flushNowOrSoon();\n      if (options2?.addToHistory) {\n        addToUndoStack([{ type: \"presence\", data: oldValues }]);\n      }\n      notify({ presence: true });\n    }\n  }\n  function onUpdatePresenceMessage(message) {\n    if (message.targetActor !== void 0) {\n      const oldUser = context.others.getUser(message.actor);\n      context.others.setOther(message.actor, message.data);\n      const newUser = context.others.getUser(message.actor);\n      if (oldUser === void 0 && newUser !== void 0) {\n        return { type: \"enter\", user: newUser };\n      }\n    } else {\n      context.others.patchOther(message.actor, message.data), message;\n    }\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      return {\n        type: \"update\",\n        updates: message.data,\n        user\n      };\n    } else {\n      return void 0;\n    }\n  }\n  function onUserLeftMessage(message) {\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      context.others.removeConnection(message.actor);\n      return { type: \"leave\", user };\n    }\n    return null;\n  }\n  function onRoomStateMessage(message) {\n    context.dynamicSessionInfoSig.set({\n      actor: message.actor,\n      nonce: message.nonce,\n      scopes: message.scopes\n    });\n    context.idFactory = makeIdFactory(message.actor);\n    notifySelfChanged();\n    for (const connectionId of context.others.connectionIds()) {\n      const user = message.users[connectionId];\n      if (user === void 0) {\n        context.others.removeConnection(connectionId);\n      }\n    }\n    for (const key in message.users) {\n      const user = message.users[key];\n      const connectionId = Number(key);\n      context.others.setConnection(\n        connectionId,\n        user.id,\n        user.info,\n        user.scopes\n      );\n    }\n    return { type: \"reset\" };\n  }\n  function canUndo() {\n    return context.undoStack.length > 0;\n  }\n  function canRedo() {\n    return context.redoStack.length > 0;\n  }\n  function onHistoryChange() {\n    eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });\n  }\n  function onUserJoinedMessage(message) {\n    context.others.setConnection(\n      message.actor,\n      message.id,\n      message.info,\n      message.scopes\n    );\n    context.buffer.messages.push({\n      type: 100 /* UPDATE_PRESENCE */,\n      data: context.myPresence.get(),\n      targetActor: message.actor\n    });\n    flushNowOrSoon();\n    const user = context.others.getUser(message.actor);\n    return user ? { type: \"enter\", user } : void 0;\n  }\n  function parseServerMessage(data) {\n    if (!isJsonObject(data)) {\n      return null;\n    }\n    return data;\n  }\n  function parseServerMessages(text) {\n    const data = tryParseJson(text);\n    if (data === void 0) {\n      return null;\n    } else if (isJsonArray(data)) {\n      return compact(data.map((item) => parseServerMessage(item)));\n    } else {\n      return compact([parseServerMessage(data)]);\n    }\n  }\n  function applyAndSendOps(offlineOps) {\n    if (offlineOps.size === 0) {\n      return;\n    }\n    const messages = [];\n    const inOps = Array.from(offlineOps.values());\n    const result = applyOps(inOps, true);\n    messages.push({\n      type: 201 /* UPDATE_STORAGE */,\n      ops: result.ops\n    });\n    notify(result.updates);\n    sendMessages(messages);\n  }\n  function handleServerMessage(event) {\n    if (typeof event.data !== \"string\") {\n      return;\n    }\n    const messages = parseServerMessages(event.data);\n    if (messages === null || messages.length === 0) {\n      return;\n    }\n    const updates = {\n      storageUpdates: /* @__PURE__ */ new Map(),\n      others: []\n    };\n    for (const message of messages) {\n      switch (message.type) {\n        case 101 /* USER_JOINED */: {\n          const userJoinedUpdate = onUserJoinedMessage(message);\n          if (userJoinedUpdate) {\n            updates.others.push(userJoinedUpdate);\n          }\n          break;\n        }\n        case 100 /* UPDATE_PRESENCE */: {\n          const othersPresenceUpdate = onUpdatePresenceMessage(message);\n          if (othersPresenceUpdate) {\n            updates.others.push(othersPresenceUpdate);\n          }\n          break;\n        }\n        case 103 /* BROADCASTED_EVENT */: {\n          const others = context.others.get();\n          eventHub.customEvent.notify({\n            connectionId: message.actor,\n            user: message.actor < 0 ? null : others.find((u) => u.connectionId === message.actor) ?? null,\n            event: message.event\n          });\n          break;\n        }\n        case 102 /* USER_LEFT */: {\n          const event2 = onUserLeftMessage(message);\n          if (event2) {\n            updates.others.push(event2);\n          }\n          break;\n        }\n        case 300 /* UPDATE_YDOC */: {\n          eventHub.ydoc.notify(message);\n          break;\n        }\n        case 104 /* ROOM_STATE */: {\n          updates.others.push(onRoomStateMessage(message));\n          break;\n        }\n        case 200 /* INITIAL_STORAGE_STATE */: {\n          processInitialStorage(message);\n          break;\n        }\n        // Write event\n        case 201 /* UPDATE_STORAGE */: {\n          const applyResult = applyOps(message.ops, false);\n          for (const [key, value] of applyResult.updates.storageUpdates) {\n            updates.storageUpdates.set(\n              key,\n              mergeStorageUpdates(updates.storageUpdates.get(key), value)\n            );\n          }\n          break;\n        }\n        // Receiving a RejectedOps message in the client means that the server is no\n        // longer in sync with the client. Trying to synchronize the client again by\n        // rolling back particular Ops may be hard/impossible. It's fine to not try and\n        // accept the out-of-sync reality and throw an error. We look at this kind of bug\n        // as a developer-owned bug. In production, these errors are not expected to happen.\n        case 299 /* REJECT_STORAGE_OP */: {\n          errorWithTitle(\n            \"Storage mutation rejection error\",\n            message.reason\n          );\n          if (true) {\n            const traces = /* @__PURE__ */ new Set();\n            for (const opId of message.opIds) {\n              const trace = context.opStackTraces?.get(opId);\n              if (trace) {\n                traces.add(trace);\n              }\n            }\n            if (traces.size > 0) {\n              warnWithTitle(\n                \"The following function calls caused the rejected storage mutations:\",\n                `\n\n${Array.from(traces).join(\"\\n\\n\")}`\n              );\n            }\n            throw new Error(\n              `Storage mutations rejected by server: ${message.reason}`\n            );\n          }\n          break;\n        }\n        case 400 /* THREAD_CREATED */:\n        case 407 /* THREAD_DELETED */:\n        case 401 /* THREAD_METADATA_UPDATED */:\n        case 408 /* THREAD_UPDATED */:\n        case 405 /* COMMENT_REACTION_ADDED */:\n        case 406 /* COMMENT_REACTION_REMOVED */:\n        case 402 /* COMMENT_CREATED */:\n        case 403 /* COMMENT_EDITED */:\n        case 404 /* COMMENT_DELETED */: {\n          eventHub.comments.notify(message);\n          break;\n        }\n      }\n    }\n    notify(updates);\n  }\n  function flushNowOrSoon() {\n    const storageOps = context.buffer.storageOperations;\n    if (storageOps.length > 0) {\n      for (const op of storageOps) {\n        context.unacknowledgedOps.set(nn(op.opId), op);\n      }\n      notifyStorageStatus();\n    }\n    if (managedSocket.getStatus() !== \"connected\") {\n      context.buffer.storageOperations = [];\n      return;\n    }\n    const now = Date.now();\n    const elapsedMillis = now - context.buffer.lastFlushedAt;\n    if (elapsedMillis >= config.throttleDelay) {\n      const messagesToFlush = serializeBuffer();\n      if (messagesToFlush.length === 0) {\n        return;\n      }\n      sendMessages(messagesToFlush);\n      context.buffer = {\n        flushTimerID: void 0,\n        lastFlushedAt: now,\n        messages: [],\n        storageOperations: [],\n        presenceUpdates: null\n      };\n    } else {\n      clearTimeout(context.buffer.flushTimerID);\n      context.buffer.flushTimerID = setTimeout(\n        flushNowOrSoon,\n        config.throttleDelay - elapsedMillis\n      );\n    }\n  }\n  function serializeBuffer() {\n    const messages = [];\n    if (context.buffer.presenceUpdates) {\n      messages.push(\n        context.buffer.presenceUpdates.type === \"full\" ? {\n          type: 100 /* UPDATE_PRESENCE */,\n          // Populating the `targetActor` field turns this message into\n          // a Full Presence update message (not a patch), which will get\n          // interpreted by other clients as such.\n          targetActor: -1,\n          data: context.buffer.presenceUpdates.data\n        } : {\n          type: 100 /* UPDATE_PRESENCE */,\n          data: context.buffer.presenceUpdates.data\n        }\n      );\n    }\n    for (const event of context.buffer.messages) {\n      messages.push(event);\n    }\n    if (context.buffer.storageOperations.length > 0) {\n      messages.push({\n        type: 201 /* UPDATE_STORAGE */,\n        ops: context.buffer.storageOperations\n      });\n    }\n    return messages;\n  }\n  function updateYDoc(update, guid, isV2) {\n    const clientMsg = {\n      type: 301 /* UPDATE_YDOC */,\n      update,\n      guid,\n      v2: isV2\n    };\n    context.buffer.messages.push(clientMsg);\n    eventHub.ydoc.notify(clientMsg);\n    flushNowOrSoon();\n  }\n  function broadcastEvent(event, options2 = {\n    shouldQueueEventIfNotReady: false\n  }) {\n    if (managedSocket.getStatus() !== \"connected\" && !options2.shouldQueueEventIfNotReady) {\n      return;\n    }\n    context.buffer.messages.push({\n      type: 103 /* BROADCAST_EVENT */,\n      event\n    });\n    flushNowOrSoon();\n  }\n  function dispatchOps(ops) {\n    const { storageOperations } = context.buffer;\n    for (const op of ops) {\n      storageOperations.push(op);\n    }\n    flushNowOrSoon();\n  }\n  let _getStorage$ = null;\n  let _resolveStoragePromise = null;\n  function processInitialStorage(message) {\n    const unacknowledgedOps = new Map(context.unacknowledgedOps);\n    createOrUpdateRootFromMessage(message);\n    applyAndSendOps(unacknowledgedOps);\n    _resolveStoragePromise?.();\n    notifyStorageStatus();\n    eventHub.storageDidLoad.notify();\n  }\n  async function streamStorage() {\n    if (!managedSocket.authValue) return;\n    const items = await httpClient.streamStorage({ roomId });\n    processInitialStorage({ type: 200 /* INITIAL_STORAGE_STATE */, items });\n  }\n  function refreshStorage(options2) {\n    const messages = context.buffer.messages;\n    if (config.unstable_streamData) {\n      void streamStorage();\n    } else if (!messages.some((msg) => msg.type === 200 /* FETCH_STORAGE */)) {\n      messages.push({ type: 200 /* FETCH_STORAGE */ });\n    }\n    if (options2.flush) {\n      flushNowOrSoon();\n    }\n  }\n  function startLoadingStorage() {\n    if (_getStorage$ === null) {\n      refreshStorage({ flush: true });\n      _getStorage$ = new Promise((resolve) => {\n        _resolveStoragePromise = resolve;\n      });\n      notifyStorageStatus();\n    }\n    return _getStorage$;\n  }\n  function getStorageSnapshot() {\n    const root = context.root;\n    if (root !== void 0) {\n      return root;\n    } else {\n      void startLoadingStorage();\n      return null;\n    }\n  }\n  async function getStorage() {\n    if (context.root !== void 0) {\n      return Promise.resolve({\n        root: context.root\n      });\n    }\n    await startLoadingStorage();\n    return {\n      root: nn(context.root)\n    };\n  }\n  function fetchYDoc(vector, guid, isV2) {\n    if (!context.buffer.messages.find((m) => {\n      return m.type === 300 /* FETCH_YDOC */ && m.vector === vector && m.guid === guid && m.v2 === isV2;\n    })) {\n      context.buffer.messages.push({\n        type: 300 /* FETCH_YDOC */,\n        vector,\n        guid,\n        v2: isV2\n      });\n    }\n    flushNowOrSoon();\n  }\n  function undo() {\n    if (context.activeBatch) {\n      throw new Error(\"undo is not allowed during a batch\");\n    }\n    const historyOps = context.undoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    notify(result.updates);\n    context.redoStack.push(result.reverse);\n    onHistoryChange();\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function redo() {\n    if (context.activeBatch) {\n      throw new Error(\"redo is not allowed during a batch\");\n    }\n    const historyOps = context.redoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    notify(result.updates);\n    context.undoStack.push(result.reverse);\n    onHistoryChange();\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function clear() {\n    context.undoStack.length = 0;\n    context.redoStack.length = 0;\n  }\n  function batch2(callback) {\n    if (context.activeBatch) {\n      return callback();\n    }\n    let returnValue = void 0;\n    context.activeBatch = {\n      ops: [],\n      updates: {\n        storageUpdates: /* @__PURE__ */ new Map(),\n        presence: false,\n        others: []\n      },\n      reverseOps: new Deque()\n    };\n    try {\n      returnValue = callback();\n    } finally {\n      const currentBatch = context.activeBatch;\n      context.activeBatch = null;\n      if (currentBatch.reverseOps.length > 0) {\n        addToUndoStack(Array.from(currentBatch.reverseOps));\n      }\n      if (currentBatch.ops.length > 0) {\n        context.redoStack.length = 0;\n      }\n      if (currentBatch.ops.length > 0) {\n        dispatchOps(currentBatch.ops);\n      }\n      notify(currentBatch.updates);\n      flushNowOrSoon();\n    }\n    return returnValue;\n  }\n  function pauseHistory() {\n    if (context.pausedHistory === null) {\n      context.pausedHistory = new Deque();\n    }\n  }\n  function resumeHistory() {\n    const historyOps = context.pausedHistory;\n    context.pausedHistory = null;\n    if (historyOps !== null && historyOps.length > 0) {\n      _addToRealUndoStack(Array.from(historyOps));\n    }\n  }\n  const syncSourceForStorage = config.createSyncSource();\n  function getStorageStatus() {\n    if (context.root === void 0) {\n      return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n    } else {\n      return context.unacknowledgedOps.size === 0 ? \"synchronized\" : \"synchronizing\";\n    }\n  }\n  let _lastStorageStatus = getStorageStatus();\n  function notifyStorageStatus() {\n    const storageStatus = getStorageStatus();\n    if (_lastStorageStatus !== storageStatus) {\n      _lastStorageStatus = storageStatus;\n      eventHub.storageStatus.notify(storageStatus);\n    }\n    syncSourceForStorage.setSyncStatus(\n      storageStatus === \"synchronizing\" ? \"synchronizing\" : \"synchronized\"\n    );\n  }\n  function isPresenceReady() {\n    return self.get() !== null;\n  }\n  async function waitUntilPresenceReady() {\n    while (!isPresenceReady()) {\n      const { promise, resolve } = Promise_withResolvers();\n      const unsub1 = events.self.subscribeOnce(resolve);\n      const unsub2 = events.status.subscribeOnce(resolve);\n      await promise;\n      unsub1();\n      unsub2();\n    }\n  }\n  function isStorageReady() {\n    return getStorageSnapshot() !== null;\n  }\n  async function waitUntilStorageReady() {\n    while (!isStorageReady()) {\n      await getStorage();\n    }\n  }\n  const others_forDevTools = DerivedSignal.from(\n    context.others.signal,\n    (others) => others.map((other, index) => userToTreeNode(`Other ${index}`, other))\n  );\n  const events = {\n    status: eventHub.status.observable,\n    lostConnection: eventHub.lostConnection.observable,\n    customEvent: eventHub.customEvent.observable,\n    others: eventHub.others.observable,\n    self: eventHub.self.observable,\n    myPresence: eventHub.myPresence.observable,\n    /** @deprecated */\n    storage: eventHub.storageBatch.observable,\n    storageBatch: eventHub.storageBatch.observable,\n    history: eventHub.history.observable,\n    storageDidLoad: eventHub.storageDidLoad.observable,\n    storageStatus: eventHub.storageStatus.observable,\n    ydoc: eventHub.ydoc.observable,\n    comments: eventHub.comments.observable,\n    roomWillDestroy: eventHub.roomWillDestroy.observable\n  };\n  async function getThreadsSince(options2) {\n    return httpClient.getThreadsSince({\n      roomId,\n      since: options2.since,\n      signal: options2.signal\n    });\n  }\n  async function getThreads(options2) {\n    return httpClient.getThreads({\n      roomId,\n      query: options2?.query,\n      cursor: options2?.cursor\n    });\n  }\n  async function getThread(threadId) {\n    return httpClient.getThread({ roomId, threadId });\n  }\n  async function createThread(options2) {\n    return httpClient.createThread({\n      roomId,\n      threadId: options2.threadId,\n      commentId: options2.commentId,\n      metadata: options2.metadata,\n      body: options2.body,\n      attachmentIds: options2.attachmentIds\n    });\n  }\n  async function deleteThread(threadId) {\n    return httpClient.deleteThread({ roomId, threadId });\n  }\n  async function editThreadMetadata({\n    metadata,\n    threadId\n  }) {\n    return httpClient.editThreadMetadata({ roomId, threadId, metadata });\n  }\n  async function markThreadAsResolved(threadId) {\n    return httpClient.markThreadAsResolved({ roomId, threadId });\n  }\n  async function markThreadAsUnresolved(threadId) {\n    return httpClient.markThreadAsUnresolved({\n      roomId,\n      threadId\n    });\n  }\n  async function createComment(options2) {\n    return httpClient.createComment({\n      roomId,\n      threadId: options2.threadId,\n      commentId: options2.commentId,\n      body: options2.body,\n      attachmentIds: options2.attachmentIds\n    });\n  }\n  async function editComment(options2) {\n    return httpClient.editComment({\n      roomId,\n      threadId: options2.threadId,\n      commentId: options2.commentId,\n      body: options2.body,\n      attachmentIds: options2.attachmentIds\n    });\n  }\n  async function deleteComment({\n    threadId,\n    commentId\n  }) {\n    return httpClient.deleteComment({ roomId, threadId, commentId });\n  }\n  async function addReaction({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    return httpClient.addReaction({ roomId, threadId, commentId, emoji });\n  }\n  async function removeReaction({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    return await httpClient.removeReaction({\n      roomId,\n      threadId,\n      commentId,\n      emoji\n    });\n  }\n  function prepareAttachment(file) {\n    return {\n      type: \"localAttachment\",\n      status: \"idle\",\n      id: createCommentAttachmentId(),\n      name: file.name,\n      size: file.size,\n      mimeType: file.type,\n      file\n    };\n  }\n  async function uploadAttachment(attachment, options2 = {}) {\n    return httpClient.uploadAttachment({\n      roomId,\n      attachment,\n      signal: options2.signal\n    });\n  }\n  function getAttachmentUrl(attachmentId) {\n    return httpClient.getAttachmentUrl({ roomId, attachmentId });\n  }\n  function getNotificationSettings(options2) {\n    return httpClient.getNotificationSettings({\n      roomId,\n      signal: options2?.signal\n    });\n  }\n  function updateNotificationSettings(settings) {\n    return httpClient.updateNotificationSettings({ roomId, settings });\n  }\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await httpClient.markRoomInboxNotificationAsRead({\n      roomId,\n      inboxNotificationId\n    });\n  }\n  const syncSourceForYjs = config.createSyncSource();\n  function yjsStatusDidChange(status) {\n    return syncSourceForYjs.setSyncStatus(\n      status === \"synchronizing\" ? \"synchronizing\" : \"synchronized\"\n    );\n  }\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        get presenceBuffer() {\n          return deepClone(context.buffer.presenceUpdates?.data ?? null);\n        },\n        // prettier-ignore\n        get undoStack() {\n          return deepClone(context.undoStack);\n        },\n        // prettier-ignore\n        get nodeCount() {\n          return context.pool.nodes.size;\n        },\n        // prettier-ignore\n        getYjsProvider() {\n          return context.yjsProvider;\n        },\n        setYjsProvider(newProvider) {\n          context.yjsProvider?.off(\"status\", yjsStatusDidChange);\n          context.yjsProvider = newProvider;\n          newProvider?.on(\"status\", yjsStatusDidChange);\n          context.yjsProviderDidChange.notify();\n        },\n        yjsProviderDidChange: context.yjsProviderDidChange.observable,\n        // send metadata when using a text editor\n        reportTextEditor,\n        // create a text mention when using a text editor\n        createTextMention,\n        // delete a text mention when using a text editor\n        deleteTextMention,\n        // list versions of the document\n        listTextVersions,\n        // List versions of the document since the specified date\n        listTextVersionsSince,\n        // get a specific version\n        getTextVersion,\n        // create a version\n        createTextVersion,\n        // execute a contextual prompt\n        executeContextualPrompt,\n        // Support for the Liveblocks browser extension\n        getSelf_forDevTools: () => selfAsTreeNode.get(),\n        getOthers_forDevTools: () => others_forDevTools.get(),\n        // prettier-ignore\n        simulate: {\n          // These exist only for our E2E testing app\n          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: \"EXPLICIT_SOCKET_CLOSE\", event }),\n          rawSend: (data) => managedSocket.send(data)\n        },\n        attachmentUrlsStore: httpClient.getOrCreateAttachmentUrlsStore(roomId)\n      },\n      id: roomId,\n      subscribe: makeClassicSubscribeFn(\n        roomId,\n        events,\n        config.errorEventSource\n      ),\n      connect: () => managedSocket.connect(),\n      reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      destroy: () => {\n        const { roomWillDestroy, ...eventsExceptDestroy } = eventHub;\n        for (const source of Object.values(eventsExceptDestroy)) {\n          source[Symbol.dispose]();\n        }\n        eventHub.roomWillDestroy.notify();\n        context.yjsProvider?.off(\"status\", yjsStatusDidChange);\n        syncSourceForStorage.destroy();\n        syncSourceForYjs.destroy();\n        uninstallBgTabSpy();\n        managedSocket.destroy();\n        roomWillDestroy[Symbol.dispose]();\n      },\n      // Presence\n      updatePresence,\n      updateYDoc,\n      broadcastEvent,\n      // Storage\n      batch: batch2,\n      history: {\n        undo,\n        redo,\n        canUndo,\n        canRedo,\n        clear,\n        pause: pauseHistory,\n        resume: resumeHistory\n      },\n      fetchYDoc,\n      getStorage,\n      getStorageSnapshot,\n      getStorageStatus,\n      isPresenceReady,\n      isStorageReady,\n      waitUntilPresenceReady: memoizeOnSuccess(waitUntilPresenceReady),\n      waitUntilStorageReady: memoizeOnSuccess(waitUntilStorageReady),\n      events,\n      // Core\n      getStatus: () => managedSocket.getStatus(),\n      getSelf: () => self.get(),\n      // Presence\n      getPresence: () => context.myPresence.get(),\n      getOthers: () => context.others.get(),\n      // Comments\n      getThreads,\n      getThreadsSince,\n      getThread,\n      createThread,\n      deleteThread,\n      editThreadMetadata,\n      markThreadAsResolved,\n      markThreadAsUnresolved,\n      createComment,\n      editComment,\n      deleteComment,\n      addReaction,\n      removeReaction,\n      prepareAttachment,\n      uploadAttachment,\n      getAttachmentUrl,\n      // Notifications\n      getNotificationSettings,\n      updateNotificationSettings,\n      markInboxNotificationAsRead\n    },\n    // Explictly make the internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    kInternal,\n    { enumerable: false }\n  );\n}\nfunction makeClassicSubscribeFn(roomId, events, errorEvents) {\n  function subscribeToLiveStructureDeeply(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      const relatedUpdates = updates.filter(\n        (update) => isSameNodeOrChildOf(update.node, node)\n      );\n      if (relatedUpdates.length > 0) {\n        callback(relatedUpdates);\n      }\n    });\n  }\n  function subscribeToLiveStructureShallowly(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      for (const update of updates) {\n        if (update.node._id === node._id) {\n          callback(update.node);\n        }\n      }\n    });\n  }\n  function subscribe(first, second, options) {\n    if (typeof first === \"string\" && isRoomEventName(first)) {\n      if (typeof second !== \"function\") {\n        throw new Error(\"Second argument must be a callback function\");\n      }\n      const callback = second;\n      switch (first) {\n        case \"event\":\n          return events.customEvent.subscribe(\n            callback\n          );\n        case \"my-presence\":\n          return events.myPresence.subscribe(callback);\n        case \"others\": {\n          const cb = callback;\n          return events.others.subscribe((event) => {\n            const { others, ...internalEvent } = event;\n            return cb(others, internalEvent);\n          });\n        }\n        case \"error\": {\n          return errorEvents.subscribe((err) => {\n            if (err.roomId === roomId) {\n              return callback(err);\n            }\n          });\n        }\n        case \"status\":\n          return events.status.subscribe(callback);\n        case \"lost-connection\":\n          return events.lostConnection.subscribe(\n            callback\n          );\n        case \"history\":\n          return events.history.subscribe(callback);\n        case \"storage-status\":\n          return events.storageStatus.subscribe(\n            callback\n          );\n        case \"comments\":\n          return events.comments.subscribe(\n            callback\n          );\n        // istanbul ignore next\n        default:\n          return assertNever(\n            first,\n            `\"${String(first)}\" is not a valid event name`\n          );\n      }\n    }\n    if (second === void 0 || typeof first === \"function\") {\n      if (typeof first === \"function\") {\n        const storageCallback = first;\n        return events.storageBatch.subscribe(storageCallback);\n      } else {\n        throw new Error(\"Please specify a listener callback\");\n      }\n    }\n    if (isLiveNode(first)) {\n      const node = first;\n      if (options?.isDeep) {\n        const storageCallback = second;\n        return subscribeToLiveStructureDeeply(node, storageCallback);\n      } else {\n        const nodeCallback = second;\n        return subscribeToLiveStructureShallowly(node, nodeCallback);\n      }\n    }\n    throw new Error(\n      `${String(first)} is not a value that can be subscribed to.`\n    );\n  }\n  return subscribe;\n}\nfunction isRoomEventName(value) {\n  return value === \"my-presence\" || value === \"others\" || value === \"event\" || value === \"error\" || value === \"history\" || value === \"status\" || value === \"storage-status\" || value === \"lost-connection\" || value === \"connection\" || value === \"comments\";\n}\nfunction makeAuthDelegateForRoom(roomId, authManager) {\n  return async () => {\n    return authManager.getAuthValue({ requestedScope: \"room:read\", roomId });\n  };\n}\nfunction makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {\n  return (authValue) => {\n    const ws = WebSocketPolyfill ?? (typeof WebSocket === \"undefined\" ? void 0 : WebSocket);\n    if (ws === void 0) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n    const url2 = new URL(baseUrl);\n    url2.protocol = url2.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url2.pathname = \"/v7\";\n    url2.searchParams.set(\"roomId\", roomId);\n    if (authValue.type === \"secret\") {\n      url2.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      url2.searchParams.set(\"pubkey\", authValue.publicApiKey);\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url2.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url2.toString());\n  };\n}\n\n// src/client.ts\nvar MIN_THROTTLE = 16;\nvar MAX_THROTTLE = 1e3;\nvar DEFAULT_THROTTLE = 100;\nvar MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;\nvar MIN_LOST_CONNECTION_TIMEOUT = 200;\nvar RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;\nvar MAX_LOST_CONNECTION_TIMEOUT = 3e4;\nvar DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;\nvar RESOLVE_USERS_BATCH_DELAY = 50;\nvar RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;\nfunction getBaseUrl(baseUrl) {\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nfunction createClient(options) {\n  const clientOptions = options;\n  const throttleDelay = getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);\n  const lostConnectionTimeout = getLostConnectionTimeout(\n    clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT\n  );\n  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(\n    clientOptions.backgroundKeepAliveTimeout\n  );\n  const baseUrl = getBaseUrl(clientOptions.baseUrl);\n  const currentUserId = new Signal(void 0);\n  const authManager = createAuthManager(options, (token) => {\n    const userId = token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.id : token.uid;\n    currentUserId.set(() => userId);\n  });\n  const fetchPolyfill = clientOptions.polyfills?.fetch || /* istanbul ignore next */\n  globalThis.fetch?.bind(globalThis);\n  const httpClient = createApiClient({\n    baseUrl,\n    fetchPolyfill,\n    authManager\n  });\n  const roomsById = /* @__PURE__ */ new Map();\n  function teardownRoom(room) {\n    unlinkDevTools(room.id);\n    roomsById.delete(room.id);\n    room.destroy();\n  }\n  function leaseRoom(details) {\n    const leave = () => {\n      const self = leave;\n      if (!details.unsubs.delete(self)) {\n        warn(\n          \"This leave function was already called. Calling it more than once has no effect.\"\n        );\n      } else {\n        if (details.unsubs.size === 0) {\n          teardownRoom(details.room);\n        }\n      }\n    };\n    details.unsubs.add(leave);\n    return {\n      room: details.room,\n      leave\n    };\n  }\n  function enterRoom(roomId, ...args) {\n    const existing = roomsById.get(roomId);\n    if (existing !== void 0) {\n      return leaseRoom(existing);\n    }\n    const options2 = args[0] ?? {};\n    const initialPresence = (typeof options2.initialPresence === \"function\" ? options2.initialPresence(roomId) : options2.initialPresence) ?? {};\n    const initialStorage = (typeof options2.initialStorage === \"function\" ? options2.initialStorage(roomId) : options2.initialStorage) ?? {};\n    const newRoom = createRoom(\n      { initialPresence, initialStorage },\n      {\n        roomId,\n        throttleDelay,\n        lostConnectionTimeout,\n        backgroundKeepAliveTimeout,\n        polyfills: clientOptions.polyfills,\n        delegates: clientOptions.mockedDelegates ?? {\n          createSocket: makeCreateSocketDelegateForRoom(\n            roomId,\n            baseUrl,\n            clientOptions.polyfills?.WebSocket\n          ),\n          authenticate: makeAuthDelegateForRoom(roomId, authManager)\n        },\n        enableDebugLogging: clientOptions.enableDebugLogging,\n        baseUrl,\n        errorEventSource: liveblocksErrorSource,\n        largeMessageStrategy: clientOptions.largeMessageStrategy ?? (clientOptions.unstable_fallbackToHTTP ? \"experimental-fallback-to-http\" : void 0),\n        unstable_streamData: !!clientOptions.unstable_streamData,\n        roomHttpClient: httpClient,\n        createSyncSource\n      }\n    );\n    const newRoomDetails = {\n      room: newRoom,\n      unsubs: /* @__PURE__ */ new Set()\n    };\n    roomsById.set(roomId, newRoomDetails);\n    setupDevTools(() => Array.from(roomsById.keys()));\n    linkDevTools(roomId, newRoom);\n    const shouldConnect = options2.autoConnect ?? true;\n    if (shouldConnect) {\n      if (typeof atob === \"undefined\") {\n        if (clientOptions.polyfills?.atob === void 0) {\n          throw new Error(\n            \"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\"\n          );\n        }\n        global.atob = clientOptions.polyfills.atob;\n      }\n      newRoom.connect();\n    }\n    return leaseRoom(newRoomDetails);\n  }\n  function getRoom(roomId) {\n    const room = roomsById.get(roomId)?.room;\n    return room ? room : null;\n  }\n  function logout() {\n    authManager.reset();\n    currentUserId.set(() => void 0);\n    for (const { room } of roomsById.values()) {\n      if (!isIdle(room.getStatus())) {\n        room.reconnect();\n      }\n    }\n  }\n  const resolveUsers = clientOptions.resolveUsers;\n  const warnIfNoResolveUsers = createDevelopmentWarning(\n    () => !resolveUsers,\n    \"Set the resolveUsers option in createClient to specify user info.\"\n  );\n  const batchedResolveUsers = new Batch(\n    async (batchedUserIds) => {\n      const userIds = batchedUserIds.flat();\n      const users = await resolveUsers?.({ userIds });\n      warnIfNoResolveUsers();\n      return users ?? userIds.map(() => void 0);\n    },\n    { delay: RESOLVE_USERS_BATCH_DELAY }\n  );\n  const usersStore = createBatchStore(batchedResolveUsers);\n  function invalidateResolvedUsers(userIds) {\n    usersStore.invalidate(userIds);\n  }\n  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;\n  const warnIfNoResolveRoomsInfo = createDevelopmentWarning(\n    () => !resolveRoomsInfo,\n    \"Set the resolveRoomsInfo option in createClient to specify room info.\"\n  );\n  const batchedResolveRoomsInfo = new Batch(\n    async (batchedRoomIds) => {\n      const roomIds = batchedRoomIds.flat();\n      const roomsInfo = await resolveRoomsInfo?.({ roomIds });\n      warnIfNoResolveRoomsInfo();\n      return roomsInfo ?? roomIds.map(() => void 0);\n    },\n    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }\n  );\n  const roomsInfoStore = createBatchStore(batchedResolveRoomsInfo);\n  function invalidateResolvedRoomsInfo(roomIds) {\n    roomsInfoStore.invalidate(roomIds);\n  }\n  const mentionSuggestionsCache = /* @__PURE__ */ new Map();\n  function invalidateResolvedMentionSuggestions() {\n    mentionSuggestionsCache.clear();\n  }\n  const syncStatusSources = [];\n  const syncStatusSignal = new Signal(\"synchronized\");\n  const liveblocksErrorSource = makeEventSource();\n  function getSyncStatus() {\n    const status = syncStatusSignal.get();\n    return status === \"synchronizing\" ? status : \"synchronized\";\n  }\n  function recompute() {\n    syncStatusSignal.set(\n      syncStatusSources.some((src) => src.get() === \"synchronizing\") ? \"synchronizing\" : syncStatusSources.some((src) => src.get() === \"has-local-changes\") ? \"has-local-changes\" : \"synchronized\"\n    );\n  }\n  function createSyncSource() {\n    const source = new Signal(\"synchronized\");\n    syncStatusSources.push(source);\n    const unsub = source.subscribe(() => recompute());\n    function setSyncStatus(status) {\n      source.set(status);\n    }\n    function destroy() {\n      unsub();\n      const index = syncStatusSources.findIndex((item) => item === source);\n      if (index > -1) {\n        const [ref] = syncStatusSources.splice(index, 1);\n        const wasStillPending = ref.get() !== \"synchronized\";\n        if (wasStillPending) {\n          recompute();\n        }\n      }\n    }\n    return { setSyncStatus, destroy };\n  }\n  {\n    const maybePreventClose = (e) => {\n      if (clientOptions.preventUnsavedChanges && syncStatusSignal.get() !== \"synchronized\") {\n        e.preventDefault();\n      }\n    };\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    win?.addEventListener(\"beforeunload\", maybePreventClose);\n  }\n  async function getNotificationSettings(options2) {\n    const plainSettings = await httpClient.getUserNotificationSettings(options2);\n    const settings = createUserNotificationSettings(plainSettings);\n    return settings;\n  }\n  async function updateNotificationSettings(settings) {\n    const plainSettings = await httpClient.updateUserNotificationSettings(settings);\n    const settingsObject = createUserNotificationSettings(plainSettings);\n    return settingsObject;\n  }\n  const client = Object.defineProperty(\n    {\n      enterRoom,\n      getRoom,\n      logout,\n      // Public inbox notifications API\n      getInboxNotifications: httpClient.getInboxNotifications,\n      getInboxNotificationsSince: httpClient.getInboxNotificationsSince,\n      getUnreadInboxNotificationsCount: httpClient.getUnreadInboxNotificationsCount,\n      markAllInboxNotificationsAsRead: httpClient.markAllInboxNotificationsAsRead,\n      markInboxNotificationAsRead: httpClient.markInboxNotificationAsRead,\n      deleteAllInboxNotifications: httpClient.deleteAllInboxNotifications,\n      deleteInboxNotification: httpClient.deleteInboxNotification,\n      // Public user notification settings API\n      getNotificationSettings,\n      updateNotificationSettings,\n      // Advanced resolvers APIs\n      resolvers: {\n        invalidateUsers: invalidateResolvedUsers,\n        invalidateRoomsInfo: invalidateResolvedRoomsInfo,\n        invalidateMentionSuggestions: invalidateResolvedMentionSuggestions\n      },\n      getSyncStatus,\n      events: {\n        error: liveblocksErrorSource,\n        syncStatus: syncStatusSignal\n      },\n      // Internal\n      [kInternal]: {\n        currentUserId,\n        mentionSuggestionsCache,\n        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,\n        usersStore,\n        roomsInfoStore,\n        getRoomIds() {\n          return Array.from(roomsById.keys());\n        },\n        httpClient,\n        // Type-level helper only, it's effectively only an identity-function at runtime\n        as: () => client,\n        createSyncSource,\n        emitError: (context, cause) => {\n          const error3 = LiveblocksError.from(context, cause);\n          const didNotify = liveblocksErrorSource.notify(error3);\n          if (!didNotify) {\n            error2(error3.message);\n          }\n        }\n      }\n    },\n    kInternal,\n    {\n      enumerable: false\n    }\n  );\n  return client;\n}\nfunction checkBounds(option, value, min, max, recommendedMin) {\n  if (typeof value !== \"number\" || value < min || max !== void 0 && value > max) {\n    throw new Error(\n      max !== void 0 ? `${option} should be between ${recommendedMin ?? min} and ${max}.` : `${option} should be at least ${recommendedMin ?? min}.`\n    );\n  }\n  return value;\n}\nfunction getBackgroundKeepAliveTimeout(value) {\n  if (value === void 0) return void 0;\n  return checkBounds(\n    \"backgroundKeepAliveTimeout\",\n    value,\n    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\n  );\n}\nfunction getThrottle(value) {\n  return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\nfunction getLostConnectionTimeout(value) {\n  return checkBounds(\n    \"lostConnectionTimeout\",\n    value,\n    MIN_LOST_CONNECTION_TIMEOUT,\n    MAX_LOST_CONNECTION_TIMEOUT,\n    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\n  );\n}\nfunction createDevelopmentWarning(condition, ...args) {\n  let hasWarned = false;\n  if (true) {\n    return () => {\n      if (!hasWarned && (typeof condition === \"function\" ? condition() : condition)) {\n        warn(...args);\n        hasWarned = true;\n      }\n    };\n  } else {}\n}\n\n// src/comments/comment-body.ts\nfunction isCommentBodyParagraph(element) {\n  return \"type\" in element && element.type === \"paragraph\";\n}\nfunction isCommentBodyText(element) {\n  return !(\"type\" in element) && \"text\" in element && typeof element.text === \"string\";\n}\nfunction isCommentBodyMention(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyLink(element) {\n  return \"type\" in element && element.type === \"link\";\n}\nvar commentBodyElementsGuards = {\n  paragraph: isCommentBodyParagraph,\n  text: isCommentBodyText,\n  link: isCommentBodyLink,\n  mention: isCommentBodyMention\n};\nvar commentBodyElementsTypes = {\n  paragraph: \"block\",\n  text: \"inline\",\n  link: \"inline\",\n  mention: \"inline\"\n};\nfunction traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {\n  if (!body || !body?.content) {\n    return;\n  }\n  const element = typeof elementOrVisitor === \"string\" ? elementOrVisitor : void 0;\n  const type = element ? commentBodyElementsTypes[element] : \"all\";\n  const guard = element ? commentBodyElementsGuards[element] : () => true;\n  const visitor = typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n  for (const block of body.content) {\n    if (type === \"all\" || type === \"block\") {\n      if (guard(block)) {\n        visitor?.(block);\n      }\n    }\n    if (type === \"all\" || type === \"inline\") {\n      for (const inline of block.children) {\n        if (guard(inline)) {\n          visitor?.(inline);\n        }\n      }\n    }\n  }\n}\nfunction getMentionedIdsFromCommentBody(body) {\n  const mentionedIds = /* @__PURE__ */ new Set();\n  traverseCommentBody(\n    body,\n    \"mention\",\n    (mention) => mentionedIds.add(mention.id)\n  );\n  return Array.from(mentionedIds);\n}\nasync function resolveUsersInCommentBody(body, resolveUsers) {\n  const resolvedUsers = /* @__PURE__ */ new Map();\n  if (!resolveUsers) {\n    return resolvedUsers;\n  }\n  const userIds = getMentionedIdsFromCommentBody(body);\n  const users = await resolveUsers({\n    userIds\n  });\n  for (const [index, userId] of userIds.entries()) {\n    const user = users?.[index];\n    if (user) {\n      resolvedUsers.set(userId, user);\n    }\n  }\n  return resolvedUsers;\n}\nvar htmlEscapables = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\"\n};\nvar htmlEscapablesRegex = new RegExp(\n  Object.keys(htmlEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction htmlSafe(value) {\n  return new HtmlSafeString([String(value)], []);\n}\nfunction joinHtml(strings) {\n  if (strings.length <= 0) {\n    return new HtmlSafeString([\"\"], []);\n  }\n  return new HtmlSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeHtml(value) {\n  if (value instanceof HtmlSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinHtml(value).toString();\n  }\n  return String(value).replace(\n    htmlEscapablesRegex,\n    (character) => htmlEscapables[character]\n  );\n}\nvar HtmlSafeString = class {\n  #strings;\n  #values;\n  constructor(strings, values2) {\n    this.#strings = strings;\n    this.#values = values2;\n  }\n  toString() {\n    return this.#strings.reduce((result, str, i) => {\n      return result + escapeHtml(nn(this.#values[i - 1])) + str;\n    });\n  }\n};\nfunction html(strings, ...values2) {\n  return new HtmlSafeString(strings, values2);\n}\nvar markdownEscapables = {\n  _: \"\\\\_\",\n  \"*\": \"\\\\*\",\n  \"#\": \"\\\\#\",\n  \"`\": \"\\\\`\",\n  \"~\": \"\\\\~\",\n  \"!\": \"\\\\!\",\n  \"|\": \"\\\\|\",\n  \"(\": \"\\\\(\",\n  \")\": \"\\\\)\",\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"[\": \"\\\\[\",\n  \"]\": \"\\\\]\"\n};\nvar markdownEscapablesRegex = new RegExp(\n  Object.keys(markdownEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction joinMarkdown(strings) {\n  if (strings.length <= 0) {\n    return new MarkdownSafeString([\"\"], []);\n  }\n  return new MarkdownSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeMarkdown(value) {\n  if (value instanceof MarkdownSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinMarkdown(value).toString();\n  }\n  return String(value).replace(\n    markdownEscapablesRegex,\n    (character) => markdownEscapables[character]\n  );\n}\nvar MarkdownSafeString = class {\n  #strings;\n  #values;\n  constructor(strings, values2) {\n    this.#strings = strings;\n    this.#values = values2;\n  }\n  toString() {\n    return this.#strings.reduce((result, str, i) => {\n      return result + escapeMarkdown(nn(this.#values[i - 1])) + str;\n    });\n  }\n};\nfunction markdown(strings, ...values2) {\n  return new MarkdownSafeString(strings, values2);\n}\nfunction toAbsoluteUrl(url2) {\n  if (url2.startsWith(\"http://\") || url2.startsWith(\"https://\")) {\n    return url2;\n  } else if (url2.startsWith(\"www.\")) {\n    return \"https://\" + url2;\n  }\n  return;\n}\nvar stringifyCommentBodyPlainElements = {\n  paragraph: ({ children }) => children,\n  text: ({ element }) => element.text,\n  link: ({ element }) => element.text ?? element.url,\n  mention: ({ element, user }) => {\n    return `@${user?.name ?? element.id}`;\n  }\n};\nvar stringifyCommentBodyHtmlElements = {\n  paragraph: ({ children }) => {\n    return children ? html`<p>${htmlSafe(children)}</p>` : children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return html`${children}`;\n    }\n    if (element.bold) {\n      children = html`<strong>${children}</strong>`;\n    }\n    if (element.italic) {\n      children = html`<em>${children}</em>`;\n    }\n    if (element.strikethrough) {\n      children = html`<s>${children}</s>`;\n    }\n    if (element.code) {\n      children = html`<code>${children}</code>`;\n    }\n    return html`${children}`;\n  },\n  link: ({ element, href }) => {\n    return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${element.text ? html`${element.text}` : element.url}</a>`;\n  },\n  mention: ({ element, user }) => {\n    return html`<span data-mention>@${user?.name ? html`${user?.name}` : element.id}</span>`;\n  }\n};\nvar stringifyCommentBodyMarkdownElements = {\n  paragraph: ({ children }) => {\n    return children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = markdown`**${children}**`;\n    }\n    if (element.italic) {\n      children = markdown`_${children}_`;\n    }\n    if (element.strikethrough) {\n      children = markdown`~~${children}~~`;\n    }\n    if (element.code) {\n      children = markdown`\\`${children}\\``;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return markdown`[${element.text ?? element.url}](${href})`;\n  },\n  mention: ({ element, user }) => {\n    return markdown`@${user?.name ?? element.id}`;\n  }\n};\nasync function stringifyCommentBody(body, options) {\n  const format = options?.format ?? \"plain\";\n  const separator = options?.separator ?? (format === \"markdown\" ? \"\\n\\n\" : \"\\n\");\n  const elements = {\n    ...format === \"html\" ? stringifyCommentBodyHtmlElements : format === \"markdown\" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,\n    ...options?.elements\n  };\n  const resolvedUsers = await resolveUsersInCommentBody(\n    body,\n    options?.resolveUsers\n  );\n  const blocks = body.content.flatMap((block, blockIndex) => {\n    switch (block.type) {\n      case \"paragraph\": {\n        const inlines = block.children.flatMap((inline, inlineIndex) => {\n          if (isCommentBodyMention(inline)) {\n            return inline.id ? [\n              elements.mention(\n                {\n                  element: inline,\n                  user: resolvedUsers.get(inline.id)\n                },\n                inlineIndex\n              )\n            ] : [];\n          }\n          if (isCommentBodyLink(inline)) {\n            return [\n              elements.link(\n                {\n                  element: inline,\n                  href: toAbsoluteUrl(inline.url) ?? inline.url\n                },\n                inlineIndex\n              )\n            ];\n          }\n          if (isCommentBodyText(inline)) {\n            return [elements.text({ element: inline }, inlineIndex)];\n          }\n          return [];\n        });\n        return [\n          elements.paragraph(\n            { element: block, children: inlines.join(\"\") },\n            blockIndex\n          )\n        ];\n      }\n      default:\n        return [];\n    }\n  });\n  return blocks.join(separator);\n}\n\n// src/comments/comment-url.ts\nvar PLACEHOLDER_BASE_URL = \"https://localhost:9999\";\nvar ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nfunction generateCommentUrl({\n  roomUrl,\n  commentId\n}) {\n  const isAbsolute = ABSOLUTE_URL_REGEX.test(roomUrl);\n  const urlObject = new URL(\n    roomUrl,\n    isAbsolute ? void 0 : PLACEHOLDER_BASE_URL\n  );\n  urlObject.hash = `#${commentId}`;\n  return isAbsolute ? urlObject.href : urlObject.href.replace(PLACEHOLDER_BASE_URL, \"\");\n}\n\n// src/crdts/utils.ts\nfunction toPlainLson(lson) {\n  if (lson instanceof LiveObject) {\n    return {\n      liveblocksType: \"LiveObject\",\n      data: Object.fromEntries(\n        Object.entries(lson.toObject()).flatMap(\n          ([key, value]) => value !== void 0 ? [[key, toPlainLson(value)]] : []\n        )\n      )\n    };\n  } else if (lson instanceof LiveMap) {\n    return {\n      liveblocksType: \"LiveMap\",\n      data: Object.fromEntries(\n        [...lson].map(([key, value]) => [key, toPlainLson(value)])\n      )\n    };\n  } else if (lson instanceof LiveList) {\n    return {\n      liveblocksType: \"LiveList\",\n      data: [...lson].map((item) => toPlainLson(item))\n    };\n  } else {\n    return lson;\n  }\n}\n\n// src/immutable.ts\nfunction lsonObjectToJson(obj) {\n  const result = {};\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== void 0) {\n      result[key] = lsonToJson(val);\n    }\n  }\n  return result;\n}\nfunction liveObjectToJson(liveObject) {\n  return lsonObjectToJson(liveObject.toObject());\n}\nfunction liveMapToJson(map) {\n  const result = {};\n  for (const [key, value] of map.entries()) {\n    result[key] = lsonToJson(value);\n  }\n  return result;\n}\nfunction lsonListToJson(value) {\n  return value.map(lsonToJson);\n}\nfunction liveListToJson(value) {\n  return lsonListToJson(value.toArray());\n}\nfunction lsonToJson(value) {\n  if (value instanceof LiveObject) {\n    return liveObjectToJson(value);\n  } else if (value instanceof LiveList) {\n    return liveListToJson(value);\n  } else if (value instanceof LiveMap) {\n    return liveMapToJson(value);\n  } else if (value instanceof LiveRegister) {\n    return value.data;\n  }\n  if (Array.isArray(value)) {\n    return lsonListToJson(value);\n  } else if (isPlainObject(value)) {\n    return lsonObjectToJson(value);\n  }\n  return value;\n}\nfunction deepLiveify(value) {\n  if (Array.isArray(value)) {\n    return new LiveList(value.map(deepLiveify));\n  } else if (isPlainObject(value)) {\n    const init = {};\n    for (const key in value) {\n      const val = value[key];\n      if (val === void 0) {\n        continue;\n      }\n      init[key] = deepLiveify(val);\n    }\n    return new LiveObject(init);\n  } else {\n    return value;\n  }\n}\nfunction patchLiveList(liveList, prev, next) {\n  let i = 0;\n  let prevEnd = prev.length - 1;\n  let nextEnd = next.length - 1;\n  let prevNode = prev[0];\n  let nextNode = next[0];\n  outer: {\n    while (prevNode === nextNode) {\n      ++i;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[i];\n      nextNode = next[i];\n    }\n    prevNode = prev[prevEnd];\n    nextNode = next[nextEnd];\n    while (prevNode === nextNode) {\n      prevEnd--;\n      nextEnd--;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[prevEnd];\n      nextNode = next[nextEnd];\n    }\n  }\n  if (i > prevEnd) {\n    if (i <= nextEnd) {\n      while (i <= nextEnd) {\n        liveList.insert(deepLiveify(next[i]), i);\n        i++;\n      }\n    }\n  } else if (i > nextEnd) {\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  } else {\n    while (i <= prevEnd && i <= nextEnd) {\n      prevNode = prev[i];\n      nextNode = next[i];\n      const liveListNode = liveList.get(i);\n      if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {\n        patchLiveObject(liveListNode, prevNode, nextNode);\n      } else {\n        liveList.set(i, deepLiveify(nextNode));\n      }\n      i++;\n    }\n    while (i <= nextEnd) {\n      liveList.insert(deepLiveify(next[i]), i);\n      i++;\n    }\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  }\n}\nfunction patchLiveObjectKey(liveObject, key, prev, next) {\n  if (true) {\n    const nonSerializableValue = findNonSerializableValue(next);\n    if (nonSerializableValue) {\n      error2(\n        `New state path: '${nonSerializableValue.path}' value: '${String(\n          nonSerializableValue.value\n        )}' is not serializable.\nOnly serializable value can be synced with Liveblocks.`\n      );\n      return;\n    }\n  }\n  const value = liveObject.get(key);\n  if (next === void 0) {\n    liveObject.delete(key);\n  } else if (value === void 0) {\n    liveObject.set(key, deepLiveify(next));\n  } else if (prev === next) {\n    return;\n  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n    patchLiveList(value, prev, next);\n  } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {\n    patchLiveObject(value, prev, next);\n  } else {\n    liveObject.set(key, deepLiveify(next));\n  }\n}\nfunction patchLiveObject(root, prev, next) {\n  const updates = {};\n  for (const key in next) {\n    patchLiveObjectKey(root, key, prev[key], next[key]);\n  }\n  for (const key in prev) {\n    if (next[key] === void 0) {\n      root.delete(key);\n    }\n  }\n  if (Object.keys(updates).length > 0) {\n    root.update(updates);\n  }\n}\nfunction getParentsPath(node) {\n  const path = [];\n  while (node.parent.type === \"HasParent\") {\n    if (isLiveList(node.parent.node)) {\n      path.push(node.parent.node._indexOfPosition(node.parent.key));\n    } else {\n      path.push(node.parent.key);\n    }\n    node = node.parent.node;\n  }\n  return path;\n}\nfunction legacy_patchImmutableObject(state, updates) {\n  return updates.reduce(\n    (state2, update) => legacy_patchImmutableObjectWithUpdate(state2, update),\n    state\n  );\n}\nfunction legacy_patchImmutableObjectWithUpdate(state, update) {\n  const path = getParentsPath(update.node);\n  return legacy_patchImmutableNode(state, path, update);\n}\nfunction legacy_patchImmutableNode(state, path, update) {\n  const pathItem = path.pop();\n  if (pathItem === void 0) {\n    switch (update.type) {\n      case \"LiveObject\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveObject but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const val = update.node.get(key);\n            if (val !== void 0) {\n              newState[key] = lsonToJson(val);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n      case \"LiveList\": {\n        if (!Array.isArray(state)) {\n          throw new Error(\n            \"Internal: received update on LiveList but state was not an array\"\n          );\n        }\n        let newState = state.map((x) => x);\n        for (const listUpdate of update.updates) {\n          if (listUpdate.type === \"set\") {\n            newState = newState.map(\n              (item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item\n            );\n          } else if (listUpdate.type === \"insert\") {\n            if (listUpdate.index === newState.length) {\n              newState.push(lsonToJson(listUpdate.item));\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index)\n              ];\n            }\n          } else if (listUpdate.type === \"delete\") {\n            newState.splice(listUpdate.index, 1);\n          } else if (listUpdate.type === \"move\") {\n            if (listUpdate.previousIndex > listUpdate.index) {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                ...newState.slice(listUpdate.previousIndex + 1)\n              ];\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.previousIndex),\n                ...newState.slice(\n                  listUpdate.previousIndex + 1,\n                  listUpdate.index + 1\n                ),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index + 1)\n              ];\n            }\n          }\n        }\n        return newState;\n      }\n      case \"LiveMap\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveMap but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const value = update.node.get(key);\n            if (value !== void 0) {\n              newState[key] = lsonToJson(value);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n    }\n  }\n  if (Array.isArray(state)) {\n    const newArray = [...state];\n    newArray[pathItem] = legacy_patchImmutableNode(\n      state[pathItem],\n      path,\n      update\n    );\n    return newArray;\n  } else if (isJsonObject(state)) {\n    const node = state[pathItem];\n    if (node === void 0) {\n      return state;\n    } else {\n      const stateAsObj = state;\n      return {\n        ...stateAsObj,\n        [pathItem]: legacy_patchImmutableNode(node, path, update)\n      };\n    }\n  } else {\n    return state;\n  }\n}\n\n// src/lib/abortController.ts\nfunction makeAbortController(externalSignal) {\n  const ctl = new AbortController();\n  return {\n    signal: externalSignal ? AbortSignal.any([ctl.signal, externalSignal]) : ctl.signal,\n    abort: ctl.abort.bind(ctl)\n  };\n}\n\n// src/lib/deprecation.ts\nvar _emittedDeprecationWarnings = /* @__PURE__ */ new Set();\nfunction deprecate(message, key = message) {\n  if (true) {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n      errorWithTitle(\"Deprecation warning\", message);\n    }\n  }\n}\nfunction deprecateIf(condition, message, key = message) {\n  if (true) {\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\nfunction throwUsageError(message) {\n  if (true) {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    errorWithTitle(\"Usage error\", message);\n    throw usageError;\n  }\n}\nfunction errorIf(condition, message) {\n  if (true) {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n}\n\n// src/lib/Poller.ts\nvar BACKOFF_DELAYS2 = [1e3, 2e3, 4e3, 8e3, 1e4];\nfunction makePoller(callback, intervalMs, options) {\n  const startTime = performance.now();\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const win = typeof window !== \"undefined\" ? window : void 0;\n  const maxStaleTimeMs = options?.maxStaleTimeMs ?? Number.POSITIVE_INFINITY;\n  const context = {\n    inForeground: doc?.visibilityState !== \"hidden\",\n    lastSuccessfulPollAt: startTime,\n    count: 0,\n    backoff: 0\n  };\n  function mayPoll() {\n    return context.count > 0 && context.inForeground;\n  }\n  const fsm = new FSM({}).addState(\"@idle\").addState(\"@enabled\").addState(\"@polling\");\n  fsm.addTransitions(\"@idle\", { START: \"@enabled\" });\n  fsm.addTransitions(\"@enabled\", { STOP: \"@idle\", POLL: \"@polling\" });\n  fsm.addTimedTransition(\n    \"@enabled\",\n    () => {\n      const lastPoll = context.lastSuccessfulPollAt;\n      const nextPoll = lastPoll + intervalMs;\n      return Math.max(0, nextPoll - performance.now()) + context.backoff;\n    },\n    \"@polling\"\n  );\n  fsm.onEnterAsync(\n    \"@polling\",\n    async (_ctx, signal) => {\n      await callback(signal);\n      if (!signal.aborted) {\n        context.lastSuccessfulPollAt = performance.now();\n      }\n    },\n    // When OK\n    () => {\n      return {\n        target: mayPoll() ? \"@enabled\" : \"@idle\",\n        effect: () => {\n          context.backoff = 0;\n        }\n      };\n    },\n    // When error\n    () => {\n      return {\n        target: mayPoll() ? \"@enabled\" : \"@idle\",\n        effect: () => {\n          context.backoff = BACKOFF_DELAYS2.find((delay) => delay > context.backoff) ?? BACKOFF_DELAYS2[BACKOFF_DELAYS2.length - 1];\n        }\n      };\n    },\n    3e4\n    // Abort the poll if the callback takes more than 30 seconds to complete\n  );\n  function startOrStop() {\n    if (mayPoll()) {\n      fsm.send({ type: \"START\" });\n    } else {\n      fsm.send({ type: \"STOP\" });\n    }\n  }\n  function inc() {\n    context.count++;\n    startOrStop();\n  }\n  function dec() {\n    context.count--;\n    if (context.count < 0) {\n      context.count = 0;\n    }\n    startOrStop();\n  }\n  function pollNowIfStale() {\n    if (performance.now() - context.lastSuccessfulPollAt > maxStaleTimeMs) {\n      fsm.send({ type: \"POLL\" });\n    }\n  }\n  function setInForeground(inForeground) {\n    context.inForeground = inForeground;\n    startOrStop();\n    pollNowIfStale();\n  }\n  function onVisibilityChange() {\n    setInForeground(doc?.visibilityState !== \"hidden\");\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  win?.addEventListener(\"online\", onVisibilityChange);\n  win?.addEventListener(\"focus\", pollNowIfStale);\n  fsm.start();\n  return {\n    inc,\n    dec,\n    pollNowIfStale,\n    // Internal API, used by unit tests only to simulate visibility events\n    setInForeground\n  };\n}\n\n// src/lib/shallow.ts\nfunction shallowArray(xs, ys) {\n  if (xs.length !== ys.length) {\n    return false;\n  }\n  for (let i = 0; i < xs.length; i++) {\n    if (!Object.is(xs[i], ys[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction shallowObj(objA, objB) {\n  if (!isPlainObject(objA) || !isPlainObject(objB)) {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key])\n  );\n}\nfunction shallow(a, b) {\n  if (Object.is(a, b)) {\n    return true;\n  }\n  const isArrayA = Array.isArray(a);\n  const isArrayB = Array.isArray(b);\n  if (isArrayA || isArrayB) {\n    if (!isArrayA || !isArrayB) {\n      return false;\n    }\n    return shallowArray(a, b);\n  }\n  return shallowObj(a, b);\n}\n\n// src/lib/SortedList.ts\nfunction bisectRight(arr, x, lt) {\n  let lo = 0;\n  let hi = arr.length;\n  while (lo < hi) {\n    const mid = lo + (hi - lo >> 1);\n    if (lt(x, arr[mid])) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo;\n}\nvar SortedList = class _SortedList {\n  #data;\n  #lt;\n  constructor(alreadySortedList, lt) {\n    this.#lt = lt;\n    this.#data = alreadySortedList;\n  }\n  static from(arr, lt) {\n    const sorted = new _SortedList([], lt);\n    for (const item of arr) {\n      sorted.add(item);\n    }\n    return sorted;\n  }\n  static fromAlreadySorted(alreadySorted, lt) {\n    return new _SortedList(alreadySorted, lt);\n  }\n  /**\n   * Clones the sorted list to a new instance.\n   */\n  clone() {\n    return new _SortedList(this.#data.slice(), this.#lt);\n  }\n  /**\n   * Adds a new item to the sorted list, such that it remains sorted.\n   */\n  add(value) {\n    const idx = bisectRight(this.#data, value, this.#lt);\n    this.#data.splice(idx, 0, value);\n  }\n  /**\n   * Removes the given value from the sorted list, if it exists. The given\n   * value must be `===` to one of the list items. Only the first entry will be\n   * removed if the element exists in the sorted list multiple times.\n   */\n  remove(value) {\n    const idx = this.#data.indexOf(value);\n    if (idx >= 0) {\n      this.#data.splice(idx, 1);\n      return true;\n    }\n    return false;\n  }\n  get length() {\n    return this.#data.length;\n  }\n  *filter(predicate) {\n    for (const item of this.#data) {\n      if (predicate(item)) {\n        yield item;\n      }\n    }\n  }\n  [Symbol.iterator]() {\n    return this.#data[Symbol.iterator]();\n  }\n};\n\n// src/types/Others.ts\nvar TextEditorType = /* @__PURE__ */ ((TextEditorType2) => {\n  TextEditorType2[\"Lexical\"] = \"lexical\";\n  TextEditorType2[\"TipTap\"] = \"tiptap\";\n  return TextEditorType2;\n})(TextEditorType || {});\n\n// src/index.ts\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\nvar CommentsApiError = HttpError;\nvar NotificationsApiError = HttpError;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY29yZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQixHQUFHLFVBQVU7QUFDeEU7QUFDQTtBQUNBLElBQUk7QUFDSixJQUFJO0FBQ0o7QUFDQSxxR0FBcUcsa0JBQWtCO0FBQ3ZIO0FBQ0E7QUFDQSxXQUFXLFNBQVMsRUFBRSxVQUFVO0FBQ2hDLFdBQVcsU0FBUyxFQUFFLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLHdCQUF3QjtBQUMzRztBQUNBO0FBQ0EsYUFBYSxVQUFVLFFBQVEsWUFBWTtBQUMzQyxhQUFhLFNBQVMsUUFBUSxXQUFXO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFL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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsTUFBcUM7QUFDbEQ7QUFDQSxFQUFFLENBQVE7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUJBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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RDtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQSx5QkFBeUIsa0NBQWtDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQixJQUFJO0FBQzVELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0JBQStCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxNQUFNLG1DQUFtQyxtQkFBbUI7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtCQUErQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU0sbUNBQW1DLHVCQUF1QjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE1BQU0sbUNBQW1DLHVCQUF1QjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQXFDLEdBQUcsQ0FBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsUUFBUTtBQUNSLGlCQUFpQjtBQUNqQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1CQUFtQiwrQkFBK0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsK0JBQStCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjs7QUFFdEI7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWEsR0FBRyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQXFDLCtCQUErQixDQUFNO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXLGVBQWUsR0FBRztBQUM5QyxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZUFBZTtBQUNyRTtBQUNBLCtDQUErQyxvQkFBb0I7QUFDbkU7QUFDQTtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQSw0REFBNEQsU0FBUyxTQUFTLEtBQUs7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMkJBQTJCO0FBQ3JFO0FBQ0E7QUFDQSwwQ0FBMEMsbUJBQW1CO0FBQzdEO0FBQ0E7QUFDQSx3Q0FBd0MsdUJBQXVCO0FBQy9EO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QyxtQkFBbUI7QUFDMUQ7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx5QkFBeUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSwwREFBMEQsSUFBSTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQXFDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxnQ0FBZ0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGVBQWU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0QsNEJBQTRCLDhDQUE4QztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQiwrQkFBK0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxNQUFNO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQ0FBa0Msa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUNBQXFDLGtCQUFrQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCwyQ0FBMkMsNEJBQTRCO0FBQ3ZFO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHNDQUFzQyw2QkFBNkI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxvQ0FBb0Msb0NBQW9DO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlDQUF5QyxzQkFBc0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbURBQW1ELGtCQUFrQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsc0NBQXNDO0FBQ25IO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBDQUEwQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGVBQWU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFDQUFxQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpQ0FBaUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRLG9CQUFvQix1QkFBdUIsTUFBTSxJQUFJLFFBQVEsUUFBUSxxQkFBcUIsc0JBQXNCO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FBSyxFQUdOO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaLFlBQVk7QUFDWixjQUFjO0FBQ2QsYUFBYTtBQUNiO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxPQUFPO0FBQ1gsSUFBSSxPQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixjQUFjLGVBQWU7QUFDN0IsZUFBZSx5QkFBeUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUIsZ0NBQWdDLG1CQUFtQjtBQUNuRCxHQUFHO0FBQ0gsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkM7QUFDQSxrQkFBa0IsU0FBUztBQUMzQixHQUFHO0FBQ0gsV0FBVyxlQUFlO0FBQzFCLDJCQUEyQixLQUFLLDhDQUE4QyxzQkFBc0IsYUFBYSxnQkFBZ0I7QUFDakksR0FBRztBQUNILGNBQWMsZUFBZTtBQUM3QixzQ0FBc0Msb0JBQW9CLFdBQVcsZUFBZTtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBLEdBQUc7QUFDSCxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkM7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsV0FBVyxlQUFlO0FBQzFCLHVCQUF1Qiw0QkFBNEIsSUFBSSxLQUFLO0FBQzVELEdBQUc7QUFDSCxjQUFjLGVBQWU7QUFDN0IsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGNBQWMsNENBQTRDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCLFlBQVk7QUFDbEU7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNCQUFzQjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUErRkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2xlYXJuLXJsLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL2NvcmUvZGlzdC9pbmRleC5qcz84ODJmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgUEtHX05BTUUgPSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbnZhciBQS0dfVkVSU0lPTiA9IFwiMi4yMi4wXCI7XG52YXIgUEtHX0ZPUk1BVCA9IFwiZXNtXCI7XG5cbi8vIHNyYy9kdXBlLWRldGVjdGlvbi50c1xudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9O1xudmFyIGNyb3NzTGlua2VkRG9jcyA9IFwiaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2Nyb3NzLWxpbmtlZFwiO1xudmFyIGR1cGVzRG9jcyA9IFwiaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2R1cGVzXCI7XG52YXIgU1BBQ0UgPSBcIiBcIjtcbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc29sZS5lcnJvcihtc2cpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICB9XG59XG5mdW5jdGlvbiBkZXRlY3REdXBlcyhwa2dOYW1lLCBwa2dWZXJzaW9uLCBwa2dGb3JtYXQpIHtcbiAgY29uc3QgcGtnSWQgPSBTeW1ib2wuZm9yKHBrZ05hbWUpO1xuICBjb25zdCBwa2dCdWlsZEluZm8gPSBwa2dGb3JtYXQgPyBgJHtwa2dWZXJzaW9uIHx8IFwiZGV2XCJ9ICgke3BrZ0Zvcm1hdH0pYCA6IHBrZ1ZlcnNpb24gfHwgXCJkZXZcIjtcbiAgaWYgKCFnW3BrZ0lkXSkge1xuICAgIGdbcGtnSWRdID0gcGtnQnVpbGRJbmZvO1xuICB9IGVsc2UgaWYgKGdbcGtnSWRdID09PSBwa2dCdWlsZEluZm8pIHtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtc2cgPSBbXG4gICAgICBgTXVsdGlwbGUgY29waWVzIG9mIExpdmVibG9ja3MgYXJlIGJlaW5nIGxvYWRlZCBpbiB5b3VyIHByb2plY3QuIFRoaXMgd2lsbCBjYXVzZSBpc3N1ZXMhIFNlZSAke2R1cGVzRG9jcyArIFNQQUNFfWAsXG4gICAgICBcIlwiLFxuICAgICAgXCJDb25mbGljdHM6XCIsXG4gICAgICBgLSAke3BrZ05hbWV9ICR7Z1twa2dJZF19IChhbHJlYWR5IGxvYWRlZClgLFxuICAgICAgYC0gJHtwa2dOYW1lfSAke3BrZ0J1aWxkSW5mb30gKHRyeWluZyB0byBsb2FkIHRoaXMgbm93KWBcbiAgICBdLmpvaW4oXCJcXG5cIik7XG4gICAgZXJyb3IobXNnKTtcbiAgfVxuICBpZiAocGtnVmVyc2lvbiAmJiBQS0dfVkVSU0lPTiAmJiBwa2dWZXJzaW9uICE9PSBQS0dfVkVSU0lPTikge1xuICAgIGVycm9yKFxuICAgICAgW1xuICAgICAgICBgQ3Jvc3MtbGlua2VkIHZlcnNpb25zIG9mIExpdmVibG9ja3MgZm91bmQsIHdoaWNoIHdpbGwgY2F1c2UgaXNzdWVzISBTZWUgJHtjcm9zc0xpbmtlZERvY3MgKyBTUEFDRX1gLFxuICAgICAgICBcIlwiLFxuICAgICAgICBcIkNvbmZsaWN0czpcIixcbiAgICAgICAgYC0gJHtQS0dfTkFNRX0gaXMgYXQgJHtQS0dfVkVSU0lPTn1gLFxuICAgICAgICBgLSAke3BrZ05hbWV9IGlzIGF0ICR7cGtnVmVyc2lvbn1gLFxuICAgICAgICBcIlwiLFxuICAgICAgICBcIkFsd2F5cyB1cGdyYWRlIGFsbCBMaXZlYmxvY2tzIHBhY2thZ2VzIHRvIHRoZSBzYW1lIHZlcnNpb24gbnVtYmVyLlwiXG4gICAgICBdLmpvaW4oXCJcXG5cIilcbiAgICApO1xuICB9XG59XG5cbi8vIHNyYy9jb252ZXJ0LXBsYWluLWRhdGEudHNcbmZ1bmN0aW9uIGNvbnZlcnRUb0NvbW1lbnREYXRhKGRhdGEpIHtcbiAgY29uc3QgZWRpdGVkQXQgPSBkYXRhLmVkaXRlZEF0ID8gbmV3IERhdGUoZGF0YS5lZGl0ZWRBdCkgOiB2b2lkIDA7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgY29uc3QgcmVhY3Rpb25zID0gZGF0YS5yZWFjdGlvbnMubWFwKChyZWFjdGlvbikgPT4gKHtcbiAgICAuLi5yZWFjdGlvbixcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKHJlYWN0aW9uLmNyZWF0ZWRBdClcbiAgfSkpO1xuICBpZiAoZGF0YS5ib2R5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICByZWFjdGlvbnMsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBlZGl0ZWRBdFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGVsZXRlZEF0ID0gbmV3IERhdGUoZGF0YS5kZWxldGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgcmVhY3Rpb25zLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgZWRpdGVkQXQsXG4gICAgICBkZWxldGVkQXRcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9UaHJlYWREYXRhKGRhdGEpIHtcbiAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICBjb25zdCB1cGRhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLnVwZGF0ZWRBdCk7XG4gIGNvbnN0IGNvbW1lbnRzID0gZGF0YS5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbnZlcnRUb0NvbW1lbnREYXRhKGNvbW1lbnQpXG4gICk7XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBjcmVhdGVkQXQsXG4gICAgdXBkYXRlZEF0LFxuICAgIGNvbW1lbnRzXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Db21tZW50VXNlclJlYWN0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEoZGF0YSkge1xuICBjb25zdCBub3RpZmllZEF0ID0gbmV3IERhdGUoZGF0YS5ub3RpZmllZEF0KTtcbiAgY29uc3QgcmVhZEF0ID0gZGF0YS5yZWFkQXQgPyBuZXcgRGF0ZShkYXRhLnJlYWRBdCkgOiBudWxsO1xuICBpZiAoXCJhY3Rpdml0aWVzXCIgaW4gZGF0YSkge1xuICAgIGNvbnN0IGFjdGl2aXRpZXMgPSBkYXRhLmFjdGl2aXRpZXMubWFwKChhY3Rpdml0eSkgPT4gKHtcbiAgICAgIC4uLmFjdGl2aXR5LFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShhY3Rpdml0eS5jcmVhdGVkQXQpXG4gICAgfSkpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgbm90aWZpZWRBdCxcbiAgICAgIHJlYWRBdCxcbiAgICAgIGFjdGl2aXRpZXNcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBub3RpZmllZEF0LFxuICAgIHJlYWRBdFxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvVGhyZWFkRGVsZXRlSW5mbyhkYXRhKSB7XG4gIGNvbnN0IGRlbGV0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuZGVsZXRlZEF0KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGRlbGV0ZWRBdFxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EZWxldGVJbmZvKGRhdGEpIHtcbiAgY29uc3QgZGVsZXRlZEF0ID0gbmV3IERhdGUoZGF0YS5kZWxldGVkQXQpO1xuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgZGVsZXRlZEF0XG4gIH07XG59XG5cbi8vIHNyYy9saWIvZmFuY3ktY29uc29sZS50c1xudmFyIGZhbmN5X2NvbnNvbGVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZmFuY3lfY29uc29sZV9leHBvcnRzLCB7XG4gIGVycm9yOiAoKSA9PiBlcnJvcjIsXG4gIGVycm9yV2l0aFRpdGxlOiAoKSA9PiBlcnJvcldpdGhUaXRsZSxcbiAgd2FybjogKCkgPT4gd2FybixcbiAgd2FybldpdGhUaXRsZTogKCkgPT4gd2FybldpdGhUaXRsZVxufSk7XG52YXIgYmFkZ2UgPSBcImJhY2tncm91bmQ6IzBlMGQxMjtib3JkZXItcmFkaXVzOjk5OTlweDtjb2xvcjojZmZmO3BhZGRpbmc6M3B4IDdweDtmb250LWZhbWlseTpzYW5zLXNlcmlmO2ZvbnQtd2VpZ2h0OjYwMDtcIjtcbnZhciBib2xkID0gXCJmb250LXdlaWdodDo2MDBcIjtcbmZ1bmN0aW9uIHdyYXAobWV0aG9kKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IGNvbnNvbGVbbWV0aG9kXSA6IChcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIChtZXNzYWdlLCAuLi5hcmdzKSA9PiBjb25zb2xlW21ldGhvZF0oXCIlY0xpdmVibG9ja3NcIiwgYmFkZ2UsIG1lc3NhZ2UsIC4uLmFyZ3MpXG4gICk7XG59XG52YXIgd2FybiA9IHdyYXAoXCJ3YXJuXCIpO1xudmFyIGVycm9yMiA9IHdyYXAoXCJlcnJvclwiKTtcbmZ1bmN0aW9uIHdyYXBXaXRoVGl0bGUobWV0aG9kKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IGNvbnNvbGVbbWV0aG9kXSA6IChcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICh0aXRsZSwgbWVzc2FnZSwgLi4uYXJncykgPT4gY29uc29sZVttZXRob2RdKFxuICAgICAgYCVjTGl2ZWJsb2NrcyVjICR7dGl0bGV9YCxcbiAgICAgIGJhZGdlLFxuICAgICAgYm9sZCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICAuLi5hcmdzXG4gICAgKVxuICApO1xufVxudmFyIHdhcm5XaXRoVGl0bGUgPSB3cmFwV2l0aFRpdGxlKFwid2FyblwiKTtcbnZhciBlcnJvcldpdGhUaXRsZSA9IHdyYXBXaXRoVGl0bGUoXCJlcnJvclwiKTtcblxuLy8gc3JjL2xpYi9ndWFyZHMudHNcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoYmxvYikge1xuICByZXR1cm4gYmxvYiAhPT0gbnVsbCAmJiB0eXBlb2YgYmxvYiA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYmxvYikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBpc1N0YXJ0c1dpdGhPcGVyYXRvcihibG9iKSB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KGJsb2IpICYmIHR5cGVvZiBibG9iLnN0YXJ0c1dpdGggPT09IFwic3RyaW5nXCI7XG59XG5cbi8vIHNyYy9saWIvdXRpbHMudHNcbmZ1bmN0aW9uIHJhaXNlKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cbmZ1bmN0aW9uIGVudHJpZXMob2JqKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhvYmopO1xufVxuZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG59XG5mdW5jdGlvbiB2YWx1ZXMob2JqKSB7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKG9iaik7XG59XG5mdW5jdGlvbiBjcmVhdGUob2JqLCBkZXNjcmlwdG9ycykge1xuICBpZiAodHlwZW9mIGRlc2NyaXB0b3JzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUob2JqLCBkZXNjcmlwdG9ycyk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5jcmVhdGUob2JqKTtcbn1cbmZ1bmN0aW9uIG1hcFZhbHVlcyhvYmosIG1hcEZuKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IHBhaXIgb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgIGNvbnN0IGtleSA9IHBhaXJbMF07XG4gICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gcGFpclsxXTtcbiAgICByZXN1bHRba2V5XSA9IG1hcEZuKHZhbHVlLCBrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0cnlQYXJzZUpzb24ocmF3TWVzc2FnZSkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHJhd01lc3NhZ2UpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gZGVlcENsb25lKHZhbHVlKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG59XG5mdW5jdGlvbiBiNjRkZWNvZGUoYjY0dmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IGI2NHZhbHVlLnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpO1xuICAgIGNvbnN0IGRlY29kZWRWYWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChcbiAgICAgIGF0b2IoZm9ybWF0dGVkVmFsdWUpLnNwbGl0KFwiXCIpLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiBcIiVcIiArIChcIjAwXCIgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG4gICAgICB9KS5qb2luKFwiXCIpXG4gICAgKTtcbiAgICByZXR1cm4gZGVjb2RlZFZhbHVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gYXRvYihiNjR2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBhY3QoaXRlbXMpIHtcbiAgcmV0dXJuIGl0ZW1zLmZpbHRlcihcbiAgICAoaXRlbSkgPT4gaXRlbSAhPT0gbnVsbCAmJiBpdGVtICE9PSB2b2lkIDBcbiAgKTtcbn1cbmZ1bmN0aW9uIGNvbXBhY3RPYmplY3Qob2JqKSB7XG4gIGNvbnN0IG5ld09iaiA9IHsgLi4ub2JqIH07XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaCgoaykgPT4ge1xuICAgIGNvbnN0IGtleSA9IGs7XG4gICAgaWYgKG5ld09ialtrZXldID09PSB2b2lkIDApIHtcbiAgICAgIGRlbGV0ZSBuZXdPYmpba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3T2JqO1xufVxuZnVuY3Rpb24gd2FpdChtaWxsaXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHNldFRpbWVvdXQocmVzLCBtaWxsaXMpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHdpdGhUaW1lb3V0KHByb21pc2UsIG1pbGxpcywgZXJybXNnKSB7XG4gIGxldCB0aW1lcklEO1xuICBjb25zdCB0aW1lciQgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgdGltZXJJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnJtc2cpKTtcbiAgICB9LCBtaWxsaXMpO1xuICB9KTtcbiAgcmV0dXJuIFByb21pc2UucmFjZShbcHJvbWlzZSwgdGltZXIkXSkuZmluYWxseSgoKSA9PiBjbGVhclRpbWVvdXQodGltZXJJRCkpO1xufVxuZnVuY3Rpb24gbWVtb2l6ZU9uU3VjY2VzcyhmYWN0b3J5Rm4pIHtcbiAgbGV0IGNhY2hlZCA9IG51bGw7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKGNhY2hlZCA9PT0gbnVsbCkge1xuICAgICAgY2FjaGVkID0gZmFjdG9yeUZuKCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjYWNoZWQgPSBudWxsO1xuICAgICAgICB9LCA1ZTMpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9hdXRvUmV0cnkudHNcbnZhciBIdHRwRXJyb3IgPSBjbGFzcyBfSHR0cEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICByZXNwb25zZTtcbiAgZGV0YWlscztcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcmVzcG9uc2UsIGRldGFpbHMpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIkh0dHBFcnJvclwiO1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmcm9tUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICBsZXQgYm9keUFzVGV4dDtcbiAgICB0cnkge1xuICAgICAgYm9keUFzVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgY29uc3QgYm9keUFzSnNvbiA9IGJvZHlBc1RleHQgPyB0cnlQYXJzZUpzb24oYm9keUFzVGV4dCkgOiB2b2lkIDA7XG4gICAgbGV0IGJvZHlBc0pzb25PYmplY3Q7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoYm9keUFzSnNvbikpIHtcbiAgICAgIGJvZHlBc0pzb25PYmplY3QgPSBib2R5QXNKc29uO1xuICAgIH1cbiAgICBsZXQgbWVzc2FnZSA9IFwiXCI7XG4gICAgbWVzc2FnZSB8fD0gdHlwZW9mIGJvZHlBc0pzb25PYmplY3Q/Lm1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBib2R5QXNKc29uT2JqZWN0Lm1lc3NhZ2UgOiBcIlwiO1xuICAgIG1lc3NhZ2UgfHw9IHR5cGVvZiBib2R5QXNKc29uT2JqZWN0Py5lcnJvciA9PT0gXCJzdHJpbmdcIiA/IGJvZHlBc0pzb25PYmplY3QuZXJyb3IgOiBcIlwiO1xuICAgIGlmIChib2R5QXNKc29uID09PSB2b2lkIDApIHtcbiAgICAgIG1lc3NhZ2UgfHw9IGJvZHlBc1RleHQgfHwgXCJcIjtcbiAgICB9XG4gICAgbWVzc2FnZSB8fD0gcmVzcG9uc2Uuc3RhdHVzVGV4dDtcbiAgICBsZXQgcGF0aDtcbiAgICB0cnkge1xuICAgICAgcGF0aCA9IG5ldyBVUkwocmVzcG9uc2UudXJsKS5wYXRobmFtZTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgbWVzc2FnZSArPSBwYXRoICE9PSB2b2lkIDAgPyBgIChnb3Qgc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzfSBmcm9tICR7cGF0aH0pYCA6IGAgKGdvdCBzdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9KWA7XG4gICAgY29uc3QgZGV0YWlscyA9IGJvZHlBc0pzb25PYmplY3Q7XG4gICAgcmV0dXJuIG5ldyBfSHR0cEVycm9yKG1lc3NhZ2UsIHJlc3BvbnNlLCBkZXRhaWxzKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVuaWVuY2UgYWNjZXNzb3IgZm9yIHJlc3BvbnNlLnN0YXR1cy5cbiAgICovXG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2Uuc3RhdHVzO1xuICB9XG59O1xudmFyIERPTlRfUkVUUllfNFhYID0gKHgpID0+IHggaW5zdGFuY2VvZiBIdHRwRXJyb3IgJiYgeC5zdGF0dXMgPj0gNDAwICYmIHguc3RhdHVzIDwgNTAwO1xuYXN5bmMgZnVuY3Rpb24gYXV0b1JldHJ5KHByb21pc2VGbiwgbWF4VHJpZXMsIGJhY2tvZmYsIHNob3VsZFN0b3BSZXRyeWluZyA9IERPTlRfUkVUUllfNFhYKSB7XG4gIGNvbnN0IGZhbGxiYWNrQmFja29mZiA9IGJhY2tvZmYubGVuZ3RoID4gMCA/IGJhY2tvZmZbYmFja29mZi5sZW5ndGggLSAxXSA6IDA7XG4gIGxldCBhdHRlbXB0ID0gMDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBhdHRlbXB0Kys7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBwcm9taXNlRm4oKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChzaG91bGRTdG9wUmV0cnlpbmcoZXJyKSkge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICBpZiAoYXR0ZW1wdCA+PSBtYXhUcmllcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCBhZnRlciAke21heFRyaWVzfSBhdHRlbXB0czogJHtTdHJpbmcoZXJyKX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGVsYXkgPSBiYWNrb2ZmW2F0dGVtcHQgLSAxXSA/PyBmYWxsYmFja0JhY2tvZmY7XG4gICAgd2FybihcbiAgICAgIGBBdHRlbXB0ICR7YXR0ZW1wdH0gd2FzIHVuc3VjY2Vzc2Z1bC4gUmV0cnlpbmcgaW4gJHtkZWxheX0gbWlsbGlzZWNvbmRzLmBcbiAgICApO1xuICAgIGF3YWl0IHdhaXQoZGVsYXkpO1xuICB9XG59XG5cbi8vIHNyYy9saWIvY29udHJvbGxlZFByb21pc2UudHNcbmZ1bmN0aW9uIGNvbnRyb2xsZWRQcm9taXNlKCkge1xuICBsZXQgcmVzb2x2ZTtcbiAgbGV0IHJlamVjdDtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIHJlc29sdmUgPSByZXM7XG4gICAgcmVqZWN0ID0gcmVqO1xuICB9KTtcbiAgcmV0dXJuIFtwcm9taXNlLCByZXNvbHZlLCByZWplY3RdO1xufVxuZnVuY3Rpb24gUHJvbWlzZV93aXRoUmVzb2x2ZXJzKCkge1xuICBjb25zdCBbcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0XSA9IGNvbnRyb2xsZWRQcm9taXNlKCk7XG4gIHJldHVybiB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9O1xufVxuXG4vLyBzcmMvbGliL0V2ZW50U291cmNlLnRzXG5mdW5jdGlvbiBtYWtlRXZlbnRTb3VyY2UoKSB7XG4gIGNvbnN0IF9vYnNlcnZlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmdW5jdGlvbiBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICBfb2JzZXJ2ZXJzLmFkZChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IF9vYnNlcnZlcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmVPbmNlKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgdW5zdWIgPSBzdWJzY3JpYmUoKGV2ZW50KSA9PiB7XG4gICAgICB1bnN1YigpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGV2ZW50KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdW5zdWI7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gd2FpdFVudGlsKHByZWRpY2F0ZSkge1xuICAgIGxldCB1bnN1YjtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcykgPT4ge1xuICAgICAgdW5zdWIgPSBzdWJzY3JpYmUoKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUgPT09IHZvaWQgMCB8fCBwcmVkaWNhdGUoZXZlbnQpKSB7XG4gICAgICAgICAgcmVzKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB1bnN1Yj8uKCkpO1xuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeShldmVudCkge1xuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIF9vYnNlcnZlcnMpIHtcbiAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBjYWxsZWQ7XG4gIH1cbiAgZnVuY3Rpb24gY291bnQoKSB7XG4gICAgcmV0dXJuIF9vYnNlcnZlcnMuc2l6ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC8vIFByaXZhdGUvaW50ZXJuYWwgY29udHJvbCBvdmVyIGV2ZW50IGVtaXNzaW9uXG4gICAgbm90aWZ5LFxuICAgIHN1YnNjcmliZSxcbiAgICBzdWJzY3JpYmVPbmNlLFxuICAgIGNvdW50LFxuICAgIHdhaXRVbnRpbCxcbiAgICBbU3ltYm9sLmRpc3Bvc2VdOiAoKSA9PiB7XG4gICAgICBfb2JzZXJ2ZXJzLmNsZWFyKCk7XG4gICAgfSxcbiAgICAvLyBQdWJsaWNseSBleHBvc2FibGUgc3Vic2NyaXB0aW9uIEFQSVxuICAgIG9ic2VydmFibGU6IHtcbiAgICAgIHN1YnNjcmliZSxcbiAgICAgIHN1YnNjcmliZU9uY2UsXG4gICAgICB3YWl0VW50aWxcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBtYWtlQnVmZmVyYWJsZUV2ZW50U291cmNlKCkge1xuICBjb25zdCBldmVudFNvdXJjZTIgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgbGV0IF9idWZmZXIgPSBudWxsO1xuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICBfYnVmZmVyID0gW107XG4gIH1cbiAgZnVuY3Rpb24gdW5wYXVzZSgpIHtcbiAgICBpZiAoX2J1ZmZlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIF9idWZmZXIpIHtcbiAgICAgIGV2ZW50U291cmNlMi5ub3RpZnkoZXZlbnQpO1xuICAgIH1cbiAgICBfYnVmZmVyID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBub3RpZnlPckJ1ZmZlcihldmVudCkge1xuICAgIGlmIChfYnVmZmVyICE9PSBudWxsKSB7XG4gICAgICBfYnVmZmVyLnB1c2goZXZlbnQpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZXZlbnRTb3VyY2UyLm5vdGlmeShldmVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZXZlbnRTb3VyY2UyLFxuICAgIG5vdGlmeTogbm90aWZ5T3JCdWZmZXIsXG4gICAgcGF1c2UsXG4gICAgdW5wYXVzZSxcbiAgICBbU3ltYm9sLmRpc3Bvc2VdOiAoKSA9PiB7XG4gICAgICBldmVudFNvdXJjZTJbU3ltYm9sLmRpc3Bvc2VdKCk7XG4gICAgICBpZiAoX2J1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgICBfYnVmZmVyLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbGliL2ZyZWV6ZS50c1xudmFyIGZyZWV6ZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IChcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgKHgpID0+IHhcbikgOiBPYmplY3QuZnJlZXplO1xuXG4vLyBzcmMvbGliL3NpZ25hbHMudHNcbnZhciBrU2lua3MgPSBTeW1ib2woXCJrU2lua3NcIik7XG52YXIga1RyaWdnZXIgPSBTeW1ib2woXCJrVHJpZ2dlclwiKTtcbnZhciBzaWduYWxzVG9UcmlnZ2VyID0gbnVsbDtcbnZhciB0cmFja2VkUmVhZHMgPSBudWxsO1xuZnVuY3Rpb24gYmF0Y2goY2FsbGJhY2spIHtcbiAgaWYgKHNpZ25hbHNUb1RyaWdnZXIgIT09IG51bGwpIHtcbiAgICBjYWxsYmFjaygpO1xuICAgIHJldHVybjtcbiAgfVxuICBzaWduYWxzVG9UcmlnZ2VyID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgdHJ5IHtcbiAgICBjYWxsYmFjaygpO1xuICB9IGZpbmFsbHkge1xuICAgIGZvciAoY29uc3Qgc2lnbmFsIG9mIHNpZ25hbHNUb1RyaWdnZXIpIHtcbiAgICAgIHNpZ25hbFtrVHJpZ2dlcl0oKTtcbiAgICB9XG4gICAgc2lnbmFsc1RvVHJpZ2dlciA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGVucXVldWVUcmlnZ2VyKHNpZ25hbCkge1xuICBpZiAoIXNpZ25hbHNUb1RyaWdnZXIpIHJhaXNlKFwiRXhwZWN0ZWQgdG8gYmUgaW4gYW4gYWN0aXZlIGJhdGNoXCIpO1xuICBzaWduYWxzVG9UcmlnZ2VyLmFkZChzaWduYWwpO1xufVxuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBwYXRjaCkge1xuICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xuICBjb25zdCBuZXdWYWx1ZSA9IHsgLi4udGFyZ2V0IH07XG4gIE9iamVjdC5rZXlzKHBhdGNoKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gaztcbiAgICBjb25zdCB2YWwgPSBwYXRjaFtrZXldO1xuICAgIGlmIChuZXdWYWx1ZVtrZXldICE9PSB2YWwpIHtcbiAgICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgICBkZWxldGUgbmV3VmFsdWVba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlW2tleV0gPSB2YWw7XG4gICAgICB9XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdXBkYXRlZCA/IG5ld1ZhbHVlIDogdGFyZ2V0O1xufVxudmFyIEFic3RyYWN0U2lnbmFsID0gY2xhc3Mge1xuICAvKiogQGludGVybmFsICovXG4gIGVxdWFscztcbiAgI2V2ZW50U291cmNlO1xuICAvKiogQGludGVybmFsICovXG4gIFtrU2lua3NdO1xuICBjb25zdHJ1Y3RvcihlcXVhbHMpIHtcbiAgICB0aGlzLmVxdWFscyA9IGVxdWFscyA/PyBPYmplY3QuaXM7XG4gICAgdGhpcy4jZXZlbnRTb3VyY2UgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgICB0aGlzW2tTaW5rc10gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuZ2V0ID0gdGhpcy5nZXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnN1YnNjcmliZSA9IHRoaXMuc3Vic2NyaWJlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zdWJzY3JpYmVPbmNlID0gdGhpcy5zdWJzY3JpYmVPbmNlLmJpbmQodGhpcyk7XG4gIH1cbiAgW1N5bWJvbC5kaXNwb3NlXSgpIHtcbiAgICB0aGlzLiNldmVudFNvdXJjZVtTeW1ib2wuZGlzcG9zZV0oKTtcbiAgICB0aGlzLiNldmVudFNvdXJjZSA9IFwiKGRpc3Bvc2VkKVwiO1xuICAgIHRoaXMuZXF1YWxzID0gXCIoZGlzcG9zZWQpXCI7XG4gIH1cbiAgZ2V0IGhhc1dhdGNoZXJzKCkge1xuICAgIGlmICh0aGlzLiNldmVudFNvdXJjZS5jb3VudCgpID4gMCkgcmV0dXJuIHRydWU7XG4gICAgZm9yIChjb25zdCBzaW5rIG9mIHRoaXNba1NpbmtzXSkge1xuICAgICAgaWYgKHNpbmsuaGFzV2F0Y2hlcnMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBba1RyaWdnZXJdKCkge1xuICAgIHRoaXMuI2V2ZW50U291cmNlLm5vdGlmeSgpO1xuICAgIGZvciAoY29uc3Qgc2luayBvZiB0aGlzW2tTaW5rc10pIHtcbiAgICAgIGVucXVldWVUcmlnZ2VyKHNpbmspO1xuICAgIH1cbiAgfVxuICBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy4jZXZlbnRTb3VyY2UuY291bnQoKSA9PT0gMCkge1xuICAgICAgdGhpcy5nZXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50U291cmNlLnN1YnNjcmliZShjYWxsYmFjayk7XG4gIH1cbiAgc3Vic2NyaWJlT25jZShjYWxsYmFjaykge1xuICAgIGNvbnN0IHVuc3ViID0gdGhpcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdW5zdWIoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH0pO1xuICAgIHJldHVybiB1bnN1YjtcbiAgfVxuICB3YWl0VW50aWwoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwid2FpdFVudGlsIG5vdCBzdXBwb3J0ZWQgb24gU2lnbmFsc1wiKTtcbiAgfVxuICBtYXJrU2lua3NEaXJ0eSgpIHtcbiAgICBmb3IgKGNvbnN0IHNpbmsgb2YgdGhpc1trU2lua3NdKSB7XG4gICAgICBzaW5rLm1hcmtEaXJ0eSgpO1xuICAgIH1cbiAgfVxuICBhZGRTaW5rKHNpbmspIHtcbiAgICB0aGlzW2tTaW5rc10uYWRkKHNpbmspO1xuICB9XG4gIHJlbW92ZVNpbmsoc2luaykge1xuICAgIHRoaXNba1NpbmtzXS5kZWxldGUoc2luayk7XG4gIH1cbiAgYXNSZWFkb25seSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnZhciBTaWduYWwgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0U2lnbmFsIHtcbiAgI3ZhbHVlO1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgZXF1YWxzKSB7XG4gICAgc3VwZXIoZXF1YWxzKTtcbiAgICB0aGlzLiN2YWx1ZSA9IGZyZWV6ZSh2YWx1ZSk7XG4gIH1cbiAgW1N5bWJvbC5kaXNwb3NlXSgpIHtcbiAgICBzdXBlcltTeW1ib2wuZGlzcG9zZV0oKTtcbiAgICB0aGlzLiN2YWx1ZSA9IFwiKGRpc3Bvc2VkKVwiO1xuICB9XG4gIGdldCgpIHtcbiAgICB0cmFja2VkUmVhZHM/LmFkZCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy4jdmFsdWU7XG4gIH1cbiAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgYmF0Y2goKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBuZXdWYWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUodGhpcy4jdmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmVxdWFscyh0aGlzLiN2YWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgICAgIHRoaXMuI3ZhbHVlID0gZnJlZXplKG5ld1ZhbHVlKTtcbiAgICAgICAgdGhpcy5tYXJrU2lua3NEaXJ0eSgpO1xuICAgICAgICBlbnF1ZXVlVHJpZ2dlcih0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbnZhciBQYXRjaGFibGVTaWduYWwgPSBjbGFzcyBleHRlbmRzIFNpZ25hbCB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcihmcmVlemUoY29tcGFjdE9iamVjdChkYXRhKSkpO1xuICB9XG4gIHNldCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEb24ndCBjYWxsIC5zZXQoKSBkaXJlY3RseSwgdXNlIC5wYXRjaCgpXCIpO1xuICB9XG4gIC8qKlxuICAgKiBQYXRjaGVzIHRoZSBjdXJyZW50IG9iamVjdC5cbiAgICovXG4gIHBhdGNoKHBhdGNoKSB7XG4gICAgc3VwZXIuc2V0KChvbGQpID0+IG1lcmdlKG9sZCwgcGF0Y2gpKTtcbiAgfVxufTtcbnZhciBJTklUSUFMID0gU3ltYm9sKCk7XG52YXIgRGVyaXZlZFNpZ25hbCA9IGNsYXNzIF9EZXJpdmVkU2lnbmFsIGV4dGVuZHMgQWJzdHJhY3RTaWduYWwge1xuICAjcHJldlZhbHVlO1xuICAjZGlydHk7XG4gIC8vIFdoZW4gdHJ1ZSwgdGhlIHZhbHVlIGluICN2YWx1ZSBtYXkgbm90IGJlIHVwLXRvLWRhdGUgYW5kIG5lZWRzIHJlLWNoZWNraW5nXG4gICNzb3VyY2VzO1xuICAjZGVwcztcbiAgI3RyYW5zZm9ybTtcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHN0YXRpYyBmcm9tKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBsYXN0ID0gYXJncy5wb3AoKTtcbiAgICBpZiAodHlwZW9mIGxhc3QgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHJhaXNlKFwiSW52YWxpZCAuZnJvbSgpIGNhbGwsIGxhc3QgYXJndW1lbnQgZXhwZWN0ZWQgdG8gYmUgYSBmdW5jdGlvblwiKTtcbiAgICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zdCBlcXVhbHMgPSBsYXN0O1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gYXJncy5wb3AoKTtcbiAgICAgIHJldHVybiBuZXcgX0Rlcml2ZWRTaWduYWwoYXJncywgdHJhbnNmb3JtLCBlcXVhbHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBsYXN0O1xuICAgICAgcmV0dXJuIG5ldyBfRGVyaXZlZFNpZ25hbChhcmdzLCB0cmFuc2Zvcm0pO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3RvcihkZXBzLCB0cmFuc2Zvcm0sIGVxdWFscykge1xuICAgIHN1cGVyKGVxdWFscyk7XG4gICAgdGhpcy4jZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuI3ByZXZWYWx1ZSA9IElOSVRJQUw7XG4gICAgdGhpcy4jZGVwcyA9IGRlcHM7XG4gICAgdGhpcy4jc291cmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy4jdHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICB9XG4gIFtTeW1ib2wuZGlzcG9zZV0oKSB7XG4gICAgZm9yIChjb25zdCBzcmMgb2YgdGhpcy4jc291cmNlcykge1xuICAgICAgc3JjLnJlbW92ZVNpbmsodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuI3ByZXZWYWx1ZSA9IFwiKGRpc3Bvc2VkKVwiO1xuICAgIHRoaXMuI3NvdXJjZXMgPSBcIihkaXNwb3NlZClcIjtcbiAgICB0aGlzLiNkZXBzID0gXCIoZGlzcG9zZWQpXCI7XG4gICAgdGhpcy4jdHJhbnNmb3JtID0gXCIoZGlzcG9zZWQpXCI7XG4gIH1cbiAgZ2V0IGlzRGlydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RpcnR5O1xuICB9XG4gICNyZWNvbXB1dGUoKSB7XG4gICAgY29uc3Qgb2xkVHJhY2tlZFJlYWRzID0gdHJhY2tlZFJlYWRzO1xuICAgIGxldCBkZXJpdmVkO1xuICAgIHRyYWNrZWRSZWFkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdHJ5IHtcbiAgICAgIGRlcml2ZWQgPSB0aGlzLiN0cmFuc2Zvcm0oLi4udGhpcy4jZGVwcy5tYXAoKHApID0+IHAuZ2V0KCkpKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY29uc3Qgb2xkU291cmNlcyA9IHRoaXMuI3NvdXJjZXM7XG4gICAgICB0aGlzLiNzb3VyY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGZvciAoY29uc3Qgc2lnIG9mIHRyYWNrZWRSZWFkcykge1xuICAgICAgICB0aGlzLiNzb3VyY2VzLmFkZChzaWcpO1xuICAgICAgICBvbGRTb3VyY2VzLmRlbGV0ZShzaWcpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBvbGRTb3VyY2Ugb2Ygb2xkU291cmNlcykge1xuICAgICAgICBvbGRTb3VyY2UucmVtb3ZlU2luayh0aGlzKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgbmV3U291cmNlIG9mIHRoaXMuI3NvdXJjZXMpIHtcbiAgICAgICAgbmV3U291cmNlLmFkZFNpbmsodGhpcyk7XG4gICAgICB9XG4gICAgICB0cmFja2VkUmVhZHMgPSBvbGRUcmFja2VkUmVhZHM7XG4gICAgfVxuICAgIHRoaXMuI2RpcnR5ID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLmVxdWFscyh0aGlzLiNwcmV2VmFsdWUsIGRlcml2ZWQpKSB7XG4gICAgICB0aGlzLiNwcmV2VmFsdWUgPSBkZXJpdmVkO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBtYXJrRGlydHkoKSB7XG4gICAgaWYgKCF0aGlzLiNkaXJ0eSkge1xuICAgICAgdGhpcy4jZGlydHkgPSB0cnVlO1xuICAgICAgdGhpcy5tYXJrU2lua3NEaXJ0eSgpO1xuICAgIH1cbiAgfVxuICBnZXQoKSB7XG4gICAgaWYgKHRoaXMuI2RpcnR5KSB7XG4gICAgICB0aGlzLiNyZWNvbXB1dGUoKTtcbiAgICB9XG4gICAgdHJhY2tlZFJlYWRzPy5hZGQodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuI3ByZXZWYWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIGJ5IHRoZSBTaWduYWwgc3lzdGVtIGlmIG9uZSBvciBtb3JlIG9mIHRoZSBkZXBlbmRlbnQgc2lnbmFscyBoYXZlXG4gICAqIGNoYW5nZWQuIEluIHRoZSBjYXNlIG9mIGEgRGVyaXZlZFNpZ25hbCwgd2UnbGwgb25seSB3YW50IHRvIHJlLWV2YWx1YXRlXG4gICAqIHRoZSBhY3R1YWwgdmFsdWUgaWYgaXQncyBiZWluZyB3YXRjaGVkLCBvciBhbnkgb2YgdGhlaXIgc2lua3MgYXJlIGJlaW5nXG4gICAqIHdhdGNoZWQgYWN0aXZlbHkuXG4gICAqL1xuICBba1RyaWdnZXJdKCkge1xuICAgIGlmICghdGhpcy5oYXNXYXRjaGVycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVkID0gdGhpcy4jcmVjb21wdXRlKCk7XG4gICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgIHN1cGVyW2tUcmlnZ2VyXSgpO1xuICAgIH1cbiAgfVxufTtcbnZhciBNdXRhYmxlU2lnbmFsID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdFNpZ25hbCB7XG4gICNzdGF0ZTtcbiAgY29uc3RydWN0b3IoaW5pdGlhbFN0YXRlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNzdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgfVxuICBbU3ltYm9sLmRpc3Bvc2VdKCkge1xuICAgIHN1cGVyW1N5bWJvbC5kaXNwb3NlXSgpO1xuICAgIHRoaXMuI3N0YXRlID0gXCIoZGlzcG9zZWQpXCI7XG4gIH1cbiAgZ2V0KCkge1xuICAgIHRyYWNrZWRSZWFkcz8uYWRkKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLiNzdGF0ZTtcbiAgfVxuICAvKipcbiAgICogSW52b2tlcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgYWxsb3dlZCB0byBtdXRhdGUgdGhlIGdpdmVuIHN0YXRlXG4gICAqIHZhbHVlLiBEbyBub3QgY2hhbmdlIHRoZSB2YWx1ZSBvdXRzaWRlIG9mIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogSWYgdGhlIGNhbGxiYWNrIGV4cGxpY2l0bHkgcmV0dXJucyBgZmFsc2VgLCBpdCdzIGFzc3VtZWQgdGhhdCB0aGUgc3RhdGVcbiAgICogd2FzIG5vdCBjaGFuZ2VkLlxuICAgKi9cbiAgbXV0YXRlKGNhbGxiYWNrKSB7XG4gICAgYmF0Y2goKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2sgPyBjYWxsYmFjayh0aGlzLiNzdGF0ZSkgOiB0cnVlO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0ID09PSBcIm9iamVjdFwiICYmIFwidGhlblwiIGluIHJlc3VsdCkge1xuICAgICAgICByYWlzZShcIk11dGFibGVTaWduYWwubXV0YXRlKCkgZG9lcyBub3Qgc3VwcG9ydCBhc3luYyBjYWxsYmFja3NcIik7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLm1hcmtTaW5rc0RpcnR5KCk7XG4gICAgICAgIGVucXVldWVUcmlnZ2VyKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL3N0cmluZ2lmeS50c1xuZnVuY3Rpb24gcmVwbGFjZXIoX2tleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBPYmplY3Qua2V5cyh2YWx1ZSkuc29ydCgpLnJlZHVjZSgoc29ydGVkLCBrZXkpID0+IHtcbiAgICBzb3J0ZWRba2V5XSA9IHZhbHVlW2tleV07XG4gICAgcmV0dXJuIHNvcnRlZDtcbiAgfSwge30pIDogdmFsdWU7XG59XG5mdW5jdGlvbiBzdGFibGVTdHJpbmdpZnkodmFsdWUpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlcik7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlPckxvZyh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkIG5vdCBzdHJpbmdpZnk6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgY29uc29sZS5lcnJvcih2YWx1ZSk7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5cbi8vIHNyYy9saWIvYmF0Y2gudHNcbnZhciBERUZBVUxUX1NJWkUgPSA1MDtcbnZhciBCYXRjaENhbGwgPSBjbGFzcyB7XG4gIGlucHV0O1xuICByZXNvbHZlO1xuICByZWplY3Q7XG4gIHByb21pc2U7XG4gIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgIGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0IH0gPSBQcm9taXNlX3dpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gIH1cbn07XG52YXIgQmF0Y2ggPSBjbGFzcyB7XG4gICNxdWV1ZSA9IFtdO1xuICAjY2FsbGJhY2s7XG4gICNzaXplO1xuICAjZGVsYXk7XG4gICNkZWxheVRpbWVvdXRJZDtcbiAgZXJyb3IgPSBmYWxzZTtcbiAgY29uc3RydWN0b3IoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICB0aGlzLiNjYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuI3NpemUgPSBvcHRpb25zLnNpemUgPz8gREVGQVVMVF9TSVpFO1xuICAgIHRoaXMuI2RlbGF5ID0gb3B0aW9ucy5kZWxheTtcbiAgfVxuICAjY2xlYXJEZWxheVRpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMuI2RlbGF5VGltZW91dElkICE9PSB2b2lkIDApIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNkZWxheVRpbWVvdXRJZCk7XG4gICAgICB0aGlzLiNkZWxheVRpbWVvdXRJZCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgI3NjaGVkdWxlKCkge1xuICAgIGlmICh0aGlzLiNxdWV1ZS5sZW5ndGggPT09IHRoaXMuI3NpemUpIHtcbiAgICAgIHZvaWQgdGhpcy4jZmx1c2goKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI3F1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhpcy4jY2xlYXJEZWxheVRpbWVvdXQoKTtcbiAgICAgIHRoaXMuI2RlbGF5VGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB2b2lkIHRoaXMuI2ZsdXNoKCksIHRoaXMuI2RlbGF5KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgI2ZsdXNoKCkge1xuICAgIGlmICh0aGlzLiNxdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2FsbHMgPSB0aGlzLiNxdWV1ZS5zcGxpY2UoMCk7XG4gICAgY29uc3QgaW5wdXRzID0gY2FsbHMubWFwKChjYWxsKSA9PiBjYWxsLmlucHV0KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuI2NhbGxiYWNrKGlucHV0cyk7XG4gICAgICB0aGlzLmVycm9yID0gZmFsc2U7XG4gICAgICBjYWxscy5mb3JFYWNoKChjYWxsLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzPy5baW5kZXhdO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzdWx0cykpIHtcbiAgICAgICAgICBjYWxsLnJlamVjdChuZXcgRXJyb3IoXCJDYWxsYmFjayBtdXN0IHJldHVybiBhbiBhcnJheS5cIikpO1xuICAgICAgICB9IGVsc2UgaWYgKGNhbGxzLmxlbmd0aCAhPT0gcmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICBjYWxsLnJlamVjdChcbiAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYENhbGxiYWNrIG11c3QgcmV0dXJuIGFuIGFycmF5IG9mIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgbnVtYmVyIG9mIHByb3ZpZGVkIGl0ZW1zLiBFeHBlY3RlZCAke2NhbGxzLmxlbmd0aH0sIGJ1dCBnb3QgJHtyZXN1bHRzLmxlbmd0aH0uYFxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBjYWxsLnJlamVjdChyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGwucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcjMpIHtcbiAgICAgIHRoaXMuZXJyb3IgPSB0cnVlO1xuICAgICAgY2FsbHMuZm9yRWFjaCgoY2FsbCkgPT4ge1xuICAgICAgICBjYWxsLnJlamVjdChlcnJvcjMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldChpbnB1dCkge1xuICAgIGNvbnN0IGV4aXN0aW5nQ2FsbCA9IHRoaXMuI3F1ZXVlLmZpbmQoXG4gICAgICAoY2FsbDIpID0+IHN0YWJsZVN0cmluZ2lmeShjYWxsMi5pbnB1dCkgPT09IHN0YWJsZVN0cmluZ2lmeShpbnB1dClcbiAgICApO1xuICAgIGlmIChleGlzdGluZ0NhbGwpIHtcbiAgICAgIHJldHVybiBleGlzdGluZ0NhbGwucHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgY2FsbCA9IG5ldyBCYXRjaENhbGwoaW5wdXQpO1xuICAgIHRoaXMuI3F1ZXVlLnB1c2goY2FsbCk7XG4gICAgdGhpcy4jc2NoZWR1bGUoKTtcbiAgICByZXR1cm4gY2FsbC5wcm9taXNlO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuI3F1ZXVlID0gW107XG4gICAgdGhpcy5lcnJvciA9IGZhbHNlO1xuICAgIHRoaXMuI2NsZWFyRGVsYXlUaW1lb3V0KCk7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVCYXRjaFN0b3JlKGJhdGNoMikge1xuICBjb25zdCBzaWduYWwgPSBuZXcgTXV0YWJsZVNpZ25hbCgvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgZnVuY3Rpb24gZ2V0Q2FjaGVLZXkoYXJncykge1xuICAgIHJldHVybiBzdGFibGVTdHJpbmdpZnkoYXJncyk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlKGNhY2hlS2V5LCBzdGF0ZSkge1xuICAgIHNpZ25hbC5tdXRhdGUoKGNhY2hlKSA9PiB7XG4gICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBpbnZhbGlkYXRlKGlucHV0cykge1xuICAgIHNpZ25hbC5tdXRhdGUoKGNhY2hlKSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dHMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgaW5wdXQgb2YgaW5wdXRzKSB7XG4gICAgICAgICAgY2FjaGUuZGVsZXRlKGdldENhY2hlS2V5KGlucHV0KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZW5xdWV1ZShpbnB1dCkge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkoaW5wdXQpO1xuICAgIGNvbnN0IGNhY2hlID0gc2lnbmFsLmdldCgpO1xuICAgIGlmIChjYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB1cGRhdGUoY2FjaGVLZXksIHsgaXNMb2FkaW5nOiB0cnVlIH0pO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYmF0Y2gyLmdldChpbnB1dCk7XG4gICAgICB1cGRhdGUoY2FjaGVLZXksIHsgaXNMb2FkaW5nOiBmYWxzZSwgZGF0YTogcmVzdWx0IH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yMykge1xuICAgICAgdXBkYXRlKGNhY2hlS2V5LCB7XG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvcjNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRJdGVtU3RhdGUoaW5wdXQpIHtcbiAgICBjb25zdCBjYWNoZUtleSA9IGdldENhY2hlS2V5KGlucHV0KTtcbiAgICBjb25zdCBjYWNoZSA9IHNpZ25hbC5nZXQoKTtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgfVxuICBmdW5jdGlvbiBfY2FjaGVLZXlzKCkge1xuICAgIGNvbnN0IGNhY2hlID0gc2lnbmFsLmdldCgpO1xuICAgIHJldHVybiBbLi4uY2FjaGUua2V5cygpXTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN1YnNjcmliZTogc2lnbmFsLnN1YnNjcmliZSxcbiAgICBlbnF1ZXVlLFxuICAgIGdldEl0ZW1TdGF0ZSxcbiAgICBpbnZhbGlkYXRlLFxuICAgIGJhdGNoOiBiYXRjaDIsXG4gICAgX2NhY2hlS2V5c1xuICB9O1xufVxuXG4vLyBzcmMvbGliL2NodW5rLnRzXG5mdW5jdGlvbiBjaHVuayhhcnJheSwgc2l6ZSkge1xuICBjb25zdCBjaHVua3MgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSBhcnJheS5sZW5ndGg7IGkgPCBqOyBpICs9IHNpemUpIHtcbiAgICBjaHVua3MucHVzaChhcnJheS5zbGljZShpLCBpICsgc2l6ZSkpO1xuICB9XG4gIHJldHVybiBjaHVua3M7XG59XG5cbi8vIHNyYy9saWIvbmFub2lkLnRzXG52YXIgbmFub2lkID0gKHQgPSAyMSkgPT4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSh0KSkucmVkdWNlKFxuICAodDIsIGUpID0+IHQyICs9IChlICY9IDYzKSA8IDM2ID8gZS50b1N0cmluZygzNikgOiBlIDwgNjIgPyAoZSAtIDI2KS50b1N0cmluZygzNikudG9VcHBlckNhc2UoKSA6IGUgPCA2MyA/IFwiX1wiIDogXCItXCIsXG4gIFwiXCJcbik7XG5cbi8vIHNyYy9saWIvY3JlYXRlSWRzLnRzXG52YXIgVEhSRUFEX0lEX1BSRUZJWCA9IFwidGhcIjtcbnZhciBDT01NRU5UX0lEX1BSRUZJWCA9IFwiY21cIjtcbnZhciBDT01NRU5UX0FUVEFDSE1FTlRfSURfUFJFRklYID0gXCJhdFwiO1xudmFyIElOQk9YX05PVElGSUNBVElPTl9JRF9QUkVGSVggPSBcImluXCI7XG5mdW5jdGlvbiBjcmVhdGVPcHRpbWlzdGljSWQocHJlZml4KSB7XG4gIHJldHVybiBgJHtwcmVmaXh9XyR7bmFub2lkKCl9YDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRocmVhZElkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKFRIUkVBRF9JRF9QUkVGSVgpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudElkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKENPTU1FTlRfSURfUFJFRklYKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRBdHRhY2htZW50SWQoKSB7XG4gIHJldHVybiBjcmVhdGVPcHRpbWlzdGljSWQoQ09NTUVOVF9BVFRBQ0hNRU5UX0lEX1BSRUZJWCk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbmJveE5vdGlmaWNhdGlvbklkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKElOQk9YX05PVElGSUNBVElPTl9JRF9QUkVGSVgpO1xufVxuXG4vLyBzcmMvbGliL0RlZmF1bHRNYXAudHNcbnZhciBEZWZhdWx0TWFwID0gY2xhc3MgZXh0ZW5kcyBNYXAge1xuICAjZGVmYXVsdEZuO1xuICAvKipcbiAgICogSWYgdGhlIGRlZmF1bHQgZnVuY3Rpb24gaXMgbm90IHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3RvciwgaXQgaGFzIHRvIGJlXG4gICAqIHByb3ZpZGVkIGluIGVhY2ggLmdldE9yQ3JlYXRlKCkgY2FsbCBpbmRpdmlkdWFsbHkuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0Rm4sIGVudHJpZXMyKSB7XG4gICAgc3VwZXIoZW50cmllczIpO1xuICAgIHRoaXMuI2RlZmF1bHRGbiA9IGRlZmF1bHRGbjtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIGtleSwgb3IgY3JlYXRlcyBpdC5cbiAgICpcbiAgICogRGlmZmVyZW5jZSBmcm9tIG5vcm1hbCBNYXA6IGlmIHRoZSBrZXkgZG9lcyBub3QgZXhpc3QsIGl0IHdpbGwgYmUgY3JlYXRlZFxuICAgKiBvbiB0aGUgZmx5IHVzaW5nIHRoZSBmYWN0b3J5IGZ1bmN0aW9uLCBhbmQgdGhhdCB2YWx1ZSB3aWxsIGdldCByZXR1cm5lZFxuICAgKiBpbnN0ZWFkIG9mIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgZ2V0T3JDcmVhdGUoa2V5LCBkZWZhdWx0Rm4pIHtcbiAgICBpZiAoc3VwZXIuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBzdXBlci5nZXQoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZm4gPSBkZWZhdWx0Rm4gPz8gdGhpcy4jZGVmYXVsdEZuID8/IHJhaXNlKFwiRGVmYXVsdE1hcCB1c2VkIHdpdGhvdXQgYSBmYWN0b3J5IGZ1bmN0aW9uXCIpO1xuICAgICAgY29uc3QgdmFsdWUgPSBmbihrZXkpO1xuICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvbGliL29iamVjdFRvUXVlcnkudHNcbnZhciBpZGVudGlmaWVyUmVnZXggPSAvXlthLXpBLVpfXVthLXpBLVowLTlfXSokLztcbmZ1bmN0aW9uIG9iamVjdFRvUXVlcnkob2JqKSB7XG4gIGxldCBmaWx0ZXJMaXN0ID0gW107XG4gIGNvbnN0IGVudHJpZXMyID0gT2JqZWN0LmVudHJpZXMob2JqKTtcbiAgY29uc3Qga2V5VmFsdWVQYWlycyA9IFtdO1xuICBjb25zdCBrZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yID0gW107XG4gIGNvbnN0IGluZGV4ZWRLZXlzID0gW107XG4gIGVudHJpZXMyLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICghaWRlbnRpZmllclJlZ2V4LnRlc3Qoa2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IG11c3Qgb25seSBjb250YWluIGxldHRlcnMsIG51bWJlcnMsIF9cIik7XG4gICAgfVxuICAgIGlmIChpc1NpbXBsZVZhbHVlKHZhbHVlKSkge1xuICAgICAga2V5VmFsdWVQYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgaWYgKGlzU3RhcnRzV2l0aE9wZXJhdG9yKHZhbHVlKSkge1xuICAgICAgICBrZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4ZWRLZXlzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBmaWx0ZXJMaXN0ID0gW1xuICAgIC4uLmdldEZpbHRlcnNGcm9tS2V5VmFsdWVQYWlycyhrZXlWYWx1ZVBhaXJzKSxcbiAgICAuLi5nZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3Ioa2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvcilcbiAgXTtcbiAgaW5kZXhlZEtleXMuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgbmVzdGVkRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHZhbHVlKTtcbiAgICBjb25zdCBuS2V5VmFsdWVQYWlycyA9IFtdO1xuICAgIGNvbnN0IG5LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yID0gW107XG4gICAgbmVzdGVkRW50cmllcy5mb3JFYWNoKChbbmVzdGVkS2V5LCBuZXN0ZWRWYWx1ZV0pID0+IHtcbiAgICAgIGlmIChpc1N0cmluZ0VtcHR5KG5lc3RlZEtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NpbXBsZVZhbHVlKG5lc3RlZFZhbHVlKSkge1xuICAgICAgICBuS2V5VmFsdWVQYWlycy5wdXNoKFtmb3JtYXRGaWx0ZXJLZXkoa2V5LCBuZXN0ZWRLZXkpLCBuZXN0ZWRWYWx1ZV0pO1xuICAgICAgfSBlbHNlIGlmIChpc1N0YXJ0c1dpdGhPcGVyYXRvcihuZXN0ZWRWYWx1ZSkpIHtcbiAgICAgICAgbktleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IucHVzaChbXG4gICAgICAgICAgZm9ybWF0RmlsdGVyS2V5KGtleSwgbmVzdGVkS2V5KSxcbiAgICAgICAgICBuZXN0ZWRWYWx1ZVxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmaWx0ZXJMaXN0ID0gW1xuICAgICAgLi4uZmlsdGVyTGlzdCxcbiAgICAgIC4uLmdldEZpbHRlcnNGcm9tS2V5VmFsdWVQYWlycyhuS2V5VmFsdWVQYWlycyksXG4gICAgICAuLi5nZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IobktleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IpXG4gICAgXTtcbiAgfSk7XG4gIHJldHVybiBmaWx0ZXJMaXN0Lm1hcCgoeyBrZXksIG9wZXJhdG9yLCB2YWx1ZSB9KSA9PiBgJHtrZXl9JHtvcGVyYXRvcn0ke3F1b3RlKHZhbHVlKX1gKS5qb2luKFwiIFwiKTtcbn1cbnZhciBnZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnMgPSAoa2V5VmFsdWVQYWlycykgPT4ge1xuICBjb25zdCBmaWx0ZXJzID0gW107XG4gIGtleVZhbHVlUGFpcnMuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgZmlsdGVycy5wdXNoKHtcbiAgICAgIGtleSxcbiAgICAgIG9wZXJhdG9yOiBcIjpcIixcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZmlsdGVycztcbn07XG52YXIgZ2V0RmlsdGVyc0Zyb21LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yID0gKGtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IpID0+IHtcbiAgY29uc3QgZmlsdGVycyA9IFtdO1xuICBrZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmIChcInN0YXJ0c1dpdGhcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuc3RhcnRzV2l0aCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZmlsdGVycy5wdXNoKHtcbiAgICAgICAga2V5LFxuICAgICAgICBvcGVyYXRvcjogXCJeXCIsXG4gICAgICAgIHZhbHVlOiB2YWx1ZS5zdGFydHNXaXRoXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZmlsdGVycztcbn07XG52YXIgaXNTaW1wbGVWYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiIHx8IHZhbHVlID09PSBudWxsO1xufTtcbnZhciBmb3JtYXRGaWx0ZXJLZXkgPSAoa2V5LCBuZXN0ZWRLZXkpID0+IHtcbiAgaWYgKG5lc3RlZEtleSkge1xuICAgIHJldHVybiBgJHtrZXl9WyR7cXVvdGUobmVzdGVkS2V5KX1dYDtcbiAgfVxuICByZXR1cm4ga2V5O1xufTtcbnZhciBpc1N0cmluZ0VtcHR5ID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiAhdmFsdWUgfHwgdmFsdWUudG9TdHJpbmcoKS50cmltKCkgPT09IFwiXCI7XG59O1xuZnVuY3Rpb24gcXVvdGUoaW5wdXQpIHtcbiAgY29uc3QgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAocmVzdWx0LmluY2x1ZGVzKFwiJ1wiKSkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGAnJHtyZXN1bHQuc2xpY2UoMSwgLTEpLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKX0nYDtcbn1cblxuLy8gc3JjL2xpYi91cmwudHNcbmZ1bmN0aW9uIHRvVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykge1xuICBjb25zdCByZXN1bHQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFtcykpIHtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXJsam9pbihiYXNlVXJsLCBwYXRoLCBwYXJhbXMpIHtcbiAgY29uc3QgdXJsMiA9IG5ldyBVUkwocGF0aCwgYmFzZVVybCk7XG4gIGlmIChwYXJhbXMgIT09IHZvaWQgMCkge1xuICAgIHVybDIuc2VhcmNoID0gKHBhcmFtcyBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcyA/IHBhcmFtcyA6IHRvVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIHVybDIudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIHVybChzdHJpbmdzLCAuLi52YWx1ZXMyKSB7XG4gIHJldHVybiBzdHJpbmdzLnJlZHVjZShcbiAgICAocmVzdWx0LCBzdHIsIGkpID0+IHJlc3VsdCArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZXMyW2kgLSAxXSA/PyBcIlwiKSArIHN0clxuICApO1xufVxuXG4vLyBzcmMvYXBpLWNsaWVudC50c1xuZnVuY3Rpb24gY3JlYXRlQXBpQ2xpZW50KHtcbiAgYmFzZVVybCxcbiAgYXV0aE1hbmFnZXIsXG4gIGZldGNoUG9seWZpbGxcbn0pIHtcbiAgY29uc3QgaHR0cENsaWVudCA9IG5ldyBIdHRwQ2xpZW50KGJhc2VVcmwsIGZldGNoUG9seWZpbGwpO1xuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWRzU2luY2Uob3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RocmVhZHMvZGVsdGFgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgc2luY2U6IG9wdGlvbnMuc2luY2UudG9JU09TdHJpbmcoKVxuICAgICAgfSxcbiAgICAgIHsgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCB9XG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgdGhyZWFkczoge1xuICAgICAgICB1cGRhdGVkOiByZXN1bHQuZGF0YS5tYXAoY29udmVydFRvVGhyZWFkRGF0YSksXG4gICAgICAgIGRlbGV0ZWQ6IHJlc3VsdC5kZWxldGVkVGhyZWFkcy5tYXAoY29udmVydFRvVGhyZWFkRGVsZXRlSW5mbylcbiAgICAgIH0sXG4gICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHtcbiAgICAgICAgdXBkYXRlZDogcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucy5tYXAoY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhKSxcbiAgICAgICAgZGVsZXRlZDogcmVzdWx0LmRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICAgIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGVsZXRlSW5mb1xuICAgICAgICApXG4gICAgICB9LFxuICAgICAgcmVxdWVzdGVkQXQ6IG5ldyBEYXRlKHJlc3VsdC5tZXRhLnJlcXVlc3RlZEF0KSxcbiAgICAgIHBlcm1pc3Npb25IaW50czogcmVzdWx0Lm1ldGEucGVybWlzc2lvbkhpbnRzXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWRzKG9wdGlvbnMpIHtcbiAgICBsZXQgcXVlcnk7XG4gICAgaWYgKG9wdGlvbnMucXVlcnkpIHtcbiAgICAgIHF1ZXJ5ID0gb2JqZWN0VG9RdWVyeShvcHRpb25zLnF1ZXJ5KTtcbiAgICB9XG4gICAgY29uc3QgUEFHRV9TSVpFID0gNTA7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0KFxuICAgICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGhyZWFkc2AsXG4gICAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgICAgfSksXG4gICAgICAgIHtcbiAgICAgICAgICBjdXJzb3I6IG9wdGlvbnMuY3Vyc29yLFxuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIGxpbWl0OiBQQUdFX1NJWkVcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRocmVhZHM6IHJlc3VsdC5kYXRhLm1hcChjb252ZXJ0VG9UaHJlYWREYXRhKSxcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zLm1hcChcbiAgICAgICAgICBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGFcbiAgICAgICAgKSxcbiAgICAgICAgbmV4dEN1cnNvcjogcmVzdWx0Lm1ldGEubmV4dEN1cnNvcixcbiAgICAgICAgcmVxdWVzdGVkQXQ6IG5ldyBEYXRlKHJlc3VsdC5tZXRhLnJlcXVlc3RlZEF0KSxcbiAgICAgICAgcGVybWlzc2lvbkhpbnRzOiByZXN1bHQubWV0YS5wZXJtaXNzaW9uSGludHNcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgSHR0cEVycm9yICYmIGVyci5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRocmVhZHM6IFtdLFxuICAgICAgICAgIGluYm94Tm90aWZpY2F0aW9uczogW10sXG4gICAgICAgICAgbmV4dEN1cnNvcjogbnVsbCxcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIEhBQ0tcbiAgICAgICAgICAvLyByZXF1ZXN0ZWRBdCBuZWVkcyB0byBiZSBhICpzZXJ2ZXIqIHRpbWVzdGFtcCBoZXJlLiBIb3dldmVyLCBvblxuICAgICAgICAgIC8vIHRoaXMgNDA0IGVycm9yIHJlc3BvbnNlLCB0aGVyZSBpcyBubyBzdWNoIHRpbWVzdGFtcC4gU28gb3V0IG9mXG4gICAgICAgICAgLy8gcHVyZSBuZWNlc3NpdHkgd2UnbGwgZmFsbCBiYWNrIHRvIGEgbG9jYWwgdGltZXN0YW1wIGluc3RlYWQgKGFuZFxuICAgICAgICAgIC8vIGFsbG93IGZvciBhIHBvc3NpYmxlIDYgaG91ciBjbG9jayBkaWZmZXJlbmNlIGJldHdlZW4gY2xpZW50IGFuZFxuICAgICAgICAgIC8vIHNlcnZlcikuXG4gICAgICAgICAgLy9cbiAgICAgICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDYgKiA2MCAqIDYwICogMWUzKSxcbiAgICAgICAgICBwZXJtaXNzaW9uSGludHM6IHt9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRocmVhZChvcHRpb25zKSB7XG4gICAgY29uc3QgY29tbWVudElkID0gb3B0aW9ucy5jb21tZW50SWQgPz8gY3JlYXRlQ29tbWVudElkKCk7XG4gICAgY29uc3QgdGhyZWFkSWQgPSBvcHRpb25zLnRocmVhZElkID8/IGNyZWF0ZVRocmVhZElkKCk7XG4gICAgY29uc3QgdGhyZWFkID0gYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RocmVhZHNgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IHRocmVhZElkLFxuICAgICAgICBjb21tZW50OiB7XG4gICAgICAgICAgaWQ6IGNvbW1lbnRJZCxcbiAgICAgICAgICBib2R5OiBvcHRpb25zLmJvZHksXG4gICAgICAgICAgYXR0YWNobWVudElkczogb3B0aW9ucy5hdHRhY2htZW50SWRzXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhOiBvcHRpb25zLm1ldGFkYXRhXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY29udmVydFRvVGhyZWFkRGF0YSh0aHJlYWQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVRocmVhZChvcHRpb25zKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5kZWxldGUoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGhyZWFkcy8ke29wdGlvbnMudGhyZWFkSWR9YCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFRocmVhZChvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBodHRwQ2xpZW50LnJhd0dldChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90aHJlYWQtd2l0aC1ub3RpZmljYXRpb24vJHtvcHRpb25zLnRocmVhZElkfWAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pXG4gICAgKTtcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aHJlYWQ6IGNvbnZlcnRUb1RocmVhZERhdGEoanNvbi50aHJlYWQpLFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbjoganNvbi5pbmJveE5vdGlmaWNhdGlvbiA/IGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YShqc29uLmluYm94Tm90aWZpY2F0aW9uKSA6IHZvaWQgMFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aHJlYWQ6IHZvaWQgMCxcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb246IHZvaWQgMFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGdldHRpbmcgdGhyZWFkICR7b3B0aW9ucy50aHJlYWRJZH0uYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZWRpdFRocmVhZE1ldGFkYXRhKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RocmVhZHMvJHtvcHRpb25zLnRocmVhZElkfS9tZXRhZGF0YWAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pLFxuICAgICAgb3B0aW9ucy5tZXRhZGF0YVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ29tbWVudChvcHRpb25zKSB7XG4gICAgY29uc3QgY29tbWVudElkID0gb3B0aW9ucy5jb21tZW50SWQgPz8gY3JlYXRlQ29tbWVudElkKCk7XG4gICAgY29uc3QgY29tbWVudCA9IGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90aHJlYWRzLyR7b3B0aW9ucy50aHJlYWRJZH0vY29tbWVudHNgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IGNvbW1lbnRJZCxcbiAgICAgICAgYm9keTogb3B0aW9ucy5ib2R5LFxuICAgICAgICBhdHRhY2htZW50SWRzOiBvcHRpb25zLmF0dGFjaG1lbnRJZHNcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50RGF0YShjb21tZW50KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBlZGl0Q29tbWVudChvcHRpb25zKSB7XG4gICAgY29uc3QgY29tbWVudCA9IGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90aHJlYWRzLyR7b3B0aW9ucy50aHJlYWRJZH0vY29tbWVudHMvJHtvcHRpb25zLmNvbW1lbnRJZH1gLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgYm9keTogb3B0aW9ucy5ib2R5LFxuICAgICAgICBhdHRhY2htZW50SWRzOiBvcHRpb25zLmF0dGFjaG1lbnRJZHNcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50RGF0YShjb21tZW50KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBkZWxldGVDb21tZW50KG9wdGlvbnMpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50LmRlbGV0ZShcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90aHJlYWRzLyR7b3B0aW9ucy50aHJlYWRJZH0vY29tbWVudHMvJHtvcHRpb25zLmNvbW1lbnRJZH1gLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gYWRkUmVhY3Rpb24ob3B0aW9ucykge1xuICAgIGNvbnN0IHJlYWN0aW9uID0gYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RocmVhZHMvJHtvcHRpb25zLnRocmVhZElkfS9jb21tZW50cy8ke29wdGlvbnMuY29tbWVudElkfS9yZWFjdGlvbnNgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIHsgZW1vamk6IG9wdGlvbnMuZW1vamkgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb0NvbW1lbnRVc2VyUmVhY3Rpb24ocmVhY3Rpb24pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlbW92ZVJlYWN0aW9uKG9wdGlvbnMpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50LmRlbGV0ZShcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90aHJlYWRzLyR7b3B0aW9ucy50aHJlYWRJZH0vY29tbWVudHMvJHtvcHRpb25zLmNvbW1lbnRJZH0vcmVhY3Rpb25zLyR7b3B0aW9ucy5lbW9qaX1gLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya1RocmVhZEFzUmVzb2x2ZWQob3B0aW9ucykge1xuICAgIGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90aHJlYWRzLyR7b3B0aW9ucy50aHJlYWRJZH0vbWFyay1hcy1yZXNvbHZlZGAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrVGhyZWFkQXNVbnJlc29sdmVkKG9wdGlvbnMpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50LnBvc3QoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGhyZWFkcy8ke29wdGlvbnMudGhyZWFkSWR9L21hcmstYXMtdW5yZXNvbHZlZGAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB1cGxvYWRBdHRhY2htZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCByb29tSWQgPSBvcHRpb25zLnJvb21JZDtcbiAgICBjb25zdCBhYm9ydFNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsO1xuICAgIGNvbnN0IGF0dGFjaG1lbnQgPSBvcHRpb25zLmF0dGFjaG1lbnQ7XG4gICAgY29uc3QgYWJvcnRFcnJvciA9IGFib3J0U2lnbmFsID8gbmV3IERPTUV4Y2VwdGlvbihcbiAgICAgIGBVcGxvYWQgb2YgYXR0YWNobWVudCAke29wdGlvbnMuYXR0YWNobWVudC5pZH0gd2FzIGFib3J0ZWQuYCxcbiAgICAgIFwiQWJvcnRFcnJvclwiXG4gICAgKSA6IHZvaWQgMDtcbiAgICBpZiAoYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgIHRocm93IGFib3J0RXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZVJldHJ5RXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICBpZiAoYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgdGhyb3cgYWJvcnRFcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBIdHRwRXJyb3IgJiYgZXJyLnN0YXR1cyA9PT0gNDEzKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IEFUVEFDSE1FTlRfUEFSVF9TSVpFID0gNSAqIDEwMjQgKiAxMDI0O1xuICAgIGNvbnN0IFJFVFJZX0FUVEVNUFRTID0gMTA7XG4gICAgY29uc3QgUkVUUllfREVMQVlTID0gW1xuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzXG4gICAgXTtcbiAgICBmdW5jdGlvbiBzcGxpdEZpbGVJbnRvUGFydHMoZmlsZSkge1xuICAgICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICB3aGlsZSAoc3RhcnQgPCBmaWxlLnNpemUpIHtcbiAgICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4oc3RhcnQgKyBBVFRBQ0hNRU5UX1BBUlRfU0laRSwgZmlsZS5zaXplKTtcbiAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgcGFydE51bWJlcjogcGFydHMubGVuZ3RoICsgMSxcbiAgICAgICAgICBwYXJ0OiBmaWxlLnNsaWNlKHN0YXJ0LCBlbmQpXG4gICAgICAgIH0pO1xuICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9XG4gICAgaWYgKGF0dGFjaG1lbnQuc2l6ZSA8PSBBVFRBQ0hNRU5UX1BBUlRfU0laRSkge1xuICAgICAgcmV0dXJuIGF1dG9SZXRyeShcbiAgICAgICAgYXN5bmMgKCkgPT4gaHR0cENsaWVudC5wdXRCbG9iKFxuICAgICAgICAgIHVybGAvdjIvYy9yb29tcy8ke3Jvb21JZH0vYXR0YWNobWVudHMvJHthdHRhY2htZW50LmlkfS91cGxvYWQvJHtlbmNvZGVVUklDb21wb25lbnQoYXR0YWNobWVudC5uYW1lKX1gLFxuICAgICAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgICAgICByb29tSWRcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBhdHRhY2htZW50LmZpbGUsXG4gICAgICAgICAgeyBmaWxlU2l6ZTogYXR0YWNobWVudC5zaXplIH0sXG4gICAgICAgICAgeyBzaWduYWw6IGFib3J0U2lnbmFsIH1cbiAgICAgICAgKSxcbiAgICAgICAgUkVUUllfQVRURU1QVFMsXG4gICAgICAgIFJFVFJZX0RFTEFZUyxcbiAgICAgICAgaGFuZGxlUmV0cnlFcnJvclxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHVwbG9hZElkO1xuICAgICAgY29uc3QgdXBsb2FkZWRQYXJ0cyA9IFtdO1xuICAgICAgY29uc3QgY3JlYXRlTXVsdGlQYXJ0VXBsb2FkID0gYXdhaXQgYXV0b1JldHJ5KFxuICAgICAgICBhc3luYyAoKSA9PiBodHRwQ2xpZW50LnBvc3QoXG4gICAgICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7cm9vbUlkfS9hdHRhY2htZW50cy8ke2F0dGFjaG1lbnQuaWR9L211bHRpcGFydC8ke2VuY29kZVVSSUNvbXBvbmVudChhdHRhY2htZW50Lm5hbWUpfWAsXG4gICAgICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgICAgIHJvb21JZFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICB7IHNpZ25hbDogYWJvcnRTaWduYWwgfSxcbiAgICAgICAgICB7IGZpbGVTaXplOiBhdHRhY2htZW50LnNpemUgfVxuICAgICAgICApLFxuICAgICAgICBSRVRSWV9BVFRFTVBUUyxcbiAgICAgICAgUkVUUllfREVMQVlTLFxuICAgICAgICBoYW5kbGVSZXRyeUVycm9yXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdXBsb2FkSWQgPSBjcmVhdGVNdWx0aVBhcnRVcGxvYWQudXBsb2FkSWQ7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gc3BsaXRGaWxlSW50b1BhcnRzKGF0dGFjaG1lbnQuZmlsZSk7XG4gICAgICAgIGlmIChhYm9ydFNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICAgIHRocm93IGFib3J0RXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmF0Y2hlcyA9IGNodW5rKHBhcnRzLCA1KTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0czIgb2YgYmF0Y2hlcykge1xuICAgICAgICAgIGNvbnN0IHVwbG9hZGVkUGFydHNQcm9taXNlcyA9IFtdO1xuICAgICAgICAgIGZvciAoY29uc3QgeyBwYXJ0LCBwYXJ0TnVtYmVyIH0gb2YgcGFydHMyKSB7XG4gICAgICAgICAgICB1cGxvYWRlZFBhcnRzUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgYXV0b1JldHJ5KFxuICAgICAgICAgICAgICAgIGFzeW5jICgpID0+IGh0dHBDbGllbnQucHV0QmxvYihcbiAgICAgICAgICAgICAgICAgIHVybGAvdjIvYy9yb29tcy8ke3Jvb21JZH0vYXR0YWNobWVudHMvJHthdHRhY2htZW50LmlkfS9tdWx0aXBhcnQvJHtjcmVhdGVNdWx0aVBhcnRVcGxvYWQudXBsb2FkSWR9LyR7U3RyaW5nKHBhcnROdW1iZXIpfWAsXG4gICAgICAgICAgICAgICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgICAgICAgICAgICAgIHJvb21JZFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgeyBzaWduYWw6IGFib3J0U2lnbmFsIH1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIFJFVFJZX0FUVEVNUFRTLFxuICAgICAgICAgICAgICAgIFJFVFJZX0RFTEFZUyxcbiAgICAgICAgICAgICAgICBoYW5kbGVSZXRyeUVycm9yXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwbG9hZGVkUGFydHMucHVzaCguLi5hd2FpdCBQcm9taXNlLmFsbCh1cGxvYWRlZFBhcnRzUHJvbWlzZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICB0aHJvdyBhYm9ydEVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvcnRlZFVwbG9hZGVkUGFydHMgPSB1cGxvYWRlZFBhcnRzLnNvcnQoXG4gICAgICAgICAgKGEsIGIpID0+IGEucGFydE51bWJlciAtIGIucGFydE51bWJlclxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gaHR0cENsaWVudC5wb3N0KFxuICAgICAgICAgIHVybGAvdjIvYy9yb29tcy8ke3Jvb21JZH0vYXR0YWNobWVudHMvJHthdHRhY2htZW50LmlkfS9tdWx0aXBhcnQvJHt1cGxvYWRJZH0vY29tcGxldGVgLFxuICAgICAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgICAgICByb29tSWRcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7IHBhcnRzOiBzb3J0ZWRVcGxvYWRlZFBhcnRzIH0sXG4gICAgICAgICAgeyBzaWduYWw6IGFib3J0U2lnbmFsIH1cbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yMykge1xuICAgICAgICBpZiAodXBsb2FkSWQgJiYgZXJyb3IzPy5uYW1lICYmIChlcnJvcjMubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIgfHwgZXJyb3IzLm5hbWUgPT09IFwiVGltZW91dEVycm9yXCIpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGh0dHBDbGllbnQucmF3RGVsZXRlKFxuICAgICAgICAgICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtyb29tSWR9L2F0dGFjaG1lbnRzLyR7YXR0YWNobWVudC5pZH0vbXVsdGlwYXJ0LyR7dXBsb2FkSWR9YCxcbiAgICAgICAgICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgICAgICAgICAgcm9vbUlkXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yNCkge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGF0dGFjaG1lbnRVcmxzQmF0Y2hTdG9yZXNCeVJvb20gPSBuZXcgRGVmYXVsdE1hcCgocm9vbUlkKSA9PiB7XG4gICAgY29uc3QgYmF0Y2gyID0gbmV3IEJhdGNoKFxuICAgICAgYXN5bmMgKGJhdGNoZWRBdHRhY2htZW50SWRzKSA9PiB7XG4gICAgICAgIGNvbnN0IGF0dGFjaG1lbnRJZHMgPSBiYXRjaGVkQXR0YWNobWVudElkcy5mbGF0KCk7XG4gICAgICAgIGNvbnN0IHsgdXJscyB9ID0gYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgICAgIHVybGAvdjIvYy9yb29tcy8ke3Jvb21JZH0vYXR0YWNobWVudHMvcHJlc2lnbmVkLXVybHNgLFxuICAgICAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgICAgICByb29tSWRcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7IGF0dGFjaG1lbnRJZHMgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdXJscy5tYXAoXG4gICAgICAgICAgKHVybDIpID0+IHVybDIgPz8gbmV3IEVycm9yKFwiVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGdldHRpbmcgdGhpcyBhdHRhY2htZW50J3MgVVJMXCIpXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgeyBkZWxheTogNTAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUJhdGNoU3RvcmUoYmF0Y2gyKTtcbiAgfSk7XG4gIGZ1bmN0aW9uIGdldE9yQ3JlYXRlQXR0YWNobWVudFVybHNTdG9yZShyb29tSWQpIHtcbiAgICByZXR1cm4gYXR0YWNobWVudFVybHNCYXRjaFN0b3Jlc0J5Um9vbS5nZXRPckNyZWF0ZShyb29tSWQpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEF0dGFjaG1lbnRVcmwob3B0aW9ucykge1xuICAgIGNvbnN0IGJhdGNoMiA9IGdldE9yQ3JlYXRlQXR0YWNobWVudFVybHNTdG9yZShvcHRpb25zLnJvb21JZCkuYmF0Y2g7XG4gICAgcmV0dXJuIGJhdGNoMi5nZXQob3B0aW9ucy5hdHRhY2htZW50SWQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldE5vdGlmaWNhdGlvblNldHRpbmdzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5nZXQoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vbm90aWZpY2F0aW9uLXNldHRpbmdzYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICB2b2lkIDAsXG4gICAgICB7XG4gICAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWxcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5wb3N0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L25vdGlmaWNhdGlvbi1zZXR0aW5nc2AsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pLFxuICAgICAgb3B0aW9ucy5zZXR0aW5nc1xuICAgICk7XG4gIH1cbiAgY29uc3QgbWFya0FzUmVhZEJhdGNoZXNCeVJvb20gPSBuZXcgRGVmYXVsdE1hcChcbiAgICAocm9vbUlkKSA9PiBuZXcgQmF0Y2goXG4gICAgICBhc3luYyAoYmF0Y2hlZEluYm94Tm90aWZpY2F0aW9uSWRzKSA9PiB7XG4gICAgICAgIGNvbnN0IGluYm94Tm90aWZpY2F0aW9uSWRzID0gYmF0Y2hlZEluYm94Tm90aWZpY2F0aW9uSWRzLmZsYXQoKTtcbiAgICAgICAgYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgICAgIHVybGAvdjIvYy9yb29tcy8ke3Jvb21JZH0vaW5ib3gtbm90aWZpY2F0aW9ucy9yZWFkYCxcbiAgICAgICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICAgICAgcm9vbUlkXG4gICAgICAgICAgfSksXG4gICAgICAgICAgeyBpbmJveE5vdGlmaWNhdGlvbklkcyB9XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBpbmJveE5vdGlmaWNhdGlvbklkcztcbiAgICAgIH0sXG4gICAgICB7IGRlbGF5OiA1MCB9XG4gICAgKVxuICApO1xuICBhc3luYyBmdW5jdGlvbiBtYXJrUm9vbUluYm94Tm90aWZpY2F0aW9uQXNSZWFkKG9wdGlvbnMpIHtcbiAgICBjb25zdCBiYXRjaDIgPSBtYXJrQXNSZWFkQmF0Y2hlc0J5Um9vbS5nZXRPckNyZWF0ZShvcHRpb25zLnJvb21JZCk7XG4gICAgcmV0dXJuIGJhdGNoMi5nZXQob3B0aW9ucy5pbmJveE5vdGlmaWNhdGlvbklkKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVUZXh0TWVudGlvbihvcHRpb25zKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5yYXdQb3N0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RleHQtbWVudGlvbnNgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgdXNlcklkOiBvcHRpb25zLnVzZXJJZCxcbiAgICAgICAgbWVudGlvbklkOiBvcHRpb25zLm1lbnRpb25JZFxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlVGV4dE1lbnRpb24ob3B0aW9ucykge1xuICAgIGF3YWl0IGh0dHBDbGllbnQucmF3RGVsZXRlKFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RleHQtbWVudGlvbnMvJHtvcHRpb25zLm1lbnRpb25JZH1gLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGV4dFZlcnNpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBodHRwQ2xpZW50LnJhd0dldChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS95LXZlcnNpb24vJHtvcHRpb25zLnZlcnNpb25JZH1gLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVGV4dFZlcnNpb24ob3B0aW9ucykge1xuICAgIGF3YWl0IGh0dHBDbGllbnQucmF3UG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS92ZXJzaW9uYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlcG9ydFRleHRFZGl0b3Iob3B0aW9ucykge1xuICAgIGF3YWl0IGh0dHBDbGllbnQucmF3UG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90ZXh0LW1ldGFkYXRhYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIHR5cGU6IG9wdGlvbnMudHlwZSxcbiAgICAgICAgcm9vdEtleTogb3B0aW9ucy5yb290S2V5XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBleGVjdXRlQ29udGV4dHVhbFByb21wdChvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L2FpL2NvbnRleHR1YWwtcHJvbXB0YCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcInJvb206cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgcHJvbXB0OiBvcHRpb25zLnByb21wdCxcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIGJlZm9yZVNlbGVjdGlvbjogb3B0aW9ucy5jb250ZXh0LmJlZm9yZVNlbGVjdGlvbixcbiAgICAgICAgICBzZWxlY3Rpb246IG9wdGlvbnMuY29udGV4dC5zZWxlY3Rpb24sXG4gICAgICAgICAgYWZ0ZXJTZWxlY3Rpb246IG9wdGlvbnMuY29udGV4dC5hZnRlclNlbGVjdGlvblxuICAgICAgICB9LFxuICAgICAgICBwcmV2aW91czogb3B0aW9ucy5wcmV2aW91c1xuICAgICAgfSxcbiAgICAgIHsgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCB9XG4gICAgKTtcbiAgICBpZiAoIXJlc3VsdCB8fCByZXN1bHQuY29udGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNvbnRlbnQgcmV0dXJuZWQgZnJvbSBzZXJ2ZXJcIik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuY29udGVudFswXS50ZXh0O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxpc3RUZXh0VmVyc2lvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3ZlcnNpb25zYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uczogcmVzdWx0LnZlcnNpb25zLm1hcCgoeyBjcmVhdGVkQXQsIC4uLnZlcnNpb24gfSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoY3JlYXRlZEF0KSxcbiAgICAgICAgICAuLi52ZXJzaW9uXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShyZXN1bHQubWV0YS5yZXF1ZXN0ZWRBdClcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxpc3RUZXh0VmVyc2lvbnNTaW5jZShvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaHR0cENsaWVudC5nZXQoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdmVyc2lvbnMvZGVsdGFgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIHsgc2luY2U6IG9wdGlvbnMuc2luY2UudG9JU09TdHJpbmcoKSB9LFxuICAgICAgeyBzaWduYWw6IG9wdGlvbnMuc2lnbmFsIH1cbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uczogcmVzdWx0LnZlcnNpb25zLm1hcCgoeyBjcmVhdGVkQXQsIC4uLnZlcnNpb24gfSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoY3JlYXRlZEF0KSxcbiAgICAgICAgICAuLi52ZXJzaW9uXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShyZXN1bHQubWV0YS5yZXF1ZXN0ZWRBdClcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0cmVhbVN0b3JhZ2Uob3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGh0dHBDbGllbnQucmF3R2V0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3N0b3JhZ2VgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwicm9vbTpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pXG4gICAgKTtcbiAgICByZXR1cm4gYXdhaXQgcmVzdWx0Lmpzb24oKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzZW5kTWVzc2FnZXMob3B0aW9ucykge1xuICAgIHJldHVybiBodHRwQ2xpZW50LnJhd1Bvc3QoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vc2VuZC1tZXNzYWdlYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcInJvb206cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgbm9uY2U6IG9wdGlvbnMubm9uY2UsXG4gICAgICAgIG1lc3NhZ2VzOiBvcHRpb25zLm1lc3NhZ2VzXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRJbmJveE5vdGlmaWNhdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IFBBR0VfU0laRSA9IDUwO1xuICAgIGNvbnN0IGpzb24gPSBhd2FpdCBodHRwQ2xpZW50LmdldChcbiAgICAgIHVybGAvdjIvYy9pbmJveC1ub3RpZmljYXRpb25zYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7IHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIiB9KSxcbiAgICAgIHtcbiAgICAgICAgY3Vyc29yOiBvcHRpb25zPy5jdXJzb3IsXG4gICAgICAgIGxpbWl0OiBQQUdFX1NJWkVcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IGpzb24uaW5ib3hOb3RpZmljYXRpb25zLm1hcChcbiAgICAgICAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhXG4gICAgICApLFxuICAgICAgdGhyZWFkczoganNvbi50aHJlYWRzLm1hcChjb252ZXJ0VG9UaHJlYWREYXRhKSxcbiAgICAgIG5leHRDdXJzb3I6IGpzb24ubWV0YS5uZXh0Q3Vyc29yLFxuICAgICAgcmVxdWVzdGVkQXQ6IG5ldyBEYXRlKGpzb24ubWV0YS5yZXF1ZXN0ZWRBdClcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldEluYm94Tm90aWZpY2F0aW9uc1NpbmNlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgaHR0cENsaWVudC5nZXQoXG4gICAgICB1cmxgL3YyL2MvaW5ib3gtbm90aWZpY2F0aW9ucy9kZWx0YWAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSksXG4gICAgICB7IHNpbmNlOiBvcHRpb25zLnNpbmNlLnRvSVNPU3RyaW5nKCkgfSxcbiAgICAgIHsgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCB9XG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiB7XG4gICAgICAgIHVwZGF0ZWQ6IGpzb24uaW5ib3hOb3RpZmljYXRpb25zLm1hcChjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEpLFxuICAgICAgICBkZWxldGVkOiBqc29uLmRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICAgIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGVsZXRlSW5mb1xuICAgICAgICApXG4gICAgICB9LFxuICAgICAgdGhyZWFkczoge1xuICAgICAgICB1cGRhdGVkOiBqc29uLnRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERhdGEpLFxuICAgICAgICBkZWxldGVkOiBqc29uLmRlbGV0ZWRUaHJlYWRzLm1hcChjb252ZXJ0VG9UaHJlYWREZWxldGVJbmZvKVxuICAgICAgfSxcbiAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShqc29uLm1ldGEucmVxdWVzdGVkQXQpXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCgpIHtcbiAgICBjb25zdCB7IGNvdW50IH0gPSBhd2FpdCBodHRwQ2xpZW50LmdldChcbiAgICAgIHVybGAvdjIvYy9pbmJveC1ub3RpZmljYXRpb25zL2NvdW50YCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7IHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIiB9KVxuICAgICk7XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQoKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgdXJsYC92Mi9jL2luYm94LW5vdGlmaWNhdGlvbnMvcmVhZGAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSksXG4gICAgICB7XG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uSWRzOiBcImFsbFwiXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWRzKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgdXJsYC92Mi9jL2luYm94LW5vdGlmaWNhdGlvbnMvcmVhZGAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSksXG4gICAgICB7XG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uSWRzXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBjb25zdCBiYXRjaGVkTWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZCA9IG5ldyBCYXRjaChcbiAgICBhc3luYyAoYmF0Y2hlZEluYm94Tm90aWZpY2F0aW9uSWRzKSA9PiB7XG4gICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbklkcyA9IGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcy5mbGF0KCk7XG4gICAgICBhd2FpdCBtYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWRzKTtcbiAgICAgIHJldHVybiBpbmJveE5vdGlmaWNhdGlvbklkcztcbiAgICB9LFxuICAgIHsgZGVsYXk6IDUwIH1cbiAgKTtcbiAgYXN5bmMgZnVuY3Rpb24gbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWQpIHtcbiAgICBhd2FpdCBiYXRjaGVkTWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZC5nZXQoaW5ib3hOb3RpZmljYXRpb25JZCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zKCkge1xuICAgIGF3YWl0IGh0dHBDbGllbnQuZGVsZXRlKFxuICAgICAgdXJsYC92Mi9jL2luYm94LW5vdGlmaWNhdGlvbnNgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHsgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiIH0pXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBkZWxldGVJbmJveE5vdGlmaWNhdGlvbihpbmJveE5vdGlmaWNhdGlvbklkKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5kZWxldGUoXG4gICAgICB1cmxgL3YyL2MvaW5ib3gtbm90aWZpY2F0aW9ucy8ke2luYm94Tm90aWZpY2F0aW9uSWR9YCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7IHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIiB9KVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VXNlck5vdGlmaWNhdGlvblNldHRpbmdzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5nZXQoXG4gICAgICB1cmxgL3YyL2Mvbm90aWZpY2F0aW9uLXNldHRpbmdzYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7IHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIiB9KSxcbiAgICAgIHZvaWQgMCxcbiAgICAgIHsgc2lnbmFsOiBvcHRpb25zPy5zaWduYWwgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gdXBkYXRlVXNlck5vdGlmaWNhdGlvblNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9ub3RpZmljYXRpb24tc2V0dGluZ3NgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHsgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiIH0pLFxuICAgICAgc2V0dGluZ3NcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbChvcHRpb25zKSB7XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGlmIChvcHRpb25zPy5xdWVyeSkge1xuICAgICAgcXVlcnkgPSBvYmplY3RUb1F1ZXJ5KG9wdGlvbnMucXVlcnkpO1xuICAgIH1cbiAgICBjb25zdCBQQUdFX1NJWkUgPSA1MDtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgaHR0cENsaWVudC5nZXQoXG4gICAgICB1cmxgL3YyL2MvdGhyZWFkc2AsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSksXG4gICAgICB7XG4gICAgICAgIGN1cnNvcjogb3B0aW9ucz8uY3Vyc29yLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgbGltaXQ6IFBBR0VfU0laRVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRocmVhZHM6IGpzb24udGhyZWFkcy5tYXAoY29udmVydFRvVGhyZWFkRGF0YSksXG4gICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IGpzb24uaW5ib3hOb3RpZmljYXRpb25zLm1hcChcbiAgICAgICAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhXG4gICAgICApLFxuICAgICAgbmV4dEN1cnNvcjoganNvbi5tZXRhLm5leHRDdXJzb3IsXG4gICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUoanNvbi5tZXRhLnJlcXVlc3RlZEF0KSxcbiAgICAgIHBlcm1pc3Npb25IaW50czoganNvbi5tZXRhLnBlcm1pc3Npb25IaW50c1xuICAgIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VXNlclRocmVhZHNTaW5jZV9leHBlcmltZW50YWwob3B0aW9ucykge1xuICAgIGNvbnN0IGpzb24gPSBhd2FpdCBodHRwQ2xpZW50LmdldChcbiAgICAgIHVybGAvdjIvYy90aHJlYWRzL2RlbHRhYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7IHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIiB9KSxcbiAgICAgIHsgc2luY2U6IG9wdGlvbnMuc2luY2UudG9JU09TdHJpbmcoKSB9LFxuICAgICAgeyBzaWduYWw6IG9wdGlvbnMuc2lnbmFsIH1cbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICB0aHJlYWRzOiB7XG4gICAgICAgIHVwZGF0ZWQ6IGpzb24udGhyZWFkcy5tYXAoY29udmVydFRvVGhyZWFkRGF0YSksXG4gICAgICAgIGRlbGV0ZWQ6IGpzb24uZGVsZXRlZFRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERlbGV0ZUluZm8pXG4gICAgICB9LFxuICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiB7XG4gICAgICAgIHVwZGF0ZWQ6IGpzb24uaW5ib3hOb3RpZmljYXRpb25zLm1hcChjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEpLFxuICAgICAgICBkZWxldGVkOiBqc29uLmRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICAgIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGVsZXRlSW5mb1xuICAgICAgICApXG4gICAgICB9LFxuICAgICAgcmVxdWVzdGVkQXQ6IG5ldyBEYXRlKGpzb24ubWV0YS5yZXF1ZXN0ZWRBdCksXG4gICAgICBwZXJtaXNzaW9uSGludHM6IGpzb24ubWV0YS5wZXJtaXNzaW9uSGludHNcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgLy8gUm9vbSB0aHJlYWRzXG4gICAgZ2V0VGhyZWFkcyxcbiAgICBnZXRUaHJlYWRzU2luY2UsXG4gICAgY3JlYXRlVGhyZWFkLFxuICAgIGdldFRocmVhZCxcbiAgICBkZWxldGVUaHJlYWQsXG4gICAgZWRpdFRocmVhZE1ldGFkYXRhLFxuICAgIGNyZWF0ZUNvbW1lbnQsXG4gICAgZWRpdENvbW1lbnQsXG4gICAgZGVsZXRlQ29tbWVudCxcbiAgICBhZGRSZWFjdGlvbixcbiAgICByZW1vdmVSZWFjdGlvbixcbiAgICBtYXJrVGhyZWFkQXNSZXNvbHZlZCxcbiAgICBtYXJrVGhyZWFkQXNVbnJlc29sdmVkLFxuICAgIG1hcmtSb29tSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQsXG4gICAgLy8gUm9vbSBub3RpZmljYXRpb25zXG4gICAgZ2V0Tm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgdXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgLy8gUm9vbSB0ZXh0IGVkaXRvclxuICAgIGNyZWF0ZVRleHRNZW50aW9uLFxuICAgIGRlbGV0ZVRleHRNZW50aW9uLFxuICAgIGdldFRleHRWZXJzaW9uLFxuICAgIGNyZWF0ZVRleHRWZXJzaW9uLFxuICAgIHJlcG9ydFRleHRFZGl0b3IsXG4gICAgbGlzdFRleHRWZXJzaW9ucyxcbiAgICBsaXN0VGV4dFZlcnNpb25zU2luY2UsXG4gICAgLy8gUm9vbSBhdHRhY2htZW50c1xuICAgIGdldEF0dGFjaG1lbnRVcmwsXG4gICAgdXBsb2FkQXR0YWNobWVudCxcbiAgICBnZXRPckNyZWF0ZUF0dGFjaG1lbnRVcmxzU3RvcmUsXG4gICAgLy8gUm9vbSBzdG9yYWdlXG4gICAgc3RyZWFtU3RvcmFnZSxcbiAgICBzZW5kTWVzc2FnZXMsXG4gICAgLy8gTm90aWZpY2F0aW9uXG4gICAgZ2V0SW5ib3hOb3RpZmljYXRpb25zLFxuICAgIGdldEluYm94Tm90aWZpY2F0aW9uc1NpbmNlLFxuICAgIGdldFVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50LFxuICAgIG1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQsXG4gICAgbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkLFxuICAgIGRlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9ucyxcbiAgICBkZWxldGVJbmJveE5vdGlmaWNhdGlvbixcbiAgICBnZXRVc2VyTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgdXBkYXRlVXNlck5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgIC8vIFVzZXIgdGhyZWFkc1xuICAgIGdldFVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbCxcbiAgICBnZXRVc2VyVGhyZWFkc1NpbmNlX2V4cGVyaW1lbnRhbCxcbiAgICAvLyBBSVxuICAgIGV4ZWN1dGVDb250ZXh0dWFsUHJvbXB0XG4gIH07XG59XG5mdW5jdGlvbiBnZXRCZWFyZXJUb2tlbkZyb21BdXRoVmFsdWUoYXV0aFZhbHVlKSB7XG4gIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJwdWJsaWNcIikge1xuICAgIHJldHVybiBhdXRoVmFsdWUucHVibGljQXBpS2V5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhdXRoVmFsdWUudG9rZW4ucmF3O1xuICB9XG59XG52YXIgSHR0cENsaWVudCA9IGNsYXNzIHtcbiAgI2Jhc2VVcmw7XG4gICNmZXRjaFBvbHlmaWxsO1xuICBjb25zdHJ1Y3RvcihiYXNlVXJsLCBmZXRjaFBvbHlmaWxsKSB7XG4gICAgdGhpcy4jYmFzZVVybCA9IGJhc2VVcmw7XG4gICAgdGhpcy4jZmV0Y2hQb2x5ZmlsbCA9IGZldGNoUG9seWZpbGw7XG4gIH1cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFB1YmxpYyBtZXRob2RzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogQ29uc3RydWN0cyBhbmQgbWFrZXMgdGhlIEhUVFAgcmVxdWVzdCwgYnV0IGRvZXMgbm90IGhhbmRsZSB0aGUgcmVzcG9uc2UuXG4gICAqXG4gICAqIFRoaXMgaXMgd2hhdCAucmF3RmV0Y2goKSBkb2VzOiAgICDwn5GIIFRoaXMgbWV0aG9kIVxuICAgKiAgIDEuIFNldCBDb250ZW50LVR5cGUgaGVhZGVyXG4gICAqICAgMi4gU2V0IEF1dGhvcml6YXRpb24gaGVhZGVyXG4gICAqICAgMy4gQ2FsbCB0aGUgY2FsbGJhY2sgdG8gb2J0YWluIHRoZSBgYXV0aFZhbHVlYCB0byB1c2UgaW4gdGhlIEF1dGhvcml6YXRpb24gaGVhZGVyXG4gICAqXG4gICAqIFRoaXMgaXMgd2hhdCAuZmV0Y2goKSBkb2VzIE9OIFRPUCBvZiB0aGF0OlxuICAgKiAgIDQuIFBhcnNlIHJlc3BvbnNlIGJvZHkgYXMgSnNvblxuICAgKiAgIDUuIC4uLmJ1dCBzaWxlbnRseSByZXR1cm4gYHt9YCBpZiB0aGF0IHBhcnNpbmcgZmFpbHNcbiAgICogICA2LiBUaHJvdyBIdHRwRXJyb3IgaWYgcmVzcG9uc2UgaXMgYW4gZXJyb3JcbiAgICovXG4gIGFzeW5jICNyYXdGZXRjaChlbmRwb2ludCwgYXV0aFZhbHVlLCBvcHRpb25zLCBwYXJhbXMpIHtcbiAgICBpZiAoIWVuZHBvaW50LnN0YXJ0c1dpdGgoXCIvdjIvYy9cIikpIHtcbiAgICAgIHJhaXNlKFwiVGhpcyBjbGllbnQgY2FuIG9ubHkgYmUgdXNlZCB0byBtYWtlIC92Mi9jLyogcmVxdWVzdHNcIik7XG4gICAgfVxuICAgIGNvbnN0IHVybDIgPSB1cmxqb2luKHRoaXMuI2Jhc2VVcmwsIGVuZHBvaW50LCBwYXJhbXMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLiNmZXRjaFBvbHlmaWxsKHVybDIsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC8vIFRoZXNlIGhlYWRlcnMgYXJlIGRlZmF1bHQsIGJ1dCBjYW4gYmUgb3ZlcnJpZGVuIGJ5IGN1c3RvbSBoZWFkZXJzXG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgICAvLyBQb3NzaWJsZSBoZWFkZXIgb3ZlcnJpZGVzXG4gICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgIC8vIENhbm5vdCBiZSBvdmVycmlkZW4gYnkgY3VzdG9tIGhlYWRlcnNcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2dldEJlYXJlclRva2VuRnJvbUF1dGhWYWx1ZShhdXRoVmFsdWUpfWAsXG4gICAgICAgIFwiWC1MQi1DbGllbnRcIjogUEtHX1ZFUlNJT04gfHwgXCJkZXZcIlxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzLCBtYWtlcyB0aGUgSFRUUCByZXF1ZXN0LCBhbmQgaGFuZGxlcyB0aGUgcmVzcG9uc2UgYnkgcGFyc2luZ1xuICAgKiBKU09OIGFuZC9vciB0aHJvd2luZyBhbiBIdHRwRXJyb3IgaWYgaXQgZmFpbGVkLlxuICAgKlxuICAgKiBUaGlzIGlzIHdoYXQgLnJhd0ZldGNoKCkgZG9lczpcbiAgICogICAxLiBTZXQgQ29udGVudC1UeXBlIGhlYWRlclxuICAgKiAgIDIuIFNldCBBdXRob3JpemF0aW9uIGhlYWRlclxuICAgKiAgIDMuIENhbGwgdGhlIGNhbGxiYWNrIHRvIG9idGFpbiB0aGUgYGF1dGhWYWx1ZWAgdG8gdXNlIGluIHRoZSBBdXRob3JpemF0aW9uIGhlYWRlclxuICAgKlxuICAgKiBUaGlzIGlzIHdoYXQgLmZldGNoKCkgZG9lcyBPTiBUT1Agb2YgdGhhdDogICDwn5GIIFRoaXMgbWV0aG9kIVxuICAgKiAgIDQuIFBhcnNlIHJlc3BvbnNlIGJvZHkgYXMgSnNvblxuICAgKiAgIDUuIC4uLmJ1dCBzaWxlbnRseSByZXR1cm4gYHt9YCBpZiB0aGF0IHBhcnNpbmcgZmFpbHMgKPCfpJQpXG4gICAqICAgNi4gVGhyb3cgSHR0cEVycm9yIGlmIHJlc3BvbnNlIGlzIGFuIGVycm9yXG4gICAqL1xuICBhc3luYyAjZmV0Y2goZW5kcG9pbnQsIGF1dGhWYWx1ZSwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLiNyYXdGZXRjaChlbmRwb2ludCwgYXV0aFZhbHVlLCBvcHRpb25zLCBwYXJhbXMpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IGF3YWl0IEh0dHBFcnJvci5mcm9tUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH1cbiAgICBsZXQgYm9keTtcbiAgICB0cnkge1xuICAgICAgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGJvZHkgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2VzIGEgR0VUIHJlcXVlc3QgYW5kIHJldHVybnMgdGhlIHJhdyByZXNwb25zZS5cbiAgICogV29uJ3QgdGhyb3cgaWYgdGhlIHJlcG9uc2UgaXMgYSBub24tMnh4LlxuICAgKiBAZGVwcmVjYXRlZCBJZGVhbGx5LCB1c2UgLmdldCgpIGluc3RlYWQuXG4gICAqL1xuICBhc3luYyByYXdHZXQoZW5kcG9pbnQsIGF1dGhWYWx1ZSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuI3Jhd0ZldGNoKGVuZHBvaW50LCBhdXRoVmFsdWUsIG9wdGlvbnMsIHBhcmFtcyk7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2VzIGEgUE9TVCByZXF1ZXN0IGFuZCByZXR1cm5zIHRoZSByYXcgcmVzcG9uc2UuXG4gICAqIFdvbid0IHRocm93IGlmIHRoZSByZXBvbnNlIGlzIGEgbm9uLTJ4eC5cbiAgICogQGRlcHJlY2F0ZWQgSWRlYWxseSwgdXNlIC5wb3N0KCkgaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIHJhd1Bvc3QoZW5kcG9pbnQsIGF1dGhWYWx1ZSwgYm9keSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLiNyYXdGZXRjaChlbmRwb2ludCwgYXV0aFZhbHVlLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogc3RyaW5naWZ5T3JMb2coYm9keSlcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgYSBERUxFVEUgcmVxdWVzdCBhbmQgcmV0dXJucyB0aGUgcmF3IHJlc3BvbnNlLlxuICAgKiBXb24ndCB0aHJvdyBpZiB0aGUgcmVwb25zZSBpcyBhIG5vbi0yeHguXG4gICAqIEBkZXByZWNhdGVkIElkZWFsbHksIHVzZSAuZGVsZXRlKCkgaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIHJhd0RlbGV0ZShlbmRwb2ludCwgYXV0aFZhbHVlKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuI3Jhd0ZldGNoKGVuZHBvaW50LCBhdXRoVmFsdWUsIHsgbWV0aG9kOiBcIkRFTEVURVwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyBhIEdFVCByZXF1ZXN0LCBhbmQgcmV0dXJuIHRoZSBKU09OIHJlc3BvbnNlLlxuICAgKiBXaWxsIHRocm93IGlmIHRoZSByZXBvbnNlIGlzIGEgbm9uLTJ4eC5cbiAgICovXG4gIGFzeW5jIGdldChlbmRwb2ludCwgYXV0aFZhbHVlLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy4jZmV0Y2goZW5kcG9pbnQsIGF1dGhWYWx1ZSwgb3B0aW9ucywgcGFyYW1zKTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgYSBQT1NUIHJlcXVlc3QsIGFuZCByZXR1cm4gdGhlIEpTT04gcmVzcG9uc2UuXG4gICAqIFdpbGwgdGhyb3cgaWYgdGhlIHJlcG9uc2UgaXMgYSBub24tMnh4LlxuICAgKi9cbiAgYXN5bmMgcG9zdChlbmRwb2ludCwgYXV0aFZhbHVlLCBib2R5LCBvcHRpb25zLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy4jZmV0Y2goXG4gICAgICBlbmRwb2ludCxcbiAgICAgIGF1dGhWYWx1ZSxcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogc3RyaW5naWZ5T3JMb2coYm9keSlcbiAgICAgIH0sXG4gICAgICBwYXJhbXNcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyBhIERFTEVURSByZXF1ZXN0LCBhbmQgcmV0dXJuIHRoZSBKU09OIHJlc3BvbnNlLlxuICAgKiBXaWxsIHRocm93IGlmIHRoZSByZXBvbnNlIGlzIGEgbm9uLTJ4eC5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZShlbmRwb2ludCwgYXV0aFZhbHVlKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuI2ZldGNoKGVuZHBvaW50LCBhdXRoVmFsdWUsIHsgbWV0aG9kOiBcIkRFTEVURVwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyBhIFBVVCByZXF1ZXN0IGZvciBhIEJsb2IgYm9keSwgYW5kIHJldHVybiB0aGUgSlNPTiByZXNwb25zZS5cbiAgICogV2lsbCB0aHJvdyBpZiB0aGUgcmVwb25zZSBpcyBhIG5vbi0yeHguXG4gICAqL1xuICBhc3luYyBwdXRCbG9iKGVuZHBvaW50LCBhdXRoVmFsdWUsIGJsb2IsIHBhcmFtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLiNmZXRjaChcbiAgICAgIGVuZHBvaW50LFxuICAgICAgYXV0aFZhbHVlLFxuICAgICAge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IGJsb2JcbiAgICAgIH0sXG4gICAgICBwYXJhbXNcbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL2Fzc2VydC50c1xuZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3ZhbHVlLCBlcnJtc2cpIHtcbiAgdGhyb3cgbmV3IEVycm9yKGVycm1zZyk7XG59XG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBlcnJtc2cpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoZXJybXNnKTtcbiAgICAgIGVyci5uYW1lID0gXCJBc3NlcnRpb24gZmFpbHVyZVwiO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbm4odmFsdWUsIGVycm1zZyA9IFwiRXhwZWN0ZWQgdmFsdWUgdG8gYmUgbm9uLW51bGxhYmxlXCIpIHtcbiAgYXNzZXJ0KHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAsIGVycm1zZyk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gc3JjL2xpYi9mc20udHNcbmZ1bmN0aW9uIGRpc3RhbmNlKHN0YXRlMSwgc3RhdGUyKSB7XG4gIGlmIChzdGF0ZTEgPT09IHN0YXRlMikge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgY29uc3QgY2h1bmtzMSA9IHN0YXRlMS5zcGxpdChcIi5cIik7XG4gIGNvbnN0IGNodW5rczIgPSBzdGF0ZTIuc3BsaXQoXCIuXCIpO1xuICBjb25zdCBtaW5MZW4gPSBNYXRoLm1pbihjaHVua3MxLmxlbmd0aCwgY2h1bmtzMi5sZW5ndGgpO1xuICBsZXQgc2hhcmVkID0gMDtcbiAgZm9yICg7IHNoYXJlZCA8IG1pbkxlbjsgc2hhcmVkKyspIHtcbiAgICBpZiAoY2h1bmtzMVtzaGFyZWRdICE9PSBjaHVua3MyW3NoYXJlZF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb25zdCB1cCA9IGNodW5rczEubGVuZ3RoIC0gc2hhcmVkO1xuICBjb25zdCBkb3duID0gY2h1bmtzMi5sZW5ndGggLSBzaGFyZWQ7XG4gIHJldHVybiBbdXAsIGRvd25dO1xufVxuZnVuY3Rpb24gcGF0dGVybnModGFyZ2V0U3RhdGUsIGxldmVscykge1xuICBjb25zdCBwYXJ0cyA9IHRhcmdldFN0YXRlLnNwbGl0KFwiLlwiKTtcbiAgaWYgKGxldmVscyA8IDEgfHwgbGV2ZWxzID4gcGFydHMubGVuZ3RoICsgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIGxldmVsc1wiKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaWYgKGxldmVscyA+IHBhcnRzLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wdXNoKFwiKlwiKTtcbiAgfVxuICBmb3IgKGxldCBpID0gcGFydHMubGVuZ3RoIC0gbGV2ZWxzICsgMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2xpY2UgPSBwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICBpZiAoc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnB1c2goc2xpY2Uuam9pbihcIi5cIikgKyBcIi4qXCIpO1xuICAgIH1cbiAgfVxuICByZXN1bHQucHVzaCh0YXJnZXRTdGF0ZSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgU2FmZUNvbnRleHQgPSBjbGFzcyB7XG4gICNjdXJyO1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsQ29udGV4dCkge1xuICAgIHRoaXMuI2N1cnIgPSBpbml0aWFsQ29udGV4dDtcbiAgfVxuICBnZXQgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycjtcbiAgfVxuICAvKipcbiAgICogQ2FsbCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHBhdGNoaW5nIG9mIHRoZSBjb250ZXh0LCBieVxuICAgKiBjYWxsaW5nIGBjb250ZXh0LnBhdGNoKClgLiBQYXRjaGluZyBpcyBvbmx5IGFsbG93ZWQgZm9yIHRoZSBkdXJhdGlvblxuICAgKiBvZiB0aGlzIHdpbmRvdy5cbiAgICovXG4gIGFsbG93UGF0Y2hpbmcoY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBsZXQgYWxsb3dlZCA9IHRydWU7XG4gICAgY29uc3QgcGF0Y2hhYmxlQ29udGV4dCA9IHtcbiAgICAgIC4uLnRoaXMuI2N1cnIsXG4gICAgICBwYXRjaChwYXRjaCkge1xuICAgICAgICBpZiAoYWxsb3dlZCkge1xuICAgICAgICAgIHNlbGYuI2N1cnIgPSBPYmplY3QuYXNzaWduKHt9LCBzZWxmLiNjdXJyLCBwYXRjaCk7XG4gICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIE9iamVjdC5lbnRyaWVzKHBhdGNoKSkge1xuICAgICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gcGFpcjtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IFwicGF0Y2hcIikge1xuICAgICAgICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vIGxvbmdlciBwYXRjaCBzdGFsZSBjb250ZXh0XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjYWxsYmFjayhwYXRjaGFibGVDb250ZXh0KTtcbiAgICBhbGxvd2VkID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9XG59O1xudmFyIG5leHRJZCA9IDE7XG52YXIgRlNNID0gY2xhc3Mge1xuICBpZDtcbiAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBzdGF0ZSBtYWNoaW5lIGlzIHN0aWxsIGJlaW5nIGNvbmZpZ3VyZWQsIGhhc1xuICAvLyBzdGFydGVkLCBvciBoYXMgdGVybWluYXRlZFxuICAjcnVubmluZ1N0YXRlO1xuICAjY3VycmVudENvbnRleHQ7XG4gICNzdGF0ZXM7XG4gICNjdXJyZW50U3RhdGVPck51bGw7XG4gICNhbGxvd2VkVHJhbnNpdGlvbnM7XG4gICNldmVudEh1YjtcbiAgZXZlbnRzO1xuICAvL1xuICAvLyBUaGUgY2xlYW51cCBzdGFjayBpcyBhIHN0YWNrIG9mIChvcHRpb25hbCkgY2FsbGJhY2sgZnVuY3Rpb25zIHRoYXQgd2lsbFxuICAvLyBiZSBydW4gd2hlbiBleGl0aW5nIHRoZSBjdXJyZW50IHN0YXRlLiBJZiBhIHN0YXRlIChvciBzdGF0ZSBncm91cCkgZG9lc1xuICAvLyBub3QgaGF2ZSBhbiBleGl0IGhhbmRsZXIsIHRoZW4gdGhlIGVudHJ5IGZvciB0aGF0IGxldmVsIG1heSBiZVxuICAvLyBgdW5kZWZpbmVkYCwgYnV0IHRoZXJlIHdpbGwgYmUgYW4gZXhwbGljaXQgZW50cnkgaW4gdGhlIHN0YWNrIGZvciBpdC5cbiAgLy9cbiAgLy8gVGhpcyB3aWxsIGFsd2F5cyBiZSB0cnVlOlxuICAvL1xuICAvLyAgIGNsZWFudXBTdGFjay5sZW5ndGggPT0gY3VycmVudFN0YXRlLnNwbGl0KCcuJykubGVuZ3RoICsgMVxuICAvL1xuICAvLyBFYWNoIHN0YWNrIGxldmVsIHJlcHJlc2VudHMgYSBkaWZmZXJlbnQgc3RhdGUgXCJncm91cFwiLlxuICAvL1xuICAvLyBGb3IgZXhhbXBsZSwgaWYgeW91IGFyZSBpbiBhIHN0YXRlIG5hbWVkIGBmb28uYmFyLnF1eGAsIHRoZW4gdGhlIHN0YWNrXG4gIC8vIHdpbGwgY29udGFpbiB0aGUgZXhpdCBoYW5kbGVyIGZvciBgZm9vLmJhci5xdXhgIChhdCB0aGUgdG9wKSwgdGhlblxuICAvLyBgZm9vLmJhci4qYCwgdGhlbiBgZm9vLipgLCBhbmQgZmluYWxseSwgYCpgLlxuICAvL1xuICAjY2xlYW51cFN0YWNrO1xuICAjZW50ZXJGbnM7XG4gIC8vIFVzZWQgdG8gcHJvdmlkZSBiZXR0ZXIgZXJyb3IgbWVzc2FnZXNcbiAgI2tub3duRXZlbnRUeXBlcztcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluaXRpYWwgc3RhdGUsIHdoaWNoIGlzIGRlZmluZWQgYnkgdGhlIGZpcnN0IGNhbGwgbWFkZSB0b1xuICAgKiAuYWRkU3RhdGUoKS5cbiAgICovXG4gIGdldCAjaW5pdGlhbFN0YXRlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI3N0YXRlcy52YWx1ZXMoKVtTeW1ib2wuaXRlcmF0b3JdKCkubmV4dCgpO1xuICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3RhdGVzIGRlZmluZWQgeWV0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgfVxuICBnZXQgY3VycmVudFN0YXRlKCkge1xuICAgIGlmICh0aGlzLiNjdXJyZW50U3RhdGVPck51bGwgPT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLiNydW5uaW5nU3RhdGUgPT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdGFydGVkIHlldFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RvcHBlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRTdGF0ZU9yTnVsbDtcbiAgfVxuICAvKipcbiAgICogU3RhcnRzIHRoZSBtYWNoaW5lIGJ5IGVudGVyaW5nIHRoZSBpbml0aWFsIHN0YXRlLlxuICAgKi9cbiAgc3RhcnQoKSB7XG4gICAgaWYgKHRoaXMuI3J1bm5pbmdTdGF0ZSAhPT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXRlIG1hY2hpbmUgaGFzIGFscmVhZHkgc3RhcnRlZFwiKTtcbiAgICB9XG4gICAgdGhpcy4jcnVubmluZ1N0YXRlID0gMSAvKiBTVEFSVEVEICovO1xuICAgIHRoaXMuI2N1cnJlbnRTdGF0ZU9yTnVsbCA9IHRoaXMuI2luaXRpYWxTdGF0ZTtcbiAgICB0aGlzLiNlbnRlcihudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU3RvcHMgdGhlIHN0YXRlIG1hY2hpbmUuIFN0b3BwaW5nIHRoZSBzdGF0ZSBtYWNoaW5lIHdpbGwgY2FsbCBleGl0XG4gICAqIGhhbmRsZXJzIGZvciB0aGUgY3VycmVudCBzdGF0ZSwgYnV0IG5vdCBlbnRlciBhIG5ldyBzdGF0ZS5cbiAgICovXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuI3J1bm5pbmdTdGF0ZSAhPT0gMSAvKiBTVEFSVEVEICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3RvcCBhIHN0YXRlIG1hY2hpbmUgdGhhdCBoYXNuJ3Qgc3RhcnRlZCB5ZXRcIik7XG4gICAgfVxuICAgIHRoaXMuI2V4aXQobnVsbCk7XG4gICAgdGhpcy4jcnVubmluZ1N0YXRlID0gMiAvKiBTVE9QUEVEICovO1xuICAgIHRoaXMuI2N1cnJlbnRTdGF0ZU9yTnVsbCA9IG51bGw7XG4gIH1cbiAgY29uc3RydWN0b3IoaW5pdGlhbENvbnRleHQpIHtcbiAgICB0aGlzLmlkID0gbmV4dElkKys7XG4gICAgdGhpcy4jcnVubmluZ1N0YXRlID0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi87XG4gICAgdGhpcy4jY3VycmVudFN0YXRlT3JOdWxsID0gbnVsbDtcbiAgICB0aGlzLiNzdGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuI2VudGVyRm5zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLiNjbGVhbnVwU3RhY2sgPSBbXTtcbiAgICB0aGlzLiNrbm93bkV2ZW50VHlwZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuI2FsbG93ZWRUcmFuc2l0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy4jY3VycmVudENvbnRleHQgPSBuZXcgU2FmZUNvbnRleHQoaW5pdGlhbENvbnRleHQpO1xuICAgIHRoaXMuI2V2ZW50SHViID0ge1xuICAgICAgZGlkUmVjZWl2ZUV2ZW50OiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAgIHdpbGxUcmFuc2l0aW9uOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAgIGRpZElnbm9yZUV2ZW50OiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAgIHdpbGxFeGl0U3RhdGU6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgZGlkRW50ZXJTdGF0ZTogbWFrZUV2ZW50U291cmNlKClcbiAgICB9O1xuICAgIHRoaXMuZXZlbnRzID0ge1xuICAgICAgZGlkUmVjZWl2ZUV2ZW50OiB0aGlzLiNldmVudEh1Yi5kaWRSZWNlaXZlRXZlbnQub2JzZXJ2YWJsZSxcbiAgICAgIHdpbGxUcmFuc2l0aW9uOiB0aGlzLiNldmVudEh1Yi53aWxsVHJhbnNpdGlvbi5vYnNlcnZhYmxlLFxuICAgICAgZGlkSWdub3JlRXZlbnQ6IHRoaXMuI2V2ZW50SHViLmRpZElnbm9yZUV2ZW50Lm9ic2VydmFibGUsXG4gICAgICB3aWxsRXhpdFN0YXRlOiB0aGlzLiNldmVudEh1Yi53aWxsRXhpdFN0YXRlLm9ic2VydmFibGUsXG4gICAgICBkaWRFbnRlclN0YXRlOiB0aGlzLiNldmVudEh1Yi5kaWRFbnRlclN0YXRlLm9ic2VydmFibGVcbiAgICB9O1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiNjdXJyZW50Q29udGV4dC5jdXJyZW50O1xuICB9XG4gIC8qKlxuICAgKiBEZWZpbmUgYW4gZXhwbGljaXQgZmluaXRlIHN0YXRlIGluIHRoZSBzdGF0ZSBtYWNoaW5lLlxuICAgKi9cbiAgYWRkU3RhdGUoc3RhdGUpIHtcbiAgICBpZiAodGhpcy4jcnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH1cbiAgICB0aGlzLiNzdGF0ZXMuYWRkKHN0YXRlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvbkVudGVyKG5hbWVPclBhdHRlcm4sIGVudGVyRm4pIHtcbiAgICBpZiAodGhpcy4jcnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jZW50ZXJGbnMuaGFzKG5hbWVPclBhdHRlcm4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIC8vIFRPRE8gV2UgX2N1cnJlbnRseV8gZG9uJ3Qgc3VwcG9ydCBtdWx0aXBsZSAub25FbnRlcnMoKSBmb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gc3RhdGUsIGJ1dCB0aGlzIGlzIG5vdCBhIGZ1bmRhbWVudGFsIGxpbWl0YXRpb24uIEp1c3Qgbm90XG4gICAgICAgIC8vIGltcGxlbWVudGVkIHlldC4gSWYgd2Ugd2FudGVkIHRvLCB3ZSBjb3VsZCBtYWtlIHRoaXMgYW4gYXJyYXkuXG4gICAgICAgIGBlbnRlci9leGl0IGZ1bmN0aW9uIGZvciAke25hbWVPclBhdHRlcm59IGFscmVhZHkgZXhpc3RzYFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy4jZW50ZXJGbnMuc2V0KG5hbWVPclBhdHRlcm4sIGVudGVyRm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgcHJvbWlzZS1iYXNlZCBzdGF0ZS4gV2hlbiB0aGUgc3RhdGUgaXMgZW50ZXJlZCwgdGhlIHByb21pc2UgaXNcbiAgICogY3JlYXRlZC4gV2hlbiB0aGUgcHJvbWlzZSByZXNvbHZlcywgdGhlIG1hY2hpbmUgd2lsbCB0cmFuc2l0aW9uIHRvIHRoZVxuICAgKiBwcm92aWRlZCBgb25PS2AgdGFyZ2V0IHN0YXRlLiBXaGVuIHRoZSBwcm9taXNlIHJlamVjdHMsIHRoZSBtYWNoaW5lIHdpbGxcbiAgICogdHJhbnNpdGlvbiB0byB0aGUgYG9uRXJyb3JgIHRhcmdldCBzdGF0ZS5cbiAgICpcbiAgICogT3B0aW9uYWxseSwgYSBgbWF4VGltZW91dGAgY2FuIGJlIHNldC4gSWYgdGhlIHRpbWVvdXQgaGFwcGVucyBiZWZvcmUgdGhlXG4gICAqIHByb21pc2UgaXMgc2V0dGxlZCwgdGhlbiB0aGUgbWFjaGluZSB3aWxsIGFsc28gdHJhbnNpdGlvbiB0byB0aGUgYG9uRXJyb3JgXG4gICAqIHRhcmdldCBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlT3JQYXR0ZXJuICBUaGUgc3RhdGUgbmFtZSwgb3Igc3RhdGUgZ3JvdXAgcGF0dGVybiBuYW1lLlxuICAgKiBAcGFyYW0gcHJvbWlzZUZuICAgICAgIFRoZSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gdGhlIHN0YXRlIGlzIGVudGVyZWQuXG4gICAqIEBwYXJhbSBvbk9LICAgICAgICAgICAgVGhlIHN0YXRlIHRvIHRyYW5zaXRpb24gdG8gd2hlbiB0aGUgcHJvbWlzZSByZXNvbHZlcy5cbiAgICogQHBhcmFtIG9uRXJyb3IgICAgICAgICBUaGUgc3RhdGUgdG8gdHJhbnNpdGlvbiB0byB3aGVuIHRoZSBwcm9taXNlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0cywgb3Igd2hlbiB0aGUgdGltZW91dCBoYXBwZW5zIGJlZm9yZSB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlIGhhcyBiZWVuIHNldHRsZWQuXG4gICAqIEBwYXJhbSBtYXhUaW1lb3V0ICAgICAgT3B0aW9uYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMuXG4gICAqXG4gICAqIFdoZW4gdGhlIHByb21pc2UgY2FsbGJhY2sgZnVuY3Rpb24gaXMgaW52b2tlZCwgaXQncyBwcm92aWRlZCB3aXRoIGFuXG4gICAqIEFib3J0U2lnbmFsICgybmQgYXJndW1lbnQpLlxuICAgKiBJZiBhIHN0YXRlIHRyYW5zaXRpb24gaGFwcGVucyB3aGlsZSB0aGUgcHJvbWlzZSBpcyBwZW5kaW5nIChmb3IgZXhhbXBsZSxcbiAgICogYW4gZXZlbnQsIG9yIGEgdGltZW91dCBoYXBwZW5zKSwgdGhlbiBhbiBhYm9ydCBzaWduYWwgd2lsbCBiZSB1c2VkIHRvXG4gICAqIGluZGljYXRlIHRoaXMuIEltcGxlbWVudGVycyBjYW4gdXNlIHRoaXMgYWJvcnQgc2lnbmFsIHRvIHRlcm1pbmF0ZSB0aGVcbiAgICogaW4tZmxpZ2h0IHByb21pc2UsIG9yIGlnbm9yZSBpdHMgcmVzdWx0cywgZXRjLlxuICAgKi9cbiAgb25FbnRlckFzeW5jKG5hbWVPclBhdHRlcm4sIHByb21pc2VGbiwgb25PSywgb25FcnJvciwgbWF4VGltZW91dCkge1xuICAgIHJldHVybiB0aGlzLm9uRW50ZXIobmFtZU9yUGF0dGVybiwgKCkgPT4ge1xuICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IG1heFRpbWVvdXQgPyBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgcmVhc29uID0gbmV3IEVycm9yKFwiVGltZWQgb3V0XCIpO1xuICAgICAgICB0aGlzLiN0cmFuc2l0aW9uKHsgdHlwZTogXCJBU1lOQ19FUlJPUlwiLCByZWFzb24gfSwgb25FcnJvcik7XG4gICAgICB9LCBtYXhUaW1lb3V0KSA6IHZvaWQgMDtcbiAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICB2b2lkIHByb21pc2VGbih0aGlzLiNjdXJyZW50Q29udGV4dC5jdXJyZW50LCBzaWduYWwpLnRoZW4oXG4gICAgICAgIC8vIE9uIE9LXG4gICAgICAgIChkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKCFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiN0cmFuc2l0aW9uKHsgdHlwZTogXCJBU1lOQ19PS1wiLCBkYXRhIH0sIG9uT0spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gT24gRXJyb3JcbiAgICAgICAgKHJlYXNvbikgPT4ge1xuICAgICAgICAgIGlmICghc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4jdHJhbnNpdGlvbih7IHR5cGU6IFwiQVNZTkNfRVJST1JcIiwgcmVhc29uIH0sIG9uRXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICAjZ2V0U3RhdGVzTWF0Y2hpbmcobmFtZU9yUGF0dGVybikge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICBpZiAobmFtZU9yUGF0dGVybiA9PT0gXCIqXCIpIHtcbiAgICAgIGZvciAoY29uc3Qgc3RhdGUgb2YgdGhpcy4jc3RhdGVzKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaChzdGF0ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuYW1lT3JQYXR0ZXJuLmVuZHNXaXRoKFwiLipcIikpIHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IG5hbWVPclBhdHRlcm4uc2xpY2UoMCwgLTEpO1xuICAgICAgZm9yIChjb25zdCBzdGF0ZSBvZiB0aGlzLiNzdGF0ZXMpIHtcbiAgICAgICAgaWYgKHN0YXRlLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmFtZSA9IG5hbWVPclBhdHRlcm47XG4gICAgICBpZiAodGhpcy4jc3RhdGVzLmhhcyhuYW1lKSkge1xuICAgICAgICBtYXRjaGVzLnB1c2gobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzdGF0ZXMgbWF0Y2ggJHtKU09OLnN0cmluZ2lmeShuYW1lT3JQYXR0ZXJuKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cbiAgLyoqXG4gICAqIERlZmluZSBhbGwgYWxsb3dlZCBvdXRnb2luZyB0cmFuc2l0aW9ucyBmb3IgYSBzdGF0ZS5cbiAgICpcbiAgICogVGhlIHRhcmdldHMgZm9yIGVhY2ggZXZlbnQgY2FuIGJlIGRlZmluZWQgYXMgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRoZVxuICAgKiBuZXh0IHN0YXRlIHRvIHRyYW5zaXRpb24gdG8uIFRoZXNlIGZ1bmN0aW9ucyBjYW4gbG9vayBhdCB0aGUgYGV2ZW50YCBvclxuICAgKiBgY29udGV4dGAgcGFyYW1zIHRvIGNvbmRpdGlvbmFsbHkgZGVjaWRlIHdoaWNoIG5leHQgc3RhdGUgdG8gdHJhbnNpdGlvblxuICAgKiB0by5cbiAgICpcbiAgICogSWYgeW91IHNldCBpdCB0byBgbnVsbGAsIHRoZW4gdGhlIHRyYW5zaXRpb24gd2lsbCBiZSBleHBsaWNpdGx5IGZvcmJpZGRlblxuICAgKiBhbmQgdGhyb3cgYW4gZXJyb3IuIElmIHlvdSBkb24ndCBkZWZpbmUgYSB0YXJnZXQgZm9yIGEgdHJhbnNpdGlvbiwgdGhlblxuICAgKiBzdWNoIGV2ZW50cyB3aWxsIGdldCBpZ25vcmVkLlxuICAgKi9cbiAgYWRkVHJhbnNpdGlvbnMobmFtZU9yUGF0dGVybiwgbWFwcGluZykge1xuICAgIGlmICh0aGlzLiNydW5uaW5nU3RhdGUgIT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc3JjU3RhdGUgb2YgdGhpcy4jZ2V0U3RhdGVzTWF0Y2hpbmcobmFtZU9yUGF0dGVybikpIHtcbiAgICAgIGxldCBtYXAgPSB0aGlzLiNhbGxvd2VkVHJhbnNpdGlvbnMuZ2V0KHNyY1N0YXRlKTtcbiAgICAgIGlmIChtYXAgPT09IHZvaWQgMCkge1xuICAgICAgICBtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNhbGxvd2VkVHJhbnNpdGlvbnMuc2V0KHNyY1N0YXRlLCBtYXApO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBbdHlwZSwgdGFyZ2V0X10gb2YgT2JqZWN0LmVudHJpZXMobWFwcGluZykpIHtcbiAgICAgICAgaWYgKG1hcC5oYXModHlwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVHJ5aW5nIHRvIHNldCB0cmFuc2l0aW9uIFwiJHt0eXBlfVwiIG9uIFwiJHtzcmNTdGF0ZX1cIiAodmlhIFwiJHtuYW1lT3JQYXR0ZXJufVwiKSwgYnV0IGEgdHJhbnNpdGlvbiBhbHJlYWR5IGV4aXN0cyB0aGVyZS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRfO1xuICAgICAgICB0aGlzLiNrbm93bkV2ZW50VHlwZXMuYWRkKHR5cGUpO1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRGbiA9IHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIiA/IHRhcmdldCA6ICgpID0+IHRhcmdldDtcbiAgICAgICAgICBtYXAuc2V0KHR5cGUsIHRhcmdldEZuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogTGlrZSBgLmFkZFRyYW5zaXRpb24oKWAsIGJ1dCB0YWtlcyBhbiAoYW5vbnltb3VzKSB0cmFuc2l0aW9uIHdoZW5ldmVyIHRoZVxuICAgKiB0aW1lciBmaXJlcy5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlT3JQYXR0ZXJuICBUaGUgc3RhdGUgbmFtZSwgb3Igc3RhdGUgZ3JvdXAgcGF0dGVybiBuYW1lLlxuICAgKiBAcGFyYW0gYWZ0ZXIgICAgICAgICAgIE51bWJlciBvZiBtaWxsaXNlY29uZHMgYWZ0ZXIgd2hpY2ggdG8gdGFrZSB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLiBJZiBpbiB0aGUgbWVhbiB0aW1lLCBhbm90aGVyIHRyYW5zaXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICBpcyB0YWtlbiwgdGhlIHRpbWVyIHdpbGwgZ2V0IGNhbmNlbGxlZC5cbiAgICogQHBhcmFtIHRhcmdldCAgICAgICAgICBUaGUgdGFyZ2V0IHN0YXRlIHRvIGdvIHRvLlxuICAgKi9cbiAgYWRkVGltZWRUcmFuc2l0aW9uKHN0YXRlT3JQYXR0ZXJuLCBhZnRlcjIsIHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLm9uRW50ZXIoc3RhdGVPclBhdHRlcm4sICgpID0+IHtcbiAgICAgIGNvbnN0IG1zID0gdHlwZW9mIGFmdGVyMiA9PT0gXCJmdW5jdGlvblwiID8gYWZ0ZXIyKHRoaXMuI2N1cnJlbnRDb250ZXh0LmN1cnJlbnQpIDogYWZ0ZXIyO1xuICAgICAgY29uc3QgdGltZW91dElEID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuI3RyYW5zaXRpb24oeyB0eXBlOiBcIlRJTUVSXCIgfSwgdGFyZ2V0KTtcbiAgICAgIH0sIG1zKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICAjZ2V0VGFyZ2V0Rm4oZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsbG93ZWRUcmFuc2l0aW9ucy5nZXQodGhpcy5jdXJyZW50U3RhdGUpPy5nZXQoZXZlbnROYW1lKTtcbiAgfVxuICAvKipcbiAgICogRXhpdHMgdGhlIGN1cnJlbnQgc3RhdGUsIGFuZCBleGVjdXRlcyBhbnkgbmVjZXNzYXJ5IGNsZWFudXAgZnVuY3Rpb25zLlxuICAgKiBDYWxsIHRoaXMgYmVmb3JlIGNoYW5naW5nIHRoZSBjdXJyZW50IHN0YXRlIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0gbGV2ZWxzIERlZmluZXMgaG93IG1hbnkgXCJsZXZlbHNcIiBvZiBuZXN0aW5nIHdpbGwgYmVcbiAgICogZXhpdGVkLiBGb3IgZXhhbXBsZSwgaWYgeW91IHRyYW5zaXRpb24gZnJvbSBgZm9vLmJhci5xdXhgIHRvXG4gICAqIGBmb28uYmFyLmJhemAsIHRoZW4gdGhlIGxldmVsIGlzIDEuIEJ1dCBpZiB5b3UgdHJhbnNpdGlvbiBmcm9tXG4gICAqIGBmb28uYmFyLnF1eGAgdG8gYGJsYS5ibGFgLCB0aGVuIHRoZSBsZXZlbCBpcyAzLlxuICAgKiBJZiBgbnVsbGAsIGl0IHdpbGwgZXhpdCBhbGwgbGV2ZWxzLlxuICAgKi9cbiAgI2V4aXQobGV2ZWxzKSB7XG4gICAgdGhpcy4jZXZlbnRIdWIud2lsbEV4aXRTdGF0ZS5ub3RpZnkodGhpcy5jdXJyZW50U3RhdGUpO1xuICAgIHRoaXMuI2N1cnJlbnRDb250ZXh0LmFsbG93UGF0Y2hpbmcoKHBhdGNoYWJsZUNvbnRleHQpID0+IHtcbiAgICAgIGxldmVscyA9IGxldmVscyA/PyB0aGlzLiNjbGVhbnVwU3RhY2subGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbHM7IGkrKykge1xuICAgICAgICB0aGlzLiNjbGVhbnVwU3RhY2sucG9wKCk/LihwYXRjaGFibGVDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW50ZXJzIHRoZSBjdXJyZW50IHN0YXRlLCBhbmQgZXhlY3V0ZXMgYW55IG5lY2Vzc2FyeSBvbkVudGVyIGhhbmRsZXJzLlxuICAgKiBDYWxsIHRoaXMgZGlyZWN0bHkgX2FmdGVyXyBzZXR0aW5nIHRoZSBjdXJyZW50IHN0YXRlIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgKi9cbiAgI2VudGVyKGxldmVscykge1xuICAgIGNvbnN0IGVudGVyUGF0dGVybnMgPSBwYXR0ZXJucyhcbiAgICAgIHRoaXMuY3VycmVudFN0YXRlLFxuICAgICAgbGV2ZWxzID8/IHRoaXMuY3VycmVudFN0YXRlLnNwbGl0KFwiLlwiKS5sZW5ndGggKyAxXG4gICAgKTtcbiAgICB0aGlzLiNjdXJyZW50Q29udGV4dC5hbGxvd1BhdGNoaW5nKChwYXRjaGFibGVDb250ZXh0KSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgZW50ZXJQYXR0ZXJucykge1xuICAgICAgICBjb25zdCBlbnRlckZuID0gdGhpcy4jZW50ZXJGbnMuZ2V0KHBhdHRlcm4pO1xuICAgICAgICBjb25zdCBjbGVhbnVwRm4gPSBlbnRlckZuPy4ocGF0Y2hhYmxlQ29udGV4dCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYW51cEZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLiNjbGVhbnVwU3RhY2sucHVzaChjbGVhbnVwRm4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuI2NsZWFudXBTdGFjay5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy4jZXZlbnRIdWIuZGlkRW50ZXJTdGF0ZS5ub3RpZnkodGhpcy5jdXJyZW50U3RhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhbiBldmVudCB0byB0aGUgbWFjaGluZSwgd2hpY2ggbWF5IGNhdXNlIGFuIGludGVybmFsIHN0YXRlXG4gICAqIHRyYW5zaXRpb24gdG8gaGFwcGVuLiBXaGVuIHRoYXQgaGFwcGVucywgd2lsbCB0cmlnZ2VyIHNpZGUgZWZmZWN0cy5cbiAgICovXG4gIHNlbmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2tub3duRXZlbnRUeXBlcy5oYXMoZXZlbnQudHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBldmVudCAke0pTT04uc3RyaW5naWZ5KGV2ZW50LnR5cGUpfWApO1xuICAgIH1cbiAgICBpZiAodGhpcy4jcnVubmluZ1N0YXRlID09PSAyIC8qIFNUT1BQRUQgKi8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0Rm4gPSB0aGlzLiNnZXRUYXJnZXRGbihldmVudC50eXBlKTtcbiAgICBpZiAodGFyZ2V0Rm4gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuI3RyYW5zaXRpb24oZXZlbnQsIHRhcmdldEZuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZXZlbnRIdWIuZGlkSWdub3JlRXZlbnQubm90aWZ5KGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgI3RyYW5zaXRpb24oZXZlbnQsIHRhcmdldCkge1xuICAgIHRoaXMuI2V2ZW50SHViLmRpZFJlY2VpdmVFdmVudC5ub3RpZnkoZXZlbnQpO1xuICAgIGNvbnN0IG9sZFN0YXRlID0gdGhpcy5jdXJyZW50U3RhdGU7XG4gICAgY29uc3QgdGFyZ2V0Rm4gPSB0eXBlb2YgdGFyZ2V0ID09PSBcImZ1bmN0aW9uXCIgPyB0YXJnZXQgOiAoKSA9PiB0YXJnZXQ7XG4gICAgY29uc3QgbmV4dFRhcmdldCA9IHRhcmdldEZuKGV2ZW50LCB0aGlzLiNjdXJyZW50Q29udGV4dC5jdXJyZW50KTtcbiAgICBsZXQgbmV4dFN0YXRlO1xuICAgIGxldCBlZmZlY3RzID0gdm9pZCAwO1xuICAgIGlmIChuZXh0VGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICB0aGlzLiNldmVudEh1Yi5kaWRJZ25vcmVFdmVudC5ub3RpZnkoZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5leHRUYXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHRUYXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHRUYXJnZXQudGFyZ2V0O1xuICAgICAgZWZmZWN0cyA9IEFycmF5LmlzQXJyYXkobmV4dFRhcmdldC5lZmZlY3QpID8gbmV4dFRhcmdldC5lZmZlY3QgOiBbbmV4dFRhcmdldC5lZmZlY3RdO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI3N0YXRlcy5oYXMobmV4dFN0YXRlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG5leHQgc3RhdGUgbmFtZTogJHtKU09OLnN0cmluZ2lmeShuZXh0U3RhdGUpfWApO1xuICAgIH1cbiAgICB0aGlzLiNldmVudEh1Yi53aWxsVHJhbnNpdGlvbi5ub3RpZnkoeyBmcm9tOiBvbGRTdGF0ZSwgdG86IG5leHRTdGF0ZSB9KTtcbiAgICBjb25zdCBbdXAsIGRvd25dID0gZGlzdGFuY2UodGhpcy5jdXJyZW50U3RhdGUsIG5leHRTdGF0ZSk7XG4gICAgaWYgKHVwID4gMCkge1xuICAgICAgdGhpcy4jZXhpdCh1cCk7XG4gICAgfVxuICAgIHRoaXMuI2N1cnJlbnRTdGF0ZU9yTnVsbCA9IG5leHRTdGF0ZTtcbiAgICBpZiAoZWZmZWN0cyAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBlZmZlY3RzVG9SdW4gPSBlZmZlY3RzO1xuICAgICAgdGhpcy4jY3VycmVudENvbnRleHQuYWxsb3dQYXRjaGluZygocGF0Y2hhYmxlQ29udGV4dCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiBlZmZlY3RzVG9SdW4pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBlZmZlY3QocGF0Y2hhYmxlQ29udGV4dCwgZXZlbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRjaGFibGVDb250ZXh0LnBhdGNoKGVmZmVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGRvd24gPiAwKSB7XG4gICAgICB0aGlzLiNlbnRlcihkb3duKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9wcm90b2NvbC9TZXJ2ZXJNc2cudHNcbnZhciBTZXJ2ZXJNc2dDb2RlID0gLyogQF9fUFVSRV9fICovICgoU2VydmVyTXNnQ29kZTIpID0+IHtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVUERBVEVfUFJFU0VOQ0VcIl0gPSAxMDBdID0gXCJVUERBVEVfUFJFU0VOQ0VcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVU0VSX0pPSU5FRFwiXSA9IDEwMV0gPSBcIlVTRVJfSk9JTkVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVNFUl9MRUZUXCJdID0gMTAyXSA9IFwiVVNFUl9MRUZUXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQlJPQURDQVNURURfRVZFTlRcIl0gPSAxMDNdID0gXCJCUk9BRENBU1RFRF9FVkVOVFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlJPT01fU1RBVEVcIl0gPSAxMDRdID0gXCJST09NX1NUQVRFXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiSU5JVElBTF9TVE9SQUdFX1NUQVRFXCJdID0gMjAwXSA9IFwiSU5JVElBTF9TVE9SQUdFX1NUQVRFXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVBEQVRFX1NUT1JBR0VcIl0gPSAyMDFdID0gXCJVUERBVEVfU1RPUkFHRVwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlJFSkVDVF9TVE9SQUdFX09QXCJdID0gMjk5XSA9IFwiUkVKRUNUX1NUT1JBR0VfT1BcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVUERBVEVfWURPQ1wiXSA9IDMwMF0gPSBcIlVQREFURV9ZRE9DXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVEhSRUFEX0NSRUFURURcIl0gPSA0MDBdID0gXCJUSFJFQURfQ1JFQVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlRIUkVBRF9ERUxFVEVEXCJdID0gNDA3XSA9IFwiVEhSRUFEX0RFTEVURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJUSFJFQURfTUVUQURBVEFfVVBEQVRFRFwiXSA9IDQwMV0gPSBcIlRIUkVBRF9NRVRBREFUQV9VUERBVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVEhSRUFEX1VQREFURURcIl0gPSA0MDhdID0gXCJUSFJFQURfVVBEQVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfQ1JFQVRFRFwiXSA9IDQwMl0gPSBcIkNPTU1FTlRfQ1JFQVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfRURJVEVEXCJdID0gNDAzXSA9IFwiQ09NTUVOVF9FRElURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX0RFTEVURURcIl0gPSA0MDRdID0gXCJDT01NRU5UX0RFTEVURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX1JFQUNUSU9OX0FEREVEXCJdID0gNDA1XSA9IFwiQ09NTUVOVF9SRUFDVElPTl9BRERFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfUkVBQ1RJT05fUkVNT1ZFRFwiXSA9IDQwNl0gPSBcIkNPTU1FTlRfUkVBQ1RJT05fUkVNT1ZFRFwiO1xuICByZXR1cm4gU2VydmVyTXNnQ29kZTI7XG59KShTZXJ2ZXJNc2dDb2RlIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL0lXZWJTb2NrZXQudHNcbnZhciBXZWJzb2NrZXRDbG9zZUNvZGVzID0gLyogQF9fUFVSRV9fICovICgoV2Vic29ja2V0Q2xvc2VDb2RlczIpID0+IHtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJDTE9TRV9OT1JNQUxcIl0gPSAxZTNdID0gXCJDTE9TRV9OT1JNQUxcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJDTE9TRV9BQk5PUk1BTFwiXSA9IDEwMDZdID0gXCJDTE9TRV9BQk5PUk1BTFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIlVORVhQRUNURURfQ09ORElUSU9OXCJdID0gMTAxMV0gPSBcIlVORVhQRUNURURfQ09ORElUSU9OXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiVFJZX0FHQUlOX0xBVEVSXCJdID0gMTAxM10gPSBcIlRSWV9BR0FJTl9MQVRFUlwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIklOVkFMSURfTUVTU0FHRV9GT1JNQVRcIl0gPSA0ZTNdID0gXCJJTlZBTElEX01FU1NBR0VfRk9STUFUXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTk9UX0FMTE9XRURcIl0gPSA0MDAxXSA9IFwiTk9UX0FMTE9XRURcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9TRUNPTkRTXCJdID0gNDAwMl0gPSBcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX1NFQ09ORFNcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNcIl0gPSA0MDAzXSA9IFwiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfREFZX1BFUl9BUFBcIl0gPSA0MDA0XSA9IFwiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfREFZX1BFUl9BUFBcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNfUEVSX1JPT01cIl0gPSA0MDA1XSA9IFwiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TX1BFUl9ST09NXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiUk9PTV9JRF9VUERBVEVEXCJdID0gNDAwNl0gPSBcIlJPT01fSURfVVBEQVRFRFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIktJQ0tFRFwiXSA9IDQxMDBdID0gXCJLSUNLRURcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJUT0tFTl9FWFBJUkVEXCJdID0gNDEwOV0gPSBcIlRPS0VOX0VYUElSRURcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJDTE9TRV9XSVRIT1VUX1JFVFJZXCJdID0gNDk5OV0gPSBcIkNMT1NFX1dJVEhPVVRfUkVUUllcIjtcbiAgcmV0dXJuIFdlYnNvY2tldENsb3NlQ29kZXMyO1xufSkoV2Vic29ja2V0Q2xvc2VDb2RlcyB8fCB7fSk7XG5mdW5jdGlvbiBzaG91bGREaXNjb25uZWN0KGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDQ5OTkgLyogQ0xPU0VfV0lUSE9VVF9SRVRSWSAqLyB8fCBjb2RlID49IDRlMyAmJiBjb2RlIDwgNDEwMDtcbn1cbmZ1bmN0aW9uIHNob3VsZFJlYXV0aChjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDQxMDAgJiYgY29kZSA8IDQyMDA7XG59XG5mdW5jdGlvbiBzaG91bGRSZXRyeVdpdGhvdXRSZWF1dGgoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gMTAxMyAvKiBUUllfQUdBSU5fTEFURVIgKi8gfHwgY29kZSA+PSA0MjAwICYmIGNvZGUgPCA0MzAwO1xufVxuXG4vLyBzcmMvY29ubmVjdGlvbi50c1xuZnVuY3Rpb24gaXNJZGxlKHN0YXR1cykge1xuICByZXR1cm4gc3RhdHVzID09PSBcImluaXRpYWxcIiB8fCBzdGF0dXMgPT09IFwiZGlzY29ubmVjdGVkXCI7XG59XG5mdW5jdGlvbiB0b05ld0Nvbm5lY3Rpb25TdGF0dXMobWFjaGluZSkge1xuICBjb25zdCBzdGF0ZSA9IG1hY2hpbmUuY3VycmVudFN0YXRlO1xuICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgY2FzZSBcIkBvay5jb25uZWN0ZWRcIjpcbiAgICBjYXNlIFwiQG9rLmF3YWl0aW5nLXBvbmdcIjpcbiAgICAgIHJldHVybiBcImNvbm5lY3RlZFwiO1xuICAgIGNhc2UgXCJAaWRsZS5pbml0aWFsXCI6XG4gICAgICByZXR1cm4gXCJpbml0aWFsXCI7XG4gICAgY2FzZSBcIkBhdXRoLmJ1c3lcIjpcbiAgICBjYXNlIFwiQGF1dGguYmFja29mZlwiOlxuICAgIGNhc2UgXCJAY29ubmVjdGluZy5idXN5XCI6XG4gICAgY2FzZSBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIjpcbiAgICBjYXNlIFwiQGlkbGUuem9tYmllXCI6XG4gICAgICByZXR1cm4gbWFjaGluZS5jb250ZXh0LnN1Y2Nlc3NDb3VudCA+IDAgPyBcInJlY29ubmVjdGluZ1wiIDogXCJjb25uZWN0aW5nXCI7XG4gICAgY2FzZSBcIkBpZGxlLmZhaWxlZFwiOlxuICAgICAgcmV0dXJuIFwiZGlzY29ubmVjdGVkXCI7XG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHN0YXRlLCBcIlVua25vd24gc3RhdGVcIik7XG4gIH1cbn1cbnZhciBCQUNLT0ZGX0RFTEFZUyA9IFsyNTAsIDUwMCwgMWUzLCAyZTMsIDRlMywgOGUzLCAxZTRdO1xudmFyIFJFU0VUX0RFTEFZID0gQkFDS09GRl9ERUxBWVNbMF0gLSAxO1xudmFyIEJBQ0tPRkZfREVMQVlTX1NMT1cgPSBbMmUzLCAzZTQsIDZlNCwgM2U1XTtcbnZhciBIRUFSVEJFQVRfSU5URVJWQUwgPSAzZTQ7XG52YXIgUE9OR19USU1FT1VUID0gMmUzO1xudmFyIEFVVEhfVElNRU9VVCA9IDFlNDtcbnZhciBTT0NLRVRfQ09OTkVDVF9USU1FT1VUID0gMWU0O1xudmFyIFN0b3BSZXRyeWluZyA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihyZWFzb24pO1xuICB9XG59O1xuZnVuY3Rpb24gbmV4dEJhY2tvZmZEZWxheShjdXJyZW50RGVsYXksIGRlbGF5cykge1xuICByZXR1cm4gZGVsYXlzLmZpbmQoKGRlbGF5KSA9PiBkZWxheSA+IGN1cnJlbnREZWxheSkgPz8gZGVsYXlzW2RlbGF5cy5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGluY3JlYXNlQmFja29mZkRlbGF5KGNvbnRleHQpIHtcbiAgY29udGV4dC5wYXRjaCh7XG4gICAgYmFja29mZkRlbGF5OiBuZXh0QmFja29mZkRlbGF5KGNvbnRleHQuYmFja29mZkRlbGF5LCBCQUNLT0ZGX0RFTEFZUylcbiAgfSk7XG59XG5mdW5jdGlvbiBpbmNyZWFzZUJhY2tvZmZEZWxheUFnZ3Jlc3NpdmVseShjb250ZXh0KSB7XG4gIGNvbnRleHQucGF0Y2goe1xuICAgIGJhY2tvZmZEZWxheTogbmV4dEJhY2tvZmZEZWxheShjb250ZXh0LmJhY2tvZmZEZWxheSwgQkFDS09GRl9ERUxBWVNfU0xPVylcbiAgfSk7XG59XG5mdW5jdGlvbiByZXNldFN1Y2Nlc3NDb3VudChjb250ZXh0KSB7XG4gIGNvbnRleHQucGF0Y2goeyBzdWNjZXNzQ291bnQ6IDAgfSk7XG59XG5mdW5jdGlvbiBsb2cobGV2ZWwsIG1lc3NhZ2UpIHtcbiAgY29uc3QgbG9nZ2VyID0gbGV2ZWwgPT09IDIgLyogRVJST1IgKi8gPyBlcnJvcjIgOiBsZXZlbCA9PT0gMSAvKiBXQVJOICovID8gd2FybiA6IChcbiAgICAvKiBibGFjayBob2xlICovXG4gICAgKCkgPT4ge1xuICAgIH1cbiAgKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsb2dnZXIobWVzc2FnZSk7XG4gIH07XG59XG5mdW5jdGlvbiBsb2dQcmVtYXR1cmVFcnJvck9yQ2xvc2VFdmVudChlKSB7XG4gIGNvbnN0IGNvbm4gPSBcIkNvbm5lY3Rpb24gdG8gTGl2ZWJsb2NrcyB3ZWJzb2NrZXQgc2VydmVyXCI7XG4gIHJldHVybiAoY3R4KSA9PiB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgd2FybihgJHtjb25ufSBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQuICR7U3RyaW5nKGUpfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFxuICAgICAgICBpc0Nsb3NlRXZlbnQoZSkgPyBgJHtjb25ufSBjbG9zZWQgcHJlbWF0dXJlbHkgKGNvZGU6ICR7ZS5jb2RlfSkuIFJldHJ5aW5nIGluICR7Y3R4LmJhY2tvZmZEZWxheX1tcy5gIDogYCR7Y29ubn0gY291bGQgbm90IGJlIGVzdGFibGlzaGVkLmBcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbG9nQ2xvc2VFdmVudChldmVudCkge1xuICBjb25zdCBkZXRhaWxzID0gW2Bjb2RlOiAke2V2ZW50LmNvZGV9YF07XG4gIGlmIChldmVudC5yZWFzb24pIHtcbiAgICBkZXRhaWxzLnB1c2goYHJlYXNvbjogJHtldmVudC5yZWFzb259YCk7XG4gIH1cbiAgcmV0dXJuIChjdHgpID0+IHtcbiAgICB3YXJuKFxuICAgICAgYENvbm5lY3Rpb24gdG8gTGl2ZWJsb2NrcyB3ZWJzb2NrZXQgc2VydmVyIGNsb3NlZCAoJHtkZXRhaWxzLmpvaW4oXCIsIFwiKX0pLiBSZXRyeWluZyBpbiAke2N0eC5iYWNrb2ZmRGVsYXl9bXMuYFxuICAgICk7XG4gIH07XG59XG52YXIgbG9nUGVybWFuZW50Q2xvc2UgPSBsb2coXG4gIDEgLyogV0FSTiAqLyxcbiAgXCJDb25uZWN0aW9uIHRvIFdlYlNvY2tldCBjbG9zZWQgcGVybWFuZW50bHkuIFdvbid0IHJldHJ5LlwiXG4pO1xuZnVuY3Rpb24gaXNDbG9zZUV2ZW50KGVycm9yMykge1xuICByZXR1cm4gIShlcnJvcjMgaW5zdGFuY2VvZiBFcnJvcikgJiYgZXJyb3IzLnR5cGUgPT09IFwiY2xvc2VcIjtcbn1cbmZ1bmN0aW9uIGVuYWJsZVRyYWNpbmcobWFjaGluZSkge1xuICBjb25zdCBzdGFydCA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICBmdW5jdGlvbiBsb2cyKC4uLmFyZ3MpIHtcbiAgICB3YXJuKFxuICAgICAgYCR7KCgoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0KSAvIDFlMykudG9GaXhlZCgyKX0gW0ZTTSAjJHttYWNoaW5lLmlkfV1gLFxuICAgICAgLi4uYXJnc1xuICAgICk7XG4gIH1cbiAgY29uc3QgdW5zdWJzID0gW1xuICAgIG1hY2hpbmUuZXZlbnRzLmRpZFJlY2VpdmVFdmVudC5zdWJzY3JpYmUoKGUpID0+IGxvZzIoYEV2ZW50ICR7ZS50eXBlfWApKSxcbiAgICBtYWNoaW5lLmV2ZW50cy53aWxsVHJhbnNpdGlvbi5zdWJzY3JpYmUoXG4gICAgICAoeyBmcm9tLCB0byB9KSA9PiBsb2cyKFwiVHJhbnNpdGlvbmluZ1wiLCBmcm9tLCBcIlxcdTIxOTJcIiwgdG8pXG4gICAgKSxcbiAgICBtYWNoaW5lLmV2ZW50cy5kaWRJZ25vcmVFdmVudC5zdWJzY3JpYmUoXG4gICAgICAoZSkgPT4gbG9nMihcIklnbm9yZWQgZXZlbnRcIiwgZS50eXBlLCBlLCBcIihjdXJyZW50IHN0YXRlIHdvbid0IGhhbmRsZSBpdClcIilcbiAgICApXG4gICAgLy8gbWFjaGluZS5ldmVudHMud2lsbEV4aXRTdGF0ZS5zdWJzY3JpYmUoKHMpID0+IGxvZyhcIkV4aXRpbmcgc3RhdGVcIiwgcykpLFxuICAgIC8vIG1hY2hpbmUuZXZlbnRzLmRpZEVudGVyU3RhdGUuc3Vic2NyaWJlKChzKSA9PiBsb2coXCJFbnRlcmluZyBzdGF0ZVwiLCBzKSksXG4gIF07XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZm9yIChjb25zdCB1bnN1YiBvZiB1bnN1YnMpIHtcbiAgICAgIHVuc3ViKCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZGVmaW5lQ29ubmVjdGl2aXR5RXZlbnRzKG1hY2hpbmUpIHtcbiAgY29uc3Qgc3RhdHVzRGlkQ2hhbmdlID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGNvbnN0IGRpZENvbm5lY3QgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgY29uc3QgZGlkRGlzY29ubmVjdCA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBsZXQgbGFzdFN0YXR1cyA9IG51bGw7XG4gIGNvbnN0IHVuc3Vic2NyaWJlID0gbWFjaGluZS5ldmVudHMuZGlkRW50ZXJTdGF0ZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJTdGF0dXMgPSB0b05ld0Nvbm5lY3Rpb25TdGF0dXMobWFjaGluZSk7XG4gICAgaWYgKGN1cnJTdGF0dXMgIT09IGxhc3RTdGF0dXMpIHtcbiAgICAgIHN0YXR1c0RpZENoYW5nZS5ub3RpZnkoY3VyclN0YXR1cyk7XG4gICAgfVxuICAgIGlmIChsYXN0U3RhdHVzID09PSBcImNvbm5lY3RlZFwiICYmIGN1cnJTdGF0dXMgIT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIGRpZERpc2Nvbm5lY3Qubm90aWZ5KCk7XG4gICAgfSBlbHNlIGlmIChsYXN0U3RhdHVzICE9PSBcImNvbm5lY3RlZFwiICYmIGN1cnJTdGF0dXMgPT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIGRpZENvbm5lY3Qubm90aWZ5KCk7XG4gICAgfVxuICAgIGxhc3RTdGF0dXMgPSBjdXJyU3RhdHVzO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXNEaWRDaGFuZ2U6IHN0YXR1c0RpZENoYW5nZS5vYnNlcnZhYmxlLFxuICAgIGRpZENvbm5lY3Q6IGRpZENvbm5lY3Qub2JzZXJ2YWJsZSxcbiAgICBkaWREaXNjb25uZWN0OiBkaWREaXNjb25uZWN0Lm9ic2VydmFibGUsXG4gICAgdW5zdWJzY3JpYmVcbiAgfTtcbn1cbnZhciBhc3NpZ24gPSAocGF0Y2gpID0+IChjdHgpID0+IGN0eC5wYXRjaChwYXRjaCk7XG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uU3RhdGVNYWNoaW5lKGRlbGVnYXRlcywgb3B0aW9ucykge1xuICBjb25zdCBvbk1lc3NhZ2UgPSBtYWtlQnVmZmVyYWJsZUV2ZW50U291cmNlKCk7XG4gIG9uTWVzc2FnZS5wYXVzZSgpO1xuICBjb25zdCBvbkNvbm5lY3Rpb25FcnJvciA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBmdW5jdGlvbiBmaXJlRXJyb3JFdmVudChtZXNzYWdlLCBjb2RlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG9uQ29ubmVjdGlvbkVycm9yLm5vdGlmeSh7IG1lc3NhZ2UsIGNvZGUgfSk7XG4gICAgfTtcbiAgfVxuICBjb25zdCBpbml0aWFsQ29udGV4dCA9IHtcbiAgICBzdWNjZXNzQ291bnQ6IDAsXG4gICAgYXV0aFZhbHVlOiBudWxsLFxuICAgIHNvY2tldDogbnVsbCxcbiAgICBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZXG4gIH07XG4gIGNvbnN0IG1hY2hpbmUgPSBuZXcgRlNNKGluaXRpYWxDb250ZXh0KS5hZGRTdGF0ZShcIkBpZGxlLmluaXRpYWxcIikuYWRkU3RhdGUoXCJAaWRsZS5mYWlsZWRcIikuYWRkU3RhdGUoXCJAaWRsZS56b21iaWVcIikuYWRkU3RhdGUoXCJAYXV0aC5idXN5XCIpLmFkZFN0YXRlKFwiQGF1dGguYmFja29mZlwiKS5hZGRTdGF0ZShcIkBjb25uZWN0aW5nLmJ1c3lcIikuYWRkU3RhdGUoXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIpLmFkZFN0YXRlKFwiQG9rLmNvbm5lY3RlZFwiKS5hZGRTdGF0ZShcIkBvay5hd2FpdGluZy1wb25nXCIpO1xuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiKlwiLCB7XG4gICAgUkVDT05ORUNUOiB7XG4gICAgICB0YXJnZXQ6IFwiQGF1dGguYmFja29mZlwiLFxuICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIHJlc2V0U3VjY2Vzc0NvdW50XVxuICAgIH0sXG4gICAgRElTQ09OTkVDVDogXCJAaWRsZS5pbml0aWFsXCJcbiAgfSk7XG4gIG1hY2hpbmUub25FbnRlcihcIkBpZGxlLipcIiwgcmVzZXRTdWNjZXNzQ291bnQpLmFkZFRyYW5zaXRpb25zKFwiQGlkbGUuKlwiLCB7XG4gICAgQ09OTkVDVDogKF8sIGN0eCkgPT4gKFxuICAgICAgLy8gSWYgd2Ugc3RpbGwgaGF2ZSBhIGtub3duIGF1dGhWYWx1ZSwgdHJ5IHRvIHJlY29ubmVjdCB0byB0aGUgc29ja2V0IGRpcmVjdGx5LFxuICAgICAgLy8gb3RoZXJ3aXNlLCB0cnkgdG8gb2J0YWluIGEgbmV3IGF1dGhWYWx1ZVxuICAgICAgY3R4LmF1dGhWYWx1ZSAhPT0gbnVsbCA/IFwiQGNvbm5lY3RpbmcuYnVzeVwiIDogXCJAYXV0aC5idXN5XCJcbiAgICApXG4gIH0pO1xuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiQGF1dGguYmFja29mZlwiLCB7XG4gICAgTkFWSUdBVE9SX09OTElORToge1xuICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJ1c3lcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHsgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWSB9KVxuICAgIH1cbiAgfSkuYWRkVGltZWRUcmFuc2l0aW9uKFxuICAgIFwiQGF1dGguYmFja29mZlwiLFxuICAgIChjdHgpID0+IGN0eC5iYWNrb2ZmRGVsYXksXG4gICAgXCJAYXV0aC5idXN5XCJcbiAgKS5vbkVudGVyQXN5bmMoXG4gICAgXCJAYXV0aC5idXN5XCIsXG4gICAgKCkgPT4gd2l0aFRpbWVvdXQoXG4gICAgICBkZWxlZ2F0ZXMuYXV0aGVudGljYXRlKCksXG4gICAgICBBVVRIX1RJTUVPVVQsXG4gICAgICBcIlRpbWVkIG91dCBkdXJpbmcgYXV0aFwiXG4gICAgKSxcbiAgICAvLyBPbiBzdWNjZXNzZnVsIGF1dGhlbnRpY2F0aW9uXG4gICAgKG9rRXZlbnQpID0+ICh7XG4gICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgICAgZWZmZWN0OiBhc3NpZ24oe1xuICAgICAgICBhdXRoVmFsdWU6IG9rRXZlbnQuZGF0YVxuICAgICAgfSlcbiAgICB9KSxcbiAgICAvLyBBdXRoIGZhaWxlZFxuICAgIChmYWlsZWRFdmVudCkgPT4ge1xuICAgICAgaWYgKGZhaWxlZEV2ZW50LnJlYXNvbiBpbnN0YW5jZW9mIFN0b3BSZXRyeWluZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgIGxvZygyIC8qIEVSUk9SICovLCBmYWlsZWRFdmVudC5yZWFzb24ubWVzc2FnZSksXG4gICAgICAgICAgICBmaXJlRXJyb3JFdmVudChmYWlsZWRFdmVudC5yZWFzb24ubWVzc2FnZSwgLTEpXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgaW5jcmVhc2VCYWNrb2ZmRGVsYXksXG4gICAgICAgICAgbG9nKFxuICAgICAgICAgICAgMiAvKiBFUlJPUiAqLyxcbiAgICAgICAgICAgIGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7ZmFpbGVkRXZlbnQucmVhc29uIGluc3RhbmNlb2YgRXJyb3IgPyBmYWlsZWRFdmVudC5yZWFzb24ubWVzc2FnZSA6IFN0cmluZyhmYWlsZWRFdmVudC5yZWFzb24pfWBcbiAgICAgICAgICApXG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgfVxuICApO1xuICBjb25zdCBvblNvY2tldEVycm9yID0gKGV2ZW50KSA9PiBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIkVYUExJQ0lUX1NPQ0tFVF9FUlJPUlwiLCBldmVudCB9KTtcbiAgY29uc3Qgb25Tb2NrZXRDbG9zZSA9IChldmVudCkgPT4gbWFjaGluZS5zZW5kKHsgdHlwZTogXCJFWFBMSUNJVF9TT0NLRVRfQ0xPU0VcIiwgZXZlbnQgfSk7XG4gIGNvbnN0IG9uU29ja2V0TWVzc2FnZSA9IChldmVudCkgPT4gZXZlbnQuZGF0YSA9PT0gXCJwb25nXCIgPyBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIlBPTkdcIiB9KSA6IG9uTWVzc2FnZS5ub3RpZnkoZXZlbnQpO1xuICBmdW5jdGlvbiB0ZWFyZG93blNvY2tldChzb2NrZXQpIHtcbiAgICBpZiAoc29ja2V0KSB7XG4gICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uU29ja2V0RXJyb3IpO1xuICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCBvblNvY2tldENsb3NlKTtcbiAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvblNvY2tldE1lc3NhZ2UpO1xuICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgfVxuICB9XG4gIG1hY2hpbmUuYWRkVHJhbnNpdGlvbnMoXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsIHtcbiAgICBOQVZJR0FUT1JfT05MSU5FOiB7XG4gICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgICAgZWZmZWN0OiBhc3NpZ24oeyBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZIH0pXG4gICAgfVxuICB9KS5hZGRUaW1lZFRyYW5zaXRpb24oXG4gICAgXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgKGN0eCkgPT4gY3R4LmJhY2tvZmZEZWxheSxcbiAgICBcIkBjb25uZWN0aW5nLmJ1c3lcIlxuICApLm9uRW50ZXJBc3luYyhcbiAgICBcIkBjb25uZWN0aW5nLmJ1c3lcIixcbiAgICAvL1xuICAgIC8vIFVzZSB0aGUgXCJjcmVhdGVTb2NrZXRcIiBkZWxlZ2F0ZSBmdW5jdGlvbiAocHJvdmlkZWQgdG8gdGhlXG4gICAgLy8gTWFuYWdlZFNvY2tldCkgdG8gY3JlYXRlIHRoZSBhY3R1YWwgV2ViU29ja2V0IGNvbm5lY3Rpb24gaW5zdGFuY2UuXG4gICAgLy8gVGhlbiwgc2V0IHVwIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycywgYW5kIHdhaXQgZm9yIHRoZVxuICAgIC8vIFwib3BlblwiIGV2ZW50IHRvIG9jY3VyLlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGUgXCJvcGVuXCIgZXZlbnQgaGFwcGVucywgd2UncmUgcmVhZHkgdG8gdHJhbnNpdGlvbiB0byB0aGVcbiAgICAvLyBPSyBzdGF0ZS4gVGhpcyBpcyBkb25lIGJ5IHJlc29sdmluZyB0aGUgUHJvbWlzZS5cbiAgICAvL1xuICAgIGFzeW5jIChjdHgsIHNpZ25hbCkgPT4ge1xuICAgICAgbGV0IGNhcHR1cmVkUHJlbWF0dXJlRXZlbnQgPSBudWxsO1xuICAgICAgbGV0IHVuY29uZmlybWVkU29ja2V0ID0gbnVsbDtcbiAgICAgIGNvbnN0IGNvbm5lY3QkID0gbmV3IFByb21pc2UoXG4gICAgICAgIChyZXNvbHZlLCByZWopID0+IHtcbiAgICAgICAgICBpZiAoY3R4LmF1dGhWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXV0aCBhdXRoVmFsdWVcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNvY2tldCA9IGRlbGVnYXRlcy5jcmVhdGVTb2NrZXQoY3R4LmF1dGhWYWx1ZSk7XG4gICAgICAgICAgdW5jb25maXJtZWRTb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgICAgZnVuY3Rpb24gcmVqZWN0KGV2ZW50KSB7XG4gICAgICAgICAgICBjYXB0dXJlZFByZW1hdHVyZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25Tb2NrZXRNZXNzYWdlKTtcbiAgICAgICAgICAgIHJlaihldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IFthY3RvciQsIGRpZFJlY2VpdmVBY3Rvcl0gPSBjb250cm9sbGVkUHJvbWlzZSgpO1xuICAgICAgICAgIGlmICghb3B0aW9ucy53YWl0Rm9yQWN0b3JJZCkge1xuICAgICAgICAgICAgZGlkUmVjZWl2ZUFjdG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHdhaXRGb3JBY3RvcklkKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJNc2cgPSB0cnlQYXJzZUpzb24oZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICBpZiAoc2VydmVyTXNnPy50eXBlID09PSAxMDQgLyogUk9PTV9TVEFURSAqLykge1xuICAgICAgICAgICAgICBkaWRSZWNlaXZlQWN0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uU29ja2V0TWVzc2FnZSk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMud2FpdEZvckFjdG9ySWQpIHtcbiAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB3YWl0Rm9yQWN0b3JJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIHJlamVjdCk7XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsICgpID0+IHtcbiAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Tb2NrZXRFcnJvcik7XG4gICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIG9uU29ja2V0Q2xvc2UpO1xuICAgICAgICAgICAgY29uc3QgdW5zdWIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCByZWplY3QpO1xuICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgd2FpdEZvckFjdG9ySWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZvaWQgYWN0b3IkLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKFtzb2NrZXQsIHVuc3ViXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiB3aXRoVGltZW91dChcbiAgICAgICAgY29ubmVjdCQsXG4gICAgICAgIFNPQ0tFVF9DT05ORUNUX1RJTUVPVVQsXG4gICAgICAgIFwiVGltZWQgb3V0IGR1cmluZyB3ZWJzb2NrZXQgY29ubmVjdGlvblwiXG4gICAgICApLnRoZW4oXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFBhcnQgMzpcbiAgICAgICAgLy8gQnkgbm93LCBvdXIgXCJvcGVuXCIgZXZlbnQgaGFzIGZpcmVkLCBhbmQgdGhlIHByb21pc2UgaGFzIGJlZW5cbiAgICAgICAgLy8gcmVzb2x2ZWQuIFR3byBwb3NzaWJsZSBzY2VuYXJpb3M6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIDEuIFRoZSBoYXBweSBwYXRoLiBNb3N0IGxpa2VseS5cbiAgICAgICAgLy8gMi4gVWgtb2guIEEgcHJlbWF0dXJlIGNsb3NlL2Vycm9yIGV2ZW50IGhhcyBiZWVuIG9ic2VydmVkLiBMZXQnc1xuICAgICAgICAvLyAgICByZWplY3QgdGhlIHByb21pc2UgYWZ0ZXIgYWxsLlxuICAgICAgICAvL1xuICAgICAgICAvLyBBbnkgY2xvc2UvZXJyb3IgZXZlbnQgdGhhdCB3aWxsIGdldCBzY2hlZHVsZWQgYWZ0ZXIgdGhpcyBwb2ludFxuICAgICAgICAvLyBvbndhcmRzLCB3aWxsIGJlIGNhdWdodCBpbiB0aGUgT0sgc3RhdGUsIGFuZCBkZWFsdCB3aXRoXG4gICAgICAgIC8vIGFjY29yZGluZ2x5LlxuICAgICAgICAvL1xuICAgICAgICAoW3NvY2tldCwgdW5zdWJdKSA9PiB7XG4gICAgICAgICAgdW5zdWIoKTtcbiAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFib3J0ZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYXB0dXJlZFByZW1hdHVyZUV2ZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBjYXB0dXJlZFByZW1hdHVyZUV2ZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc29ja2V0O1xuICAgICAgICB9XG4gICAgICApLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIHRlYXJkb3duU29ja2V0KHVuY29uZmlybWVkU29ja2V0KTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gT25seSB0cmFuc2l0aW9uIHRvIE9LIHN0YXRlIGFmdGVyIGEgc3VjY2Vzc2Z1bGx5IG9wZW5lZCBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAgIChva0V2ZW50KSA9PiAoe1xuICAgICAgdGFyZ2V0OiBcIkBvay5jb25uZWN0ZWRcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHtcbiAgICAgICAgc29ja2V0OiBva0V2ZW50LmRhdGEsXG4gICAgICAgIGJhY2tvZmZEZWxheTogUkVTRVRfREVMQVlcbiAgICAgIH0pXG4gICAgfSksXG4gICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGNhbm5vdCBiZSBlc3RhYmxpc2hlZFxuICAgIChmYWlsdXJlKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSBmYWlsdXJlLnJlYXNvbjtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBTdG9wUmV0cnlpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiQGlkbGUuZmFpbGVkXCIsXG4gICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICBsb2coMiAvKiBFUlJPUiAqLywgZXJyLm1lc3NhZ2UpLFxuICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZXJyLm1lc3NhZ2UsIC0xKVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Nsb3NlRXZlbnQoZXJyKSkge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDQxMDkgLyogVE9LRU5fRVhQSVJFRCAqLykge1xuICAgICAgICAgIHJldHVybiBcIkBhdXRoLmJ1c3lcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkUmV0cnlXaXRob3V0UmVhdXRoKGVyci5jb2RlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICAgIGluY3JlYXNlQmFja29mZkRlbGF5QWdncmVzc2l2ZWx5LFxuICAgICAgICAgICAgICBsb2dQcmVtYXR1cmVFcnJvck9yQ2xvc2VFdmVudChlcnIpXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkRGlzY29ubmVjdChlcnIuY29kZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFyZ2V0OiBcIkBpZGxlLmZhaWxlZFwiLFxuICAgICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICAgIGxvZygyIC8qIEVSUk9SICovLCBlcnIucmVhc29uKSxcbiAgICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZXJyLnJlYXNvbiwgZXJyLmNvZGUpXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIGxvZ1ByZW1hdHVyZUVycm9yT3JDbG9zZUV2ZW50KGVycildXG4gICAgICB9O1xuICAgIH1cbiAgKTtcbiAgY29uc3Qgc2VuZEhlYXJ0YmVhdCA9IHtcbiAgICB0YXJnZXQ6IFwiQG9rLmF3YWl0aW5nLXBvbmdcIixcbiAgICBlZmZlY3Q6IChjdHgpID0+IHtcbiAgICAgIGN0eC5zb2NrZXQ/LnNlbmQoXCJwaW5nXCIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbWF5YmVIZWFydGJlYXQgPSAoKSA9PiB7XG4gICAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gICAgY29uc3QgY2FuWm9tYmllID0gZG9jPy52aXNpYmlsaXR5U3RhdGUgPT09IFwiaGlkZGVuXCIgJiYgZGVsZWdhdGVzLmNhblpvbWJpZSgpO1xuICAgIHJldHVybiBjYW5ab21iaWUgPyBcIkBpZGxlLnpvbWJpZVwiIDogc2VuZEhlYXJ0YmVhdDtcbiAgfTtcbiAgbWFjaGluZS5hZGRUaW1lZFRyYW5zaXRpb24oXCJAb2suY29ubmVjdGVkXCIsIEhFQVJUQkVBVF9JTlRFUlZBTCwgbWF5YmVIZWFydGJlYXQpLmFkZFRyYW5zaXRpb25zKFwiQG9rLmNvbm5lY3RlZFwiLCB7XG4gICAgTkFWSUdBVE9SX09GRkxJTkU6IG1heWJlSGVhcnRiZWF0LFxuICAgIC8vIERvbid0IHRha2UgdGhlIGJyb3dzZXIncyB3b3JkIGZvciBpdCB3aGVuIGl0IHNheXMgaXQncyBvZmZsaW5lLiBEbyBhIHBpbmcvcG9uZyB0byBtYWtlIHN1cmUuXG4gICAgV0lORE9XX0dPVF9GT0NVUzogc2VuZEhlYXJ0YmVhdFxuICB9KTtcbiAgbWFjaGluZS5hZGRUcmFuc2l0aW9ucyhcIkBpZGxlLnpvbWJpZVwiLCB7XG4gICAgV0lORE9XX0dPVF9GT0NVUzogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCJcbiAgICAvLyBXaGVuIGluIHpvbWJpZSBzdGF0ZSwgdGhlIGNsaWVudCB3aWxsIHRyeSB0byB3YWtlIHVwIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgd2luZG93IHJlZ2FpbnMgZm9jdXNcbiAgfSk7XG4gIG1hY2hpbmUub25FbnRlcihcIkBvay4qXCIsIChjdHgpID0+IHtcbiAgICBjdHgucGF0Y2goeyBzdWNjZXNzQ291bnQ6IGN0eC5zdWNjZXNzQ291bnQgKyAxIH0pO1xuICAgIGNvbnN0IHRpbWVySUQgPSBzZXRUaW1lb3V0KFxuICAgICAgLy8gT24gdGhlIG5leHQgdGljaywgc3RhcnQgZGVsaXZlcmluZyBhbGwgbWVzc2FnZXMgdGhhdCBoYXZlIGFscmVhZHlcbiAgICAgIC8vIGJlZW4gcmVjZWl2ZWQsIGFuZCBjb250aW51ZSBzeW5jaHJvbm91cyBkZWxpdmVyeSBvZiBhbGwgZnV0dXJlXG4gICAgICAvLyBpbmNvbWluZyBtZXNzYWdlcy5cbiAgICAgIG9uTWVzc2FnZS51bnBhdXNlLFxuICAgICAgMFxuICAgICk7XG4gICAgcmV0dXJuIChjdHgyKSA9PiB7XG4gICAgICB0ZWFyZG93blNvY2tldChjdHgyLnNvY2tldCk7XG4gICAgICBjdHgyLnBhdGNoKHsgc29ja2V0OiBudWxsIH0pO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySUQpO1xuICAgICAgb25NZXNzYWdlLnBhdXNlKCk7XG4gICAgfTtcbiAgfSkuYWRkVHJhbnNpdGlvbnMoXCJAb2suYXdhaXRpbmctcG9uZ1wiLCB7IFBPTkc6IFwiQG9rLmNvbm5lY3RlZFwiIH0pLmFkZFRpbWVkVHJhbnNpdGlvbihcIkBvay5hd2FpdGluZy1wb25nXCIsIFBPTkdfVElNRU9VVCwge1xuICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5idXN5XCIsXG4gICAgLy8gTG9nIGltcGxpY2l0IGNvbm5lY3Rpb24gbG9zcyBhbmQgZHJvcCB0aGUgY3VycmVudCBvcGVuIHNvY2tldFxuICAgIGVmZmVjdDogbG9nKFxuICAgICAgMSAvKiBXQVJOICovLFxuICAgICAgXCJSZWNlaXZlZCBubyBwb25nIGZyb20gc2VydmVyLCBhc3N1bWUgaW1wbGljaXQgY29ubmVjdGlvbiBsb3NzLlwiXG4gICAgKVxuICB9KS5hZGRUcmFuc2l0aW9ucyhcIkBvay4qXCIsIHtcbiAgICAvLyBXaGVuIGEgc29ja2V0IHJlY2VpdmVzIGFuIGVycm9yLCB0aGlzIGNhbiBjYXVzZSB0aGUgY2xvc2luZyBvZiB0aGVcbiAgICAvLyBzb2NrZXQsIG9yIG5vdC4gU28gYWx3YXlzIGNoZWNrIHRvIHNlZSBpZiB0aGUgc29ja2V0IGlzIHN0aWxsIE9QRU4gb3JcbiAgICAvLyBub3QuIFdoZW4gc3RpbGwgT1BFTiwgZG9uJ3QgdHJhbnNpdGlvbi5cbiAgICBFWFBMSUNJVF9TT0NLRVRfRVJST1I6IChfLCBjb250ZXh0KSA9PiB7XG4gICAgICBpZiAoY29udGV4dC5zb2NrZXQ/LnJlYWR5U3RhdGUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICBlZmZlY3Q6IGluY3JlYXNlQmFja29mZkRlbGF5XG4gICAgICB9O1xuICAgIH0sXG4gICAgRVhQTElDSVRfU09DS0VUX0NMT1NFOiAoZSkgPT4ge1xuICAgICAgaWYgKHNob3VsZERpc2Nvbm5lY3QoZS5ldmVudC5jb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgIGxvZ1Blcm1hbmVudENsb3NlLFxuICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZS5ldmVudC5yZWFzb24sIGUuZXZlbnQuY29kZSlcbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmVhdXRoKGUuZXZlbnQuY29kZSkpIHtcbiAgICAgICAgaWYgKGUuZXZlbnQuY29kZSA9PT0gNDEwOSAvKiBUT0tFTl9FWFBJUkVEICovKSB7XG4gICAgICAgICAgcmV0dXJuIFwiQGF1dGguYnVzeVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiQGF1dGguYmFja29mZlwiLFxuICAgICAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIGxvZ0Nsb3NlRXZlbnQoZS5ldmVudCldXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFJldHJ5V2l0aG91dFJlYXV0aChlLmV2ZW50LmNvZGUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAgICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheUFnZ3Jlc3NpdmVseSwgbG9nQ2xvc2VFdmVudChlLmV2ZW50KV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCBsb2dDbG9zZUV2ZW50KGUuZXZlbnQpXVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gICAgY29uc3Qgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHZvaWQgMDtcbiAgICBjb25zdCByb290ID0gd2luID8/IGRvYztcbiAgICBtYWNoaW5lLm9uRW50ZXIoXCIqXCIsIChjdHgpID0+IHtcbiAgICAgIGZ1bmN0aW9uIG9uTmV0d29ya09mZmxpbmUoKSB7XG4gICAgICAgIG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiTkFWSUdBVE9SX09GRkxJTkVcIiB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uTmV0d29ya0JhY2tPbmxpbmUoKSB7XG4gICAgICAgIG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiTkFWSUdBVE9SX09OTElORVwiIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb25WaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgICAgICBpZiAoZG9jPy52aXNpYmlsaXR5U3RhdGUgPT09IFwidmlzaWJsZVwiKSB7XG4gICAgICAgICAgbWFjaGluZS5zZW5kKHsgdHlwZTogXCJXSU5ET1dfR09UX0ZPQ1VTXCIgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdpbj8uYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBvbk5ldHdvcmtCYWNrT25saW5lKTtcbiAgICAgIHdpbj8uYWRkRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgb25OZXR3b3JrT2ZmbGluZSk7XG4gICAgICByb290Py5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcm9vdD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgICAgd2luPy5yZW1vdmVFdmVudExpc3RlbmVyKFwib25saW5lXCIsIG9uTmV0d29ya0JhY2tPbmxpbmUpO1xuICAgICAgICB3aW4/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIG9uTmV0d29ya09mZmxpbmUpO1xuICAgICAgICB0ZWFyZG93blNvY2tldChjdHguc29ja2V0KTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgY2xlYW51cHMgPSBbXTtcbiAgY29uc3QgeyBzdGF0dXNEaWRDaGFuZ2UsIGRpZENvbm5lY3QsIGRpZERpc2Nvbm5lY3QsIHVuc3Vic2NyaWJlIH0gPSBkZWZpbmVDb25uZWN0aXZpdHlFdmVudHMobWFjaGluZSk7XG4gIGNsZWFudXBzLnB1c2godW5zdWJzY3JpYmUpO1xuICBpZiAob3B0aW9ucy5lbmFibGVEZWJ1Z0xvZ2dpbmcpIHtcbiAgICBjbGVhbnVwcy5wdXNoKGVuYWJsZVRyYWNpbmcobWFjaGluZSkpO1xuICB9XG4gIG1hY2hpbmUuc3RhcnQoKTtcbiAgcmV0dXJuIHtcbiAgICBtYWNoaW5lLFxuICAgIGNsZWFudXBzLFxuICAgIC8vIE9ic2VydmFibGUgZXZlbnRzIHRoYXQgd2lsbCBiZSBlbWl0dGVkIGJ5IHRoaXMgbWFjaGluZVxuICAgIGV2ZW50czoge1xuICAgICAgc3RhdHVzRGlkQ2hhbmdlLFxuICAgICAgZGlkQ29ubmVjdCxcbiAgICAgIGRpZERpc2Nvbm5lY3QsXG4gICAgICBvbk1lc3NhZ2U6IG9uTWVzc2FnZS5vYnNlcnZhYmxlLFxuICAgICAgb25Db25uZWN0aW9uRXJyb3I6IG9uQ29ubmVjdGlvbkVycm9yLm9ic2VydmFibGVcbiAgICB9XG4gIH07XG59XG52YXIgTWFuYWdlZFNvY2tldCA9IGNsYXNzIHtcbiAgI21hY2hpbmU7XG4gICNjbGVhbnVwcztcbiAgZXZlbnRzO1xuICBjb25zdHJ1Y3RvcihkZWxlZ2F0ZXMsIGVuYWJsZURlYnVnTG9nZ2luZyA9IGZhbHNlLCB3YWl0Rm9yQWN0b3JJZCA9IHRydWUpIHtcbiAgICBjb25zdCB7IG1hY2hpbmUsIGV2ZW50cywgY2xlYW51cHMgfSA9IGNyZWF0ZUNvbm5lY3Rpb25TdGF0ZU1hY2hpbmUoXG4gICAgICBkZWxlZ2F0ZXMsXG4gICAgICB7IHdhaXRGb3JBY3RvcklkLCBlbmFibGVEZWJ1Z0xvZ2dpbmcgfVxuICAgICk7XG4gICAgdGhpcy4jbWFjaGluZSA9IG1hY2hpbmU7XG4gICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgdGhpcy4jY2xlYW51cHMgPSBjbGVhbnVwcztcbiAgfVxuICBnZXRTdGF0dXMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0b05ld0Nvbm5lY3Rpb25TdGF0dXModGhpcy4jbWFjaGluZSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gXCJpbml0aWFsXCI7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGF1dGggYXV0aFZhbHVlLlxuICAgKi9cbiAgZ2V0IGF1dGhWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jbWFjaGluZS5jb250ZXh0LmF1dGhWYWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCB0aGlzIG1ldGhvZCB0byB0cnkgdG8gY29ubmVjdCB0byBhIFdlYlNvY2tldC4gVGhpcyBvbmx5IGhhcyBhbiBlZmZlY3RcbiAgICogaWYgdGhlIG1hY2hpbmUgaXMgaWRsZSBhdCB0aGUgbW9tZW50LCBvdGhlcndpc2UgdGhpcyBpcyBhIG5vLW9wLlxuICAgKi9cbiAgY29ubmVjdCgpIHtcbiAgICB0aGlzLiNtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIkNPTk5FQ1RcIiB9KTtcbiAgfVxuICAvKipcbiAgICogSWYgaWRsZSwgd2lsbCB0cnkgdG8gY29ubmVjdC4gT3RoZXJ3aXNlLCBpdCB3aWxsIGF0dGVtcHQgdG8gcmVjb25uZWN0IHRvXG4gICAqIHRoZSBzb2NrZXQsIHBvdGVudGlhbGx5IG9idGFpbmluZyBhIG5ldyBhdXRoVmFsdWUgZmlyc3QsIGlmIG5lZWRlZC5cbiAgICovXG4gIHJlY29ubmVjdCgpIHtcbiAgICB0aGlzLiNtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIlJFQ09OTkVDVFwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgbWV0aG9kIHRvIGRpc2Nvbm5lY3QgZnJvbSB0aGUgY3VycmVudCBXZWJTb2NrZXQuIElzIGdvaW5nIHRvIGJlXG4gICAqIGEgbm8tb3AgaWYgdGhlcmUgaXMgbm8gYWN0aXZlIGNvbm5lY3Rpb24uXG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMuI21hY2hpbmUuc2VuZCh7IHR5cGU6IFwiRElTQ09OTkVDVFwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgdG8gc3RvcCB0aGUgbWFjaGluZSBhbmQgcnVuIG5lY2Vzc2FyeSBjbGVhbnVwIGZ1bmN0aW9ucy4gQWZ0ZXJcbiAgICogY2FsbGluZyBkZXN0cm95KCksIHlvdSBjYW4gbm8gbG9uZ2VyIHVzZSB0aGlzIGluc3RhbmNlLiBDYWxsIHRoaXMgYmVmb3JlXG4gICAqIGxldHRpbmcgdGhlIGluc3RhbmNlIGdldCBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jbWFjaGluZS5zdG9wKCk7XG4gICAgbGV0IGNsZWFudXA7XG4gICAgd2hpbGUgKGNsZWFudXAgPSB0aGlzLiNjbGVhbnVwcy5wb3AoKSkge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2FmZWx5IHNlbmQgYSBtZXNzYWdlIHRvIHRoZSBjdXJyZW50IFdlYlNvY2tldCBjb25uZWN0aW9uLiBXaWxsIGVtaXQgYSBsb2dcbiAgICogbWVzc2FnZSBpZiB0aGlzIGlzIHNvbWVob3cgaW1wb3NzaWJsZS5cbiAgICovXG4gIHNlbmQoZGF0YSkge1xuICAgIGNvbnN0IHNvY2tldCA9IHRoaXMuI21hY2hpbmUuY29udGV4dD8uc29ja2V0O1xuICAgIGlmIChzb2NrZXQgPT09IG51bGwpIHtcbiAgICAgIHdhcm4oXCJDYW5ub3Qgc2VuZDogbm90IGNvbm5lY3RlZCB5ZXRcIiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChzb2NrZXQucmVhZHlTdGF0ZSAhPT0gMSkge1xuICAgICAgd2FybihcIkNhbm5vdCBzZW5kOiBXZWJTb2NrZXQgbm8gbG9uZ2VyIG9wZW5cIiwgZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvY2tldC5zZW5kKGRhdGEpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTk9URTogVXNlZCBieSB0aGUgRTJFIGFwcCBvbmx5LCB0byBzaW11bGF0ZSBleHBsaWNpdCBldmVudHMuXG4gICAqIE5vdCBpZGVhbCB0byBrZWVwIGV4cG9zZWQgOihcbiAgICovXG4gIF9wcml2YXRlU2VuZE1hY2hpbmVFdmVudChldmVudCkge1xuICAgIHRoaXMuI21hY2hpbmUuc2VuZChldmVudCk7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm90b2NvbC9BdXRoVG9rZW4udHNcbnZhciBQZXJtaXNzaW9uID0gLyogQF9fUFVSRV9fICovICgoUGVybWlzc2lvbjIpID0+IHtcbiAgUGVybWlzc2lvbjJbXCJSZWFkXCJdID0gXCJyb29tOnJlYWRcIjtcbiAgUGVybWlzc2lvbjJbXCJXcml0ZVwiXSA9IFwicm9vbTp3cml0ZVwiO1xuICBQZXJtaXNzaW9uMltcIlByZXNlbmNlV3JpdGVcIl0gPSBcInJvb206cHJlc2VuY2U6d3JpdGVcIjtcbiAgUGVybWlzc2lvbjJbXCJDb21tZW50c1dyaXRlXCJdID0gXCJjb21tZW50czp3cml0ZVwiO1xuICBQZXJtaXNzaW9uMltcIkNvbW1lbnRzUmVhZFwiXSA9IFwiY29tbWVudHM6cmVhZFwiO1xuICByZXR1cm4gUGVybWlzc2lvbjI7XG59KShQZXJtaXNzaW9uIHx8IHt9KTtcbmZ1bmN0aW9uIGNhbldyaXRlU3RvcmFnZShzY29wZXMpIHtcbiAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG59XG5mdW5jdGlvbiBjYW5Db21tZW50KHNjb3Blcykge1xuICByZXR1cm4gc2NvcGVzLmluY2x1ZGVzKFwiY29tbWVudHM6d3JpdGVcIiAvKiBDb21tZW50c1dyaXRlICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xufVxuZnVuY3Rpb24gaXNWYWxpZEF1dGhUb2tlblBheWxvYWQoZGF0YSkge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdChkYXRhKSAmJiAoZGF0YS5rID09PSBcImFjY1wiIC8qIEFDQ0VTU19UT0tFTiAqLyB8fCBkYXRhLmsgPT09IFwiaWRcIiAvKiBJRF9UT0tFTiAqLyB8fCBkYXRhLmsgPT09IFwic2VjLWxlZ2FjeVwiIC8qIFNFQ1JFVF9MRUdBQ1kgKi8pO1xufVxuZnVuY3Rpb24gcGFyc2VBdXRoVG9rZW4ocmF3VG9rZW5TdHJpbmcpIHtcbiAgY29uc3QgdG9rZW5QYXJ0cyA9IHJhd1Rva2VuU3RyaW5nLnNwbGl0KFwiLlwiKTtcbiAgaWYgKHRva2VuUGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXV0aGVudGljYXRpb24gZXJyb3I6IGludmFsaWQgSldUIHRva2VuXCIpO1xuICB9XG4gIGNvbnN0IHBheWxvYWQgPSB0cnlQYXJzZUpzb24oYjY0ZGVjb2RlKHRva2VuUGFydHNbMV0pKTtcbiAgaWYgKCEocGF5bG9hZCAmJiBpc1ZhbGlkQXV0aFRva2VuUGF5bG9hZChwYXlsb2FkKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkF1dGhlbnRpY2F0aW9uIGVycm9yOiBleHBlY3RlZCBhIHZhbGlkIHRva2VuIGJ1dCBkaWQgbm90IGdldCBvbmUuIEhpbnQ6IGlmIHlvdSBhcmUgdXNpbmcgYSBjYWxsYmFjaywgZW5zdXJlIHRoZSByb29tIGlzIHBhc3NlZCB3aGVuIGNyZWF0aW5nIHRoZSB0b2tlbi4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50Q2FsbGJhY2tcIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByYXc6IHJhd1Rva2VuU3RyaW5nLFxuICAgIHBhcnNlZDogcGF5bG9hZFxuICB9O1xufVxuXG4vLyBzcmMvYXV0aC1tYW5hZ2VyLnRzXG5mdW5jdGlvbiBjcmVhdGVBdXRoTWFuYWdlcihhdXRoT3B0aW9ucywgb25BdXRoZW50aWNhdGUpIHtcbiAgY29uc3QgYXV0aGVudGljYXRpb24gPSBwcmVwYXJlQXV0aGVudGljYXRpb24oYXV0aE9wdGlvbnMpO1xuICBjb25zdCBzZWVuVG9rZW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgdG9rZW5zID0gW107XG4gIGNvbnN0IGV4cGlyeVRpbWVzID0gW107XG4gIGNvbnN0IHJlcXVlc3RQcm9taXNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHNlZW5Ub2tlbnMuY2xlYXIoKTtcbiAgICB0b2tlbnMubGVuZ3RoID0gMDtcbiAgICBleHBpcnlUaW1lcy5sZW5ndGggPSAwO1xuICAgIHJlcXVlc3RQcm9taXNlcy5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGhhc0NvcnJlc3BvbmRpbmdTY29wZXMocmVxdWVzdGVkU2NvcGUsIHNjb3Blcykge1xuICAgIGlmIChyZXF1ZXN0ZWRTY29wZSA9PT0gXCJjb21tZW50czpyZWFkXCIpIHtcbiAgICAgIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJjb21tZW50czpyZWFkXCIgLyogQ29tbWVudHNSZWFkICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJjb21tZW50czp3cml0ZVwiIC8qIENvbW1lbnRzV3JpdGUgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206cmVhZFwiIC8qIFJlYWQgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0ZWRTY29wZSA9PT0gXCJyb29tOnJlYWRcIikge1xuICAgICAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcInJvb206cmVhZFwiIC8qIFJlYWQgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDYWNoZWRUb2tlbihyZXF1ZXN0T3B0aW9ucykge1xuICAgIGNvbnN0IG5vdyA9IE1hdGguY2VpbChEYXRlLm5vdygpIC8gMWUzKTtcbiAgICBmb3IgKGxldCBpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IGV4cGlyeVRpbWVzW2ldO1xuICAgICAgaWYgKGV4cGlyZXNBdCA8PSBub3cpIHtcbiAgICAgICAgdG9rZW5zLnNwbGljZShpLCAxKTtcbiAgICAgICAgZXhwaXJ5VGltZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi5wYXJzZWQuayA9PT0gXCJpZFwiIC8qIElEX1RPS0VOICovKSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH0gZWxzZSBpZiAodG9rZW4ucGFyc2VkLmsgPT09IFwiYWNjXCIgLyogQUNDRVNTX1RPS0VOICovKSB7XG4gICAgICAgIGlmICghcmVxdWVzdE9wdGlvbnMucm9vbUlkICYmIE9iamVjdC5lbnRyaWVzKHRva2VuLnBhcnNlZC5wZXJtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW3Jlc291cmNlLCBzY29wZXNdIG9mIE9iamVjdC5lbnRyaWVzKHRva2VuLnBhcnNlZC5wZXJtcykpIHtcbiAgICAgICAgICBpZiAoIXJlcXVlc3RPcHRpb25zLnJvb21JZCkge1xuICAgICAgICAgICAgaWYgKHJlc291cmNlLmluY2x1ZGVzKFwiKlwiKSAmJiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKHJlcXVlc3RPcHRpb25zLnJlcXVlc3RlZFNjb3BlLCBzY29wZXMpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc291cmNlLmluY2x1ZGVzKFwiKlwiKSAmJiByZXF1ZXN0T3B0aW9ucy5yb29tSWQuc3RhcnRzV2l0aChyZXNvdXJjZS5yZXBsYWNlKFwiKlwiLCBcIlwiKSkgfHwgcmVxdWVzdE9wdGlvbnMucm9vbUlkID09PSByZXNvdXJjZSAmJiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKHJlcXVlc3RPcHRpb25zLnJlcXVlc3RlZFNjb3BlLCBzY29wZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFrZUF1dGhSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICBjb25zdCBmZXRjaGVyID0gYXV0aE9wdGlvbnMucG9seWZpbGxzPy5mZXRjaCA/PyAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IHdpbmRvdy5mZXRjaCk7XG4gICAgaWYgKGF1dGhlbnRpY2F0aW9uLnR5cGUgPT09IFwicHJpdmF0ZVwiKSB7XG4gICAgICBpZiAoZmV0Y2hlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgICAgXCJUbyB1c2UgTGl2ZWJsb2NrcyBjbGllbnQgaW4gYSBub24tRE9NIGVudmlyb25tZW50IHdpdGggYSB1cmwgYXMgYXV0aCBlbmRwb2ludCwgeW91IG5lZWQgdG8gcHJvdmlkZSBhIGZldGNoIHBvbHlmaWxsLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQXV0aEVuZHBvaW50KGZldGNoZXIsIGF1dGhlbnRpY2F0aW9uLnVybCwge1xuICAgICAgICByb29tOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSk7XG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUF1dGhUb2tlbihyZXNwb25zZS50b2tlbik7XG4gICAgICBpZiAoc2VlblRva2Vucy5oYXMocGFyc2VkLnJhdykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhcbiAgICAgICAgICBcIlRoZSBzYW1lIExpdmVibG9ja3MgYXV0aCB0b2tlbiB3YXMgaXNzdWVkIGZyb20gdGhlIGJhY2tlbmQgYmVmb3JlLiBDYWNoaW5nIExpdmVibG9ja3MgdG9rZW5zIGlzIG5vdCBzdXBwb3J0ZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG9uQXV0aGVudGljYXRlPy4ocGFyc2VkLnBhcnNlZCk7XG4gICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cbiAgICBpZiAoYXV0aGVudGljYXRpb24udHlwZSA9PT0gXCJjdXN0b21cIikge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhdXRoZW50aWNhdGlvbi5jYWxsYmFjayhvcHRpb25zLnJvb21JZCk7XG4gICAgICBpZiAocmVzcG9uc2UgJiYgdHlwZW9mIHJlc3BvbnNlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UudG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUF1dGhUb2tlbihyZXNwb25zZS50b2tlbik7XG4gICAgICAgICAgb25BdXRoZW50aWNhdGU/LihwYXJzZWQucGFyc2VkKTtcbiAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZS5lcnJvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7XCJyZWFzb25cIiBpbiByZXNwb25zZSAmJiB0eXBlb2YgcmVzcG9uc2UucmVhc29uID09PSBcInN0cmluZ1wiID8gcmVzcG9uc2UucmVhc29uIDogXCJGb3JiaWRkZW5cIn1gO1xuICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvciA9PT0gXCJmb3JiaWRkZW5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhyZWFzb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhc29uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1lvdXIgYXV0aGVudGljYXRpb24gY2FsbGJhY2sgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIHRva2VuLCBidXQgaXQgZGlkIG5vdC4gSGludDogdGhlIHJldHVybiB2YWx1ZSBzaG91bGQgbG9vayBsaWtlOiB7IHRva2VuOiBcIi4uLlwiIH0nXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlVuZXhwZWN0ZWQgYXV0aGVudGljYXRpb24gdHlwZS4gTXVzdCBiZSBwcml2YXRlIG9yIGN1c3RvbS5cIlxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0QXV0aFZhbHVlKHJlcXVlc3RPcHRpb25zKSB7XG4gICAgaWYgKGF1dGhlbnRpY2F0aW9uLnR5cGUgPT09IFwicHVibGljXCIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwicHVibGljXCIsIHB1YmxpY0FwaUtleTogYXV0aGVudGljYXRpb24ucHVibGljQXBpS2V5IH07XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlZFRva2VuID0gZ2V0Q2FjaGVkVG9rZW4ocmVxdWVzdE9wdGlvbnMpO1xuICAgIGlmIChjYWNoZWRUb2tlbiAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInNlY3JldFwiLCB0b2tlbjogY2FjaGVkVG9rZW4gfTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRQcm9taXNlO1xuICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5yb29tSWQpIHtcbiAgICAgIGN1cnJlbnRQcm9taXNlID0gcmVxdWVzdFByb21pc2VzLmdldChyZXF1ZXN0T3B0aW9ucy5yb29tSWQpO1xuICAgICAgaWYgKGN1cnJlbnRQcm9taXNlID09PSB2b2lkIDApIHtcbiAgICAgICAgY3VycmVudFByb21pc2UgPSBtYWtlQXV0aFJlcXVlc3QocmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXMuc2V0KHJlcXVlc3RPcHRpb25zLnJvb21JZCwgY3VycmVudFByb21pc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHJlcXVlc3RQcm9taXNlcy5nZXQoXCJsaXZlYmxvY2tzLXVzZXItdG9rZW5cIik7XG4gICAgICBpZiAoY3VycmVudFByb21pc2UgPT09IHZvaWQgMCkge1xuICAgICAgICBjdXJyZW50UHJvbWlzZSA9IG1ha2VBdXRoUmVxdWVzdChyZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIHJlcXVlc3RQcm9taXNlcy5zZXQoXCJsaXZlYmxvY2tzLXVzZXItdG9rZW5cIiwgY3VycmVudFByb21pc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCBjdXJyZW50UHJvbWlzZTtcbiAgICAgIGNvbnN0IEJVRkZFUiA9IDMwO1xuICAgICAgY29uc3QgZXhwaXJlc0F0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKSArICh0b2tlbi5wYXJzZWQuZXhwIC0gdG9rZW4ucGFyc2VkLmlhdCkgLSBCVUZGRVI7XG4gICAgICBzZWVuVG9rZW5zLmFkZCh0b2tlbi5yYXcpO1xuICAgICAgaWYgKHRva2VuLnBhcnNlZC5rICE9PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgZXhwaXJ5VGltZXMucHVzaChleHBpcmVzQXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJzZWNyZXRcIiwgdG9rZW4gfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHJlcXVlc3RPcHRpb25zLnJvb21JZCkge1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXMuZGVsZXRlKHJlcXVlc3RPcHRpb25zLnJvb21JZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXMuZGVsZXRlKFwibGl2ZWJsb2Nrcy11c2VyLXRva2VuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHJlc2V0LFxuICAgIGdldEF1dGhWYWx1ZVxuICB9O1xufVxuZnVuY3Rpb24gcHJlcGFyZUF1dGhlbnRpY2F0aW9uKGF1dGhPcHRpb25zKSB7XG4gIGNvbnN0IHsgcHVibGljQXBpS2V5LCBhdXRoRW5kcG9pbnQgfSA9IGF1dGhPcHRpb25zO1xuICBpZiAoYXV0aEVuZHBvaW50ICE9PSB2b2lkIDAgJiYgcHVibGljQXBpS2V5ICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIllvdSBjYW5ub3Qgc2ltdWx0YW5lb3VzbHkgdXNlIGBwdWJsaWNBcGlLZXlgIGFuZCBgYXV0aEVuZHBvaW50YCBvcHRpb25zLiBQbGVhc2UgcGljayBvbmUgYW5kIGxlYXZlIHRoZSBvdGhlciBvcHRpb24gdW5zcGVjaWZpZWQuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudFwiXG4gICAgKTtcbiAgfVxuICBpZiAodHlwZW9mIHB1YmxpY0FwaUtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChwdWJsaWNBcGlLZXkuc3RhcnRzV2l0aChcInNrX1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkludmFsaWQgYHB1YmxpY0FwaUtleWAgb3B0aW9uLiBUaGUgdmFsdWUgeW91IHBhc3NlZCBpcyBhIHNlY3JldCBrZXksIHdoaWNoIHNob3VsZCBub3QgYmUgdXNlZCBmcm9tIHRoZSBjbGllbnQuIFBsZWFzZSBvbmx5IGV2ZXIgcGFzcyBhIHB1YmxpYyBrZXkgaGVyZS4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50UHVibGljS2V5XCJcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghcHVibGljQXBpS2V5LnN0YXJ0c1dpdGgoXCJwa19cIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJJbnZhbGlkIGtleS4gUGxlYXNlIHVzZSB0aGUgcHVibGljIGtleSBmb3JtYXQ6IHBrXzxwdWJsaWMga2V5Pi4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50UHVibGljS2V5XCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInB1YmxpY1wiLFxuICAgICAgcHVibGljQXBpS2V5XG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIGF1dGhFbmRwb2ludCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInByaXZhdGVcIixcbiAgICAgIHVybDogYXV0aEVuZHBvaW50XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXV0aEVuZHBvaW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjdXN0b21cIixcbiAgICAgIGNhbGxiYWNrOiBhdXRoRW5kcG9pbnRcbiAgICB9O1xuICB9IGVsc2UgaWYgKGF1dGhFbmRwb2ludCAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJUaGUgYGF1dGhFbmRwb2ludGAgb3B0aW9uIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvbi4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50QXV0aEVuZHBvaW50XCJcbiAgICApO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBcIkludmFsaWQgTGl2ZWJsb2NrcyBjbGllbnQgb3B0aW9ucy4gUGxlYXNlIHByb3ZpZGUgZWl0aGVyIGEgYHB1YmxpY0FwaUtleWAgb3IgYGF1dGhFbmRwb2ludGAgb3B0aW9uLiBUaGV5IGNhbm5vdCBib3RoIGJlIGVtcHR5LiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRcIlxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBdXRoRW5kcG9pbnQoZmV0Y2gsIGVuZHBvaW50LCBib2R5KSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGVuZHBvaW50LCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH0sXG4gICAgYm9keTogc3RyaW5naWZ5T3JMb2coYm9keSlcbiAgfSk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgY29uc3QgcmVhc29uID0gYCR7KGF3YWl0IHJlcy50ZXh0KCkpLnRyaW0oKSB8fCBcInJlYXNvbiBub3QgcHJvdmlkZWQgaW4gYXV0aCByZXNwb25zZVwifSAoJHtyZXMuc3RhdHVzfSByZXR1cm5lZCBieSBQT1NUICR7ZW5kcG9pbnR9KWA7XG4gICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwMSB8fCByZXMuc3RhdHVzID09PSA0MDMpIHtcbiAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoYFVuYXV0aG9yaXplZDogJHtyZWFzb259YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGF1dGhlbnRpY2F0ZTogJHtyZWFzb259YCk7XG4gICAgfVxuICB9XG4gIGxldCBkYXRhO1xuICB0cnkge1xuICAgIGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICB9IGNhdGNoIChlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHBlY3RlZCBhIEpTT04gcmVzcG9uc2Ugd2hlbiBkb2luZyBhIFBPU1QgcmVxdWVzdCBvbiBcIiR7ZW5kcG9pbnR9XCIuICR7U3RyaW5nKFxuICAgICAgICBlclxuICAgICAgKX1gXG4gICAgKTtcbiAgfVxuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkgfHwgdHlwZW9mIGRhdGEudG9rZW4gIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYSBKU09OIHJlc3BvbnNlIG9mIHRoZSBmb3JtIFxcYHsgdG9rZW46IFwiLi4uXCIgfVxcYCB3aGVuIGRvaW5nIGEgUE9TVCByZXF1ZXN0IG9uIFwiJHtlbmRwb2ludH1cIiwgYnV0IGdvdCAke3N0cmluZ2lmeU9yTG9nKFxuICAgICAgICBkYXRhXG4gICAgICApfWBcbiAgICApO1xuICB9XG4gIGNvbnN0IHsgdG9rZW4gfSA9IGRhdGE7XG4gIHJldHVybiB7IHRva2VuIH07XG59XG5cbi8vIHNyYy9jb25zdGFudHMudHNcbnZhciBERUZBVUxUX0JBU0VfVVJMID0gXCJodHRwczovL2FwaS5saXZlYmxvY2tzLmlvXCI7XG5cbi8vIHNyYy9pbnRlcm5hbC50c1xudmFyIGtJbnRlcm5hbCA9IFN5bWJvbCgpO1xuXG4vLyBzcmMvZGV2dG9vbHMvYnJpZGdlLnRzXG52YXIgX2JyaWRnZUFjdGl2ZSA9IGZhbHNlO1xuZnVuY3Rpb24gYWN0aXZhdGVCcmlkZ2UoYWxsb3dlZCkge1xuICBfYnJpZGdlQWN0aXZlID0gYWxsb3dlZDtcbn1cbmZ1bmN0aW9uIHNlbmRUb1BhbmVsKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZ1bGxNc2cgPSB7XG4gICAgLi4ubWVzc2FnZSxcbiAgICBzb3VyY2U6IFwibGl2ZWJsb2Nrcy1kZXZ0b29scy1jbGllbnRcIlxuICB9O1xuICBpZiAoIShvcHRpb25zPy5mb3JjZSB8fCBfYnJpZGdlQWN0aXZlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cucG9zdE1lc3NhZ2UoZnVsbE1zZywgXCIqXCIpO1xufVxudmFyIGV2ZW50U291cmNlID0gbWFrZUV2ZW50U291cmNlKCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5zb3VyY2UgPT09IHdpbmRvdyAmJiBldmVudC5kYXRhPy5zb3VyY2UgPT09IFwibGl2ZWJsb2Nrcy1kZXZ0b29scy1wYW5lbFwiKSB7XG4gICAgICBldmVudFNvdXJjZS5ub3RpZnkoZXZlbnQuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICB9XG4gIH0pO1xufVxudmFyIG9uTWVzc2FnZUZyb21QYW5lbCA9IGV2ZW50U291cmNlLm9ic2VydmFibGU7XG5cbi8vIHNyYy9kZXZ0b29scy9pbmRleC50c1xudmFyIFZFUlNJT04gPSBQS0dfVkVSU0lPTiB8fCBcImRldlwiO1xudmFyIF9kZXZ0b29sc1NldHVwSGFzUnVuID0gZmFsc2U7XG5mdW5jdGlvbiBzZXR1cERldlRvb2xzKGdldEFsbFJvb21zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoX2RldnRvb2xzU2V0dXBIYXNSdW4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgX2RldnRvb2xzU2V0dXBIYXNSdW4gPSB0cnVlO1xuICBvbk1lc3NhZ2VGcm9tUGFuZWwuc3Vic2NyaWJlKChtc2cpID0+IHtcbiAgICBzd2l0Y2ggKG1zZy5tc2cpIHtcbiAgICAgIC8vIFdoZW4gYSBkZXZ0b29sIHBhbmVsIHNlbmRzIGFuIGV4cGxpY2l0IFwiY29ubmVjdFwiIG1lc3NhZ2UgYmFjayB0byB0aGlzXG4gICAgICAvLyBsaXZlIHJ1bm5pbmcgY2xpZW50IChpbiByZXNwb25zZSB0byB0aGUgXCJ3YWtlLXVwLWRldnRvb2xzXCIgbWVzc2FnZSxcbiAgICAgIC8vIG9yIHdoZW4gdGhlIGRldnRvb2wgcGFuZWwgaXMgb3BlbmVkIGZvciB0aGUgZmlyc3QgdGltZSksIGl0IG1lYW5zIHRoYXQgaXQncyBva2F5IHRvXG4gICAgICAvLyBzdGFydCBlbWl0dGluZyBtZXNzYWdlcy5cbiAgICAgIC8vIEJlZm9yZSB0aGlzIGV4cGxpY2l0IGFja25vd2xlZGdlbWVudCwgYW55IGNhbGwgdG8gc2VuZFRvUGFuZWwoKSB3aWxsXG4gICAgICAvLyBiZSBhIG5vLW9wLlxuICAgICAgY2FzZSBcImNvbm5lY3RcIjoge1xuICAgICAgICBhY3RpdmF0ZUJyaWRnZSh0cnVlKTtcbiAgICAgICAgZm9yIChjb25zdCByb29tSWQgb2YgZ2V0QWxsUm9vbXMoKSkge1xuICAgICAgICAgIHNlbmRUb1BhbmVsKHtcbiAgICAgICAgICAgIG1zZzogXCJyb29tOjphdmFpbGFibGVcIixcbiAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgIGNsaWVudFZlcnNpb246IFZFUlNJT05cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBzZW5kVG9QYW5lbCh7IG1zZzogXCJ3YWtlLXVwLWRldnRvb2xzXCIgfSwgeyBmb3JjZTogdHJ1ZSB9KTtcbn1cbnZhciB1bnN1YnNCeVJvb21JZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBzdG9wU3luY1N0cmVhbShyb29tSWQpIHtcbiAgY29uc3QgdW5zdWJzID0gdW5zdWJzQnlSb29tSWQuZ2V0KHJvb21JZCkgPz8gW107XG4gIHVuc3Vic0J5Um9vbUlkLmRlbGV0ZShyb29tSWQpO1xuICBmb3IgKGNvbnN0IHVuc3ViIG9mIHVuc3Vicykge1xuICAgIHVuc3ViKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHN0YXJ0U3luY1N0cmVhbShyb29tKSB7XG4gIHN0b3BTeW5jU3RyZWFtKHJvb20uaWQpO1xuICBmdWxsU3luYyhyb29tKTtcbiAgdW5zdWJzQnlSb29tSWQuc2V0KHJvb20uaWQsIFtcbiAgICAvLyBXaGVuIHRoZSBjb25uZWN0aW9uIHN0YXR1cyBjaGFuZ2VzXG4gICAgcm9vbS5ldmVudHMuc3RhdHVzLnN1YnNjcmliZSgoKSA9PiBwYXJ0aWFsU3luY0Nvbm5lY3Rpb24ocm9vbSkpLFxuICAgIC8vIFdoZW4gc3RvcmFnZSBpbml0aWFsaXplcywgc2VuZCB0aGUgdXBkYXRlXG4gICAgcm9vbS5ldmVudHMuc3RvcmFnZURpZExvYWQuc3Vic2NyaWJlT25jZSgoKSA9PiBwYXJ0aWFsU3luY1N0b3JhZ2Uocm9vbSkpLFxuICAgIC8vIEFueSB0aW1lIHN0b3JhZ2UgdXBkYXRlcywgc2VuZCB0aGUgbmV3IHN0b3JhZ2Ugcm9vdFxuICAgIHJvb20uZXZlbnRzLnN0b3JhZ2VCYXRjaC5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNTdG9yYWdlKHJvb20pKSxcbiAgICAvLyBBbnkgdGltZSBcIm1lXCIgb3IgXCJvdGhlcnNcIiB1cGRhdGVzLCBzZW5kIHRoZSBuZXcgdmFsdWVzIGFjY29yZGluZ2x5XG4gICAgcm9vbS5ldmVudHMuc2VsZi5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNNZShyb29tKSksXG4gICAgcm9vbS5ldmVudHMub3RoZXJzLnN1YnNjcmliZSgoKSA9PiBwYXJ0aWFsU3luY090aGVycyhyb29tKSksXG4gICAgLy8gQW55IHRpbWUgeWRvYyBpcyB1cGRhdGVkLCBmb3J3YXJkIHRoZSB1cGRhdGVcbiAgICByb29tLmV2ZW50cy55ZG9jLnN1YnNjcmliZSgodXBkYXRlKSA9PiBzeW5jWWRvY1VwZGF0ZShyb29tLCB1cGRhdGUpKSxcbiAgICAvLyBBbnkgdGltZSBhIGN1c3RvbSByb29tIGV2ZW50IGlzIHJlY2VpdmVkLCBmb3J3YXJkIGl0XG4gICAgcm9vbS5ldmVudHMuY3VzdG9tRXZlbnQuc3Vic2NyaWJlKFxuICAgICAgKGV2ZW50RGF0YSkgPT4gZm9yd2FyZEV2ZW50KHJvb20sIGV2ZW50RGF0YSlcbiAgICApXG4gIF0pO1xufVxuZnVuY3Rpb24gc3luY1lkb2NVcGRhdGUocm9vbSwgdXBkYXRlKSB7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6c3luYzo6eWRvY1wiLFxuICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICB1cGRhdGVcbiAgfSk7XG59XG52YXIgbG9hZGVkQXQgPSBEYXRlLm5vdygpO1xudmFyIGV2ZW50Q291bnRlciA9IDA7XG5mdW5jdGlvbiBuZXh0RXZlbnRJZCgpIHtcbiAgcmV0dXJuIGBldmVudC0ke2xvYWRlZEF0fS0ke2V2ZW50Q291bnRlcisrfWA7XG59XG5mdW5jdGlvbiBmb3J3YXJkRXZlbnQocm9vbSwgZXZlbnREYXRhKSB7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6ZXZlbnRzOjpjdXN0b20tZXZlbnRcIixcbiAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgZXZlbnQ6IHtcbiAgICAgIHR5cGU6IFwiQ3VzdG9tRXZlbnRcIixcbiAgICAgIGlkOiBuZXh0RXZlbnRJZCgpLFxuICAgICAga2V5OiBcIkV2ZW50XCIsXG4gICAgICBjb25uZWN0aW9uSWQ6IGV2ZW50RGF0YS5jb25uZWN0aW9uSWQsXG4gICAgICBwYXlsb2FkOiBldmVudERhdGEuZXZlbnRcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcGFydGlhbFN5bmNDb25uZWN0aW9uKHJvb20pIHtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgcm9vbUlkOiByb29tLmlkLFxuICAgIHN0YXR1czogcm9vbS5nZXRTdGF0dXMoKVxuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jU3RvcmFnZShyb29tKSB7XG4gIGNvbnN0IHJvb3QgPSByb29tLmdldFN0b3JhZ2VTbmFwc2hvdCgpO1xuICBpZiAocm9vdCkge1xuICAgIHNlbmRUb1BhbmVsKHtcbiAgICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICBzdG9yYWdlOiByb290LnRvVHJlZU5vZGUoXCJyb290XCIpLnBheWxvYWRcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGFydGlhbFN5bmNNZShyb29tKSB7XG4gIGNvbnN0IG1lID0gcm9vbVtrSW50ZXJuYWxdLmdldFNlbGZfZm9yRGV2VG9vbHMoKTtcbiAgaWYgKG1lKSB7XG4gICAgc2VuZFRvUGFuZWwoe1xuICAgICAgbXNnOiBcInJvb206OnN5bmM6OnBhcnRpYWxcIixcbiAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgIG1lXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jT3RoZXJzKHJvb20pIHtcbiAgY29uc3Qgb3RoZXJzID0gcm9vbVtrSW50ZXJuYWxdLmdldE90aGVyc19mb3JEZXZUb29scygpO1xuICBpZiAob3RoZXJzKSB7XG4gICAgc2VuZFRvUGFuZWwoe1xuICAgICAgbXNnOiBcInJvb206OnN5bmM6OnBhcnRpYWxcIixcbiAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgIG90aGVyc1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBmdWxsU3luYyhyb29tKSB7XG4gIGNvbnN0IHJvb3QgPSByb29tLmdldFN0b3JhZ2VTbmFwc2hvdCgpO1xuICBjb25zdCBtZSA9IHJvb21ba0ludGVybmFsXS5nZXRTZWxmX2ZvckRldlRvb2xzKCk7XG4gIGNvbnN0IG90aGVycyA9IHJvb21ba0ludGVybmFsXS5nZXRPdGhlcnNfZm9yRGV2VG9vbHMoKTtcbiAgcm9vbS5mZXRjaFlEb2MoXCJcIik7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6c3luYzo6ZnVsbFwiLFxuICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICBzdGF0dXM6IHJvb20uZ2V0U3RhdHVzKCksXG4gICAgc3RvcmFnZTogcm9vdD8udG9UcmVlTm9kZShcInJvb3RcIikucGF5bG9hZCA/PyBudWxsLFxuICAgIG1lLFxuICAgIG90aGVyc1xuICB9KTtcbn1cbnZhciByb29tQ2hhbm5lbExpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBzdG9wUm9vbUNoYW5uZWxMaXN0ZW5lcihyb29tSWQpIHtcbiAgY29uc3QgbGlzdGVuZXIgPSByb29tQ2hhbm5lbExpc3RlbmVycy5nZXQocm9vbUlkKTtcbiAgcm9vbUNoYW5uZWxMaXN0ZW5lcnMuZGVsZXRlKHJvb21JZCk7XG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGxpc3RlbmVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGxpbmtEZXZUb29scyhyb29tSWQsIHJvb20pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNlbmRUb1BhbmVsKHsgbXNnOiBcInJvb206OmF2YWlsYWJsZVwiLCByb29tSWQsIGNsaWVudFZlcnNpb246IFZFUlNJT04gfSk7XG4gIHN0b3BSb29tQ2hhbm5lbExpc3RlbmVyKHJvb21JZCk7XG4gIHJvb21DaGFubmVsTGlzdGVuZXJzLnNldChcbiAgICByb29tSWQsXG4gICAgLy8gUmV0dXJucyB0aGUgdW5zdWJzY3JpYmUgY2FsbGJhY2ssIHRoYXQgd2Ugc3RvcmUgaW4gdGhlXG4gICAgLy8gcm9vbUNoYW5uZWxMaXN0ZW5lcnMgcmVnaXN0cnlcbiAgICBvbk1lc3NhZ2VGcm9tUGFuZWwuc3Vic2NyaWJlKChtc2cpID0+IHtcbiAgICAgIHN3aXRjaCAobXNnLm1zZykge1xuICAgICAgICAvLyBTZW50IGJ5IHRoZSBkZXZ0b29sIHBhbmVsIHdoZW4gaXQgd2FudHMgdG8gcmVjZWl2ZSB0aGUgc3luYyBzdHJlYW1cbiAgICAgICAgLy8gZm9yIGEgcm9vbVxuICAgICAgICBjYXNlIFwicm9vbTo6c3Vic2NyaWJlXCI6IHtcbiAgICAgICAgICBpZiAobXNnLnJvb21JZCA9PT0gcm9vbUlkKSB7XG4gICAgICAgICAgICBzdGFydFN5bmNTdHJlYW0ocm9vbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJyb29tOjp1bnN1YnNjcmliZVwiOiB7XG4gICAgICAgICAgaWYgKG1zZy5yb29tSWQgPT09IHJvb21JZCkge1xuICAgICAgICAgICAgc3RvcFN5bmNTdHJlYW0ocm9vbUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gdW5saW5rRGV2VG9vbHMocm9vbUlkKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBzdG9wU3luY1N0cmVhbShyb29tSWQpO1xuICBzdG9wUm9vbUNoYW5uZWxMaXN0ZW5lcihyb29tSWQpO1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OnVuYXZhaWxhYmxlXCIsXG4gICAgcm9vbUlkXG4gIH0pO1xufVxuXG4vLyBzcmMvcHJvdG9jb2wvVXNlck5vdGlmaWNhdGlvblNldHRpbmdzLnRzXG52YXIga1BsYWluID0gU3ltYm9sKFwidXNlci1ub3RpZmljYXRpb24tc2V0dGluZ3MtcGxhaW5cIik7XG5mdW5jdGlvbiBjcmVhdGVVc2VyTm90aWZpY2F0aW9uU2V0dGluZ3MocGxhaW4pIHtcbiAgY29uc3QgY2hhbm5lbHMgPSBbXG4gICAgXCJlbWFpbFwiLFxuICAgIFwic2xhY2tcIixcbiAgICBcInRlYW1zXCIsXG4gICAgXCJ3ZWJQdXNoXCJcbiAgXTtcbiAgY29uc3QgZGVzY3JpcHRvcnMgPSB7XG4gICAgW2tQbGFpbl06IHtcbiAgICAgIHZhbHVlOiBwbGFpbixcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgfVxuICB9O1xuICBmb3IgKGNvbnN0IGNoYW5uZWwgb2YgY2hhbm5lbHMpIHtcbiAgICBkZXNjcmlwdG9yc1tjaGFubmVsXSA9IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAvKipcbiAgICAgICAqIEluIHRoZSBUeXBlU2NyaXB0IHN0YW5kYXJkIGxpYnJhcnkgZGVmaW5pdGlvbnMsIHRoZSBidWlsdC1pbiBpbnRlcmZhY2UgZm9yIGEgcHJvcGVydHkgZGVzY3JpcHRvclxuICAgICAgICogZG9lcyBub3QgaW5jbHVkZSBhIHNwZWNpYWxpemVkIHR5cGUgZm9yIHRoZSDigJx0aGlz4oCdIGNvbnRleHQgaW4gdGhlIGdldHRlciBvciBzZXR0ZXIgZnVuY3Rpb25zLlxuICAgICAgICogQXMgYSByZXN1bHQsIGJvdGggdGhlIOKBoGdldCBhbmQg4oGgc2V0IG1ldGhvZHMgaW1wbGljaXRseSBoYXZlIOKBoHRoaXM6IGFueS5cbiAgICAgICAqIFRoZSByZWFzb24gaXMgdGhhdCBwcm9wZXJ0eSBkZXNjcmlwdG9ycyBpbiBKYXZhU2NyaXB0IGFyZSB1c2VkIGFjcm9zcyB2YXJpb3VzIG9iamVjdHMgd2l0aFxuICAgICAgICogbm8gZW5mb3JjZWQgc2hhcGUgZm9yIOKBoHRoaXMuIEFuZCBzbyB0aGUgc3RhbmRhcmQgbGlicmFyeSBkZWZpbml0aW9ucyBoYXZlIHRvIHJlbWFpbiBhcyBicm9hZCBhcyBwb3NzaWJsZVxuICAgICAgICogdG8gc3VwcG9ydCBhbnkgdmFsaWQgSmF2YVNjcmlwdCB1c2FnZSAoZS5nIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgKS5cbiAgICAgICAqXG4gICAgICAgKiBTbyB3ZSBjYW4gc2FmZWx5IHRlbGxzIHRoYXQgdGhpcyBnZXR0ZXIgaXMgdHlwZWQgYXMgYHRoaXM6IFVzZXJOb3RpZmljYXRpb25TZXR0aW5nc2AgYmVjYXVzZSB3ZSdyZVxuICAgICAgICogY3JlYXRpbmcgYSB3ZWxsIGtub3duIHNoYXBlZCBvYmplY3Qg4oaSIGBVc2VyTm90aWZpY2F0aW9uU2V0dGluZ3NgLlxuICAgICAgICovXG4gICAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpc1trUGxhaW5dW2NoYW5uZWxdO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgZXJyb3IyKFxuICAgICAgICAgICAgYEluIG9yZGVyIHRvIHVzZSB0aGUgJyR7Y2hhbm5lbH0nIGNoYW5uZWwsIHBsZWFzZSBzZXQgdXAgeW91ciBwcm9qZWN0IGZpcnN0LiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2VuYWJsZS1hLW5vdGlmaWNhdGlvbi1jaGFubmVsYFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZShudWxsLCBkZXNjcmlwdG9ycyk7XG59XG5mdW5jdGlvbiBwYXRjaFVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyhleGlzdGluZywgcGF0Y2gpIHtcbiAgY29uc3Qgb3V0Y29taW5nID0gY3JlYXRlVXNlck5vdGlmaWNhdGlvblNldHRpbmdzKHtcbiAgICAuLi5leGlzdGluZ1trUGxhaW5dXG4gIH0pO1xuICBmb3IgKGNvbnN0IGNoYW5uZWwgb2Yga2V5cyhwYXRjaCkpIHtcbiAgICBjb25zdCB1cGRhdGVzID0gcGF0Y2hbY2hhbm5lbF07XG4gICAgaWYgKHVwZGF0ZXMgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3Qga2luZFVwZGF0ZXMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIGVudHJpZXModXBkYXRlcykuZmlsdGVyKChbLCB2YWx1ZV0pID0+IHZhbHVlICE9PSB2b2lkIDApXG4gICAgICApO1xuICAgICAgb3V0Y29taW5nW2tQbGFpbl1bY2hhbm5lbF0gPSB7XG4gICAgICAgIC4uLm91dGNvbWluZ1trUGxhaW5dW2NoYW5uZWxdLFxuICAgICAgICAuLi5raW5kVXBkYXRlc1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dGNvbWluZztcbn1cbmZ1bmN0aW9uIGlzTm90aWZpY2F0aW9uQ2hhbm5lbEVuYWJsZWQoc2V0dGluZ3MpIHtcbiAgcmV0dXJuIHNldHRpbmdzICE9PSBudWxsID8gdmFsdWVzKHNldHRpbmdzKS5ldmVyeSgoZW5hYmxlZCkgPT4gZW5hYmxlZCA9PT0gdHJ1ZSkgOiBmYWxzZTtcbn1cblxuLy8gc3JjL2xpYi9wb3NpdGlvbi50c1xudmFyIE1JTl9DT0RFID0gMzI7XG52YXIgTUFYX0NPREUgPSAxMjY7XG52YXIgTlVNX0RJR0lUUyA9IE1BWF9DT0RFIC0gTUlOX0NPREUgKyAxO1xudmFyIFpFUk8gPSBudGhEaWdpdCgwKTtcbnZhciBPTkUgPSBudGhEaWdpdCgxKTtcbnZhciBaRVJPX05JTkUgPSBaRVJPICsgbnRoRGlnaXQoLTEpO1xuZnVuY3Rpb24gbnRoRGlnaXQobikge1xuICBjb25zdCBjb2RlID0gTUlOX0NPREUgKyAobiA8IDAgPyBOVU1fRElHSVRTICsgbiA6IG4pO1xuICBpZiAoY29kZSA8IE1JTl9DT0RFIHx8IGNvZGUgPiBNQVhfQ09ERSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuIHZhbHVlOiAke259YCk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG59XG5mdW5jdGlvbiBtYWtlUG9zaXRpb24oeCwgeSkge1xuICBpZiAoeCAhPT0gdm9pZCAwICYmIHkgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBiZXR3ZWVuKHgsIHkpO1xuICB9IGVsc2UgaWYgKHggIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBhZnRlcih4KTtcbiAgfSBlbHNlIGlmICh5ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gYmVmb3JlKHkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBPTkU7XG4gIH1cbn1cbmZ1bmN0aW9uIGJlZm9yZShwb3MpIHtcbiAgY29uc3QgbGFzdEluZGV4ID0gcG9zLmxlbmd0aCAtIDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHBvcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlIDw9IE1JTl9DT0RFKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGkgPT09IGxhc3RJbmRleCkge1xuICAgICAgaWYgKGNvZGUgPT09IE1JTl9DT0RFICsgMSkge1xuICAgICAgICByZXR1cm4gcG9zLnN1YnN0cmluZygwLCBpKSArIFpFUk9fTklORTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkgKyAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9ORTtcbn1cbmZ1bmN0aW9uIGFmdGVyKHBvcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8PSBwb3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHBvcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID49IE1BWF9DT0RFKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcy5zdWJzdHJpbmcoMCwgaSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUgKyAxKTtcbiAgfVxuICByZXR1cm4gcG9zICsgT05FO1xufVxuZnVuY3Rpb24gYmV0d2VlbihsbywgaGkpIHtcbiAgaWYgKGxvIDwgaGkpIHtcbiAgICByZXR1cm4gX2JldHdlZW4obG8sIGhpKTtcbiAgfSBlbHNlIGlmIChsbyA+IGhpKSB7XG4gICAgcmV0dXJuIF9iZXR3ZWVuKGhpLCBsbyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgdmFsdWUgYmV0d2VlbiB0d28gZXF1YWwgcG9zaXRpb25zXCIpO1xuICB9XG59XG5mdW5jdGlvbiBfYmV0d2VlbihsbywgaGkpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgY29uc3QgbG9MZW4gPSBsby5sZW5ndGg7XG4gIGNvbnN0IGhpTGVuID0gaGkubGVuZ3RoO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IGxvQ29kZSA9IGluZGV4IDwgbG9MZW4gPyBsby5jaGFyQ29kZUF0KGluZGV4KSA6IE1JTl9DT0RFO1xuICAgIGNvbnN0IGhpQ29kZSA9IGluZGV4IDwgaGlMZW4gPyBoaS5jaGFyQ29kZUF0KGluZGV4KSA6IE1BWF9DT0RFO1xuICAgIGlmIChsb0NvZGUgPT09IGhpQ29kZSkge1xuICAgICAgaW5kZXgrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaGlDb2RlIC0gbG9Db2RlID09PSAxKSB7XG4gICAgICBjb25zdCBzaXplID0gaW5kZXggKyAxO1xuICAgICAgbGV0IHByZWZpeCA9IGxvLnN1YnN0cmluZygwLCBzaXplKTtcbiAgICAgIGlmIChwcmVmaXgubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgICBwcmVmaXggKz0gWkVSTy5yZXBlYXQoc2l6ZSAtIHByZWZpeC5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3VmZml4ID0gbG8uc3Vic3RyaW5nKHNpemUpO1xuICAgICAgY29uc3QgbmluZXMgPSBcIlwiO1xuICAgICAgcmV0dXJuIHByZWZpeCArIF9iZXR3ZWVuKHN1ZmZpeCwgbmluZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGFrZU4obG8sIGluZGV4KSArIFN0cmluZy5mcm9tQ2hhckNvZGUoaGlDb2RlICsgbG9Db2RlID4+IDEpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdGFrZU4ocG9zLCBuKSB7XG4gIHJldHVybiBuIDwgcG9zLmxlbmd0aCA/IHBvcy5zdWJzdHJpbmcoMCwgbikgOiBwb3MgKyBaRVJPLnJlcGVhdChuIC0gcG9zLmxlbmd0aCk7XG59XG52YXIgTUlOX05PTl9aRVJPX0NPREUgPSBNSU5fQ09ERSArIDE7XG5mdW5jdGlvbiBpc1BvcyhzdHIpIHtcbiAgaWYgKHN0ciA9PT0gXCJcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsYXN0SWR4ID0gc3RyLmxlbmd0aCAtIDE7XG4gIGNvbnN0IGxhc3QgPSBzdHIuY2hhckNvZGVBdChsYXN0SWR4KTtcbiAgaWYgKGxhc3QgPCBNSU5fTk9OX1pFUk9fQ09ERSB8fCBsYXN0ID4gTUFYX0NPREUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0SWR4OyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPCBNSU5fQ09ERSB8fCBjb2RlID4gTUFYX0NPREUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Qb3Moc3RyKSB7XG4gIGNvbnN0IGNvZGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGNvZGVzLnB1c2goY29kZSA8IE1JTl9DT0RFID8gTUlOX0NPREUgOiBjb2RlID4gTUFYX0NPREUgPyBNQVhfQ09ERSA6IGNvZGUpO1xuICB9XG4gIHdoaWxlIChjb2Rlcy5sZW5ndGggPiAwICYmIGNvZGVzW2NvZGVzLmxlbmd0aCAtIDFdID09PSBNSU5fQ09ERSkge1xuICAgIGNvZGVzLmxlbmd0aC0tO1xuICB9XG4gIHJldHVybiBjb2Rlcy5sZW5ndGggPiAwID8gU3RyaW5nLmZyb21DaGFyQ29kZSguLi5jb2RlcykgOiAoXG4gICAgLy8gRWRnZSBjYXNlOiB0aGUgc3RyIHdhcyBhIDAtb25seSBzdHJpbmcsIHdoaWNoIGlzIGludmFsaWQuIERlZmF1bHQgYmFjayB0byAuMVxuICAgIE9ORVxuICApO1xufVxuZnVuY3Rpb24gYXNQb3Moc3RyKSB7XG4gIHJldHVybiBpc1BvcyhzdHIpID8gc3RyIDogY29udmVydFRvUG9zKHN0cik7XG59XG5cbi8vIHNyYy9wcm90b2NvbC9PcC50c1xudmFyIE9wQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE9wQ29kZTIpID0+IHtcbiAgT3BDb2RlMltPcENvZGUyW1wiSU5JVFwiXSA9IDBdID0gXCJJTklUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIlNFVF9QQVJFTlRfS0VZXCJdID0gMV0gPSBcIlNFVF9QQVJFTlRfS0VZXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9MSVNUXCJdID0gMl0gPSBcIkNSRUFURV9MSVNUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIlVQREFURV9PQkpFQ1RcIl0gPSAzXSA9IFwiVVBEQVRFX09CSkVDVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJDUkVBVEVfT0JKRUNUXCJdID0gNF0gPSBcIkNSRUFURV9PQkpFQ1RcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiREVMRVRFX0NSRFRcIl0gPSA1XSA9IFwiREVMRVRFX0NSRFRcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiREVMRVRFX09CSkVDVF9LRVlcIl0gPSA2XSA9IFwiREVMRVRFX09CSkVDVF9LRVlcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiQ1JFQVRFX01BUFwiXSA9IDddID0gXCJDUkVBVEVfTUFQXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9SRUdJU1RFUlwiXSA9IDhdID0gXCJDUkVBVEVfUkVHSVNURVJcIjtcbiAgcmV0dXJuIE9wQ29kZTI7XG59KShPcENvZGUgfHwge30pO1xuZnVuY3Rpb24gYWNrT3Aob3BJZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sXG4gICAgaWQ6IFwiQUNLXCIsXG4gICAgLy8gKEgpQUNLXG4gICAgb3BJZFxuICB9O1xufVxuZnVuY3Rpb24gaXNBY2tPcChvcCkge1xuICByZXR1cm4gb3AudHlwZSA9PT0gNSAvKiBERUxFVEVfQ1JEVCAqLyAmJiBvcC5pZCA9PT0gXCJBQ0tcIjtcbn1cblxuLy8gc3JjL2NyZHRzL0Fic3RyYWN0Q3JkdC50c1xuZnVuY3Rpb24gY3JlYXRlTWFuYWdlZFBvb2wocm9vbUlkLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBnZXRDdXJyZW50Q29ubmVjdGlvbklkLFxuICAgIG9uRGlzcGF0Y2gsXG4gICAgaXNTdG9yYWdlV3JpdGFibGUgPSAoKSA9PiB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBsZXQgY2xvY2sgPSAwO1xuICBsZXQgb3BDbG9jayA9IDA7XG4gIGNvbnN0IG5vZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgcmV0dXJuIHtcbiAgICByb29tSWQsXG4gICAgbm9kZXMsXG4gICAgZ2V0Tm9kZTogKGlkKSA9PiBub2Rlcy5nZXQoaWQpLFxuICAgIGFkZE5vZGU6IChpZCwgbm9kZSkgPT4gdm9pZCBub2Rlcy5zZXQoaWQsIG5vZGUpLFxuICAgIGRlbGV0ZU5vZGU6IChpZCkgPT4gdm9pZCBub2Rlcy5kZWxldGUoaWQpLFxuICAgIGdlbmVyYXRlSWQ6ICgpID0+IGAke2dldEN1cnJlbnRDb25uZWN0aW9uSWQoKX06JHtjbG9jaysrfWAsXG4gICAgZ2VuZXJhdGVPcElkOiAoKSA9PiBgJHtnZXRDdXJyZW50Q29ubmVjdGlvbklkKCl9OiR7b3BDbG9jaysrfWAsXG4gICAgZGlzcGF0Y2gob3BzLCByZXZlcnNlLCBzdG9yYWdlVXBkYXRlcykge1xuICAgICAgb25EaXNwYXRjaD8uKG9wcywgcmV2ZXJzZSwgc3RvcmFnZVVwZGF0ZXMpO1xuICAgIH0sXG4gICAgYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGU6ICgpID0+IHtcbiAgICAgIGlmICghaXNTdG9yYWdlV3JpdGFibGUoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJDYW5ub3Qgd3JpdGUgdG8gc3RvcmFnZSB3aXRoIGEgcmVhZCBvbmx5IHVzZXIsIHBsZWFzZSBlbnN1cmUgdGhlIHVzZXIgaGFzIHdyaXRlIHBlcm1pc3Npb25zXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjcmR0QXNMaXZlTm9kZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBIYXNQYXJlbnQobm9kZSwga2V5LCBwb3MgPSBhc1BvcyhrZXkpKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHsgdHlwZTogXCJIYXNQYXJlbnRcIiwgbm9kZSwga2V5LCBwb3MgfSk7XG59XG52YXIgTm9QYXJlbnQgPSBPYmplY3QuZnJlZXplKHsgdHlwZTogXCJOb1BhcmVudFwiIH0pO1xuZnVuY3Rpb24gT3JwaGFuZWQob2xkS2V5LCBvbGRQb3MgPSBhc1BvcyhvbGRLZXkpKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHsgdHlwZTogXCJPcnBoYW5lZFwiLCBvbGRLZXksIG9sZFBvcyB9KTtcbn1cbnZhciBBYnN0cmFjdENyZHQgPSBjbGFzcyB7XG4gIC8vICAgICAgICAgICAgICAgICAgXl5eXl5eXl5eXl5eIFRPRE86IE1ha2UgdGhpcyBhbiBpbnRlcmZhY2VcbiAgI3Bvb2w7XG4gICNpZDtcbiAgI3BhcmVudCA9IE5vUGFyZW50O1xuICAvKiogQGludGVybmFsICovXG4gIF9nZXRQYXJlbnRLZXlPclRocm93KCkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQua2V5O1xuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBrZXkgaXMgbWlzc2luZ1wiKTtcbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQub2xkS2V5O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IF9wYXJlbnRQb3MoKSB7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiSGFzUGFyZW50XCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5wb3M7XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyZW50IGtleSBpcyBtaXNzaW5nXCIpO1xuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5vbGRQb3M7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX3Bvb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Bvb2w7XG4gIH1cbiAgZ2V0IHJvb21JZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9vbCA/IHRoaXMuI3Bvb2wucm9vbUlkIDogbnVsbDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lkO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IHBhcmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcGFyZW50O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IF9wYXJlbnRLZXkoKSB7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiSGFzUGFyZW50XCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5rZXk7XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm9sZEtleTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseShvcCwgX2lzTG9jYWwpIHtcbiAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgIGNhc2UgNSAvKiBERUxFVEVfQ1JEVCAqLzoge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5ub2RlLl9kZXRhY2hDaGlsZChjcmR0QXNMaXZlTm9kZSh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NldFBhcmVudExpbmsobmV3UGFyZW50Tm9kZSwgbmV3UGFyZW50S2V5KSB7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiSGFzUGFyZW50XCI6XG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5ub2RlICE9PSBuZXdQYXJlbnROb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBwYXJlbnQ6IG5vZGUgYWxyZWFkeSBoYXMgYSBwYXJlbnRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4jcGFyZW50ID0gSGFzUGFyZW50KG5ld1BhcmVudE5vZGUsIG5ld1BhcmVudEtleSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjpcbiAgICAgIGNhc2UgXCJOb1BhcmVudFwiOiB7XG4gICAgICAgIHRoaXMuI3BhcmVudCA9IEhhc1BhcmVudChuZXdQYXJlbnROb2RlLCBuZXdQYXJlbnRLZXkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoKGlkLCBwb29sKSB7XG4gICAgaWYgKHRoaXMuI2lkIHx8IHRoaXMuI3Bvb2wpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhdHRhY2ggbm9kZTogYWxyZWFkeSBhdHRhY2hlZFwiKTtcbiAgICB9XG4gICAgcG9vbC5hZGROb2RlKGlkLCBjcmR0QXNMaXZlTm9kZSh0aGlzKSk7XG4gICAgdGhpcy4jaWQgPSBpZDtcbiAgICB0aGlzLiNwb29sID0gcG9vbDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2goKSB7XG4gICAgaWYgKHRoaXMuI3Bvb2wgJiYgdGhpcy4jaWQpIHtcbiAgICAgIHRoaXMuI3Bvb2wuZGVsZXRlTm9kZSh0aGlzLiNpZCk7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOiB7XG4gICAgICAgIHRoaXMuI3BhcmVudCA9IE9ycGhhbmVkKHRoaXMucGFyZW50LmtleSwgdGhpcy5wYXJlbnQucG9zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjoge1xuICAgICAgICB0aGlzLiNwYXJlbnQgPSBOb1BhcmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjoge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICAgIHRoaXMuI3Bvb2wgPSB2b2lkIDA7XG4gIH1cbiAgLyoqIFRoaXMgY2FjaGVzIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgLnRvSW1tdXRhYmxlKCkgY2FsbCBmb3IgdGhpcyBMaXZlIG5vZGUuICovXG4gICNjYWNoZWRJbW11dGFibGU7XG4gICNjYWNoZWRUcmVlTm9kZUtleTtcbiAgLyoqIFRoaXMgY2FjaGVzIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgLnRvVHJlZU5vZGUoKSBjYWxsIGZvciB0aGlzIExpdmUgbm9kZS4gKi9cbiAgI2NhY2hlZFRyZWVOb2RlO1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIENsZWFyIHRoZSBJbW11dGFibGUgY2FjaGUsIHNvIHRoYXQgdGhlIG5leHQgY2FsbCB0byBgLnRvSW1tdXRhYmxlKClgIHdpbGxcbiAgICogcmVjb21wdXRlIHRoZSBlcXVpdmFsZW50IEltbXV0YWJsZSB2YWx1ZSBhZ2Fpbi4gIENhbGwgdGhpcyBhZnRlciBldmVyeVxuICAgKiBtdXRhdGlvbiB0byB0aGUgTGl2ZSBub2RlLlxuICAgKi9cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICBpZiAodGhpcy4jY2FjaGVkSW1tdXRhYmxlICE9PSB2b2lkIDAgfHwgdGhpcy4jY2FjaGVkVHJlZU5vZGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy4jY2FjaGVkSW1tdXRhYmxlID0gdm9pZCAwO1xuICAgICAgdGhpcy4jY2FjaGVkVHJlZU5vZGUgPSB2b2lkIDA7XG4gICAgICBpZiAodGhpcy5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgICB0aGlzLnBhcmVudC5ub2RlLmludmFsaWRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBSZXR1cm4gYW4gc25hcHNob3Qgb2YgdGhpcyBMaXZlIHRyZWUgZm9yIHVzZSBpbiBEZXZUb29scy5cbiAgICovXG4gIHRvVHJlZU5vZGUoa2V5KSB7XG4gICAgaWYgKHRoaXMuI2NhY2hlZFRyZWVOb2RlID09PSB2b2lkIDAgfHwgdGhpcy4jY2FjaGVkVHJlZU5vZGVLZXkgIT09IGtleSkge1xuICAgICAgdGhpcy4jY2FjaGVkVHJlZU5vZGVLZXkgPSBrZXk7XG4gICAgICB0aGlzLiNjYWNoZWRUcmVlTm9kZSA9IHRoaXMuX3RvVHJlZU5vZGUoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlZFRyZWVOb2RlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gaW1tdXRhYmxlIHNuYXBzaG90IG9mIHRoaXMgTGl2ZSBub2RlIGFuZCBpdHMgY2hpbGRyZW4uXG4gICAqL1xuICB0b0ltbXV0YWJsZSgpIHtcbiAgICBpZiAodGhpcy4jY2FjaGVkSW1tdXRhYmxlID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuI2NhY2hlZEltbXV0YWJsZSA9IHRoaXMuX3RvSW1tdXRhYmxlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNjYWNoZWRJbW11dGFibGU7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm90b2NvbC9TZXJpYWxpemVkQ3JkdC50c1xudmFyIENyZHRUeXBlID0gLyogQF9fUFVSRV9fICovICgoQ3JkdFR5cGUyKSA9PiB7XG4gIENyZHRUeXBlMltDcmR0VHlwZTJbXCJPQkpFQ1RcIl0gPSAwXSA9IFwiT0JKRUNUXCI7XG4gIENyZHRUeXBlMltDcmR0VHlwZTJbXCJMSVNUXCJdID0gMV0gPSBcIkxJU1RcIjtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIk1BUFwiXSA9IDJdID0gXCJNQVBcIjtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIlJFR0lTVEVSXCJdID0gM10gPSBcIlJFR0lTVEVSXCI7XG4gIHJldHVybiBDcmR0VHlwZTI7XG59KShDcmR0VHlwZSB8fCB7fSk7XG5mdW5jdGlvbiBpc1Jvb3RDcmR0KGNyZHQpIHtcbiAgcmV0dXJuIGNyZHQudHlwZSA9PT0gMCAvKiBPQkpFQ1QgKi8gJiYgIWlzQ2hpbGRDcmR0KGNyZHQpO1xufVxuZnVuY3Rpb24gaXNDaGlsZENyZHQoY3JkdCkge1xuICByZXR1cm4gY3JkdC5wYXJlbnRJZCAhPT0gdm9pZCAwICYmIGNyZHQucGFyZW50S2V5ICE9PSB2b2lkIDA7XG59XG5cbi8vIHNyYy9jcmR0cy9MaXZlUmVnaXN0ZXIudHNcbnZhciBMaXZlUmVnaXN0ZXIgPSBjbGFzcyBfTGl2ZVJlZ2lzdGVyIGV4dGVuZHMgQWJzdHJhY3RDcmR0IHtcbiAgI2RhdGE7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI2RhdGEgPSBkYXRhO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLiNkYXRhO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZShbaWQsIGl0ZW1dLCBfcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IHJlZ2lzdGVyID0gbmV3IF9MaXZlUmVnaXN0ZXIoaXRlbS5kYXRhKTtcbiAgICByZWdpc3Rlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICByZXR1cm4gcmVnaXN0ZXI7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9PcHMocGFyZW50SWQsIHBhcmVudEtleSwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ2Fubm90IHNlcmlhbGl6ZSByZWdpc3RlciBpZiBwYXJlbnRJZCBvciBwYXJlbnRLZXkgaXMgdW5kZWZpbmVkXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IDggLyogQ1JFQVRFX1JFR0lTVEVSICovLFxuICAgICAgICBvcElkOiBwb29sPy5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgICBwYXJlbnRJZCxcbiAgICAgICAgcGFyZW50S2V5LFxuICAgICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSAhPT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBMaXZlUmVnaXN0ZXIgaWYgcGFyZW50IGlzIG1pc3NpbmdcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAzIC8qIFJFR0lTVEVSICovLFxuICAgICAgcGFyZW50SWQ6IG5uKHRoaXMucGFyZW50Lm5vZGUuX2lkLCBcIlBhcmVudCBub2RlIGV4cGVjdGVkIHRvIGhhdmUgSURcIiksXG4gICAgICBwYXJlbnRLZXk6IHRoaXMucGFyZW50LmtleSxcbiAgICAgIGRhdGE6IHRoaXMuZGF0YVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoQ2hpbGQoX29wKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoQ2hpbGQoX2NyZHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseShvcCwgaXNMb2NhbCkge1xuICAgIHJldHVybiBzdXBlci5fYXBwbHkob3AsIGlzTG9jYWwpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSnNvblwiLFxuICAgICAgaWQ6IHRoaXMuX2lkID8/IG5hbm9pZCgpLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogdGhpcy4jZGF0YVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RhdGE7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIGRlZXBDbG9uZSh0aGlzLmRhdGEpO1xuICB9XG59O1xuXG4vLyBzcmMvY3JkdHMvTGl2ZUxpc3QudHNcbmZ1bmN0aW9uIGNvbXBhcmVOb2RlUG9zaXRpb24oaXRlbUEsIGl0ZW1CKSB7XG4gIGNvbnN0IHBvc0EgPSBpdGVtQS5fcGFyZW50UG9zO1xuICBjb25zdCBwb3NCID0gaXRlbUIuX3BhcmVudFBvcztcbiAgcmV0dXJuIHBvc0EgPT09IHBvc0IgPyAwIDogcG9zQSA8IHBvc0IgPyAtMSA6IDE7XG59XG52YXIgTGl2ZUxpc3QgPSBjbGFzcyBfTGl2ZUxpc3QgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICAvLyBUT0RPOiBOYWl2ZSBhcnJheSBhdCBmaXJzdCwgZmluZCBhIGJldHRlciBkYXRhIHN0cnVjdHVyZS4gTWF5YmUgYW4gT3JkZXIgc3RhdGlzdGljcyB0cmVlP1xuICAjaXRlbXM7XG4gICNpbXBsaWNpdGx5RGVsZXRlZEl0ZW1zO1xuICAjdW5hY2tub3dsZWRnZWRTZXRzO1xuICBjb25zdHJ1Y3RvcihpdGVtcykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jaXRlbXMgPSBbXTtcbiAgICB0aGlzLiNpbXBsaWNpdGx5RGVsZXRlZEl0ZW1zID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgdGhpcy4jdW5hY2tub3dsZWRnZWRTZXRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgcG9zaXRpb24gPSB2b2lkIDA7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBjb25zdCBuZXdQb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICBjb25zdCBub2RlID0gbHNvblRvTGl2ZU5vZGUoaXRlbSk7XG4gICAgICBub2RlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld1Bvc2l0aW9uKTtcbiAgICAgIHRoaXMuI2l0ZW1zLnB1c2gobm9kZSk7XG4gICAgICBwb3NpdGlvbiA9IG5ld1Bvc2l0aW9uO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkXSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IGxpc3QgPSBuZXcgX0xpdmVMaXN0KFtdKTtcbiAgICBsaXN0Ll9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50VG9DaGlsZHJlbi5nZXQoaWQpO1xuICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbaWQyLCBjcmR0XSBvZiBjaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGQgPSBkZXNlcmlhbGl6ZShbaWQyLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayhsaXN0LCBjcmR0LnBhcmVudEtleSk7XG4gICAgICBsaXN0Ll9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCB0aGUgcmVzdWx0aW5nIG9wcyB3aWxsIGJlIHNlbnQgdG8gdGhlIHNlcnZlciBpZiB0aGV5IGhhdmUgYW4gJ29wSWQnXG4gICAqIHNvIHdlIG11dGF0ZSBfdW5hY2tub3dsZWRnZWRTZXRzIHRvIGF2b2lkIHBvdGVudGlhbCBmbGlja2VyaW5nXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9saXZlYmxvY2tzL2xpdmVibG9ja3MvcHVsbC8xMTc3XG4gICAqXG4gICAqIFRoaXMgaXMgcXVpdGUgdW5pbnR1aXRpdmUgYW5kIHNob3VsZCBkaXNhcHBlYXIgYXMgc29vbiBhc1xuICAgKiB3ZSBpbnRyb2R1Y2UgYW4gZXhwbGljaXQgTGl2ZUxpc3QuU2V0IG9wZXJhdGlvblxuICAgKi9cbiAgX3RvT3BzKHBhcmVudElkLCBwYXJlbnRLZXksIHBvb2wpIHtcbiAgICBpZiAodGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBpdGVtIGlzIG5vdCBhdHRhY2hlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICBvcElkOiBwb29sPy5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgIHR5cGU6IDIgLyogQ1JFQVRFX0xJU1QgKi8sXG4gICAgICBwYXJlbnRJZCxcbiAgICAgIHBhcmVudEtleVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLiNpdGVtcykge1xuICAgICAgY29uc3QgcGFyZW50S2V5MiA9IGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKTtcbiAgICAgIGNvbnN0IGNoaWxkT3BzID0gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihcbiAgICAgICAgaXRlbS5fdG9PcHModGhpcy5faWQsIHBhcmVudEtleTIsIHBvb2wpLFxuICAgICAgICB2b2lkIDBcbiAgICAgICk7XG4gICAgICBjb25zdCBjaGlsZE9wSWQgPSBjaGlsZE9wc1swXS5vcElkO1xuICAgICAgaWYgKGNoaWxkT3BJZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuI3VuYWNrbm93bGVkZ2VkU2V0cy5zZXQocGFyZW50S2V5MiwgY2hpbGRPcElkKTtcbiAgICAgIH1cbiAgICAgIG9wcy5wdXNoKC4uLmNoaWxkT3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIEFkZHMgYSBuZXcgaXRlbSBpbnRvIHRoZSBzb3J0ZWQgbGlzdCwgaW4gdGhlIGNvcnJlY3QgcG9zaXRpb24uXG4gICAqL1xuICBfaW5zZXJ0QW5kU29ydChpdGVtKSB7XG4gICAgdGhpcy4jaXRlbXMucHVzaChpdGVtKTtcbiAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zb3J0SXRlbXMoKSB7XG4gICAgdGhpcy4jaXRlbXMuc29ydChjb21wYXJlTm9kZVBvc2l0aW9uKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9pbmRleE9mUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy4jaXRlbXMuZmluZEluZGV4KFxuICAgICAgKGl0ZW0pID0+IGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKSA9PT0gcG9zaXRpb25cbiAgICApO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaChpZCwgcG9vbCkge1xuICAgIHN1cGVyLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLiNpdGVtcykge1xuICAgICAgaXRlbS5fYXR0YWNoKHBvb2wuZ2VuZXJhdGVJZCgpLCBwb29sKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoKCkge1xuICAgIHN1cGVyLl9kZXRhY2goKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy4jaXRlbXMpIHtcbiAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIH1cbiAgfVxuICAjYXBwbHlTZXRSZW1vdGUob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjb25zdCBkZWxldGVkSWQgPSBvcC5kZWxldGVkSWQ7XG4gICAgY29uc3QgaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy4jaXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXTtcbiAgICAgIGlmIChpdGVtV2l0aFNhbWVQb3NpdGlvbi5faWQgPT09IGRlbGV0ZWRJZCkge1xuICAgICAgICBpdGVtV2l0aFNhbWVQb3NpdGlvbi5fZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuI2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl0gPSBjaGlsZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBzZXREZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIGNoaWxkKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiNpbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmFkZChpdGVtV2l0aFNhbWVQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuI2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl0gPSBjaGlsZDtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBbXG4gICAgICAgICAgc2V0RGVsdGEoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCBjaGlsZClcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgZGVsZXRlRGVsdGEyID0gdGhpcy4jZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihcbiAgICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGRlbGV0ZURlbHRhMikge1xuICAgICAgICAgIGRlbHRhLnB1c2goZGVsZXRlRGVsdGEyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB1cGRhdGVzID0gW107XG4gICAgICBjb25zdCBkZWxldGVEZWx0YTIgPSB0aGlzLiNkZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKFxuICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICk7XG4gICAgICBpZiAoZGVsZXRlRGVsdGEyKSB7XG4gICAgICAgIHVwZGF0ZXMucHVzaChkZWxldGVEZWx0YTIpO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICB1cGRhdGVzLnB1c2goaW5zZXJ0RGVsdGEodGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSksIGNoaWxkKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXZlcnNlOiBbXSxcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgdXBkYXRlcylcbiAgICAgIH07XG4gICAgfVxuICB9XG4gICNhcHBseVNldEFjayhvcCkge1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGF0dGFjaCBjaGlsZCBpZiBtYW5hZ2VkIHBvb2wgaXMgbm90IHByZXNlbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IGRlbHRhID0gW107XG4gICAgY29uc3QgZGVsZXRlZERlbHRhID0gdGhpcy4jZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihvcC5kZWxldGVkSWQpO1xuICAgIGlmIChkZWxldGVkRGVsdGEpIHtcbiAgICAgIGRlbHRhLnB1c2goZGVsZXRlZERlbHRhKTtcbiAgICB9XG4gICAgY29uc3QgdW5hY2tub3dsZWRnZWRPcElkID0gdGhpcy4jdW5hY2tub3dsZWRnZWRTZXRzLmdldChvcC5wYXJlbnRLZXkpO1xuICAgIGlmICh1bmFja25vd2xlZGdlZE9wSWQgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHVuYWNrbm93bGVkZ2VkT3BJZCAhPT0gb3Aub3BJZCkge1xuICAgICAgICByZXR1cm4gZGVsdGEubGVuZ3RoID09PSAwID8geyBtb2RpZmllZDogZmFsc2UgfSA6IHsgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgZGVsdGEpLCByZXZlcnNlOiBbXSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4jdW5hY2tub3dsZWRnZWRTZXRzLmRlbGV0ZShvcC5wYXJlbnRLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gPSB0aGlzLl9pbmRleE9mUG9zaXRpb24ob3AucGFyZW50S2V5KTtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLiNpdGVtcy5maW5kKChpdGVtKSA9PiBpdGVtLl9pZCA9PT0gb3AuaWQpO1xuICAgIGlmIChleGlzdGluZ0l0ZW0gIT09IHZvaWQgMCkge1xuICAgICAgaWYgKGV4aXN0aW5nSXRlbS5fcGFyZW50S2V5ID09PSBvcC5wYXJlbnRLZXkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZGVsdGEubGVuZ3RoID4gMCA/IG1ha2VVcGRhdGUodGhpcywgZGVsdGEpIDogZmFsc2UsXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgIHRoaXMuI2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuYWRkKFxuICAgICAgICAgIHRoaXMuI2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl1cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgW3ByZXZOb2RlXSA9IHRoaXMuI2l0ZW1zLnNwbGljZShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIDEpO1xuICAgICAgICBkZWx0YS5wdXNoKGRlbGV0ZURlbHRhKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiwgcHJldk5vZGUpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZJbmRleCA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoZXhpc3RpbmdJdGVtKTtcbiAgICAgIGV4aXN0aW5nSXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBvcC5wYXJlbnRLZXkpO1xuICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoZXhpc3RpbmdJdGVtKTtcbiAgICAgIGlmIChuZXdJbmRleCAhPT0gcHJldkluZGV4KSB7XG4gICAgICAgIGRlbHRhLnB1c2gobW92ZURlbHRhKHByZXZJbmRleCwgbmV3SW5kZXgsIGV4aXN0aW5nSXRlbSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IGRlbHRhLmxlbmd0aCA+IDAgPyBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSA6IGZhbHNlLFxuICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3JwaGFuID0gdGhpcy5fcG9vbC5nZXROb2RlKG9wLmlkKTtcbiAgICAgIGlmIChvcnBoYW4gJiYgdGhpcy4jaW1wbGljaXRseURlbGV0ZWRJdGVtcy5oYXMob3JwaGFuKSkge1xuICAgICAgICBvcnBoYW4uX3NldFBhcmVudExpbmsodGhpcywgb3AucGFyZW50S2V5KTtcbiAgICAgICAgdGhpcy4jaW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUob3JwaGFuKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChvcnBoYW4pO1xuICAgICAgICBjb25zdCByZWNyZWF0ZWRJdGVtSW5kZXggPSB0aGlzLiNpdGVtcy5pbmRleE9mKG9ycGhhbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gaXRlbSBhdCB0aGlzIHBvc2l0aW9uLCB1cGRhdGUgaXMgYSBzZXQsIGVsc2UgaXQncyBhbiBpbnNlcnRcbiAgICAgICAgICAgIGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9PT0gLTEgPyBpbnNlcnREZWx0YShyZWNyZWF0ZWRJdGVtSW5kZXgsIG9ycGhhbikgOiBzZXREZWx0YShyZWNyZWF0ZWRJdGVtSW5kZXgsIG9ycGhhbiksXG4gICAgICAgICAgICAuLi5kZWx0YVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuI2l0ZW1zLnNwbGljZShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuI2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KFxuICAgICAgICAgIG9wLFxuICAgICAgICAgIG9wLnBhcmVudEtleVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGl0ZW0gYXQgdGhpcyBwb3NpdGlvbiwgdXBkYXRlIGlzIGEgc2V0LCBlbHNlIGl0J3MgYW4gaW5zZXJ0XG4gICAgICAgICAgICBpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gPT09IC0xID8gaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pIDogc2V0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pLFxuICAgICAgICAgICAgLi4uZGVsdGFcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdXBkYXRlIGRlbHRhIG9mIHRoZSBkZWxldGlvbiBvciBudWxsXG4gICAqL1xuICAjZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihkZWxldGVkSWQpIHtcbiAgICBpZiAoZGVsZXRlZElkID09PSB2b2lkIDAgfHwgdGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGVsZXRlZEl0ZW0gPSB0aGlzLl9wb29sLmdldE5vZGUoZGVsZXRlZElkKTtcbiAgICBpZiAoZGVsZXRlZEl0ZW0gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RldGFjaENoaWxkKGRlbGV0ZWRJdGVtKTtcbiAgICBpZiAocmVzdWx0Lm1vZGlmaWVkID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQubW9kaWZpZWQudXBkYXRlc1swXTtcbiAgfVxuICAjYXBwbHlSZW1vdGVJbnNlcnQob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBhc1BvcyhvcC5wYXJlbnRLZXkpO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy4jc2hpZnRJdGVtUG9zaXRpb24oZXhpc3RpbmdJdGVtSW5kZXgsIGtleSk7XG4gICAgfVxuICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuI2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KG9wLCBrZXkpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pXSksXG4gICAgICByZXZlcnNlOiBbXVxuICAgIH07XG4gIH1cbiAgI2FwcGx5SW5zZXJ0QWNrKG9wKSB7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtID0gdGhpcy4jaXRlbXMuZmluZCgoaXRlbSkgPT4gaXRlbS5faWQgPT09IG9wLmlkKTtcbiAgICBjb25zdCBrZXkgPSBhc1BvcyhvcC5wYXJlbnRLZXkpO1xuICAgIGNvbnN0IGl0ZW1JbmRleEF0UG9zaXRpb24gPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtKSB7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtLl9wYXJlbnRLZXkgPT09IGtleSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb2xkUG9zaXRpb25JbmRleCA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoZXhpc3RpbmdJdGVtKTtcbiAgICAgICAgaWYgKGl0ZW1JbmRleEF0UG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy4jc2hpZnRJdGVtUG9zaXRpb24oaXRlbUluZGV4QXRQb3NpdGlvbiwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBleGlzdGluZ0l0ZW0uX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgICAgIGlmIChuZXdJbmRleCA9PT0gb2xkUG9zaXRpb25JbmRleCkge1xuICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW1xuICAgICAgICAgICAgbW92ZURlbHRhKG9sZFBvc2l0aW9uSW5kZXgsIG5ld0luZGV4LCBleGlzdGluZ0l0ZW0pXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3JwaGFuID0gbm4odGhpcy5fcG9vbCkuZ2V0Tm9kZShvcC5pZCk7XG4gICAgICBpZiAob3JwaGFuICYmIHRoaXMuI2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuaGFzKG9ycGhhbikpIHtcbiAgICAgICAgb3JwaGFuLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIHRoaXMuI2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuZGVsZXRlKG9ycGhhbik7XG4gICAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQob3JwaGFuKTtcbiAgICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG9ycGhhbildKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGl0ZW1JbmRleEF0UG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy4jc2hpZnRJdGVtUG9zaXRpb24oaXRlbUluZGV4QXRQb3NpdGlvbiwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG5ld0l0ZW0sIG5ld0luZGV4IH0gPSB0aGlzLiNjcmVhdGVBdHRhY2hJdGVtQW5kU29ydChvcCwga2V5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI2FwcGx5SW5zZXJ0VW5kb1JlZG8ob3ApIHtcbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2w/LmdldE5vZGUoaWQpICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBjaGlsZC5fYXR0YWNoKGlkLCBubih0aGlzLl9wb29sKSk7XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGxldCBuZXdLZXkgPSBrZXk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgY29uc3QgYmVmb3JlMiA9IHRoaXMuI2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XT8uX3BhcmVudFBvcztcbiAgICAgIGNvbnN0IGFmdGVyMiA9IHRoaXMuI2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3M7XG4gICAgICBuZXdLZXkgPSBtYWtlUG9zaXRpb24oYmVmb3JlMiwgYWZ0ZXIyKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgfVxuICAgIHRoaXMuX2luc2VydEFuZFNvcnQoY2hpbGQpO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICByZXZlcnNlOiBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XVxuICAgIH07XG4gIH1cbiAgI2FwcGx5U2V0VW5kb1JlZG8ob3ApIHtcbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2w/LmdldE5vZGUoaWQpICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICB0aGlzLiN1bmFja25vd2xlZGdlZFNldHMuc2V0KGtleSwgbm4ob3Aub3BJZCkpO1xuICAgIGNvbnN0IGluZGV4T2ZJdGVtV2l0aFNhbWVLZXkgPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBjaGlsZC5fYXR0YWNoKGlkLCBubih0aGlzLl9wb29sKSk7XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjb25zdCBuZXdLZXkgPSBrZXk7XG4gICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVLZXkgIT09IC0xKSB7XG4gICAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLiNpdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lS2V5XTtcbiAgICAgIGV4aXN0aW5nSXRlbS5fZGV0YWNoKCk7XG4gICAgICB0aGlzLiNpdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lS2V5XSA9IGNoaWxkO1xuICAgICAgY29uc3QgcmV2ZXJzZSA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIGV4aXN0aW5nSXRlbS5fdG9PcHMobm4odGhpcy5faWQpLCBrZXksIHRoaXMuX3Bvb2wpLFxuICAgICAgICBvcC5pZFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGRlbHRhID0gW3NldERlbHRhKGluZGV4T2ZJdGVtV2l0aFNhbWVLZXksIGNoaWxkKV07XG4gICAgICBjb25zdCBkZWxldGVkRGVsdGEgPSB0aGlzLiNkZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKFxuICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICk7XG4gICAgICBpZiAoZGVsZXRlZERlbHRhKSB7XG4gICAgICAgIGRlbHRhLnB1c2goZGVsZXRlZERlbHRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICB0aGlzLiNkZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKG9wLmRlbGV0ZWRJZCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmV2ZXJzZTogW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV0sXG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgY2hpbGQpXSlcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChvcC5pbnRlbnQgPT09IFwic2V0XCIpIHtcbiAgICAgIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuI2FwcGx5U2V0UmVtb3RlKG9wKTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlID09PSAyIC8qIEFDSyAqLykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLiNhcHBseVNldEFjayhvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLiNhcHBseVNldFVuZG9SZWRvKG9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNvdXJjZSA9PT0gMSAvKiBSRU1PVEUgKi8pIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy4jYXBwbHlSZW1vdGVJbnNlcnQob3ApO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuI2FwcGx5SW5zZXJ0QWNrKG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuI2FwcGx5SW5zZXJ0VW5kb1JlZG8ob3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzdWx0Lm1vZGlmaWVkICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoQ2hpbGQoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGNvbnN0IHBhcmVudEtleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgICAgY29uc3QgcmV2ZXJzZSA9IGNoaWxkLl90b09wcyhubih0aGlzLl9pZCksIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBpbmRleFRvRGVsZXRlID0gdGhpcy4jaXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBpZiAoaW5kZXhUb0RlbGV0ZSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFtwcmV2aW91c05vZGVdID0gdGhpcy4jaXRlbXMuc3BsaWNlKGluZGV4VG9EZWxldGUsIDEpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICBjaGlsZC5fZGV0YWNoKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbZGVsZXRlRGVsdGEoaW5kZXhUb0RlbGV0ZSwgcHJldmlvdXNOb2RlKV0pLFxuICAgICAgICByZXZlcnNlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgfVxuICAjYXBwbHlTZXRDaGlsZEtleVJlbW90ZShuZXdLZXksIGNoaWxkKSB7XG4gICAgaWYgKHRoaXMuI2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuaGFzKGNoaWxkKSkge1xuICAgICAgdGhpcy4jaW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQoY2hpbGQpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLiNpdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c0tleSA9IGNoaWxkLl9wYXJlbnRLZXk7XG4gICAgaWYgKG5ld0tleSA9PT0gcHJldmlvdXNLZXkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggPT09IC0xKSB7XG4gICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy4jaXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKG5ld0luZGV4ID09PSBwcmV2aW91c0luZGV4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgbWFrZVBvc2l0aW9uKG5ld0tleSwgdGhpcy4jaXRlbXNbZXhpc3RpbmdJdGVtSW5kZXggKyAxXT8uX3BhcmVudFBvcylcbiAgICAgICk7XG4gICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy4jaXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKG5ld0luZGV4ID09PSBwcmV2aW91c0luZGV4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgIH07XG4gICAgfVxuICB9XG4gICNhcHBseVNldENoaWxkS2V5QWNrKG5ld0tleSwgY2hpbGQpIHtcbiAgICBjb25zdCBwcmV2aW91c0tleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgIGlmICh0aGlzLiNpbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhjaGlsZCkpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgICB0aGlzLiNpbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmRlbGV0ZShjaGlsZCk7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuI2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuI2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXdLZXkgPT09IHByZXZpb3VzS2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy4jaXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLiNpdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBtYWtlUG9zaXRpb24obmV3S2V5LCB0aGlzLiNpdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLiNpdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChwcmV2aW91c0luZGV4ID09PSBuZXdJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBtb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGNoaWxkKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNhcHBseVNldENoaWxkS2V5VW5kb1JlZG8obmV3S2V5LCBjaGlsZCkge1xuICAgIGNvbnN0IHByZXZpb3VzS2V5ID0gbm4oY2hpbGQuX3BhcmVudEtleSk7XG4gICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy4jaXRlbXNbZXhpc3RpbmdJdGVtSW5kZXhdLl9zZXRQYXJlbnRMaW5rKFxuICAgICAgICB0aGlzLFxuICAgICAgICBtYWtlUG9zaXRpb24obmV3S2V5LCB0aGlzLiNpdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zKVxuICAgICAgKTtcbiAgICB9XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgIGlmIChwcmV2aW91c0luZGV4ID09PSBuZXdJbmRleCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICByZXZlcnNlOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAxIC8qIFNFVF9QQVJFTlRfS0VZICovLFxuICAgICAgICAgIGlkOiBubihjaGlsZC5faWQpLFxuICAgICAgICAgIHBhcmVudEtleTogcHJldmlvdXNLZXlcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2V0Q2hpbGRLZXkobmV3S2V5LCBjaGlsZCwgc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZSA9PT0gMSAvKiBSRU1PVEUgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLiNhcHBseVNldENoaWxkS2V5UmVtb3RlKG5ld0tleSwgY2hpbGQpO1xuICAgIH0gZWxzZSBpZiAoc291cmNlID09PSAyIC8qIEFDSyAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuI2FwcGx5U2V0Q2hpbGRLZXlBY2sobmV3S2V5LCBjaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLiNhcHBseVNldENoaWxkS2V5VW5kb1JlZG8obmV3S2V5LCBjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5KG9wLCBpc0xvY2FsKSB7XG4gICAgcmV0dXJuIHN1cGVyLl9hcHBseShvcCwgaXNMb2NhbCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2VyaWFsaXplKCkge1xuICAgIGlmICh0aGlzLnBhcmVudC50eXBlICE9PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIExpdmVMaXN0IGlmIHBhcmVudCBpcyBtaXNzaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMSAvKiBMSVNUICovLFxuICAgICAgcGFyZW50SWQ6IG5uKHRoaXMucGFyZW50Lm5vZGUuX2lkLCBcIlBhcmVudCBub2RlIGV4cGVjdGVkIHRvIGhhdmUgSURcIiksXG4gICAgICBwYXJlbnRLZXk6IHRoaXMucGFyZW50LmtleVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cy5cbiAgICovXG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2l0ZW1zLmxlbmd0aDtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvbmUgZWxlbWVudCB0byB0aGUgZW5kIG9mIHRoZSBMaXZlTGlzdC5cbiAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSBlbmQgb2YgdGhlIExpdmVMaXN0LlxuICAgKi9cbiAgcHVzaChlbGVtZW50KSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnQoZWxlbWVudCwgdGhpcy5sZW5ndGgpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnRzIG9uZSBlbGVtZW50IGF0IGEgc3BlY2lmaWVkIGluZGV4LlxuICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBpbnNlcnQuXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggYXQgd2hpY2ggeW91IHdhbnQgdG8gaW5zZXJ0IHRoZSBlbGVtZW50LlxuICAgKi9cbiAgaW5zZXJ0KGVsZW1lbnQsIGluZGV4KSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGhpcy4jaXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgaW5zZXJ0IGxpc3QgaXRlbSBhdCBpbmRleCBcIlx1MDAxZCR7aW5kZXh9XCIuIGluZGV4IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kICR7dGhpcy4jaXRlbXMubGVuZ3RofWBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGJlZm9yZTIgPSB0aGlzLiNpdGVtc1tpbmRleCAtIDFdID8gdGhpcy4jaXRlbXNbaW5kZXggLSAxXS5fcGFyZW50UG9zIDogdm9pZCAwO1xuICAgIGNvbnN0IGFmdGVyMiA9IHRoaXMuI2l0ZW1zW2luZGV4XSA/IHRoaXMuI2l0ZW1zW2luZGV4XS5fcGFyZW50UG9zIDogdm9pZCAwO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gbWFrZVBvc2l0aW9uKGJlZm9yZTIsIGFmdGVyMik7XG4gICAgY29uc3QgdmFsdWUgPSBsc29uVG9MaXZlTm9kZShlbGVtZW50KTtcbiAgICB2YWx1ZS5fc2V0UGFyZW50TGluayh0aGlzLCBwb3NpdGlvbik7XG4gICAgdGhpcy5faW5zZXJ0QW5kU29ydCh2YWx1ZSk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgJiYgdGhpcy5faWQpIHtcbiAgICAgIGNvbnN0IGlkID0gdGhpcy5fcG9vbC5nZW5lcmF0ZUlkKCk7XG4gICAgICB2YWx1ZS5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2goXG4gICAgICAgIHZhbHVlLl90b09wcyh0aGlzLl9pZCwgcG9zaXRpb24sIHRoaXMuX3Bvb2wpLFxuICAgICAgICBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICAgIFt0aGlzLl9pZCwgbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEoaW5kZXgsIHZhbHVlKV0pXVxuICAgICAgICBdKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE1vdmUgb25lIGVsZW1lbnQgZnJvbSBvbmUgaW5kZXggdG8gYW5vdGhlci5cbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byBtb3ZlXG4gICAqIEBwYXJhbSB0YXJnZXRJbmRleCBUaGUgaW5kZXggd2hlcmUgdGhlIGVsZW1lbnQgc2hvdWxkIGJlIGFmdGVyIG1vdmluZy5cbiAgICovXG4gIG1vdmUoaW5kZXgsIHRhcmdldEluZGV4KSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAodGFyZ2V0SW5kZXggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXRJbmRleCBjYW5ub3QgYmUgbGVzcyB0aGFuIDBcIik7XG4gICAgfVxuICAgIGlmICh0YXJnZXRJbmRleCA+PSB0aGlzLiNpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJ0YXJnZXRJbmRleCBjYW5ub3QgYmUgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHRoZSBsaXN0IGxlbmd0aFwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBjYW5ub3QgYmUgbGVzcyB0aGFuIDBcIik7XG4gICAgfVxuICAgIGlmIChpbmRleCA+PSB0aGlzLiNpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImluZGV4IGNhbm5vdCBiZSBncmVhdGVyIG9yIGVxdWFsIHRoYW4gdGhlIGxpc3QgbGVuZ3RoXCIpO1xuICAgIH1cbiAgICBsZXQgYmVmb3JlUG9zaXRpb24gPSBudWxsO1xuICAgIGxldCBhZnRlclBvc2l0aW9uID0gbnVsbDtcbiAgICBpZiAoaW5kZXggPCB0YXJnZXRJbmRleCkge1xuICAgICAgYWZ0ZXJQb3NpdGlvbiA9IHRhcmdldEluZGV4ID09PSB0aGlzLiNpdGVtcy5sZW5ndGggLSAxID8gdm9pZCAwIDogdGhpcy4jaXRlbXNbdGFyZ2V0SW5kZXggKyAxXS5fcGFyZW50UG9zO1xuICAgICAgYmVmb3JlUG9zaXRpb24gPSB0aGlzLiNpdGVtc1t0YXJnZXRJbmRleF0uX3BhcmVudFBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJQb3NpdGlvbiA9IHRoaXMuI2l0ZW1zW3RhcmdldEluZGV4XS5fcGFyZW50UG9zO1xuICAgICAgYmVmb3JlUG9zaXRpb24gPSB0YXJnZXRJbmRleCA9PT0gMCA/IHZvaWQgMCA6IHRoaXMuI2l0ZW1zW3RhcmdldEluZGV4IC0gMV0uX3BhcmVudFBvcztcbiAgICB9XG4gICAgY29uc3QgcG9zaXRpb24gPSBtYWtlUG9zaXRpb24oYmVmb3JlUG9zaXRpb24sIGFmdGVyUG9zaXRpb24pO1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLiNpdGVtc1tpbmRleF07XG4gICAgY29uc3QgcHJldmlvdXNQb3NpdGlvbiA9IGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKTtcbiAgICBpdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIHBvc2l0aW9uKTtcbiAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFt0aGlzLl9pZCwgbWFrZVVwZGF0ZSh0aGlzLCBbbW92ZURlbHRhKGluZGV4LCB0YXJnZXRJbmRleCwgaXRlbSldKV1cbiAgICAgIF0pO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgICAgW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgICBpZDogbm4oaXRlbS5faWQpLFxuICAgICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgICAgICAgIHBhcmVudEtleTogcG9zaXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAxIC8qIFNFVF9QQVJFTlRfS0VZICovLFxuICAgICAgICAgICAgaWQ6IG5uKGl0ZW0uX2lkKSxcbiAgICAgICAgICAgIHBhcmVudEtleTogcHJldmlvdXNQb3NpdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGFuIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIGRlbGV0ZVxuICAgKi9cbiAgZGVsZXRlKGluZGV4KSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuI2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGRlbGV0ZSBsaXN0IGl0ZW0gYXQgaW5kZXggXCIke2luZGV4fVwiLiBpbmRleCBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAke3RoaXMuI2l0ZW1zLmxlbmd0aCAtIDF9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuI2l0ZW1zW2luZGV4XTtcbiAgICBpdGVtLl9kZXRhY2goKTtcbiAgICBjb25zdCBbcHJldl0gPSB0aGlzLiNpdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGlmICh0aGlzLl9wb29sKSB7XG4gICAgICBjb25zdCBjaGlsZFJlY29yZElkID0gaXRlbS5faWQ7XG4gICAgICBpZiAoY2hpbGRSZWNvcmRJZCkge1xuICAgICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHN0b3JhZ2VVcGRhdGVzLnNldChcbiAgICAgICAgICBubih0aGlzLl9pZCksXG4gICAgICAgICAgbWFrZVVwZGF0ZSh0aGlzLCBbZGVsZXRlRGVsdGEoaW5kZXgsIHByZXYpXSlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgICAgICBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlkOiBjaGlsZFJlY29yZElkLFxuICAgICAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpLFxuICAgICAgICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXSxcbiAgICAgICAgICBpdGVtLl90b09wcyhubih0aGlzLl9pZCksIGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKSksXG4gICAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCkge1xuICAgICAgY29uc3Qgb3BzID0gW107XG4gICAgICBjb25zdCByZXZlcnNlT3BzID0gW107XG4gICAgICBjb25zdCB1cGRhdGVEZWx0YSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuI2l0ZW1zKSB7XG4gICAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgICAgICBjb25zdCBjaGlsZElkID0gaXRlbS5faWQ7XG4gICAgICAgIGlmIChjaGlsZElkKSB7XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICAgICAgICAgIGlkOiBjaGlsZElkLFxuICAgICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldmVyc2VPcHMucHVzaChcbiAgICAgICAgICAgIC4uLml0ZW0uX3RvT3BzKG5uKHRoaXMuX2lkKSwgaXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpKVxuICAgICAgICAgICk7XG4gICAgICAgICAgdXBkYXRlRGVsdGEucHVzaChkZWxldGVEZWx0YSgwLCBpdGVtKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuI2l0ZW1zID0gW107XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzLnNldChubih0aGlzLl9pZCksIG1ha2VVcGRhdGUodGhpcywgdXBkYXRlRGVsdGEpKTtcbiAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2gob3BzLCByZXZlcnNlT3BzLCBzdG9yYWdlVXBkYXRlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLiNpdGVtcykge1xuICAgICAgICBpdGVtLl9kZXRhY2goKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI2l0ZW1zID0gW107XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICB9XG4gIH1cbiAgc2V0KGluZGV4LCBpdGVtKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuI2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IHNldCBsaXN0IGl0ZW0gYXQgaW5kZXggXCJcdTAwMWQke2luZGV4fVwiLiBpbmRleCBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAke3RoaXMuI2l0ZW1zLmxlbmd0aCAtIDF9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtID0gdGhpcy4jaXRlbXNbaW5kZXhdO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gZXhpc3RpbmdJdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCk7XG4gICAgY29uc3QgZXhpc3RpbmdJZCA9IGV4aXN0aW5nSXRlbS5faWQ7XG4gICAgZXhpc3RpbmdJdGVtLl9kZXRhY2goKTtcbiAgICBjb25zdCB2YWx1ZSA9IGxzb25Ub0xpdmVOb2RlKGl0ZW0pO1xuICAgIHZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIHBvc2l0aW9uKTtcbiAgICB0aGlzLiNpdGVtc1tpbmRleF0gPSB2YWx1ZTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlSWQoKTtcbiAgICAgIHZhbHVlLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCBtYWtlVXBkYXRlKHRoaXMsIFtzZXREZWx0YShpbmRleCwgdmFsdWUpXSkpO1xuICAgICAgY29uc3Qgb3BzID0gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihcbiAgICAgICAgdmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBwb3NpdGlvbiwgdGhpcy5fcG9vbCksXG4gICAgICAgIGV4aXN0aW5nSWRcbiAgICAgICk7XG4gICAgICB0aGlzLiN1bmFja25vd2xlZGdlZFNldHMuc2V0KHBvc2l0aW9uLCBubihvcHNbMF0ub3BJZCkpO1xuICAgICAgY29uc3QgcmV2ZXJzZU9wcyA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIGV4aXN0aW5nSXRlbS5fdG9PcHModGhpcy5faWQsIHBvc2l0aW9uLCB2b2lkIDApLFxuICAgICAgICBpZFxuICAgICAgKTtcbiAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2gob3BzLCByZXZlcnNlT3BzLCBzdG9yYWdlVXBkYXRlcyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIEFycmF5IG9mIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIExpdmVMaXN0LlxuICAgKi9cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaXRlbXMubWFwKFxuICAgICAgKGVudHJ5KSA9PiBsaXZlTm9kZVRvTHNvbihlbnRyeSlcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF5eXl5eXl5eXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGSVhNRSEgVGhpcyBpc24ndCBzYWZlLlxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFRlc3RzIHdoZXRoZXIgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHRlc3QgaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIHRlc3QgZm9yIGVhY2ggZWxlbWVudCwgdGFraW5nIHR3byBhcmd1bWVudHMgKHRoZSBlbGVtZW50IGFuZCBpdHMgaW5kZXgpLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gcmV0dXJucyBhIHRydXRoeSB2YWx1ZSBmb3IgZXZlcnkgZWxlbWVudC4gT3RoZXJ3aXNlLCBmYWxzZS5cbiAgICovXG4gIGV2ZXJ5KHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5ldmVyeShwcmVkaWNhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGVsZW1lbnRzIHRoYXQgcGFzcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gdGVzdCBlYWNoIGVsZW1lbnQgb2YgdGhlIExpdmVMaXN0LiBSZXR1cm4gYSB2YWx1ZSB0aGF0IGNvZXJjZXMgdG8gdHJ1ZSB0byBrZWVwIHRoZSBlbGVtZW50LCBvciB0byBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IHdpdGggdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyB0aGUgdGVzdC5cbiAgICovXG4gIGZpbHRlcihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZmlsdGVyKHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIHZhbHVlLlxuICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0IHRoYXQgc2F0aXNmaWVzIHRoZSBwcm92aWRlZCB0ZXN0aW5nIGZ1bmN0aW9uLiBPdGhlcndpc2UsIHVuZGVmaW5lZCBpcyByZXR1cm5lZC5cbiAgICovXG4gIGZpbmQocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZpbmQocHJlZGljYXRlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0IHRoYXQgc2F0aXNmaWVzIHRoZSBwcm92aWRlZCB0ZXN0aW5nIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCB2YWx1ZSB1bnRpbCB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlLCBpbmRpY2F0aW5nIHRoYXQgdGhlIHNhdGlzZnlpbmcgZWxlbWVudCB3YXMgZm91bmQuXG4gICAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3QgdGhhdCBwYXNzZXMgdGhlIHRlc3QuIE90aGVyd2lzZSwgLTEuXG4gICAqL1xuICBmaW5kSW5kZXgocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZpbmRJbmRleChwcmVkaWNhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uY2UgZm9yIGVhY2ggZWxlbWVudC5cbiAgICogQHBhcmFtIGNhbGxiYWNrZm4gRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIGVsZW1lbnQuXG4gICAqL1xuICBmb3JFYWNoKGNhbGxiYWNrZm4pIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZm9yRWFjaChjYWxsYmFja2ZuKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb24gdGhlIGVsZW1lbnQgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyBUaGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IG9yIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldChpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy4jaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gbGl2ZU5vZGVUb0xzb24odGhpcy4jaXRlbXNbaW5kZXhdKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiBlbGVtZW50IGNhbiBiZSBmb3VuZCBpbiB0aGUgTGl2ZUxpc3QsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICAgKiBAcGFyYW0gc2VhcmNoRWxlbWVudCBFbGVtZW50IHRvIGxvY2F0ZS5cbiAgICogQHBhcmFtIGZyb21JbmRleCBUaGUgaW5kZXggdG8gc3RhcnQgdGhlIHNlYXJjaCBhdC5cbiAgICogQHJldHVybnMgVGhlIGZpcnN0IGluZGV4IG9mIHRoZSBlbGVtZW50IGluIHRoZSBMaXZlTGlzdDsgLTEgaWYgbm90IGZvdW5kLlxuICAgKi9cbiAgaW5kZXhPZihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuaW5kZXhPZihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsYXN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gdGhlIExpdmVMaXN0LCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC4gVGhlIExpdmVMc2l0IGlzIHNlYXJjaGVkIGJhY2t3YXJkcywgc3RhcnRpbmcgYXQgZnJvbUluZGV4LlxuICAgKiBAcGFyYW0gc2VhcmNoRWxlbWVudCBFbGVtZW50IHRvIGxvY2F0ZS5cbiAgICogQHBhcmFtIGZyb21JbmRleCBUaGUgaW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nIGJhY2t3YXJkcy5cbiAgICogQHJldHVybnNcbiAgICovXG4gIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5sYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IHBvcHVsYXRlZCB3aXRoIHRoZSByZXN1bHRzIG9mIGNhbGxpbmcgYSBwcm92aWRlZCBmdW5jdGlvbiBvbiBldmVyeSBlbGVtZW50LlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgZm9yIGV2ZXJ5IGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IHdpdGggZWFjaCBlbGVtZW50IGJlaW5nIHRoZSByZXN1bHQgb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKi9cbiAgbWFwKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuI2l0ZW1zLm1hcChcbiAgICAgIChlbnRyeSwgaSkgPT4gY2FsbGJhY2soXG4gICAgICAgIGxpdmVOb2RlVG9Mc29uKGVudHJ5KSxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIF5eXl5eXl5eXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBGSVhNRSEgVGhpcyBpc24ndCBzYWZlLlxuICAgICAgICBpXG4gICAgICApXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogVGVzdHMgd2hldGhlciBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3QgcGFzc2VzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byB0ZXN0IGZvciBlYWNoIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgZm9yIGF0IGxlYXN0IG9uZSBlbGVtZW50LiBPdGhlcndpc2UsIGZhbHNlLlxuICAgKi9cbiAgc29tZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuc29tZShwcmVkaWNhdGUpO1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBuZXcgTGl2ZUxpc3RJdGVyYXRvcih0aGlzLiNpdGVtcyk7XG4gIH1cbiAgI2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KG9wLCBrZXkpIHtcbiAgICBjb25zdCBuZXdJdGVtID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIG5ld0l0ZW0uX2F0dGFjaChvcC5pZCwgbm4odGhpcy5fcG9vbCkpO1xuICAgIG5ld0l0ZW0uX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KG5ld0l0ZW0pO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgcmV0dXJuIHsgbmV3SXRlbSwgbmV3SW5kZXggfTtcbiAgfVxuICAjc2hpZnRJdGVtUG9zaXRpb24oaW5kZXgsIGtleSkge1xuICAgIGNvbnN0IHNoaWZ0ZWRQb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihcbiAgICAgIGtleSxcbiAgICAgIHRoaXMuI2l0ZW1zLmxlbmd0aCA+IGluZGV4ICsgMSA/IHRoaXMuI2l0ZW1zW2luZGV4ICsgMV0/Ll9wYXJlbnRQb3MgOiB2b2lkIDBcbiAgICApO1xuICAgIHRoaXMuI2l0ZW1zW2luZGV4XS5fc2V0UGFyZW50TGluayh0aGlzLCBzaGlmdGVkUG9zaXRpb24pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICAgIGlkOiB0aGlzLl9pZCA/PyBuYW5vaWQoKSxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IHRoaXMuI2l0ZW1zLm1hcChcbiAgICAgICAgKGl0ZW0sIGluZGV4KSA9PiBpdGVtLnRvVHJlZU5vZGUoaW5kZXgudG9TdHJpbmcoKSlcbiAgICAgIClcbiAgICB9O1xuICB9XG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci50b0ltbXV0YWJsZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI2l0ZW1zLm1hcCgobm9kZSkgPT4gbm9kZS50b0ltbXV0YWJsZSgpKTtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gcmVzdWx0IDogT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX0xpdmVMaXN0KHRoaXMuI2l0ZW1zLm1hcCgoaXRlbSkgPT4gaXRlbS5jbG9uZSgpKSk7XG4gIH1cbn07XG52YXIgTGl2ZUxpc3RJdGVyYXRvciA9IGNsYXNzIHtcbiAgI2lubmVySXRlcmF0b3I7XG4gIGNvbnN0cnVjdG9yKGl0ZW1zKSB7XG4gICAgdGhpcy4jaW5uZXJJdGVyYXRvciA9IGl0ZW1zW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBuZXh0KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI2lubmVySXRlcmF0b3IubmV4dCgpO1xuICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBsaXZlTm9kZVRvTHNvbihyZXN1bHQudmFsdWUpO1xuICAgIHJldHVybiB7IHZhbHVlIH07XG4gIH1cbn07XG5mdW5jdGlvbiBtYWtlVXBkYXRlKGxpdmVMaXN0LCBkZWx0YVVwZGF0ZXMpIHtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiBsaXZlTGlzdCxcbiAgICB0eXBlOiBcIkxpdmVMaXN0XCIsXG4gICAgdXBkYXRlczogZGVsdGFVcGRhdGVzXG4gIH07XG59XG5mdW5jdGlvbiBzZXREZWx0YShpbmRleCwgaXRlbSkge1xuICByZXR1cm4ge1xuICAgIGluZGV4LFxuICAgIHR5cGU6IFwic2V0XCIsXG4gICAgaXRlbTogaXRlbSBpbnN0YW5jZW9mIExpdmVSZWdpc3RlciA/IGl0ZW0uZGF0YSA6IGl0ZW1cbiAgfTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZURlbHRhKGluZGV4LCBkZWxldGVkTm9kZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZGVsZXRlXCIsXG4gICAgaW5kZXgsXG4gICAgZGVsZXRlZEl0ZW06IGRlbGV0ZWROb2RlIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyID8gZGVsZXRlZE5vZGUuZGF0YSA6IGRlbGV0ZWROb2RlXG4gIH07XG59XG5mdW5jdGlvbiBpbnNlcnREZWx0YShpbmRleCwgaXRlbSkge1xuICByZXR1cm4ge1xuICAgIGluZGV4LFxuICAgIHR5cGU6IFwiaW5zZXJ0XCIsXG4gICAgaXRlbTogaXRlbSBpbnN0YW5jZW9mIExpdmVSZWdpc3RlciA/IGl0ZW0uZGF0YSA6IGl0ZW1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1vdmVEZWx0YShwcmV2aW91c0luZGV4LCBpbmRleCwgaXRlbSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibW92ZVwiLFxuICAgIGluZGV4LFxuICAgIGl0ZW06IGl0ZW0gaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXIgPyBpdGVtLmRhdGEgOiBpdGVtLFxuICAgIHByZXZpb3VzSW5kZXhcbiAgfTtcbn1cbmZ1bmN0aW9uIEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24ob3BzLCBkZWxldGVkSWQpIHtcbiAgcmV0dXJuIG9wcy5tYXAoKG9wLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgY29uc3QgZmlyc3RPcCA9IG9wO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZmlyc3RPcCxcbiAgICAgICAgaW50ZW50OiBcInNldFwiLFxuICAgICAgICBkZWxldGVkSWRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcDtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvY3JkdHMvTGl2ZU1hcC50c1xudmFyIExpdmVNYXAgPSBjbGFzcyBfTGl2ZU1hcCBleHRlbmRzIEFic3RyYWN0Q3JkdCB7XG4gICNtYXA7XG4gICN1bmFja25vd2xlZGdlZFNldDtcbiAgY29uc3RydWN0b3IoZW50cmllczIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI3VuYWNrbm93bGVkZ2VkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBpZiAoZW50cmllczIpIHtcbiAgICAgIGNvbnN0IG1hcHBlZEVudHJpZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMyKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBsc29uVG9MaXZlTm9kZSh2YWx1ZSk7XG4gICAgICAgIG5vZGUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgbWFwcGVkRW50cmllcy5wdXNoKFtrZXksIG5vZGVdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI21hcCA9IG5ldyBNYXAobWFwcGVkRW50cmllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI21hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvT3BzKHBhcmVudElkLCBwYXJlbnRLZXksIHBvb2wpIHtcbiAgICBpZiAodGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBpdGVtIGlzIG5vdCBhdHRhY2hlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICBvcElkOiBwb29sPy5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgIHR5cGU6IDcgLyogQ1JFQVRFX01BUCAqLyxcbiAgICAgIHBhcmVudElkLFxuICAgICAgcGFyZW50S2V5XG4gICAgfTtcbiAgICBvcHMucHVzaChvcCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy4jbWFwKSB7XG4gICAgICBvcHMucHVzaCguLi52YWx1ZS5fdG9PcHModGhpcy5faWQsIGtleSwgcG9vbCkpO1xuICAgIH1cbiAgICByZXR1cm4gb3BzO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZShbaWQsIF9pdGVtXSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBfTGl2ZU1hcCgpO1xuICAgIG1hcC5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KGlkKTtcbiAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbaWQyLCBjcmR0XSBvZiBjaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGQgPSBkZXNlcmlhbGl6ZShbaWQyLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayhtYXAsIGNyZHQucGFyZW50S2V5KTtcbiAgICAgIG1hcC4jbWFwLnNldChjcmR0LnBhcmVudEtleSwgY2hpbGQpO1xuICAgICAgbWFwLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBzdXBlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBmb3IgKGNvbnN0IFtfa2V5LCB2YWx1ZV0gb2YgdGhpcy4jbWFwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX2F0dGFjaChwb29sLmdlbmVyYXRlSWQoKSwgcG9vbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXksIG9wSWQgfSA9IG9wO1xuICAgIGNvbnN0IGtleSA9IHBhcmVudEtleTtcbiAgICBjb25zdCBjaGlsZCA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBpZiAodGhpcy5fcG9vbC5nZXROb2RlKGlkKSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZSA9PT0gMiAvKiBBQ0sgKi8pIHtcbiAgICAgIGNvbnN0IGxhc3RVcGRhdGVPcElkID0gdGhpcy4jdW5hY2tub3dsZWRnZWRTZXQuZ2V0KGtleSk7XG4gICAgICBpZiAobGFzdFVwZGF0ZU9wSWQgPT09IG9wSWQpIHtcbiAgICAgICAgdGhpcy4jdW5hY2tub3dsZWRnZWRTZXQuZGVsZXRlKGtleSk7XG4gICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgfSBlbHNlIGlmIChsYXN0VXBkYXRlT3BJZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc291cmNlID09PSAxIC8qIFJFTU9URSAqLykge1xuICAgICAgdGhpcy4jdW5hY2tub3dsZWRnZWRTZXQuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0aGlzLiNtYXAuZ2V0KGtleSk7XG4gICAgbGV0IHJldmVyc2U7XG4gICAgaWYgKHByZXZpb3VzVmFsdWUpIHtcbiAgICAgIGNvbnN0IHRoaXNJZCA9IG5uKHRoaXMuX2lkKTtcbiAgICAgIHJldmVyc2UgPSBwcmV2aW91c1ZhbHVlLl90b09wcyh0aGlzSWQsIGtleSk7XG4gICAgICBwcmV2aW91c1ZhbHVlLl9kZXRhY2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV2ZXJzZSA9IFt7IHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sIGlkIH1dO1xuICAgIH1cbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIGNoaWxkLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgIHRoaXMuI21hcC5zZXQoa2V5LCBjaGlsZCk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVkOiB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwidXBkYXRlXCIgfSB9XG4gICAgICB9LFxuICAgICAgcmV2ZXJzZVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoKCkge1xuICAgIHN1cGVyLl9kZXRhY2goKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy4jbWFwLnZhbHVlcygpKSB7XG4gICAgICBpdGVtLl9kZXRhY2goKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoQ2hpbGQoY2hpbGQpIHtcbiAgICBjb25zdCBpZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICBjb25zdCByZXZlcnNlID0gY2hpbGQuX3RvT3BzKGlkLCBwYXJlbnRLZXksIHRoaXMuX3Bvb2wpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuI21hcCkge1xuICAgICAgaWYgKHZhbHVlID09PSBjaGlsZCkge1xuICAgICAgICB0aGlzLiNtYXAuZGVsZXRlKGtleSk7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjaGlsZC5fZGV0YWNoKCk7XG4gICAgY29uc3Qgc3RvcmFnZVVwZGF0ZSA9IHtcbiAgICAgIG5vZGU6IHRoaXMsXG4gICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgIHVwZGF0ZXM6IHsgW3BhcmVudEtleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICB9O1xuICAgIHJldHVybiB7IG1vZGlmaWVkOiBzdG9yYWdlVXBkYXRlLCByZXZlcnNlIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2VyaWFsaXplKCkge1xuICAgIGlmICh0aGlzLnBhcmVudC50eXBlICE9PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIExpdmVNYXAgaWYgcGFyZW50IGlzIG1pc3NpbmdcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAyIC8qIE1BUCAqLyxcbiAgICAgIHBhcmVudElkOiBubih0aGlzLnBhcmVudC5ub2RlLl9pZCwgXCJQYXJlbnQgbm9kZSBleHBlY3RlZCB0byBoYXZlIElEXCIpLFxuICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3BlY2lmaWVkIGVsZW1lbnQgZnJvbSB0aGUgTGl2ZU1hcC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICogQHJldHVybnMgVGhlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LCBvciB1bmRlZmluZWQgaWYgdGhlIGtleSBjYW4ndCBiZSBmb3VuZCBpbiB0aGUgTGl2ZU1hcC5cbiAgICovXG4gIGdldChrZXkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI21hcC5nZXQoa2V5KTtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVOb2RlVG9Mc29uKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIGFuIGVsZW1lbnQgd2l0aCBhIHNwZWNpZmllZCBrZXkgYW5kIGEgdmFsdWUuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byBhZGQuIFNob3VsZCBiZSBhIHN0cmluZy5cbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCB0byBhZGQuIFNob3VsZCBiZSBzZXJpYWxpemFibGUgdG8gSlNPTi5cbiAgICovXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuI21hcC5nZXQoa2V5KTtcbiAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IGxzb25Ub0xpdmVOb2RlKHZhbHVlKTtcbiAgICBpdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgdGhpcy4jbWFwLnNldChrZXksIGl0ZW0pO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuX3Bvb2wuZ2VuZXJhdGVJZCgpO1xuICAgICAgaXRlbS5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzLnNldCh0aGlzLl9pZCwge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcInVwZGF0ZVwiIH0gfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBvcHMgPSBpdGVtLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKTtcbiAgICAgIHRoaXMuI3VuYWNrbm93bGVkZ2VkU2V0LnNldChrZXksIG5uKG9wc1swXS5vcElkKSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBpdGVtLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKSxcbiAgICAgICAgb2xkVmFsdWUgPyBvbGRWYWx1ZS5fdG9PcHModGhpcy5faWQsIGtleSkgOiBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XSxcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIExpdmVNYXAuXG4gICAqL1xuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jbWFwLnNpemU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCBrZXkgZXhpc3RzIG9yIG5vdC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHRlc3QgZm9yIHByZXNlbmNlLlxuICAgKi9cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLiNtYXAuaGFzKGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBlbGVtZW50IGJ5IGtleS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiBhbiBlbGVtZW50IGV4aXN0ZWQgYW5kIGhhcyBiZWVuIHJlbW92ZWQsIG9yIGZhbHNlIGlmIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0LlxuICAgKi9cbiAgZGVsZXRlKGtleSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuI21hcC5nZXQoa2V5KTtcbiAgICBpZiAoaXRlbSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIHRoaXMuI21hcC5kZWxldGUoa2V5KTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiBpdGVtLl9pZCkge1xuICAgICAgY29uc3QgdGhpc0lkID0gbm4odGhpcy5faWQpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXNJZCwge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH0gfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICAgICAgICAgIGlkOiBpdGVtLl9pZCxcbiAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKClcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGl0ZW0uX3RvT3BzKHRoaXNJZCwga2V5KSxcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBba2V5LCB2YWx1ZV0gcGFpcnMgZm9yIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIGVudHJpZXMoKSB7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRoaXMuI21hcC5lbnRyaWVzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvclZhbHVlID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChpdGVyYXRvclZhbHVlLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gaXRlcmF0b3JWYWx1ZS52YWx1ZTtcbiAgICAgICAgY29uc3Qga2V5ID0gZW50cnlbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGl2ZU5vZGVUb0xzb24oaXRlcmF0b3JWYWx1ZS52YWx1ZVsxXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IFtrZXksIHZhbHVlXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNhbWUgZnVuY3Rpb24gb2JqZWN0IGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBlbnRyaWVzIG1ldGhvZC5cbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUga2V5cyBmb3IgZWFjaCBlbGVtZW50LlxuICAgKi9cbiAga2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy4jbWFwLmtleXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgdmFsdWVzIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqL1xuICB2YWx1ZXMoKSB7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRoaXMuI21hcC52YWx1ZXMoKTtcbiAgICByZXR1cm4ge1xuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yVmFsdWUgPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yVmFsdWUuZG9uZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBsaXZlTm9kZVRvTHNvbihpdGVyYXRvclZhbHVlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uY2UgcGVyIGVhY2gga2V5L3ZhbHVlIHBhaXIgaW4gdGhlIE1hcCBvYmplY3QsIGluIGluc2VydGlvbiBvcmRlci5cbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZW50cnkgaW4gdGhlIG1hcC5cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMpIHtcbiAgICAgIGNhbGxiYWNrKGVudHJ5WzFdLCBlbnRyeVswXSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgaWQ6IHRoaXMuX2lkID8/IG5hbm9pZCgpLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogQXJyYXkuZnJvbSh0aGlzLiNtYXAuZW50cmllcygpKS5tYXAoXG4gICAgICAgIChba2V5MiwgdmFsXSkgPT4gdmFsLnRvVHJlZU5vZGUoa2V5MilcbiAgICAgIClcbiAgICB9O1xuICB9XG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci50b0ltbXV0YWJsZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy4jbWFwKSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUudG9JbW11dGFibGUoKSk7XG4gICAgfVxuICAgIHJldHVybiBmcmVlemUocmVzdWx0KTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9MaXZlTWFwKFxuICAgICAgQXJyYXkuZnJvbSh0aGlzLiNtYXApLm1hcCgoW2tleSwgbm9kZV0pID0+IFtrZXksIG5vZGUuY2xvbmUoKV0pXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2NyZHRzL0xpdmVPYmplY3QudHNcbnZhciBMaXZlT2JqZWN0ID0gY2xhc3MgX0xpdmVPYmplY3QgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICAjbWFwO1xuICAjcHJvcFRvTGFzdFVwZGF0ZTtcbiAgc3RhdGljICNidWlsZFJvb3RBbmRQYXJlbnRUb0NoaWxkcmVuKGl0ZW1zKSB7XG4gICAgY29uc3QgcGFyZW50VG9DaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IHJvb3QgPSBudWxsO1xuICAgIGZvciAoY29uc3QgW2lkLCBjcmR0XSBvZiBpdGVtcykge1xuICAgICAgaWYgKGlzUm9vdENyZHQoY3JkdCkpIHtcbiAgICAgICAgcm9vdCA9IFtpZCwgY3JkdF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0dXBsZSA9IFtpZCwgY3JkdF07XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50VG9DaGlsZHJlbi5nZXQoY3JkdC5wYXJlbnRJZCk7XG4gICAgICAgIGlmIChjaGlsZHJlbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh0dXBsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyZW50VG9DaGlsZHJlbi5zZXQoY3JkdC5wYXJlbnRJZCwgW3R1cGxlXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJvb3QgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvb3QgY2FuJ3QgYmUgbnVsbFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFtyb290LCBwYXJlbnRUb0NoaWxkcmVuXTtcbiAgfVxuICAvKiogQHByaXZhdGUgRG8gbm90IHVzZSB0aGlzIEFQSSBkaXJlY3RseSAqL1xuICBzdGF0aWMgX2Zyb21JdGVtcyhpdGVtcywgcG9vbCkge1xuICAgIGNvbnN0IFtyb290LCBwYXJlbnRUb0NoaWxkcmVuXSA9IF9MaXZlT2JqZWN0LiNidWlsZFJvb3RBbmRQYXJlbnRUb0NoaWxkcmVuKGl0ZW1zKTtcbiAgICByZXR1cm4gX0xpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFxuICAgICAgcm9vdCxcbiAgICAgIHBhcmVudFRvQ2hpbGRyZW4sXG4gICAgICBwb29sXG4gICAgKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihvYmogPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jcHJvcFRvTGFzdFVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgbyA9IGNvbXBhY3RPYmplY3Qob2JqKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvW2tleV07XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jbWFwID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhvKSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9PcHMocGFyZW50SWQsIHBhcmVudEtleSwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIGl0ZW0gaXMgbm90IGF0dGFjaGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBvcElkID0gcG9vbD8uZ2VuZXJhdGVPcElkKCk7XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICB0eXBlOiA0IC8qIENSRUFURV9PQkpFQ1QgKi8sXG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICBvcElkLFxuICAgICAgcGFyZW50SWQsXG4gICAgICBwYXJlbnRLZXksXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuI21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIG9wcy5wdXNoKC4uLnZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCBwb29sKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcC5kYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBpdGVtXSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IGxpdmVPYmogPSBuZXcgX0xpdmVPYmplY3QoaXRlbS5kYXRhKTtcbiAgICBsaXZlT2JqLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZUNoaWxkcmVuKGxpdmVPYmosIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZUNoaWxkcmVuKGxpdmVPYmosIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KG5uKGxpdmVPYmouX2lkKSk7XG4gICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBsaXZlT2JqO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZCwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemVUb0xzb24oW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgICBpZiAoaXNMaXZlU3RydWN0dXJlKGNoaWxkKSkge1xuICAgICAgICBjaGlsZC5fc2V0UGFyZW50TGluayhsaXZlT2JqLCBjcmR0LnBhcmVudEtleSk7XG4gICAgICB9XG4gICAgICBsaXZlT2JqLiNtYXAuc2V0KGNyZHQucGFyZW50S2V5LCBjaGlsZCk7XG4gICAgICBsaXZlT2JqLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVPYmo7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoKGlkLCBwb29sKSB7XG4gICAgc3VwZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgZm9yIChjb25zdCBbX2tleSwgdmFsdWVdIG9mIHRoaXMuI21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLl9hdHRhY2gocG9vbC5nZW5lcmF0ZUlkKCksIHBvb2wpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgb3BJZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTHNvbihvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wuZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wSWQpIHtcbiAgICAgICAgdGhpcy4jcHJvcFRvTGFzdFVwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBpZiAoc291cmNlID09PSAwIC8qIFVORE9SRURPX1JFQ09OTkVDVCAqLykge1xuICAgICAgdGhpcy4jcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihvcElkKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNwcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wSWQpIHtcbiAgICAgIHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IHRoaXNJZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy4jbWFwLmdldChrZXkpO1xuICAgIGxldCByZXZlcnNlO1xuICAgIGlmIChpc0xpdmVOb2RlKHByZXZpb3VzVmFsdWUpKSB7XG4gICAgICByZXZlcnNlID0gcHJldmlvdXNWYWx1ZS5fdG9PcHModGhpc0lkLCBrZXkpO1xuICAgICAgcHJldmlvdXNWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIGlmIChwcmV2aW91c1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldmVyc2UgPSBbeyB0eXBlOiA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovLCBpZDogdGhpc0lkLCBrZXkgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgaWQ6IHRoaXNJZCxcbiAgICAgICAgICBkYXRhOiB7IFtrZXldOiBwcmV2aW91c1ZhbHVlIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgdGhpcy4jbWFwLnNldChrZXksIGNoaWxkKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAoaXNMaXZlU3RydWN0dXJlKGNoaWxkKSkge1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgIGNoaWxkLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmV2ZXJzZSxcbiAgICAgIG1vZGlmaWVkOiB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwidXBkYXRlXCIgfSB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2hDaGlsZChjaGlsZCkge1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgY29uc3QgaWQgPSBubih0aGlzLl9pZCk7XG4gICAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICAgIGNvbnN0IHJldmVyc2UgPSBjaGlsZC5fdG9PcHMoaWQsIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLiNtYXApIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBjaGlsZCkge1xuICAgICAgICAgIHRoaXMuI21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hpbGQuX2RldGFjaCgpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZSA9IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgICBbcGFyZW50S2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBzdG9yYWdlVXBkYXRlLCByZXZlcnNlIH07XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBzdXBlci5fZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLiNtYXAudmFsdWVzKCkpIHtcbiAgICAgIGlmIChpc0xpdmVOb2RlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5KG9wLCBpc0xvY2FsKSB7XG4gICAgaWYgKG9wLnR5cGUgPT09IDMgLyogVVBEQVRFX09CSkVDVCAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuI2FwcGx5VXBkYXRlKG9wLCBpc0xvY2FsKTtcbiAgICB9IGVsc2UgaWYgKG9wLnR5cGUgPT09IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLiNhcHBseURlbGV0ZU9iamVjdEtleShvcCwgaXNMb2NhbCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5fYXBwbHkob3AsIGlzTG9jYWwpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBjb25zdCBkYXRhID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy4jbWFwKSB7XG4gICAgICBpZiAoIWlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIiAmJiB0aGlzLnBhcmVudC5ub2RlLl9pZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMCAvKiBPQkpFQ1QgKi8sXG4gICAgICAgIHBhcmVudElkOiB0aGlzLnBhcmVudC5ub2RlLl9pZCxcbiAgICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXksXG4gICAgICAgIGRhdGFcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDAgLyogT0JKRUNUICovLFxuICAgICAgICBkYXRhXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAjYXBwbHlVcGRhdGUob3AsIGlzTG9jYWwpIHtcbiAgICBsZXQgaXNNb2RpZmllZCA9IGZhbHNlO1xuICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgIGNvbnN0IHJldmVyc2UgPSBbXTtcbiAgICBjb25zdCByZXZlcnNlVXBkYXRlID0ge1xuICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgaWQsXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3AuZGF0YSkge1xuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLiNtYXAuZ2V0KGtleSk7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgcmV2ZXJzZS5wdXNoKC4uLm9sZFZhbHVlLl90b09wcyhpZCwga2V5KSk7XG4gICAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICByZXZlcnNlVXBkYXRlLmRhdGFba2V5XSA9IG9sZFZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldmVyc2UucHVzaCh7IHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sIGlkLCBrZXkgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZURlbHRhID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3AuZGF0YSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvcC5kYXRhW2tleV07XG4gICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xvY2FsKSB7XG4gICAgICAgIHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuc2V0KGtleSwgbm4ob3Aub3BJZCkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLiNwcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICAgICAgaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wLm9wSWQpIHtcbiAgICAgICAgdGhpcy4jcHJvcFRvTGFzdFVwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy4jbWFwLmdldChrZXkpO1xuICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgIH1cbiAgICAgIGlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgdXBkYXRlRGVsdGFba2V5XSA9IHsgdHlwZTogXCJ1cGRhdGVcIiB9O1xuICAgICAgdGhpcy4jbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMocmV2ZXJzZVVwZGF0ZS5kYXRhKS5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldmVyc2UudW5zaGlmdChyZXZlcnNlVXBkYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzTW9kaWZpZWQgPyB7XG4gICAgICBtb2RpZmllZDoge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgICAgdXBkYXRlczogdXBkYXRlRGVsdGFcbiAgICAgIH0sXG4gICAgICByZXZlcnNlXG4gICAgfSA6IHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gIH1cbiAgI2FwcGx5RGVsZXRlT2JqZWN0S2V5KG9wLCBpc0xvY2FsKSB7XG4gICAgY29uc3Qga2V5ID0gb3Aua2V5O1xuICAgIGlmICh0aGlzLiNtYXAuaGFzKGtleSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgaWYgKCFpc0xvY2FsICYmIHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy4jbWFwLmdldChrZXkpO1xuICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgIGxldCByZXZlcnNlID0gW107XG4gICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICByZXZlcnNlID0gb2xkVmFsdWUuX3RvT3BzKGlkLCBvcC5rZXkpO1xuICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgcmV2ZXJzZSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBkYXRhOiB7IFtrZXldOiBvbGRWYWx1ZSB9XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIHRoaXMuI21hcC5kZWxldGUoa2V5KTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW29wLmtleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICAgIH0sXG4gICAgICByZXZlcnNlXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBMaXZlT2JqZWN0IGludG8gYSBqYXZhc2NyaXB0IG9iamVjdFxuICAgKi9cbiAgdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLiNtYXApO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgYSBwcm9wZXJ0eSB3aXRoIGEgc3BlY2lmaWVkIGtleSBhbmQgYSB2YWx1ZS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhZGRcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gYWRkXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgdGhpcy51cGRhdGUoeyBba2V5XTogdmFsdWUgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzcGVjaWZpZWQgcHJvcGVydHkgZnJvbSB0aGUgTGl2ZU9iamVjdC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXRcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy4jbWFwLmdldChrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEga2V5IGZyb20gdGhlIExpdmVPYmplY3RcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShrZXkpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGNvbnN0IGtleUFzU3RyaW5nID0ga2V5O1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy4jbWFwLmdldChrZXlBc1N0cmluZyk7XG4gICAgaWYgKG9sZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCB8fCB0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy4jbWFwLmRlbGV0ZShrZXlBc1N0cmluZyk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHJldmVyc2U7XG4gICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICByZXZlcnNlID0gb2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXlBc1N0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgZGF0YTogeyBba2V5QXNTdHJpbmddOiBvbGRWYWx1ZSB9LFxuICAgICAgICAgIGlkOiB0aGlzLl9pZFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgICB0aGlzLiNtYXAuZGVsZXRlKGtleUFzU3RyaW5nKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfSB9XG4gICAgfSk7XG4gICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sXG4gICAgICAgICAga2V5OiBrZXlBc1N0cmluZyxcbiAgICAgICAgICBpZDogdGhpcy5faWQsXG4gICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgcmV2ZXJzZSxcbiAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZSB3aXRoIGFuIG9iamVjdC5cbiAgICogQHBhcmFtIHBhdGNoIFRoZSBvYmplY3QgdXNlZCB0byBvdmVycmlkZXMgcHJvcGVydGllc1xuICAgKi9cbiAgdXBkYXRlKHBhdGNoKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwIHx8IHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoKSB7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcGF0Y2hba2V5XTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuI21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xpdmVOb2RlKG5ld1ZhbHVlKSkge1xuICAgICAgICAgIG5ld1ZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbWFwLnNldChrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IHJldmVyc2VPcHMgPSBbXTtcbiAgICBjb25zdCBvcElkID0gdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKTtcbiAgICBjb25zdCB1cGRhdGVkUHJvcHMgPSB7fTtcbiAgICBjb25zdCByZXZlcnNlVXBkYXRlT3AgPSB7XG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgY29uc3QgdXBkYXRlRGVsdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXRjaCkge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBwYXRjaFtrZXldO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuI21hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICByZXZlcnNlT3BzLnB1c2goLi4ub2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXkpKTtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldmVyc2VPcHMucHVzaCh7IHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sIGlkOiB0aGlzLl9pZCwga2V5IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV2ZXJzZVVwZGF0ZU9wLmRhdGFba2V5XSA9IG9sZFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzTGl2ZU5vZGUobmV3VmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIG5ld1ZhbHVlLl9hdHRhY2godGhpcy5fcG9vbC5nZW5lcmF0ZUlkKCksIHRoaXMuX3Bvb2wpO1xuICAgICAgICBjb25zdCBuZXdBdHRhY2hDaGlsZE9wcyA9IG5ld1ZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKTtcbiAgICAgICAgY29uc3QgY3JlYXRlQ3JkdE9wID0gbmV3QXR0YWNoQ2hpbGRPcHMuZmluZChcbiAgICAgICAgICAob3ApID0+IG9wLnBhcmVudElkID09PSB0aGlzLl9pZFxuICAgICAgICApO1xuICAgICAgICBpZiAoY3JlYXRlQ3JkdE9wKSB7XG4gICAgICAgICAgdGhpcy4jcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihjcmVhdGVDcmR0T3Aub3BJZCkpO1xuICAgICAgICB9XG4gICAgICAgIG9wcy5wdXNoKC4uLm5ld0F0dGFjaENoaWxkT3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZWRQcm9wc1trZXldID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuc2V0KGtleSwgb3BJZCk7XG4gICAgICB9XG4gICAgICB0aGlzLiNtYXAuc2V0KGtleSwgbmV3VmFsdWUpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB1cGRhdGVEZWx0YVtrZXldID0geyB0eXBlOiBcInVwZGF0ZVwiIH07XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhyZXZlcnNlVXBkYXRlT3AuZGF0YSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXZlcnNlT3BzLnVuc2hpZnQocmV2ZXJzZVVwZGF0ZU9wKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZWRQcm9wcykubGVuZ3RoICE9PSAwKSB7XG4gICAgICBvcHMudW5zaGlmdCh7XG4gICAgICAgIG9wSWQsXG4gICAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICBkYXRhOiB1cGRhdGVkUHJvcHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICB1cGRhdGVzOiB1cGRhdGVEZWx0YVxuICAgIH0pO1xuICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2gob3BzLCByZXZlcnNlT3BzLCBzdG9yYWdlVXBkYXRlcyk7XG4gIH1cbiAgdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvSW1tdXRhYmxlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB0b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiBzdXBlci50b1RyZWVOb2RlKGtleSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9UcmVlTm9kZShrZXkpIHtcbiAgICBjb25zdCBub2RlSWQgPSB0aGlzLl9pZCA/PyBuYW5vaWQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICBpZDogbm9kZUlkLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogQXJyYXkuZnJvbSh0aGlzLiNtYXAuZW50cmllcygpKS5tYXAoXG4gICAgICAgIChba2V5MiwgdmFsdWVdKSA9PiBpc0xpdmVOb2RlKHZhbHVlKSA/IHZhbHVlLnRvVHJlZU5vZGUoa2V5MikgOiB7IHR5cGU6IFwiSnNvblwiLCBpZDogYCR7bm9kZUlkfToke2tleTJ9YCwga2V5OiBrZXkyLCBwYXlsb2FkOiB2YWx1ZSB9XG4gICAgICApXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy4jbWFwKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGlzTGl2ZVN0cnVjdHVyZSh2YWwpID8gdmFsLnRvSW1tdXRhYmxlKCkgOiB2YWw7XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyByZXN1bHQgOiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfTGl2ZU9iamVjdChcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLiNtYXApLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBbXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkgPyB2YWx1ZS5jbG9uZSgpIDogZGVlcENsb25lKHZhbHVlKVxuICAgICAgICBdKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9jcmR0cy9saXZlYmxvY2tzLWhlbHBlcnMudHNcbmZ1bmN0aW9uIGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKSB7XG4gIHJldHVybiBsc29uVG9MaXZlTm9kZShjcmVhdGlvbk9wVG9Mc29uKG9wKSk7XG59XG5mdW5jdGlvbiBjcmVhdGlvbk9wVG9Mc29uKG9wKSB7XG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgOCAvKiBDUkVBVEVfUkVHSVNURVIgKi86XG4gICAgICByZXR1cm4gb3AuZGF0YTtcbiAgICBjYXNlIDQgLyogQ1JFQVRFX09CSkVDVCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZU9iamVjdChvcC5kYXRhKTtcbiAgICBjYXNlIDcgLyogQ1JFQVRFX01BUCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZU1hcCgpO1xuICAgIGNhc2UgMiAvKiBDUkVBVEVfTElTVCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZUxpc3QoW10pO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIob3AsIFwiVW5rbm93biBjcmVhdGlvbiBPcFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTYW1lTm9kZU9yQ2hpbGRPZihub2RlLCBwYXJlbnQpIHtcbiAgaWYgKG5vZGUgPT09IHBhcmVudCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChub2RlLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgcmV0dXJuIGlzU2FtZU5vZGVPckNoaWxkT2Yobm9kZS5wYXJlbnQubm9kZSwgcGFyZW50KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgY2FzZSAwIC8qIE9CSkVDVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDEgLyogTElTVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVMaXN0Ll9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAyIC8qIE1BUCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVNYXAuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDMgLyogUkVHSVNURVIgKi86IHtcbiAgICAgIHJldHVybiBMaXZlUmVnaXN0ZXIuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIENSRFQgdHlwZVwiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplVG9Mc29uKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgc3dpdGNoIChjcmR0LnR5cGUpIHtcbiAgICBjYXNlIDAgLyogT0JKRUNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU9iamVjdC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMSAvKiBMSVNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZUxpc3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDIgLyogTUFQICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU1hcC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMyAvKiBSRUdJU1RFUiAqLzoge1xuICAgICAgcmV0dXJuIGNyZHQuZGF0YTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBDUkRUIHR5cGVcIik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpIHtcbiAgcmV0dXJuIGlzTGl2ZUxpc3QodmFsdWUpIHx8IGlzTGl2ZU1hcCh2YWx1ZSkgfHwgaXNMaXZlT2JqZWN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkgfHwgaXNMaXZlUmVnaXN0ZXIodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNMaXZlTGlzdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlTGlzdDtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU1hcCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwO1xufVxuZnVuY3Rpb24gaXNMaXZlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3Q7XG59XG5mdW5jdGlvbiBpc0xpdmVSZWdpc3Rlcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXI7XG59XG5mdW5jdGlvbiBjbG9uZUxzb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpID8gdmFsdWUuY2xvbmUoKSA6IGRlZXBDbG9uZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBsaXZlTm9kZVRvTHNvbihvYmopIHtcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIExpdmVSZWdpc3Rlcikge1xuICAgIHJldHVybiBvYmouZGF0YTtcbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMaXZlTGlzdCB8fCBvYmogaW5zdGFuY2VvZiBMaXZlTWFwIHx8IG9iaiBpbnN0YW5jZW9mIExpdmVPYmplY3QpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc3NlcnROZXZlcihvYmosIFwiVW5rbm93biBBYnN0cmFjdENyZHRcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGxzb25Ub0xpdmVOb2RlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlUmVnaXN0ZXIodmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUcmVlc0RpZmZPcGVyYXRpb25zKGN1cnJlbnRJdGVtcywgbmV3SXRlbXMpIHtcbiAgY29uc3Qgb3BzID0gW107XG4gIGN1cnJlbnRJdGVtcy5mb3JFYWNoKChfLCBpZCkgPT4ge1xuICAgIGlmICghbmV3SXRlbXMuZ2V0KGlkKSkge1xuICAgICAgb3BzLnB1c2goe1xuICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLFxuICAgICAgICBpZFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgbmV3SXRlbXMuZm9yRWFjaCgoY3JkdCwgaWQpID0+IHtcbiAgICBjb25zdCBjdXJyZW50Q3JkdCA9IGN1cnJlbnRJdGVtcy5nZXQoaWQpO1xuICAgIGlmIChjdXJyZW50Q3JkdCkge1xuICAgICAgaWYgKGNyZHQudHlwZSA9PT0gMCAvKiBPQkpFQ1QgKi8pIHtcbiAgICAgICAgaWYgKGN1cnJlbnRDcmR0LnR5cGUgIT09IDAgLyogT0JKRUNUICovIHx8IHN0cmluZ2lmeU9yTG9nKGNyZHQuZGF0YSkgIT09IHN0cmluZ2lmeU9yTG9nKGN1cnJlbnRDcmR0LmRhdGEpKSB7XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBkYXRhOiBjcmR0LmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNyZHQucGFyZW50S2V5ICE9PSBjdXJyZW50Q3JkdC5wYXJlbnRLZXkpIHtcbiAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGFyZW50S2V5OiBubihjcmR0LnBhcmVudEtleSwgXCJQYXJlbnQga2V5IG11c3Qgbm90IGJlIG1pc3NpbmdcIilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgICAgIGNhc2UgMyAvKiBSRUdJU1RFUiAqLzpcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA4IC8qIENSRUFURV9SRUdJU1RFUiAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5LFxuICAgICAgICAgICAgZGF0YTogY3JkdC5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBMSVNUICovOlxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDIgLyogQ1JFQVRFX0xJU1QgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDAgLyogT0JKRUNUICovOlxuICAgICAgICAgIGlmIChjcmR0LnBhcmVudElkID09PSB2b2lkIDAgfHwgY3JkdC5wYXJlbnRLZXkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBcIkludGVybmFsIGVycm9yLiBDYW5ub3Qgc2VyaWFsaXplIHN0b3JhZ2Ugcm9vdCBpbnRvIGFuIG9wZXJhdGlvblwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA0IC8qIENSRUFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleSxcbiAgICAgICAgICAgIGRhdGE6IGNyZHQuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogTUFQICovOlxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDcgLyogQ1JFQVRFX01BUCAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG9wcztcbn1cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBjb25zdCB1cGRhdGVzID0gZmlyc3QudXBkYXRlcztcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cmllcyhzZWNvbmQudXBkYXRlcykpIHtcbiAgICB1cGRhdGVzW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnNlY29uZCxcbiAgICB1cGRhdGVzXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZU1hcFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IGZpcnN0LnVwZGF0ZXM7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMoc2Vjb25kLnVwZGF0ZXMpKSB7XG4gICAgdXBkYXRlc1trZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlc1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VMaXN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBjb25zdCB1cGRhdGVzID0gZmlyc3QudXBkYXRlcztcbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlczogdXBkYXRlcy5jb25jYXQoc2Vjb25kLnVwZGF0ZXMpXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZVN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgaWYgKGZpcnN0ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gc2Vjb25kO1xuICB9XG4gIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVPYmplY3RcIiAmJiBzZWNvbmQudHlwZSA9PT0gXCJMaXZlT2JqZWN0XCIpIHtcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVNYXBcIiAmJiBzZWNvbmQudHlwZSA9PT0gXCJMaXZlTWFwXCIpIHtcbiAgICByZXR1cm4gbWVyZ2VNYXBTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVMaXN0XCIgJiYgc2Vjb25kLnR5cGUgPT09IFwiTGl2ZUxpc3RcIikge1xuICAgIHJldHVybiBtZXJnZUxpc3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIHtcbiAgfVxuICByZXR1cm4gc2Vjb25kO1xufVxuZnVuY3Rpb24gaXNQbGFpbih2YWx1ZSkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUodmFsdWUsIHBhdGggPSBcIlwiKSB7XG4gIGlmICghaXNQbGFpbikge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBwYXRoIHx8IFwicm9vdFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCBuZXN0ZWRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgaWYgKCFpc1BsYWluKG5lc3RlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogbmVzdGVkUGF0aCxcbiAgICAgICAgdmFsdWU6IG5lc3RlZFZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCBub25TZXJpYWxpemFibGVOZXN0ZWRWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShcbiAgICAgICAgbmVzdGVkVmFsdWUsXG4gICAgICAgIG5lc3RlZFBhdGhcbiAgICAgICk7XG4gICAgICBpZiAobm9uU2VyaWFsaXphYmxlTmVzdGVkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5vblNlcmlhbGl6YWJsZU5lc3RlZFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNyYy9saWIvZGVidWcudHNcbmZ1bmN0aW9uIGNhcHR1cmVTdGFja1RyYWNlKG1zZywgdHJhY2VSb290KSB7XG4gIGNvbnN0IGVycm9yTGlrZSA9IHsgbmFtZTogbXNnIH07XG4gIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3JMaWtlLCB0cmFjZVJvb3QpO1xuICByZXR1cm4gZXJyb3JMaWtlLnN0YWNrO1xufVxuXG4vLyBzcmMvbGliL0RlcXVlLnRzXG52YXIgRGVxdWUgPSBjbGFzcyB7XG4gICNkYXRhO1xuICAjZnJvbnQ7XG4gICNiYWNrO1xuICAjc2l6ZTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy4jZGF0YSA9IHt9O1xuICAgIHRoaXMuI2Zyb250ID0gMDtcbiAgICB0aGlzLiNiYWNrID0gMTtcbiAgICB0aGlzLiNzaXplID0gMDtcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLiNzaXplO1xuICB9XG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBjb25zdCBzaXplID0gdGhpcy4jc2l6ZTtcbiAgICBjb25zdCBmcm9udCA9IHRoaXMuI2Zyb250O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICB5aWVsZCB0aGlzLiNkYXRhW2Zyb250ICsgaV07XG4gICAgfVxuICB9XG4gIHB1c2godmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZXMyID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgaWYgKHRoaXMuI2JhY2sgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAtIHZhbHVlczIubGVuZ3RoIC0gMSlcbiAgICAgIHJhaXNlKFwiRGVxdWUgZnVsbFwiKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlMiBvZiB2YWx1ZXMyKSB7XG4gICAgICB0aGlzLiNkYXRhW3RoaXMuI2JhY2srKyAtIDFdID0gdmFsdWUyO1xuICAgIH1cbiAgICB0aGlzLiNzaXplICs9IHZhbHVlczIubGVuZ3RoO1xuICB9XG4gIHBvcCgpIHtcbiAgICBpZiAodGhpcy4jc2l6ZSA8IDEpIHJldHVybiB2b2lkIDA7XG4gICAgdGhpcy4jYmFjay0tO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jZGF0YVt0aGlzLiNiYWNrIC0gMV07XG4gICAgZGVsZXRlIHRoaXMuI2RhdGFbdGhpcy4jYmFjayAtIDFdO1xuICAgIHRoaXMuI3NpemUtLTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcHVzaExlZnQodmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZXMyID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgaWYgKHRoaXMuI2Zyb250IDwgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgKyB2YWx1ZXMyLmxlbmd0aClcbiAgICAgIHJhaXNlKFwiRGVxdWUgZnVsbFwiKTtcbiAgICBmb3IgKGxldCBpID0gdmFsdWVzMi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy4jZGF0YVstLXRoaXMuI2Zyb250XSA9IHZhbHVlczJbaV07XG4gICAgfVxuICAgIHRoaXMuI3NpemUgKz0gdmFsdWVzMi5sZW5ndGg7XG4gIH1cbiAgcG9wTGVmdCgpIHtcbiAgICBpZiAodGhpcy4jc2l6ZSA8IDEpIHJldHVybiB2b2lkIDA7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiNkYXRhW3RoaXMuI2Zyb250XTtcbiAgICBkZWxldGUgdGhpcy4jZGF0YVt0aGlzLiNmcm9udF07XG4gICAgdGhpcy4jZnJvbnQrKztcbiAgICB0aGlzLiNzaXplLS07XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL0pzb24udHNcbmZ1bmN0aW9uIGlzSnNvblNjYWxhcihkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSBudWxsIHx8IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBkYXRhID09PSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIGlzSnNvbkFycmF5KGRhdGEpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGF0YSk7XG59XG5mdW5jdGlvbiBpc0pzb25PYmplY3QoZGF0YSkge1xuICByZXR1cm4gIWlzSnNvblNjYWxhcihkYXRhKSAmJiAhaXNKc29uQXJyYXkoZGF0YSk7XG59XG5cbi8vIHNyYy9wcm90b2NvbC9DbGllbnRNc2cudHNcbnZhciBDbGllbnRNc2dDb2RlID0gLyogQF9fUFVSRV9fICovICgoQ2xpZW50TXNnQ29kZTIpID0+IHtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJVUERBVEVfUFJFU0VOQ0VcIl0gPSAxMDBdID0gXCJVUERBVEVfUFJFU0VOQ0VcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJCUk9BRENBU1RfRVZFTlRcIl0gPSAxMDNdID0gXCJCUk9BRENBU1RfRVZFTlRcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJGRVRDSF9TVE9SQUdFXCJdID0gMjAwXSA9IFwiRkVUQ0hfU1RPUkFHRVwiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIlVQREFURV9TVE9SQUdFXCJdID0gMjAxXSA9IFwiVVBEQVRFX1NUT1JBR0VcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJGRVRDSF9ZRE9DXCJdID0gMzAwXSA9IFwiRkVUQ0hfWURPQ1wiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIlVQREFURV9ZRE9DXCJdID0gMzAxXSA9IFwiVVBEQVRFX1lET0NcIjtcbiAgcmV0dXJuIENsaWVudE1zZ0NvZGUyO1xufSkoQ2xpZW50TXNnQ29kZSB8fCB7fSk7XG5cbi8vIHNyYy9yZWZzL01hbmFnZWRPdGhlcnMudHNcbmZ1bmN0aW9uIG1ha2VVc2VyKGNvbm4sIHByZXNlbmNlKSB7XG4gIGNvbnN0IHsgY29ubmVjdGlvbklkLCBpZCwgaW5mbyB9ID0gY29ubjtcbiAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2UoY29ubi5zY29wZXMpO1xuICByZXR1cm4gZnJlZXplKFxuICAgIGNvbXBhY3RPYmplY3Qoe1xuICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgaWQsXG4gICAgICBpbmZvLFxuICAgICAgY2FuV3JpdGUsXG4gICAgICBjYW5Db21tZW50OiBjYW5Db21tZW50KGNvbm4uc2NvcGVzKSxcbiAgICAgIGlzUmVhZE9ubHk6ICFjYW5Xcml0ZSxcbiAgICAgIC8vIERlcHJlY2F0ZWQsIGtlcHQgZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHlcbiAgICAgIHByZXNlbmNlXG4gICAgfSlcbiAgKTtcbn1cbnZhciBNYW5hZ2VkT3RoZXJzID0gY2xhc3Mge1xuICAvLyBUcmFjayBtdXRhYmxlIHN0YXRlIGludGVybmFsbHksIGJ1dCBzaWduYWwgdG8gdGhlIG91dHNpZGUgd2hlbiB0aGVcbiAgLy8gb2JzZXJ2YWJsZSBkZXJpdmVkIHN0YXRlIGNoYW5nZXMgb25seVxuICAjaW50ZXJuYWw7XG4gICN1c2VyQ2FjaGU7XG4gIC8vIFRoZSBcImNsZWFuXCIgc2lnbmFsIHRoYXQgaXMgZXhwb3NlZCB0byB0aGUgb3V0c2lkZSB3b3JsZFxuICBzaWduYWw7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuI2ludGVybmFsID0gbmV3IE11dGFibGVTaWduYWwoe1xuICAgICAgY29ubmVjdGlvbnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICBwcmVzZW5jZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgICB9KTtcbiAgICB0aGlzLnNpZ25hbCA9IERlcml2ZWRTaWduYWwuZnJvbShcbiAgICAgIHRoaXMuI2ludGVybmFsLFxuICAgICAgKF9pZ25vcmUpID0+IGNvbXBhY3QoXG4gICAgICAgIEFycmF5LmZyb20odGhpcy4jaW50ZXJuYWwuZ2V0KCkucHJlc2VuY2VzLmtleXMoKSkubWFwKFxuICAgICAgICAgIChjb25uZWN0aW9uSWQpID0+IHRoaXMuZ2V0VXNlcihOdW1iZXIoY29ubmVjdGlvbklkKSlcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gICAgdGhpcy4jdXNlckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICAvLyBTaG9ydGhhbmQgZm9yIC5zaWduYWwuZ2V0KClcbiAgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLnNpZ25hbC5nZXQoKTtcbiAgfVxuICBjb25uZWN0aW9uSWRzKCkge1xuICAgIHJldHVybiB0aGlzLiNpbnRlcm5hbC5nZXQoKS5jb25uZWN0aW9ucy5rZXlzKCk7XG4gIH1cbiAgY2xlYXJPdGhlcnMoKSB7XG4gICAgdGhpcy4jaW50ZXJuYWwubXV0YXRlKChzdGF0ZSkgPT4ge1xuICAgICAgc3RhdGUuY29ubmVjdGlvbnMuY2xlYXIoKTtcbiAgICAgIHN0YXRlLnByZXNlbmNlcy5jbGVhcigpO1xuICAgICAgdGhpcy4jdXNlckNhY2hlLmNsZWFyKCk7XG4gICAgfSk7XG4gIH1cbiAgI19nZXRVc2VyKGNvbm5lY3Rpb25JZCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy4jaW50ZXJuYWwuZ2V0KCk7XG4gICAgY29uc3QgY29ubiA9IHN0YXRlLmNvbm5lY3Rpb25zLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGNvbnN0IHByZXNlbmNlID0gc3RhdGUucHJlc2VuY2VzLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGlmIChjb25uICE9PSB2b2lkIDAgJiYgcHJlc2VuY2UgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG1ha2VVc2VyKGNvbm4sIHByZXNlbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBnZXRVc2VyKGNvbm5lY3Rpb25JZCkge1xuICAgIGNvbnN0IGNhY2hlZFVzZXIgPSB0aGlzLiN1c2VyQ2FjaGUuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKGNhY2hlZFVzZXIpIHtcbiAgICAgIHJldHVybiBjYWNoZWRVc2VyO1xuICAgIH1cbiAgICBjb25zdCBjb21wdXRlZFVzZXIgPSB0aGlzLiNfZ2V0VXNlcihjb25uZWN0aW9uSWQpO1xuICAgIGlmIChjb21wdXRlZFVzZXIpIHtcbiAgICAgIHRoaXMuI3VzZXJDYWNoZS5zZXQoY29ubmVjdGlvbklkLCBjb21wdXRlZFVzZXIpO1xuICAgICAgcmV0dXJuIGNvbXB1dGVkVXNlcjtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAjaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKSB7XG4gICAgdGhpcy4jdXNlckNhY2hlLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICB9XG4gIC8qKlxuICAgKiBSZWNvcmRzIGEga25vd24gY29ubmVjdGlvbi4gVGhpcyByZWNvcmRzIHRoZSBjb25uZWN0aW9uIElEIGFuZCB0aGVcbiAgICogYXNzb2NpYXRlZCBtZXRhZGF0YS5cbiAgICovXG4gIHNldENvbm5lY3Rpb24oY29ubmVjdGlvbklkLCBtZXRhVXNlcklkLCBtZXRhVXNlckluZm8sIHNjb3Blcykge1xuICAgIHRoaXMuI2ludGVybmFsLm11dGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgIHN0YXRlLmNvbm5lY3Rpb25zLnNldChcbiAgICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgICBmcmVlemUoe1xuICAgICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgICBpZDogbWV0YVVzZXJJZCxcbiAgICAgICAgICBpbmZvOiBtZXRhVXNlckluZm8sXG4gICAgICAgICAgc2NvcGVzXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgaWYgKCFzdGF0ZS5wcmVzZW5jZXMuaGFzKGNvbm5lY3Rpb25JZCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuI2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBrbm93biBjb25uZWN0aW9uSWQuIFJlbW92ZXMgYm90aCB0aGUgY29ubmVjdGlvbidzIG1ldGFkYXRhIGFuZFxuICAgKiB0aGUgcHJlc2VuY2UgaW5mb3JtYXRpb24uXG4gICAqL1xuICByZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCkge1xuICAgIHRoaXMuI2ludGVybmFsLm11dGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgIHN0YXRlLmNvbm5lY3Rpb25zLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgICAgc3RhdGUucHJlc2VuY2VzLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgICAgdGhpcy4jaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3RvcmVzIGEgbmV3IHVzZXIgZnJvbSBhIGZ1bGwgcHJlc2VuY2UgdXBkYXRlLiBJZiB0aGUgdXNlciBhbHJlYWR5IGV4aXN0cyxcbiAgICogaXRzIGtub3duIHByZXNlbmNlIGRhdGEgaXMgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBzZXRPdGhlcihjb25uZWN0aW9uSWQsIHByZXNlbmNlKSB7XG4gICAgdGhpcy4jaW50ZXJuYWwubXV0YXRlKChzdGF0ZSkgPT4ge1xuICAgICAgc3RhdGUucHJlc2VuY2VzLnNldChjb25uZWN0aW9uSWQsIGZyZWV6ZShjb21wYWN0T2JqZWN0KHByZXNlbmNlKSkpO1xuICAgICAgaWYgKCFzdGF0ZS5jb25uZWN0aW9ucy5oYXMoY29ubmVjdGlvbklkKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4jaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUGF0Y2hlcyB0aGUgcHJlc2VuY2UgZGF0YSBmb3IgYW4gZXhpc3RpbmcgXCJvdGhlclwiLiBJZiB3ZSBkb24ndCBrbm93IHRoZVxuICAgKiBpbml0aWFsIHByZXNlbmNlIGRhdGEgZm9yIHRoaXMgdXNlciB5ZXQsIGRpc2NhcmQgdGhpcyBwYXRjaCBhbmQgYXdhaXQgdGhlXG4gICAqIGZ1bGwgLnNldE90aGVyKCkgY2FsbCBmaXJzdC5cbiAgICovXG4gIHBhdGNoT3RoZXIoY29ubmVjdGlvbklkLCBwYXRjaCkge1xuICAgIHRoaXMuI2ludGVybmFsLm11dGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IG9sZFByZXNlbmNlID0gc3RhdGUucHJlc2VuY2VzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgaWYgKG9sZFByZXNlbmNlID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3UHJlc2VuY2UgPSBtZXJnZShvbGRQcmVzZW5jZSwgcGF0Y2gpO1xuICAgICAgaWYgKG9sZFByZXNlbmNlID09PSBuZXdQcmVzZW5jZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wcmVzZW5jZXMuc2V0KGNvbm5lY3Rpb25JZCwgZnJlZXplKG5ld1ByZXNlbmNlKSk7XG4gICAgICByZXR1cm4gdGhpcy4jaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3R5cGVzL0xpdmVibG9ja3NFcnJvci50c1xudmFyIExpdmVibG9ja3NFcnJvciA9IGNsYXNzIF9MaXZlYmxvY2tzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnRleHQ7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvbnRleHQsIGNhdXNlKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgeyBjYXVzZSB9KTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiTGl2ZWJsb2Nrc0Vycm9yXCI7XG4gIH1cbiAgLyoqIENvbnZlbmllbmNlIGFjY2Vzc29yIGZvciBlcnJvci5jb250ZXh0LnJvb21JZCAoaWYgYXZhaWxhYmxlKSAqL1xuICBnZXQgcm9vbUlkKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQucm9vbUlkO1xuICB9XG4gIC8qKiBAZGVwcmVjYXRlZCBQcmVmZXIgdXNpbmcgYGNvbnRleHQuY29kZWAgaW5zdGVhZCwgdG8gZW5hYmxlIHR5cGUgbmFycm93aW5nICovXG4gIGdldCBjb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuY29kZTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIExpdmVibG9ja3NFcnJvciBmcm9tIGEgZ2VuZXJpYyBlcnJvciwgYnkgYXR0YWNoaW5nIExpdmVibG9ja3NcbiAgICogY29udGV4dHVhbCBpbmZvcm1hdGlvbiBsaWtlIHJvb20gSUQsIHRocmVhZCBJRCwgZXRjLlxuICAgKi9cbiAgc3RhdGljIGZyb20oY29udGV4dCwgY2F1c2UpIHtcbiAgICByZXR1cm4gbmV3IF9MaXZlYmxvY2tzRXJyb3IoXG4gICAgICBkZWZhdWx0TWVzc2FnZUZyb21Db250ZXh0KGNvbnRleHQpLFxuICAgICAgY29udGV4dCxcbiAgICAgIGNhdXNlXG4gICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGRlZmF1bHRNZXNzYWdlRnJvbUNvbnRleHQoY29udGV4dCkge1xuICBzd2l0Y2ggKGNvbnRleHQudHlwZSkge1xuICAgIGNhc2UgXCJST09NX0NPTk5FQ1RJT05fRVJST1JcIjoge1xuICAgICAgc3dpdGNoIChjb250ZXh0LmNvZGUpIHtcbiAgICAgICAgY2FzZSA0MDAxOlxuICAgICAgICAgIHJldHVybiBcIk5vdCBhbGxvd2VkIHRvIGNvbm5lY3QgdG8gdGhlIHJvb21cIjtcbiAgICAgICAgY2FzZSA0MDA1OlxuICAgICAgICAgIHJldHVybiBcIlJvb20gaXMgYWxyZWFkeSBmdWxsXCI7XG4gICAgICAgIGNhc2UgNDAwNjpcbiAgICAgICAgICByZXR1cm4gXCJLaWNrZWQgb3V0IG9mIHRoZSByb29tLCBiZWNhdXNlIHRoZSByb29tIElEIGNoYW5nZWRcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gXCJDb3VsZCBub3QgY29ubmVjdCB0byB0aGUgcm9vbVwiO1xuICAgICAgfVxuICAgIH1cbiAgICBjYXNlIFwiQ1JFQVRFX1RIUkVBRF9FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IGNyZWF0ZSBuZXcgdGhyZWFkXCI7XG4gICAgY2FzZSBcIkRFTEVURV9USFJFQURfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBkZWxldGUgdGhyZWFkXCI7XG4gICAgY2FzZSBcIkVESVRfVEhSRUFEX01FVEFEQVRBX0VSUk9SXCI6XG4gICAgICByZXR1cm4gXCJDb3VsZCBub3QgZWRpdCB0aHJlYWQgbWV0YWRhdGFcIjtcbiAgICBjYXNlIFwiTUFSS19USFJFQURfQVNfUkVTT0xWRURfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBtYXJrIHRocmVhZCBhcyByZXNvbHZlZFwiO1xuICAgIGNhc2UgXCJNQVJLX1RIUkVBRF9BU19VTlJFU09MVkVEX0VSUk9SXCI6XG4gICAgICByZXR1cm4gXCJDb3VsZCBub3QgbWFyayB0aHJlYWQgYXMgdW5yZXNvbHZlZFwiO1xuICAgIGNhc2UgXCJDUkVBVEVfQ09NTUVOVF9FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IGNyZWF0ZSBuZXcgY29tbWVudFwiO1xuICAgIGNhc2UgXCJFRElUX0NPTU1FTlRfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBlZGl0IGNvbW1lbnRcIjtcbiAgICBjYXNlIFwiREVMRVRFX0NPTU1FTlRfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBkZWxldGUgY29tbWVudFwiO1xuICAgIGNhc2UgXCJBRERfUkVBQ1RJT05fRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBhZGQgcmVhY3Rpb25cIjtcbiAgICBjYXNlIFwiUkVNT1ZFX1JFQUNUSU9OX0VSUk9SXCI6XG4gICAgICByZXR1cm4gXCJDb3VsZCBub3QgcmVtb3ZlIHJlYWN0aW9uXCI7XG4gICAgY2FzZSBcIk1BUktfSU5CT1hfTk9USUZJQ0FUSU9OX0FTX1JFQURfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBtYXJrIGluYm94IG5vdGlmaWNhdGlvbiBhcyByZWFkXCI7XG4gICAgY2FzZSBcIkRFTEVURV9JTkJPWF9OT1RJRklDQVRJT05fRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBkZWxldGUgaW5ib3ggbm90aWZpY2F0aW9uXCI7XG4gICAgY2FzZSBcIk1BUktfQUxMX0lOQk9YX05PVElGSUNBVElPTlNfQVNfUkVBRF9FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IG1hcmsgYWxsIGluYm94IG5vdGlmaWNhdGlvbnMgYXMgcmVhZFwiO1xuICAgIGNhc2UgXCJERUxFVEVfQUxMX0lOQk9YX05PVElGSUNBVElPTlNfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBkZWxldGUgYWxsIGluYm94IG5vdGlmaWNhdGlvbnNcIjtcbiAgICBjYXNlIFwiVVBEQVRFX05PVElGSUNBVElPTl9TRVRUSU5HU19FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IHVwZGF0ZSBub3RpZmljYXRpb24gc2V0dGluZ3NcIjtcbiAgICBjYXNlIFwiVVBEQVRFX1VTRVJfTk9USUZJQ0FUSU9OX1NFVFRJTkdTX0VSUk9SXCI6XG4gICAgICByZXR1cm4gXCJDb3VsZCBub3QgdXBkYXRlIHVzZXIgbm90aWZpY2F0aW9uIHNldHRpbmdzXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBhc3NlcnROZXZlcihjb250ZXh0LCBcIlVuaGFuZGxlZCBjYXNlXCIpO1xuICB9XG59XG5cbi8vIHNyYy9yb29tLnRzXG52YXIgTUFYX1NPQ0tFVF9NRVNTQUdFX1NJWkUgPSAxMDI0ICogMTAyNCAtIDUxMjtcbmZ1bmN0aW9uIG1ha2VJZEZhY3RvcnkoY29ubmVjdGlvbklkKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIHJldHVybiAoKSA9PiBgJHtjb25uZWN0aW9uSWR9OiR7Y291bnQrK31gO1xufVxuZnVuY3Rpb24gdXNlclRvVHJlZU5vZGUoa2V5LCB1c2VyKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJVc2VyXCIsXG4gICAgaWQ6IGAke3VzZXIuY29ubmVjdGlvbklkfWAsXG4gICAga2V5LFxuICAgIHBheWxvYWQ6IHtcbiAgICAgIGNvbm5lY3Rpb25JZDogdXNlci5jb25uZWN0aW9uSWQsXG4gICAgICBpZDogdXNlci5pZCxcbiAgICAgIGluZm86IHVzZXIuaW5mbyxcbiAgICAgIHByZXNlbmNlOiB1c2VyLnByZXNlbmNlLFxuICAgICAgaXNSZWFkT25seTogIXVzZXIuY2FuV3JpdGVcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpbnN0YWxsQmFja2dyb3VuZFRhYlNweSgpIHtcbiAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gIGNvbnN0IGluQmFja2dyb3VuZFNpbmNlID0geyBjdXJyZW50OiBudWxsIH07XG4gIGZ1bmN0aW9uIG9uVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICBpZiAoZG9jPy52aXNpYmlsaXR5U3RhdGUgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgIGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgPSBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ID8/IERhdGUubm93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBkb2M/LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gIGNvbnN0IHVuc3ViID0gKCkgPT4ge1xuICAgIGRvYz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgfTtcbiAgcmV0dXJuIFtpbkJhY2tncm91bmRTaW5jZSwgdW5zdWJdO1xufVxuZnVuY3Rpb24gY3JlYXRlUm9vbShvcHRpb25zLCBjb25maWcpIHtcbiAgY29uc3Qgcm9vbUlkID0gY29uZmlnLnJvb21JZDtcbiAgY29uc3QgaW5pdGlhbFByZXNlbmNlID0gb3B0aW9ucy5pbml0aWFsUHJlc2VuY2U7XG4gIGNvbnN0IGluaXRpYWxTdG9yYWdlID0gb3B0aW9ucy5pbml0aWFsU3RvcmFnZTtcbiAgY29uc3QgaHR0cENsaWVudCA9IGNvbmZpZy5yb29tSHR0cENsaWVudDtcbiAgY29uc3QgW2luQmFja2dyb3VuZFNpbmNlLCB1bmluc3RhbGxCZ1RhYlNweV0gPSBpbnN0YWxsQmFja2dyb3VuZFRhYlNweSgpO1xuICBjb25zdCBkZWxlZ2F0ZXMgPSB7XG4gICAgLi4uY29uZmlnLmRlbGVnYXRlcyxcbiAgICAvLyBBIGNvbm5lY3Rpb24gaXMgYWxsb3dlZCB0byBnbyBpbnRvIFwiem9tYmllIHN0YXRlXCIgb25seSBpZiBhbGwgb2YgdGhlXG4gICAgLy8gZm9sbG93aW5nIGNvbmRpdGlvbnMgYXBwbHk6XG4gICAgLy9cbiAgICAvLyAtIFRoZSBgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXRgIGNsaWVudCBvcHRpb24gaXMgY29uZmlndXJlZFxuICAgIC8vIC0gVGhlIGJyb3dzZXIgd2luZG93IGhhcyBiZWVuIGluIHRoZSBiYWNrZ3JvdW5kIGZvciBhdCBsZWFzdFxuICAgIC8vICAgYGJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0YCBtaWxsaXNlY29uZHNcbiAgICAvLyAtIFRoZXJlIGFyZSBubyBwZW5kaW5nIGNoYW5nZXNcbiAgICAvL1xuICAgIGNhblpvbWJpZSgpIHtcbiAgICAgIHJldHVybiBjb25maWcuYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQgIT09IHZvaWQgMCAmJiBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ICE9PSBudWxsICYmIERhdGUubm93KCkgPiBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ICsgY29uZmlnLmJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0ICYmIGdldFN0b3JhZ2VTdGF0dXMoKSAhPT0gXCJzeW5jaHJvbml6aW5nXCI7XG4gICAgfVxuICB9O1xuICBjb25zdCBtYW5hZ2VkU29ja2V0ID0gbmV3IE1hbmFnZWRTb2NrZXQoXG4gICAgZGVsZWdhdGVzLFxuICAgIGNvbmZpZy5lbmFibGVEZWJ1Z0xvZ2dpbmdcbiAgKTtcbiAgY29uc3QgY29udGV4dCA9IHtcbiAgICBidWZmZXI6IHtcbiAgICAgIGZsdXNoVGltZXJJRDogdm9pZCAwLFxuICAgICAgbGFzdEZsdXNoZWRBdDogMCxcbiAgICAgIHByZXNlbmNlVXBkYXRlczogKFxuICAgICAgICAvLyBRdWV1ZSB1cCB0aGUgaW5pdGlhbCBwcmVzZW5jZSBtZXNzYWdlIGFzIGEgRnVsbCBQcmVzZW5jZeKEoiB1cGRhdGVcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiZnVsbFwiLFxuICAgICAgICAgIGRhdGE6IGluaXRpYWxQcmVzZW5jZVxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgc3RvcmFnZU9wZXJhdGlvbnM6IFtdXG4gICAgfSxcbiAgICBzdGF0aWNTZXNzaW9uSW5mb1NpZzogbmV3IFNpZ25hbChudWxsKSxcbiAgICBkeW5hbWljU2Vzc2lvbkluZm9TaWc6IG5ldyBTaWduYWwobnVsbCksXG4gICAgbXlQcmVzZW5jZTogbmV3IFBhdGNoYWJsZVNpZ25hbChpbml0aWFsUHJlc2VuY2UpLFxuICAgIG90aGVyczogbmV3IE1hbmFnZWRPdGhlcnMoKSxcbiAgICBpbml0aWFsU3RvcmFnZSxcbiAgICBpZEZhY3Rvcnk6IG51bGwsXG4gICAgLy8gVGhlIFlqcyBwcm92aWRlciBhc3NvY2lhdGVkIHRvIHRoaXMgcm9vbVxuICAgIHlqc1Byb3ZpZGVyOiB2b2lkIDAsXG4gICAgeWpzUHJvdmlkZXJEaWRDaGFuZ2U6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIC8vIFN0b3JhZ2VcbiAgICBwb29sOiBjcmVhdGVNYW5hZ2VkUG9vbChyb29tSWQsIHtcbiAgICAgIGdldEN1cnJlbnRDb25uZWN0aW9uSWQsXG4gICAgICBvbkRpc3BhdGNoLFxuICAgICAgaXNTdG9yYWdlV3JpdGFibGVcbiAgICB9KSxcbiAgICByb290OiB2b2lkIDAsXG4gICAgdW5kb1N0YWNrOiBbXSxcbiAgICByZWRvU3RhY2s6IFtdLFxuICAgIHBhdXNlZEhpc3Rvcnk6IG51bGwsXG4gICAgYWN0aXZlQmF0Y2g6IG51bGwsXG4gICAgdW5hY2tub3dsZWRnZWRPcHM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgLy8gRGVidWdcbiAgICBvcFN0YWNrVHJhY2VzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpIDogdm9pZCAwXG4gIH07XG4gIGxldCBsYXN0VG9rZW5LZXk7XG4gIGZ1bmN0aW9uIG9uU3RhdHVzRGlkQ2hhbmdlKG5ld1N0YXR1cykge1xuICAgIGNvbnN0IGF1dGhWYWx1ZSA9IG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlO1xuICAgIGlmIChhdXRoVmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHRva2VuS2V5ID0gZ2V0QmVhcmVyVG9rZW5Gcm9tQXV0aFZhbHVlKGF1dGhWYWx1ZSk7XG4gICAgICBpZiAodG9rZW5LZXkgIT09IGxhc3RUb2tlbktleSkge1xuICAgICAgICBsYXN0VG9rZW5LZXkgPSB0b2tlbktleTtcbiAgICAgICAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInNlY3JldFwiKSB7XG4gICAgICAgICAgY29uc3QgdG9rZW4gPSBhdXRoVmFsdWUudG9rZW4ucGFyc2VkO1xuICAgICAgICAgIGNvbnRleHQuc3RhdGljU2Vzc2lvbkluZm9TaWcuc2V0KHtcbiAgICAgICAgICAgIHVzZXJJZDogdG9rZW4uayA9PT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLyA/IHRva2VuLmlkIDogdG9rZW4udWlkLFxuICAgICAgICAgICAgdXNlckluZm86IHRva2VuLmsgPT09IFwic2VjLWxlZ2FjeVwiIC8qIFNFQ1JFVF9MRUdBQ1kgKi8gPyB0b2tlbi5pbmZvIDogdG9rZW4udWlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LnN0YXRpY1Nlc3Npb25JbmZvU2lnLnNldCh7XG4gICAgICAgICAgICB1c2VySWQ6IHZvaWQgMCxcbiAgICAgICAgICAgIHVzZXJJbmZvOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBldmVudEh1Yi5zdGF0dXMubm90aWZ5KG5ld1N0YXR1cyk7XG4gICAgbm90aWZ5U2VsZkNoYW5nZWQoKTtcbiAgfVxuICBsZXQgX2Nvbm5lY3Rpb25Mb3NzVGltZXJJZDtcbiAgbGV0IF9oYXNMb3N0Q29ubmVjdGlvbiA9IGZhbHNlO1xuICBmdW5jdGlvbiBoYW5kbGVDb25uZWN0aW9uTG9zc0V2ZW50KG5ld1N0YXR1cykge1xuICAgIGlmIChuZXdTdGF0dXMgPT09IFwicmVjb25uZWN0aW5nXCIpIHtcbiAgICAgIF9jb25uZWN0aW9uTG9zc1RpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwibG9zdFwiKTtcbiAgICAgICAgX2hhc0xvc3RDb25uZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgY29udGV4dC5vdGhlcnMuY2xlYXJPdGhlcnMoKTtcbiAgICAgICAgbm90aWZ5KHsgb3RoZXJzOiBbeyB0eXBlOiBcInJlc2V0XCIgfV0gfSk7XG4gICAgICB9LCBjb25maWcubG9zdENvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJUaW1lb3V0KF9jb25uZWN0aW9uTG9zc1RpbWVySWQpO1xuICAgICAgaWYgKF9oYXNMb3N0Q29ubmVjdGlvbikge1xuICAgICAgICBpZiAobmV3U3RhdHVzID09PSBcImRpc2Nvbm5lY3RlZFwiKSB7XG4gICAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwiZmFpbGVkXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV2ZW50SHViLmxvc3RDb25uZWN0aW9uLm5vdGlmeShcInJlc3RvcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9oYXNMb3N0Q29ubmVjdGlvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvbkRpZENvbm5lY3QoKSB7XG4gICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID0ge1xuICAgICAgdHlwZTogXCJmdWxsXCIsXG4gICAgICBkYXRhOiAoXG4gICAgICAgIC8vIEJlY2F1c2UgY29udGV4dC5tZS5jdXJyZW50IGlzIGEgcmVhZG9ubHkgb2JqZWN0LCB3ZSdsbCBoYXZlIHRvXG4gICAgICAgIC8vIG1ha2UgYSBjb3B5IGhlcmUuIE90aGVyd2lzZSwgdHlwZSBlcnJvcnMgaGFwcGVuIGxhdGVyIHdoZW5cbiAgICAgICAgLy8gXCJwYXRjaGluZ1wiIG15IHByZXNlbmNlLlxuICAgICAgICB7IC4uLmNvbnRleHQubXlQcmVzZW5jZS5nZXQoKSB9XG4gICAgICApXG4gICAgfTtcbiAgICBpZiAoX2dldFN0b3JhZ2UkICE9PSBudWxsKSB7XG4gICAgICByZWZyZXNoU3RvcmFnZSh7IGZsdXNoOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBvbkRpZERpc2Nvbm5lY3QoKSB7XG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuYnVmZmVyLmZsdXNoVGltZXJJRCk7XG4gIH1cbiAgbWFuYWdlZFNvY2tldC5ldmVudHMub25NZXNzYWdlLnN1YnNjcmliZShoYW5kbGVTZXJ2ZXJNZXNzYWdlKTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuc3RhdHVzRGlkQ2hhbmdlLnN1YnNjcmliZShvblN0YXR1c0RpZENoYW5nZSk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLnN0YXR1c0RpZENoYW5nZS5zdWJzY3JpYmUoaGFuZGxlQ29ubmVjdGlvbkxvc3NFdmVudCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLmRpZENvbm5lY3Quc3Vic2NyaWJlKG9uRGlkQ29ubmVjdCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLmRpZERpc2Nvbm5lY3Quc3Vic2NyaWJlKG9uRGlkRGlzY29ubmVjdCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLm9uQ29ubmVjdGlvbkVycm9yLnN1YnNjcmliZSgoeyBtZXNzYWdlLCBjb2RlIH0pID0+IHtcbiAgICBjb25zdCB0eXBlID0gXCJST09NX0NPTk5FQ1RJT05fRVJST1JcIjtcbiAgICBjb25zdCBlcnIgPSBuZXcgTGl2ZWJsb2Nrc0Vycm9yKG1lc3NhZ2UsIHsgdHlwZSwgY29kZSwgcm9vbUlkIH0pO1xuICAgIGNvbnN0IGRpZE5vdGlmeSA9IGNvbmZpZy5lcnJvckV2ZW50U291cmNlLm5vdGlmeShlcnIpO1xuICAgIGlmICghZGlkTm90aWZ5KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGVycm9yMihcbiAgICAgICAgICBgQ29ubmVjdGlvbiB0byB3ZWJzb2NrZXQgc2VydmVyIGNsb3NlZC4gUmVhc29uOiAke21lc3NhZ2V9IChjb2RlOiAke2NvZGV9KS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gb25EaXNwYXRjaChvcHMsIHJldmVyc2UsIHN0b3JhZ2VVcGRhdGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc3Qgc3RhY2tUcmFjZSA9IGNhcHR1cmVTdGFja1RyYWNlKFwiU3RvcmFnZSBtdXRhdGlvblwiLCBvbkRpc3BhdGNoKTtcbiAgICAgIGlmIChzdGFja1RyYWNlKSB7XG4gICAgICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgICAgICAgaWYgKG9wLm9wSWQpIHtcbiAgICAgICAgICAgIG5uKGNvbnRleHQub3BTdGFja1RyYWNlcykuc2V0KG9wLm9wSWQsIHN0YWNrVHJhY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICAgICAgY29udGV4dC5hY3RpdmVCYXRjaC5vcHMucHVzaChvcCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzdG9yYWdlVXBkYXRlcykge1xuICAgICAgICBjb250ZXh0LmFjdGl2ZUJhdGNoLnVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBtZXJnZVN0b3JhZ2VVcGRhdGVzKFxuICAgICAgICAgICAgY29udGV4dC5hY3RpdmVCYXRjaC51cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLmdldChrZXkpLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmFjdGl2ZUJhdGNoLnJldmVyc2VPcHMucHVzaExlZnQocmV2ZXJzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZFRvVW5kb1N0YWNrKHJldmVyc2UpO1xuICAgICAgY29udGV4dC5yZWRvU3RhY2subGVuZ3RoID0gMDtcbiAgICAgIGRpc3BhdGNoT3BzKG9wcyk7XG4gICAgICBub3RpZnkoeyBzdG9yYWdlVXBkYXRlcyB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNTdG9yYWdlV3JpdGFibGUoKSB7XG4gICAgY29uc3Qgc2NvcGVzID0gY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm9TaWcuZ2V0KCk/LnNjb3BlcztcbiAgICByZXR1cm4gc2NvcGVzICE9PSB2b2lkIDAgPyBjYW5Xcml0ZVN0b3JhZ2Uoc2NvcGVzKSA6IHRydWU7XG4gIH1cbiAgY29uc3QgZXZlbnRIdWIgPSB7XG4gICAgc3RhdHVzOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAvLyBOZXcvcmVjb21tZW5kZWQgQVBJXG4gICAgbG9zdENvbm5lY3Rpb246IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIGN1c3RvbUV2ZW50OiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBzZWxmOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBteVByZXNlbmNlOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBvdGhlcnM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHN0b3JhZ2VCYXRjaDogbWFrZUV2ZW50U291cmNlKCksXG4gICAgaGlzdG9yeTogbWFrZUV2ZW50U291cmNlKCksXG4gICAgc3RvcmFnZURpZExvYWQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHN0b3JhZ2VTdGF0dXM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHlkb2M6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIGNvbW1lbnRzOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICByb29tV2lsbERlc3Ryb3k6IG1ha2VFdmVudFNvdXJjZSgpXG4gIH07XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRleHRNZW50aW9uKHVzZXJJZCwgbWVudGlvbklkKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuY3JlYXRlVGV4dE1lbnRpb24oeyByb29tSWQsIHVzZXJJZCwgbWVudGlvbklkIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVRleHRNZW50aW9uKG1lbnRpb25JZCkge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmRlbGV0ZVRleHRNZW50aW9uKHsgcm9vbUlkLCBtZW50aW9uSWQgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmVwb3J0VGV4dEVkaXRvcih0eXBlLCByb290S2V5KSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5yZXBvcnRUZXh0RWRpdG9yKHsgcm9vbUlkLCB0eXBlLCByb290S2V5IH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxpc3RUZXh0VmVyc2lvbnMoKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQubGlzdFRleHRWZXJzaW9ucyh7IHJvb21JZCB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBsaXN0VGV4dFZlcnNpb25zU2luY2Uob3B0aW9uczIpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5saXN0VGV4dFZlcnNpb25zU2luY2Uoe1xuICAgICAgcm9vbUlkLFxuICAgICAgc2luY2U6IG9wdGlvbnMyLnNpbmNlLFxuICAgICAgc2lnbmFsOiBvcHRpb25zMi5zaWduYWxcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUZXh0VmVyc2lvbih2ZXJzaW9uSWQpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5nZXRUZXh0VmVyc2lvbih7IHJvb21JZCwgdmVyc2lvbklkIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRleHRWZXJzaW9uKCkge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmNyZWF0ZVRleHRWZXJzaW9uKHsgcm9vbUlkIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVDb250ZXh0dWFsUHJvbXB0KG9wdGlvbnMyKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZXhlY3V0ZUNvbnRleHR1YWxQcm9tcHQoe1xuICAgICAgcm9vbUlkLFxuICAgICAgLi4ub3B0aW9uczJcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiogY2h1bmtPcHMobXNnKSB7XG4gICAgY29uc3QgeyBvcHMsIC4uLnJlc3QgfSA9IG1zZztcbiAgICBpZiAob3BzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzcGxpdCBvcHMgaW50byBzbWFsbGVyIGNodW5rc1wiKTtcbiAgICB9XG4gICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcihvcHMubGVuZ3RoIC8gMik7XG4gICAgY29uc3QgZmlyc3RIYWxmID0gb3BzLnNsaWNlKDAsIG1pZCk7XG4gICAgY29uc3Qgc2Vjb25kSGFsZiA9IG9wcy5zbGljZShtaWQpO1xuICAgIGZvciAoY29uc3QgaGFsZk9wcyBvZiBbZmlyc3RIYWxmLCBzZWNvbmRIYWxmXSkge1xuICAgICAgY29uc3QgaGFsZiA9IHsgb3BzOiBoYWxmT3BzLCAuLi5yZXN0IH07XG4gICAgICBjb25zdCB0ZXh0ID0gc3RyaW5naWZ5T3JMb2coW2hhbGZdKTtcbiAgICAgIGlmICghaXNUb29CaWdGb3JXZWJTb2NrZXQodGV4dCkpIHtcbiAgICAgICAgeWllbGQgdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkKiBjaHVua09wcyhoYWxmKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24qIGNodW5rTWVzc2FnZXMobWVzc2FnZXMpIHtcbiAgICBpZiAobWVzc2FnZXMubGVuZ3RoIDwgMikge1xuICAgICAgaWYgKG1lc3NhZ2VzWzBdLnR5cGUgPT09IDIwMSAvKiBVUERBVEVfU1RPUkFHRSAqLykge1xuICAgICAgICB5aWVsZCogY2h1bmtPcHMobWVzc2FnZXNbMF0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJDYW5ub3Qgc3BsaXQgaW50byBjaHVua3Mgc21hbGxlciB0aGFuIHRoZSBhbGxvd2VkIG1lc3NhZ2Ugc2l6ZVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IobWVzc2FnZXMubGVuZ3RoIC8gMik7XG4gICAgY29uc3QgZmlyc3RIYWxmID0gbWVzc2FnZXMuc2xpY2UoMCwgbWlkKTtcbiAgICBjb25zdCBzZWNvbmRIYWxmID0gbWVzc2FnZXMuc2xpY2UobWlkKTtcbiAgICBmb3IgKGNvbnN0IGhhbGYgb2YgW2ZpcnN0SGFsZiwgc2Vjb25kSGFsZl0pIHtcbiAgICAgIGNvbnN0IHRleHQgPSBzdHJpbmdpZnlPckxvZyhoYWxmKTtcbiAgICAgIGlmICghaXNUb29CaWdGb3JXZWJTb2NrZXQodGV4dCkpIHtcbiAgICAgICAgeWllbGQgdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkKiBjaHVua01lc3NhZ2VzKGhhbGYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc1Rvb0JpZ0ZvcldlYlNvY2tldCh0ZXh0KSB7XG4gICAgaWYgKHRleHQubGVuZ3RoICogNCA8IE1BWF9TT0NLRVRfTUVTU0FHRV9TSVpFKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGV4dCkubGVuZ3RoID49IE1BWF9TT0NLRVRfTUVTU0FHRV9TSVpFO1xuICB9XG4gIGZ1bmN0aW9uIHNlbmRNZXNzYWdlcyhtZXNzYWdlcykge1xuICAgIGNvbnN0IHN0cmF0ZWd5ID0gY29uZmlnLmxhcmdlTWVzc2FnZVN0cmF0ZWd5ID8/IFwiZGVmYXVsdFwiO1xuICAgIGNvbnN0IHRleHQgPSBzdHJpbmdpZnlPckxvZyhtZXNzYWdlcyk7XG4gICAgaWYgKCFpc1Rvb0JpZ0ZvcldlYlNvY2tldCh0ZXh0KSkge1xuICAgICAgcmV0dXJuIG1hbmFnZWRTb2NrZXQuc2VuZCh0ZXh0KTtcbiAgICB9XG4gICAgc3dpdGNoIChzdHJhdGVneSkge1xuICAgICAgY2FzZSBcImRlZmF1bHRcIjoge1xuICAgICAgICBlcnJvcjIoXCJNZXNzYWdlIGlzIHRvbyBsYXJnZSBmb3Igd2Vic29ja2V0cywgbm90IHNlbmRpbmcuIENvbmZpZ3VyZSBsYXJnZU1lc3NhZ2VTdHJhdGVneSBvcHRpb24gdG8gZGVhbCB3aXRoIHRoaXMuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYXNlIFwic3BsaXRcIjoge1xuICAgICAgICB3YXJuKFwiTWVzc2FnZSBpcyB0b28gbGFyZ2UgZm9yIHdlYnNvY2tldHMsIHNwbGl0dGluZyBpbnRvIHNtYWxsZXIgY2h1bmtzXCIpO1xuICAgICAgICBmb3IgKGNvbnN0IGNodW5rMiBvZiBjaHVua01lc3NhZ2VzKG1lc3NhZ2VzKSkge1xuICAgICAgICAgIG1hbmFnZWRTb2NrZXQuc2VuZChjaHVuazIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJleHBlcmltZW50YWwtZmFsbGJhY2stdG8taHR0cFwiOiB7XG4gICAgICAgIHdhcm4oXCJNZXNzYWdlIGlzIHRvbyBsYXJnZSBmb3Igd2Vic29ja2V0cywgc28gc2VuZGluZyBvdmVyIEhUVFAgaW5zdGVhZFwiKTtcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mb1NpZy5nZXQoKT8ubm9uY2UgPz8gcmFpc2UoXCJTZXNzaW9uIGlzIG5vdCBhdXRob3JpemVkIHRvIHNlbmQgbWVzc2FnZSBvdmVyIEhUVFBcIik7XG4gICAgICAgIHZvaWQgaHR0cENsaWVudC5zZW5kTWVzc2FnZXMoeyByb29tSWQsIG5vbmNlLCBtZXNzYWdlcyB9KS50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXNwLm9rICYmIHJlc3Auc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgICAgIG1hbmFnZWRTb2NrZXQucmVjb25uZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBzZWxmID0gRGVyaXZlZFNpZ25hbC5mcm9tKFxuICAgIGNvbnRleHQuc3RhdGljU2Vzc2lvbkluZm9TaWcsXG4gICAgY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm9TaWcsXG4gICAgY29udGV4dC5teVByZXNlbmNlLFxuICAgIChzdGF0aWNTZXNzaW9uLCBkeW5hbWljU2Vzc2lvbiwgbXlQcmVzZW5jZSkgPT4ge1xuICAgICAgaWYgKHN0YXRpY1Nlc3Npb24gPT09IG51bGwgfHwgZHluYW1pY1Nlc3Npb24gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjYW5Xcml0ZSA9IGNhbldyaXRlU3RvcmFnZShkeW5hbWljU2Vzc2lvbi5zY29wZXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbm5lY3Rpb25JZDogZHluYW1pY1Nlc3Npb24uYWN0b3IsXG4gICAgICAgICAgaWQ6IHN0YXRpY1Nlc3Npb24udXNlcklkLFxuICAgICAgICAgIGluZm86IHN0YXRpY1Nlc3Npb24udXNlckluZm8sXG4gICAgICAgICAgcHJlc2VuY2U6IG15UHJlc2VuY2UsXG4gICAgICAgICAgY2FuV3JpdGUsXG4gICAgICAgICAgY2FuQ29tbWVudDogY2FuQ29tbWVudChkeW5hbWljU2Vzc2lvbi5zY29wZXMpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICApO1xuICBsZXQgX2xhc3RTZWxmO1xuICBmdW5jdGlvbiBub3RpZnlTZWxmQ2hhbmdlZCgpIHtcbiAgICBjb25zdCBjdXJyU2VsZiA9IHNlbGYuZ2V0KCk7XG4gICAgaWYgKGN1cnJTZWxmICE9PSBudWxsICYmIGN1cnJTZWxmICE9PSBfbGFzdFNlbGYpIHtcbiAgICAgIGV2ZW50SHViLnNlbGYubm90aWZ5KGN1cnJTZWxmKTtcbiAgICAgIF9sYXN0U2VsZiA9IGN1cnJTZWxmO1xuICAgIH1cbiAgfVxuICBjb25zdCBzZWxmQXNUcmVlTm9kZSA9IERlcml2ZWRTaWduYWwuZnJvbShcbiAgICBzZWxmLFxuICAgIChtZSkgPT4gbWUgIT09IG51bGwgPyB1c2VyVG9UcmVlTm9kZShcIk1lXCIsIG1lKSA6IG51bGxcbiAgKTtcbiAgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVSb290RnJvbU1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlLml0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgZXJyb3I6IGNhbm5vdCBsb2FkIHN0b3JhZ2Ugd2l0aG91dCBpdGVtc1wiKTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQucm9vdCAhPT0gdm9pZCAwKSB7XG4gICAgICB1cGRhdGVSb290KG1lc3NhZ2UuaXRlbXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnJvb3QgPSBMaXZlT2JqZWN0Ll9mcm9tSXRlbXMobWVzc2FnZS5pdGVtcywgY29udGV4dC5wb29sKTtcbiAgICB9XG4gICAgY29uc3QgY2FuV3JpdGUgPSBzZWxmLmdldCgpPy5jYW5Xcml0ZSA/PyB0cnVlO1xuICAgIGNvbnN0IHN0YWNrU2l6ZUJlZm9yZSA9IGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aDtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjb250ZXh0LmluaXRpYWxTdG9yYWdlKSB7XG4gICAgICBpZiAoY29udGV4dC5yb290LmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKGNhbldyaXRlKSB7XG4gICAgICAgICAgY29udGV4dC5yb290LnNldChrZXksIGNsb25lTHNvbihjb250ZXh0LmluaXRpYWxTdG9yYWdlW2tleV0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYEF0dGVtcHRlZCB0byBwb3B1bGF0ZSBtaXNzaW5nIHN0b3JhZ2Uga2V5ICcke2tleX0nLCBidXQgY3VycmVudCB1c2VyIGhhcyBubyB3cml0ZSBhY2Nlc3NgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPSBzdGFja1NpemVCZWZvcmU7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUm9vdChpdGVtcykge1xuICAgIGlmIChjb250ZXh0LnJvb3QgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50SXRlbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW2lkLCBub2RlXSBvZiBjb250ZXh0LnBvb2wubm9kZXMpIHtcbiAgICAgIGN1cnJlbnRJdGVtcy5zZXQoaWQsIG5vZGUuX3NlcmlhbGl6ZSgpKTtcbiAgICB9XG4gICAgY29uc3Qgb3BzID0gZ2V0VHJlZXNEaWZmT3BlcmF0aW9ucyhjdXJyZW50SXRlbXMsIG5ldyBNYXAoaXRlbXMpKTtcbiAgICBjb25zdCByZXN1bHQgPSBhcHBseU9wcyhvcHMsIGZhbHNlKTtcbiAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMpO1xuICB9XG4gIGZ1bmN0aW9uIF9hZGRUb1JlYWxVbmRvU3RhY2soaGlzdG9yeU9wcykge1xuICAgIGlmIChjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPj0gNTApIHtcbiAgICAgIGNvbnRleHQudW5kb1N0YWNrLnNoaWZ0KCk7XG4gICAgfVxuICAgIGNvbnRleHQudW5kb1N0YWNrLnB1c2goaGlzdG9yeU9wcyk7XG4gICAgb25IaXN0b3J5Q2hhbmdlKCk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkVG9VbmRvU3RhY2soaGlzdG9yeU9wcykge1xuICAgIGlmIChjb250ZXh0LnBhdXNlZEhpc3RvcnkgIT09IG51bGwpIHtcbiAgICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeS5wdXNoTGVmdChoaXN0b3J5T3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2FkZFRvUmVhbFVuZG9TdGFjayhoaXN0b3J5T3BzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5KHVwZGF0ZXMpIHtcbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IHVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXM7XG4gICAgY29uc3Qgb3RoZXJzVXBkYXRlcyA9IHVwZGF0ZXMub3RoZXJzO1xuICAgIGlmIChvdGhlcnNVcGRhdGVzICE9PSB2b2lkIDAgJiYgb3RoZXJzVXBkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBvdGhlcnMgPSBjb250ZXh0Lm90aGVycy5nZXQoKTtcbiAgICAgIGZvciAoY29uc3QgZXZlbnQgb2Ygb3RoZXJzVXBkYXRlcykge1xuICAgICAgICBldmVudEh1Yi5vdGhlcnMubm90aWZ5KHsgLi4uZXZlbnQsIG90aGVycyB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHVwZGF0ZXMucHJlc2VuY2UgPz8gZmFsc2UpIHtcbiAgICAgIG5vdGlmeVNlbGZDaGFuZ2VkKCk7XG4gICAgICBldmVudEh1Yi5teVByZXNlbmNlLm5vdGlmeShjb250ZXh0Lm15UHJlc2VuY2UuZ2V0KCkpO1xuICAgIH1cbiAgICBpZiAoc3RvcmFnZVVwZGF0ZXMgIT09IHZvaWQgMCAmJiBzdG9yYWdlVXBkYXRlcy5zaXplID4gMCkge1xuICAgICAgY29uc3QgdXBkYXRlczIgPSBBcnJheS5mcm9tKHN0b3JhZ2VVcGRhdGVzLnZhbHVlcygpKTtcbiAgICAgIGV2ZW50SHViLnN0b3JhZ2VCYXRjaC5ub3RpZnkodXBkYXRlczIpO1xuICAgIH1cbiAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudENvbm5lY3Rpb25JZCgpIHtcbiAgICBjb25zdCBpbmZvID0gY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm9TaWcuZ2V0KCk7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgIHJldHVybiBpbmZvLmFjdG9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludGVybmFsLiBUcmllZCB0byBnZXQgY29ubmVjdGlvbiBpZCBidXQgY29ubmVjdGlvbiB3YXMgbmV2ZXIgb3BlblwiXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseU9wcyhyYXdPcHMsIGlzTG9jYWwpIHtcbiAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICByZXZlcnNlOiBuZXcgRGVxdWUoKSxcbiAgICAgIHN0b3JhZ2VVcGRhdGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgcHJlc2VuY2U6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVkTm9kZUlkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3Qgb3BzID0gcmF3T3BzLm1hcCgob3ApID0+IHtcbiAgICAgIGlmIChvcC50eXBlICE9PSBcInByZXNlbmNlXCIgJiYgIW9wLm9wSWQpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ub3AsIG9wSWQ6IGNvbnRleHQucG9vbC5nZW5lcmF0ZU9wSWQoKSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgICBpZiAob3AudHlwZSA9PT0gXCJwcmVzZW5jZVwiKSB7XG4gICAgICAgIGNvbnN0IHJldmVyc2UgPSB7XG4gICAgICAgICAgdHlwZTogXCJwcmVzZW5jZVwiLFxuICAgICAgICAgIGRhdGE6IHt9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgICAgICByZXZlcnNlLmRhdGFba2V5XSA9IGNvbnRleHQubXlQcmVzZW5jZS5nZXQoKVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQubXlQcmVzZW5jZS5wYXRjaChvcC5kYXRhKTtcbiAgICAgICAgaWYgKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9IHsgdHlwZTogXCJwYXJ0aWFsXCIsIGRhdGE6IG9wLmRhdGEgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcC5kYXRhKSB7XG4gICAgICAgICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVtrZXldID0gb3AuZGF0YVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQucmV2ZXJzZS5wdXNoTGVmdChyZXZlcnNlKTtcbiAgICAgICAgb3V0cHV0LnByZXNlbmNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBzb3VyY2U7XG4gICAgICAgIGlmIChpc0xvY2FsKSB7XG4gICAgICAgICAgc291cmNlID0gMCAvKiBVTkRPUkVET19SRUNPTk5FQ1QgKi87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgb3BJZCA9IG5uKG9wLm9wSWQpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIG5uKGNvbnRleHQub3BTdGFja1RyYWNlcykuZGVsZXRlKG9wSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkZWxldGVkID0gY29udGV4dC51bmFja25vd2xlZGdlZE9wcy5kZWxldGUob3BJZCk7XG4gICAgICAgICAgc291cmNlID0gZGVsZXRlZCA/IDIgLyogQUNLICovIDogMSAvKiBSRU1PVEUgKi87XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBwbHlPcFJlc3VsdCA9IGFwcGx5T3Aob3AsIHNvdXJjZSk7XG4gICAgICAgIGlmIChhcHBseU9wUmVzdWx0Lm1vZGlmaWVkKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZUlkID0gYXBwbHlPcFJlc3VsdC5tb2RpZmllZC5ub2RlLl9pZDtcbiAgICAgICAgICBpZiAoIShub2RlSWQgJiYgY3JlYXRlZE5vZGVJZHMuaGFzKG5vZGVJZCkpKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgICAgICBubihhcHBseU9wUmVzdWx0Lm1vZGlmaWVkLm5vZGUuX2lkKSxcbiAgICAgICAgICAgICAgbWVyZ2VTdG9yYWdlVXBkYXRlcyhcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3RvcmFnZVVwZGF0ZXMuZ2V0KG5uKGFwcGx5T3BSZXN1bHQubW9kaWZpZWQubm9kZS5faWQpKSxcbiAgICAgICAgICAgICAgICBhcHBseU9wUmVzdWx0Lm1vZGlmaWVkXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvdXRwdXQucmV2ZXJzZS5wdXNoTGVmdChhcHBseU9wUmVzdWx0LnJldmVyc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3AudHlwZSA9PT0gMiAvKiBDUkVBVEVfTElTVCAqLyB8fCBvcC50eXBlID09PSA3IC8qIENSRUFURV9NQVAgKi8gfHwgb3AudHlwZSA9PT0gNCAvKiBDUkVBVEVfT0JKRUNUICovKSB7XG4gICAgICAgICAgICBjcmVhdGVkTm9kZUlkcy5hZGQobm4ob3AuaWQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wcyxcbiAgICAgIHJldmVyc2U6IEFycmF5LmZyb20ob3V0cHV0LnJldmVyc2UpLFxuICAgICAgdXBkYXRlczoge1xuICAgICAgICBzdG9yYWdlVXBkYXRlczogb3V0cHV0LnN0b3JhZ2VVcGRhdGVzLFxuICAgICAgICBwcmVzZW5jZTogb3V0cHV0LnByZXNlbmNlXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseU9wKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAoaXNBY2tPcChvcCkpIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgIGNhc2UgNiAvKiBERUxFVEVfT0JKRUNUX0tFWSAqLzpcbiAgICAgIGNhc2UgMyAvKiBVUERBVEVfT0JKRUNUICovOlxuICAgICAgY2FzZSA1IC8qIERFTEVURV9DUkRUICovOiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBjb250ZXh0LnBvb2wubm9kZXMuZ2V0KG9wLmlkKTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLl9hcHBseShvcCwgc291cmNlID09PSAwIC8qIFVORE9SRURPX1JFQ09OTkVDVCAqLyk7XG4gICAgICB9XG4gICAgICBjYXNlIDEgLyogU0VUX1BBUkVOVF9LRVkgKi86IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGNvbnRleHQucG9vbC5ub2Rlcy5nZXQob3AuaWQpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIgJiYgaXNMaXZlTGlzdChub2RlLnBhcmVudC5ub2RlKSkge1xuICAgICAgICAgIHJldHVybiBub2RlLnBhcmVudC5ub2RlLl9zZXRDaGlsZEtleShcbiAgICAgICAgICAgIGFzUG9zKG9wLnBhcmVudEtleSksXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgc291cmNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgNCAvKiBDUkVBVEVfT0JKRUNUICovOlxuICAgICAgY2FzZSAyIC8qIENSRUFURV9MSVNUICovOlxuICAgICAgY2FzZSA3IC8qIENSRUFURV9NQVAgKi86XG4gICAgICBjYXNlIDggLyogQ1JFQVRFX1JFR0lTVEVSICovOiB7XG4gICAgICAgIGlmIChvcC5wYXJlbnRJZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGNvbnRleHQucG9vbC5ub2Rlcy5nZXQob3AucGFyZW50SWQpO1xuICAgICAgICBpZiAocGFyZW50Tm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudE5vZGUuX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVQcmVzZW5jZShwYXRjaCwgb3B0aW9uczIpIHtcbiAgICBjb25zdCBvbGRWYWx1ZXMgPSB7fTtcbiAgICBpZiAoY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPSB7XG4gICAgICAgIHR5cGU6IFwicGFydGlhbFwiLFxuICAgICAgICBkYXRhOiB7fVxuICAgICAgfTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGF0Y2gpIHtcbiAgICAgIGNvbnN0IG92ZXJyaWRlVmFsdWUgPSBwYXRjaFtrZXldO1xuICAgICAgaWYgKG92ZXJyaWRlVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy5kYXRhW2tleV0gPSBvdmVycmlkZVZhbHVlO1xuICAgICAgb2xkVmFsdWVzW2tleV0gPSBjb250ZXh0Lm15UHJlc2VuY2UuZ2V0KClba2V5XTtcbiAgICB9XG4gICAgY29udGV4dC5teVByZXNlbmNlLnBhdGNoKHBhdGNoKTtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgaWYgKG9wdGlvbnMyPy5hZGRUb0hpc3RvcnkpIHtcbiAgICAgICAgY29udGV4dC5hY3RpdmVCYXRjaC5yZXZlcnNlT3BzLnB1c2hMZWZ0KHtcbiAgICAgICAgICB0eXBlOiBcInByZXNlbmNlXCIsXG4gICAgICAgICAgZGF0YTogb2xkVmFsdWVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29udGV4dC5hY3RpdmVCYXRjaC51cGRhdGVzLnByZXNlbmNlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmx1c2hOb3dPclNvb24oKTtcbiAgICAgIGlmIChvcHRpb25zMj8uYWRkVG9IaXN0b3J5KSB7XG4gICAgICAgIGFkZFRvVW5kb1N0YWNrKFt7IHR5cGU6IFwicHJlc2VuY2VcIiwgZGF0YTogb2xkVmFsdWVzIH1dKTtcbiAgICAgIH1cbiAgICAgIG5vdGlmeSh7IHByZXNlbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvblVwZGF0ZVByZXNlbmNlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UudGFyZ2V0QWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3Qgb2xkVXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgICBjb250ZXh0Lm90aGVycy5zZXRPdGhlcihtZXNzYWdlLmFjdG9yLCBtZXNzYWdlLmRhdGEpO1xuICAgICAgY29uc3QgbmV3VXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgICBpZiAob2xkVXNlciA9PT0gdm9pZCAwICYmIG5ld1VzZXIgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVudGVyXCIsIHVzZXI6IG5ld1VzZXIgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5vdGhlcnMucGF0Y2hPdGhlcihtZXNzYWdlLmFjdG9yLCBtZXNzYWdlLmRhdGEpLCBtZXNzYWdlO1xuICAgIH1cbiAgICBjb25zdCB1c2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICBpZiAodXNlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcbiAgICAgICAgdXBkYXRlczogbWVzc2FnZS5kYXRhLFxuICAgICAgICB1c2VyXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvblVzZXJMZWZ0TWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29uc3QgdXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIGNvbnRleHQub3RoZXJzLnJlbW92ZUNvbm5lY3Rpb24obWVzc2FnZS5hY3Rvcik7XG4gICAgICByZXR1cm4geyB0eXBlOiBcImxlYXZlXCIsIHVzZXIgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gb25Sb29tU3RhdGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mb1NpZy5zZXQoe1xuICAgICAgYWN0b3I6IG1lc3NhZ2UuYWN0b3IsXG4gICAgICBub25jZTogbWVzc2FnZS5ub25jZSxcbiAgICAgIHNjb3BlczogbWVzc2FnZS5zY29wZXNcbiAgICB9KTtcbiAgICBjb250ZXh0LmlkRmFjdG9yeSA9IG1ha2VJZEZhY3RvcnkobWVzc2FnZS5hY3Rvcik7XG4gICAgbm90aWZ5U2VsZkNoYW5nZWQoKTtcbiAgICBmb3IgKGNvbnN0IGNvbm5lY3Rpb25JZCBvZiBjb250ZXh0Lm90aGVycy5jb25uZWN0aW9uSWRzKCkpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBtZXNzYWdlLnVzZXJzW2Nvbm5lY3Rpb25JZF07XG4gICAgICBpZiAodXNlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRleHQub3RoZXJzLnJlbW92ZUNvbm5lY3Rpb24oY29ubmVjdGlvbklkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWVzc2FnZS51c2Vycykge1xuICAgICAgY29uc3QgdXNlciA9IG1lc3NhZ2UudXNlcnNba2V5XTtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb25JZCA9IE51bWJlcihrZXkpO1xuICAgICAgY29udGV4dC5vdGhlcnMuc2V0Q29ubmVjdGlvbihcbiAgICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgICB1c2VyLmlkLFxuICAgICAgICB1c2VyLmluZm8sXG4gICAgICAgIHVzZXIuc2NvcGVzXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcInJlc2V0XCIgfTtcbiAgfVxuICBmdW5jdGlvbiBjYW5VbmRvKCkge1xuICAgIHJldHVybiBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPiAwO1xuICB9XG4gIGZ1bmN0aW9uIGNhblJlZG8oKSB7XG4gICAgcmV0dXJuIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA+IDA7XG4gIH1cbiAgZnVuY3Rpb24gb25IaXN0b3J5Q2hhbmdlKCkge1xuICAgIGV2ZW50SHViLmhpc3Rvcnkubm90aWZ5KHsgY2FuVW5kbzogY2FuVW5kbygpLCBjYW5SZWRvOiBjYW5SZWRvKCkgfSk7XG4gIH1cbiAgZnVuY3Rpb24gb25Vc2VySm9pbmVkTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29udGV4dC5vdGhlcnMuc2V0Q29ubmVjdGlvbihcbiAgICAgIG1lc3NhZ2UuYWN0b3IsXG4gICAgICBtZXNzYWdlLmlkLFxuICAgICAgbWVzc2FnZS5pbmZvLFxuICAgICAgbWVzc2FnZS5zY29wZXNcbiAgICApO1xuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goe1xuICAgICAgdHlwZTogMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLyxcbiAgICAgIGRhdGE6IGNvbnRleHQubXlQcmVzZW5jZS5nZXQoKSxcbiAgICAgIHRhcmdldEFjdG9yOiBtZXNzYWdlLmFjdG9yXG4gICAgfSk7XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgICBjb25zdCB1c2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICByZXR1cm4gdXNlciA/IHsgdHlwZTogXCJlbnRlclwiLCB1c2VyIH0gOiB2b2lkIDA7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VTZXJ2ZXJNZXNzYWdlKGRhdGEpIHtcbiAgICBpZiAoIWlzSnNvbk9iamVjdChkYXRhKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU2VydmVyTWVzc2FnZXModGV4dCkge1xuICAgIGNvbnN0IGRhdGEgPSB0cnlQYXJzZUpzb24odGV4dCk7XG4gICAgaWYgKGRhdGEgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChpc0pzb25BcnJheShkYXRhKSkge1xuICAgICAgcmV0dXJuIGNvbXBhY3QoZGF0YS5tYXAoKGl0ZW0pID0+IHBhcnNlU2VydmVyTWVzc2FnZShpdGVtKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29tcGFjdChbcGFyc2VTZXJ2ZXJNZXNzYWdlKGRhdGEpXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFwcGx5QW5kU2VuZE9wcyhvZmZsaW5lT3BzKSB7XG4gICAgaWYgKG9mZmxpbmVPcHMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGNvbnN0IGluT3BzID0gQXJyYXkuZnJvbShvZmZsaW5lT3BzLnZhbHVlcygpKTtcbiAgICBjb25zdCByZXN1bHQgPSBhcHBseU9wcyhpbk9wcywgdHJ1ZSk7XG4gICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICB0eXBlOiAyMDEgLyogVVBEQVRFX1NUT1JBR0UgKi8sXG4gICAgICBvcHM6IHJlc3VsdC5vcHNcbiAgICB9KTtcbiAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMpO1xuICAgIHNlbmRNZXNzYWdlcyhtZXNzYWdlcyk7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlU2VydmVyTWVzc2FnZShldmVudCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnQuZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IHBhcnNlU2VydmVyTWVzc2FnZXMoZXZlbnQuZGF0YSk7XG4gICAgaWYgKG1lc3NhZ2VzID09PSBudWxsIHx8IG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVzID0ge1xuICAgICAgc3RvcmFnZVVwZGF0ZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICBvdGhlcnM6IFtdXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgIGNhc2UgMTAxIC8qIFVTRVJfSk9JTkVEICovOiB7XG4gICAgICAgICAgY29uc3QgdXNlckpvaW5lZFVwZGF0ZSA9IG9uVXNlckpvaW5lZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgaWYgKHVzZXJKb2luZWRVcGRhdGUpIHtcbiAgICAgICAgICAgIHVwZGF0ZXMub3RoZXJzLnB1c2godXNlckpvaW5lZFVwZGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLzoge1xuICAgICAgICAgIGNvbnN0IG90aGVyc1ByZXNlbmNlVXBkYXRlID0gb25VcGRhdGVQcmVzZW5jZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgaWYgKG90aGVyc1ByZXNlbmNlVXBkYXRlKSB7XG4gICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKG90aGVyc1ByZXNlbmNlVXBkYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxMDMgLyogQlJPQURDQVNURURfRVZFTlQgKi86IHtcbiAgICAgICAgICBjb25zdCBvdGhlcnMgPSBjb250ZXh0Lm90aGVycy5nZXQoKTtcbiAgICAgICAgICBldmVudEh1Yi5jdXN0b21FdmVudC5ub3RpZnkoe1xuICAgICAgICAgICAgY29ubmVjdGlvbklkOiBtZXNzYWdlLmFjdG9yLFxuICAgICAgICAgICAgdXNlcjogbWVzc2FnZS5hY3RvciA8IDAgPyBudWxsIDogb3RoZXJzLmZpbmQoKHUpID0+IHUuY29ubmVjdGlvbklkID09PSBtZXNzYWdlLmFjdG9yKSA/PyBudWxsLFxuICAgICAgICAgICAgZXZlbnQ6IG1lc3NhZ2UuZXZlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDEwMiAvKiBVU0VSX0xFRlQgKi86IHtcbiAgICAgICAgICBjb25zdCBldmVudDIgPSBvblVzZXJMZWZ0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICBpZiAoZXZlbnQyKSB7XG4gICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKGV2ZW50Mik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMzAwIC8qIFVQREFURV9ZRE9DICovOiB7XG4gICAgICAgICAgZXZlbnRIdWIueWRvYy5ub3RpZnkobWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxMDQgLyogUk9PTV9TVEFURSAqLzoge1xuICAgICAgICAgIHVwZGF0ZXMub3RoZXJzLnB1c2gob25Sb29tU3RhdGVNZXNzYWdlKG1lc3NhZ2UpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDIwMCAvKiBJTklUSUFMX1NUT1JBR0VfU1RBVEUgKi86IHtcbiAgICAgICAgICBwcm9jZXNzSW5pdGlhbFN0b3JhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV3JpdGUgZXZlbnRcbiAgICAgICAgY2FzZSAyMDEgLyogVVBEQVRFX1NUT1JBR0UgKi86IHtcbiAgICAgICAgICBjb25zdCBhcHBseVJlc3VsdCA9IGFwcGx5T3BzKG1lc3NhZ2Uub3BzLCBmYWxzZSk7XG4gICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYXBwbHlSZXN1bHQudXBkYXRlcy5zdG9yYWdlVXBkYXRlcykge1xuICAgICAgICAgICAgdXBkYXRlcy5zdG9yYWdlVXBkYXRlcy5zZXQoXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgbWVyZ2VTdG9yYWdlVXBkYXRlcyh1cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLmdldChrZXkpLCB2YWx1ZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY2VpdmluZyBhIFJlamVjdGVkT3BzIG1lc3NhZ2UgaW4gdGhlIGNsaWVudCBtZWFucyB0aGF0IHRoZSBzZXJ2ZXIgaXMgbm9cbiAgICAgICAgLy8gbG9uZ2VyIGluIHN5bmMgd2l0aCB0aGUgY2xpZW50LiBUcnlpbmcgdG8gc3luY2hyb25pemUgdGhlIGNsaWVudCBhZ2FpbiBieVxuICAgICAgICAvLyByb2xsaW5nIGJhY2sgcGFydGljdWxhciBPcHMgbWF5IGJlIGhhcmQvaW1wb3NzaWJsZS4gSXQncyBmaW5lIHRvIG5vdCB0cnkgYW5kXG4gICAgICAgIC8vIGFjY2VwdCB0aGUgb3V0LW9mLXN5bmMgcmVhbGl0eSBhbmQgdGhyb3cgYW4gZXJyb3IuIFdlIGxvb2sgYXQgdGhpcyBraW5kIG9mIGJ1Z1xuICAgICAgICAvLyBhcyBhIGRldmVsb3Blci1vd25lZCBidWcuIEluIHByb2R1Y3Rpb24sIHRoZXNlIGVycm9ycyBhcmUgbm90IGV4cGVjdGVkIHRvIGhhcHBlbi5cbiAgICAgICAgY2FzZSAyOTkgLyogUkVKRUNUX1NUT1JBR0VfT1AgKi86IHtcbiAgICAgICAgICBlcnJvcldpdGhUaXRsZShcbiAgICAgICAgICAgIFwiU3RvcmFnZSBtdXRhdGlvbiByZWplY3Rpb24gZXJyb3JcIixcbiAgICAgICAgICAgIG1lc3NhZ2UucmVhc29uXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFjZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcElkIG9mIG1lc3NhZ2Uub3BJZHMpIHtcbiAgICAgICAgICAgICAgY29uc3QgdHJhY2UgPSBjb250ZXh0Lm9wU3RhY2tUcmFjZXM/LmdldChvcElkKTtcbiAgICAgICAgICAgICAgaWYgKHRyYWNlKSB7XG4gICAgICAgICAgICAgICAgdHJhY2VzLmFkZCh0cmFjZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFjZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgd2FybldpdGhUaXRsZShcbiAgICAgICAgICAgICAgICBcIlRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gY2FsbHMgY2F1c2VkIHRoZSByZWplY3RlZCBzdG9yYWdlIG11dGF0aW9uczpcIixcbiAgICAgICAgICAgICAgICBgXG5cbiR7QXJyYXkuZnJvbSh0cmFjZXMpLmpvaW4oXCJcXG5cXG5cIil9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgU3RvcmFnZSBtdXRhdGlvbnMgcmVqZWN0ZWQgYnkgc2VydmVyOiAke21lc3NhZ2UucmVhc29ufWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNDAwIC8qIFRIUkVBRF9DUkVBVEVEICovOlxuICAgICAgICBjYXNlIDQwNyAvKiBUSFJFQURfREVMRVRFRCAqLzpcbiAgICAgICAgY2FzZSA0MDEgLyogVEhSRUFEX01FVEFEQVRBX1VQREFURUQgKi86XG4gICAgICAgIGNhc2UgNDA4IC8qIFRIUkVBRF9VUERBVEVEICovOlxuICAgICAgICBjYXNlIDQwNSAvKiBDT01NRU5UX1JFQUNUSU9OX0FEREVEICovOlxuICAgICAgICBjYXNlIDQwNiAvKiBDT01NRU5UX1JFQUNUSU9OX1JFTU9WRUQgKi86XG4gICAgICAgIGNhc2UgNDAyIC8qIENPTU1FTlRfQ1JFQVRFRCAqLzpcbiAgICAgICAgY2FzZSA0MDMgLyogQ09NTUVOVF9FRElURUQgKi86XG4gICAgICAgIGNhc2UgNDA0IC8qIENPTU1FTlRfREVMRVRFRCAqLzoge1xuICAgICAgICAgIGV2ZW50SHViLmNvbW1lbnRzLm5vdGlmeShtZXNzYWdlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBub3RpZnkodXBkYXRlcyk7XG4gIH1cbiAgZnVuY3Rpb24gZmx1c2hOb3dPclNvb24oKSB7XG4gICAgY29uc3Qgc3RvcmFnZU9wcyA9IGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zO1xuICAgIGlmIChzdG9yYWdlT3BzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoY29uc3Qgb3Agb2Ygc3RvcmFnZU9wcykge1xuICAgICAgICBjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzLnNldChubihvcC5vcElkKSwgb3ApO1xuICAgICAgfVxuICAgICAgbm90aWZ5U3RvcmFnZVN0YXR1cygpO1xuICAgIH1cbiAgICBpZiAobWFuYWdlZFNvY2tldC5nZXRTdGF0dXMoKSAhPT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnMgPSBbXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBlbGFwc2VkTWlsbGlzID0gbm93IC0gY29udGV4dC5idWZmZXIubGFzdEZsdXNoZWRBdDtcbiAgICBpZiAoZWxhcHNlZE1pbGxpcyA+PSBjb25maWcudGhyb3R0bGVEZWxheSkge1xuICAgICAgY29uc3QgbWVzc2FnZXNUb0ZsdXNoID0gc2VyaWFsaXplQnVmZmVyKCk7XG4gICAgICBpZiAobWVzc2FnZXNUb0ZsdXNoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZW5kTWVzc2FnZXMobWVzc2FnZXNUb0ZsdXNoKTtcbiAgICAgIGNvbnRleHQuYnVmZmVyID0ge1xuICAgICAgICBmbHVzaFRpbWVySUQ6IHZvaWQgMCxcbiAgICAgICAgbGFzdEZsdXNoZWRBdDogbm93LFxuICAgICAgICBtZXNzYWdlczogW10sXG4gICAgICAgIHN0b3JhZ2VPcGVyYXRpb25zOiBbXSxcbiAgICAgICAgcHJlc2VuY2VVcGRhdGVzOiBudWxsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclRpbWVvdXQoY29udGV4dC5idWZmZXIuZmx1c2hUaW1lcklEKTtcbiAgICAgIGNvbnRleHQuYnVmZmVyLmZsdXNoVGltZXJJRCA9IHNldFRpbWVvdXQoXG4gICAgICAgIGZsdXNoTm93T3JTb29uLFxuICAgICAgICBjb25maWcudGhyb3R0bGVEZWxheSAtIGVsYXBzZWRNaWxsaXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZUJ1ZmZlcigpIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGlmIChjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMpIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goXG4gICAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy50eXBlID09PSBcImZ1bGxcIiA/IHtcbiAgICAgICAgICB0eXBlOiAxMDAgLyogVVBEQVRFX1BSRVNFTkNFICovLFxuICAgICAgICAgIC8vIFBvcHVsYXRpbmcgdGhlIGB0YXJnZXRBY3RvcmAgZmllbGQgdHVybnMgdGhpcyBtZXNzYWdlIGludG9cbiAgICAgICAgICAvLyBhIEZ1bGwgUHJlc2VuY2XihKIgdXBkYXRlIG1lc3NhZ2UgKG5vdCBhIHBhdGNoKSwgd2hpY2ggd2lsbCBnZXRcbiAgICAgICAgICAvLyBpbnRlcnByZXRlZCBieSBvdGhlciBjbGllbnRzIGFzIHN1Y2guXG4gICAgICAgICAgdGFyZ2V0QWN0b3I6IC0xLFxuICAgICAgICAgIGRhdGE6IGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy5kYXRhXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgdHlwZTogMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLyxcbiAgICAgICAgICBkYXRhOiBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICB0eXBlOiAyMDEgLyogVVBEQVRFX1NUT1JBR0UgKi8sXG4gICAgICAgIG9wczogY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZXM7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlWURvYyh1cGRhdGUsIGd1aWQsIGlzVjIpIHtcbiAgICBjb25zdCBjbGllbnRNc2cgPSB7XG4gICAgICB0eXBlOiAzMDEgLyogVVBEQVRFX1lET0MgKi8sXG4gICAgICB1cGRhdGUsXG4gICAgICBndWlkLFxuICAgICAgdjI6IGlzVjJcbiAgICB9O1xuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goY2xpZW50TXNnKTtcbiAgICBldmVudEh1Yi55ZG9jLm5vdGlmeShjbGllbnRNc2cpO1xuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gYnJvYWRjYXN0RXZlbnQoZXZlbnQsIG9wdGlvbnMyID0ge1xuICAgIHNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5OiBmYWxzZVxuICB9KSB7XG4gICAgaWYgKG1hbmFnZWRTb2NrZXQuZ2V0U3RhdHVzKCkgIT09IFwiY29ubmVjdGVkXCIgJiYgIW9wdGlvbnMyLnNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goe1xuICAgICAgdHlwZTogMTAzIC8qIEJST0FEQ0FTVF9FVkVOVCAqLyxcbiAgICAgIGV2ZW50XG4gICAgfSk7XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwYXRjaE9wcyhvcHMpIHtcbiAgICBjb25zdCB7IHN0b3JhZ2VPcGVyYXRpb25zIH0gPSBjb250ZXh0LmJ1ZmZlcjtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgc3RvcmFnZU9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgbGV0IF9nZXRTdG9yYWdlJCA9IG51bGw7XG4gIGxldCBfcmVzb2x2ZVN0b3JhZ2VQcm9taXNlID0gbnVsbDtcbiAgZnVuY3Rpb24gcHJvY2Vzc0luaXRpYWxTdG9yYWdlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCB1bmFja25vd2xlZGdlZE9wcyA9IG5ldyBNYXAoY29udGV4dC51bmFja25vd2xlZGdlZE9wcyk7XG4gICAgY3JlYXRlT3JVcGRhdGVSb290RnJvbU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgYXBwbHlBbmRTZW5kT3BzKHVuYWNrbm93bGVkZ2VkT3BzKTtcbiAgICBfcmVzb2x2ZVN0b3JhZ2VQcm9taXNlPy4oKTtcbiAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gICAgZXZlbnRIdWIuc3RvcmFnZURpZExvYWQubm90aWZ5KCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc3RyZWFtU3RvcmFnZSgpIHtcbiAgICBpZiAoIW1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlKSByZXR1cm47XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCBodHRwQ2xpZW50LnN0cmVhbVN0b3JhZ2UoeyByb29tSWQgfSk7XG4gICAgcHJvY2Vzc0luaXRpYWxTdG9yYWdlKHsgdHlwZTogMjAwIC8qIElOSVRJQUxfU1RPUkFHRV9TVEFURSAqLywgaXRlbXMgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVmcmVzaFN0b3JhZ2Uob3B0aW9uczIpIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzO1xuICAgIGlmIChjb25maWcudW5zdGFibGVfc3RyZWFtRGF0YSkge1xuICAgICAgdm9pZCBzdHJlYW1TdG9yYWdlKCk7XG4gICAgfSBlbHNlIGlmICghbWVzc2FnZXMuc29tZSgobXNnKSA9PiBtc2cudHlwZSA9PT0gMjAwIC8qIEZFVENIX1NUT1JBR0UgKi8pKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKHsgdHlwZTogMjAwIC8qIEZFVENIX1NUT1JBR0UgKi8gfSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zMi5mbHVzaCkge1xuICAgICAgZmx1c2hOb3dPclNvb24oKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnRMb2FkaW5nU3RvcmFnZSgpIHtcbiAgICBpZiAoX2dldFN0b3JhZ2UkID09PSBudWxsKSB7XG4gICAgICByZWZyZXNoU3RvcmFnZSh7IGZsdXNoOiB0cnVlIH0pO1xuICAgICAgX2dldFN0b3JhZ2UkID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgX3Jlc29sdmVTdG9yYWdlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICB9KTtcbiAgICAgIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXRTdG9yYWdlJDtcbiAgfVxuICBmdW5jdGlvbiBnZXRTdG9yYWdlU25hcHNob3QoKSB7XG4gICAgY29uc3Qgcm9vdCA9IGNvbnRleHQucm9vdDtcbiAgICBpZiAocm9vdCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdm9pZCBzdGFydExvYWRpbmdTdG9yYWdlKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0U3RvcmFnZSgpIHtcbiAgICBpZiAoY29udGV4dC5yb290ICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICByb290OiBjb250ZXh0LnJvb3RcbiAgICAgIH0pO1xuICAgIH1cbiAgICBhd2FpdCBzdGFydExvYWRpbmdTdG9yYWdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3Q6IG5uKGNvbnRleHQucm9vdClcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGZldGNoWURvYyh2ZWN0b3IsIGd1aWQsIGlzVjIpIHtcbiAgICBpZiAoIWNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLmZpbmQoKG0pID0+IHtcbiAgICAgIHJldHVybiBtLnR5cGUgPT09IDMwMCAvKiBGRVRDSF9ZRE9DICovICYmIG0udmVjdG9yID09PSB2ZWN0b3IgJiYgbS5ndWlkID09PSBndWlkICYmIG0udjIgPT09IGlzVjI7XG4gICAgfSkpIHtcbiAgICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goe1xuICAgICAgICB0eXBlOiAzMDAgLyogRkVUQ0hfWURPQyAqLyxcbiAgICAgICAgdmVjdG9yLFxuICAgICAgICBndWlkLFxuICAgICAgICB2MjogaXNWMlxuICAgICAgfSk7XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gdW5kbygpIHtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5kbyBpcyBub3QgYWxsb3dlZCBkdXJpbmcgYSBiYXRjaFwiKTtcbiAgICB9XG4gICAgY29uc3QgaGlzdG9yeU9wcyA9IGNvbnRleHQudW5kb1N0YWNrLnBvcCgpO1xuICAgIGlmIChoaXN0b3J5T3BzID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gbnVsbDtcbiAgICBjb25zdCByZXN1bHQgPSBhcHBseU9wcyhoaXN0b3J5T3BzLCB0cnVlKTtcbiAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMpO1xuICAgIGNvbnRleHQucmVkb1N0YWNrLnB1c2gocmVzdWx0LnJldmVyc2UpO1xuICAgIG9uSGlzdG9yeUNoYW5nZSgpO1xuICAgIGZvciAoY29uc3Qgb3Agb2YgcmVzdWx0Lm9wcykge1xuICAgICAgaWYgKG9wLnR5cGUgIT09IFwicHJlc2VuY2VcIikge1xuICAgICAgICBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiByZWRvKCkge1xuICAgIGlmIChjb250ZXh0LmFjdGl2ZUJhdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWRvIGlzIG5vdCBhbGxvd2VkIGR1cmluZyBhIGJhdGNoXCIpO1xuICAgIH1cbiAgICBjb25zdCBoaXN0b3J5T3BzID0gY29udGV4dC5yZWRvU3RhY2sucG9wKCk7XG4gICAgaWYgKGhpc3RvcnlPcHMgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBudWxsO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGx5T3BzKGhpc3RvcnlPcHMsIHRydWUpO1xuICAgIG5vdGlmeShyZXN1bHQudXBkYXRlcyk7XG4gICAgY29udGV4dC51bmRvU3RhY2sucHVzaChyZXN1bHQucmV2ZXJzZSk7XG4gICAgb25IaXN0b3J5Q2hhbmdlKCk7XG4gICAgZm9yIChjb25zdCBvcCBvZiByZXN1bHQub3BzKSB7XG4gICAgICBpZiAob3AudHlwZSAhPT0gXCJwcmVzZW5jZVwiKSB7XG4gICAgICAgIGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zLnB1c2gob3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgY29udGV4dC5yZWRvU3RhY2subGVuZ3RoID0gMDtcbiAgfVxuICBmdW5jdGlvbiBiYXRjaDIoY2FsbGJhY2spIHtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGxldCByZXR1cm5WYWx1ZSA9IHZvaWQgMDtcbiAgICBjb250ZXh0LmFjdGl2ZUJhdGNoID0ge1xuICAgICAgb3BzOiBbXSxcbiAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICAgIHByZXNlbmNlOiBmYWxzZSxcbiAgICAgICAgb3RoZXJzOiBbXVxuICAgICAgfSxcbiAgICAgIHJldmVyc2VPcHM6IG5ldyBEZXF1ZSgpXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuVmFsdWUgPSBjYWxsYmFjaygpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjb25zdCBjdXJyZW50QmF0Y2ggPSBjb250ZXh0LmFjdGl2ZUJhdGNoO1xuICAgICAgY29udGV4dC5hY3RpdmVCYXRjaCA9IG51bGw7XG4gICAgICBpZiAoY3VycmVudEJhdGNoLnJldmVyc2VPcHMubGVuZ3RoID4gMCkge1xuICAgICAgICBhZGRUb1VuZG9TdGFjayhBcnJheS5mcm9tKGN1cnJlbnRCYXRjaC5yZXZlcnNlT3BzKSk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudEJhdGNoLm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudEJhdGNoLm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRpc3BhdGNoT3BzKGN1cnJlbnRCYXRjaC5vcHMpO1xuICAgICAgfVxuICAgICAgbm90aWZ5KGN1cnJlbnRCYXRjaC51cGRhdGVzKTtcbiAgICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBwYXVzZUhpc3RvcnkoKSB7XG4gICAgaWYgKGNvbnRleHQucGF1c2VkSGlzdG9yeSA9PT0gbnVsbCkge1xuICAgICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gbmV3IERlcXVlKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlc3VtZUhpc3RvcnkoKSB7XG4gICAgY29uc3QgaGlzdG9yeU9wcyA9IGNvbnRleHQucGF1c2VkSGlzdG9yeTtcbiAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBudWxsO1xuICAgIGlmIChoaXN0b3J5T3BzICE9PSBudWxsICYmIGhpc3RvcnlPcHMubGVuZ3RoID4gMCkge1xuICAgICAgX2FkZFRvUmVhbFVuZG9TdGFjayhBcnJheS5mcm9tKGhpc3RvcnlPcHMpKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3luY1NvdXJjZUZvclN0b3JhZ2UgPSBjb25maWcuY3JlYXRlU3luY1NvdXJjZSgpO1xuICBmdW5jdGlvbiBnZXRTdG9yYWdlU3RhdHVzKCkge1xuICAgIGlmIChjb250ZXh0LnJvb3QgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIF9nZXRTdG9yYWdlJCA9PT0gbnVsbCA/IFwibm90LWxvYWRlZFwiIDogXCJsb2FkaW5nXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzLnNpemUgPT09IDAgPyBcInN5bmNocm9uaXplZFwiIDogXCJzeW5jaHJvbml6aW5nXCI7XG4gICAgfVxuICB9XG4gIGxldCBfbGFzdFN0b3JhZ2VTdGF0dXMgPSBnZXRTdG9yYWdlU3RhdHVzKCk7XG4gIGZ1bmN0aW9uIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKSB7XG4gICAgY29uc3Qgc3RvcmFnZVN0YXR1cyA9IGdldFN0b3JhZ2VTdGF0dXMoKTtcbiAgICBpZiAoX2xhc3RTdG9yYWdlU3RhdHVzICE9PSBzdG9yYWdlU3RhdHVzKSB7XG4gICAgICBfbGFzdFN0b3JhZ2VTdGF0dXMgPSBzdG9yYWdlU3RhdHVzO1xuICAgICAgZXZlbnRIdWIuc3RvcmFnZVN0YXR1cy5ub3RpZnkoc3RvcmFnZVN0YXR1cyk7XG4gICAgfVxuICAgIHN5bmNTb3VyY2VGb3JTdG9yYWdlLnNldFN5bmNTdGF0dXMoXG4gICAgICBzdG9yYWdlU3RhdHVzID09PSBcInN5bmNocm9uaXppbmdcIiA/IFwic3luY2hyb25pemluZ1wiIDogXCJzeW5jaHJvbml6ZWRcIlxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gaXNQcmVzZW5jZVJlYWR5KCkge1xuICAgIHJldHVybiBzZWxmLmdldCgpICE9PSBudWxsO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHdhaXRVbnRpbFByZXNlbmNlUmVhZHkoKSB7XG4gICAgd2hpbGUgKCFpc1ByZXNlbmNlUmVhZHkoKSkge1xuICAgICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlIH0gPSBQcm9taXNlX3dpdGhSZXNvbHZlcnMoKTtcbiAgICAgIGNvbnN0IHVuc3ViMSA9IGV2ZW50cy5zZWxmLnN1YnNjcmliZU9uY2UocmVzb2x2ZSk7XG4gICAgICBjb25zdCB1bnN1YjIgPSBldmVudHMuc3RhdHVzLnN1YnNjcmliZU9uY2UocmVzb2x2ZSk7XG4gICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgdW5zdWIxKCk7XG4gICAgICB1bnN1YjIoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNTdG9yYWdlUmVhZHkoKSB7XG4gICAgcmV0dXJuIGdldFN0b3JhZ2VTbmFwc2hvdCgpICE9PSBudWxsO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHdhaXRVbnRpbFN0b3JhZ2VSZWFkeSgpIHtcbiAgICB3aGlsZSAoIWlzU3RvcmFnZVJlYWR5KCkpIHtcbiAgICAgIGF3YWl0IGdldFN0b3JhZ2UoKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgb3RoZXJzX2ZvckRldlRvb2xzID0gRGVyaXZlZFNpZ25hbC5mcm9tKFxuICAgIGNvbnRleHQub3RoZXJzLnNpZ25hbCxcbiAgICAob3RoZXJzKSA9PiBvdGhlcnMubWFwKChvdGhlciwgaW5kZXgpID0+IHVzZXJUb1RyZWVOb2RlKGBPdGhlciAke2luZGV4fWAsIG90aGVyKSlcbiAgKTtcbiAgY29uc3QgZXZlbnRzID0ge1xuICAgIHN0YXR1czogZXZlbnRIdWIuc3RhdHVzLm9ic2VydmFibGUsXG4gICAgbG9zdENvbm5lY3Rpb246IGV2ZW50SHViLmxvc3RDb25uZWN0aW9uLm9ic2VydmFibGUsXG4gICAgY3VzdG9tRXZlbnQ6IGV2ZW50SHViLmN1c3RvbUV2ZW50Lm9ic2VydmFibGUsXG4gICAgb3RoZXJzOiBldmVudEh1Yi5vdGhlcnMub2JzZXJ2YWJsZSxcbiAgICBzZWxmOiBldmVudEh1Yi5zZWxmLm9ic2VydmFibGUsXG4gICAgbXlQcmVzZW5jZTogZXZlbnRIdWIubXlQcmVzZW5jZS5vYnNlcnZhYmxlLFxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIHN0b3JhZ2U6IGV2ZW50SHViLnN0b3JhZ2VCYXRjaC5vYnNlcnZhYmxlLFxuICAgIHN0b3JhZ2VCYXRjaDogZXZlbnRIdWIuc3RvcmFnZUJhdGNoLm9ic2VydmFibGUsXG4gICAgaGlzdG9yeTogZXZlbnRIdWIuaGlzdG9yeS5vYnNlcnZhYmxlLFxuICAgIHN0b3JhZ2VEaWRMb2FkOiBldmVudEh1Yi5zdG9yYWdlRGlkTG9hZC5vYnNlcnZhYmxlLFxuICAgIHN0b3JhZ2VTdGF0dXM6IGV2ZW50SHViLnN0b3JhZ2VTdGF0dXMub2JzZXJ2YWJsZSxcbiAgICB5ZG9jOiBldmVudEh1Yi55ZG9jLm9ic2VydmFibGUsXG4gICAgY29tbWVudHM6IGV2ZW50SHViLmNvbW1lbnRzLm9ic2VydmFibGUsXG4gICAgcm9vbVdpbGxEZXN0cm95OiBldmVudEh1Yi5yb29tV2lsbERlc3Ryb3kub2JzZXJ2YWJsZVxuICB9O1xuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWRzU2luY2Uob3B0aW9uczIpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5nZXRUaHJlYWRzU2luY2Uoe1xuICAgICAgcm9vbUlkLFxuICAgICAgc2luY2U6IG9wdGlvbnMyLnNpbmNlLFxuICAgICAgc2lnbmFsOiBvcHRpb25zMi5zaWduYWxcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWRzKG9wdGlvbnMyKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZ2V0VGhyZWFkcyh7XG4gICAgICByb29tSWQsXG4gICAgICBxdWVyeTogb3B0aW9uczI/LnF1ZXJ5LFxuICAgICAgY3Vyc29yOiBvcHRpb25zMj8uY3Vyc29yXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkKHRocmVhZElkKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZ2V0VGhyZWFkKHsgcm9vbUlkLCB0aHJlYWRJZCB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVUaHJlYWQob3B0aW9uczIpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5jcmVhdGVUaHJlYWQoe1xuICAgICAgcm9vbUlkLFxuICAgICAgdGhyZWFkSWQ6IG9wdGlvbnMyLnRocmVhZElkLFxuICAgICAgY29tbWVudElkOiBvcHRpb25zMi5jb21tZW50SWQsXG4gICAgICBtZXRhZGF0YTogb3B0aW9uczIubWV0YWRhdGEsXG4gICAgICBib2R5OiBvcHRpb25zMi5ib2R5LFxuICAgICAgYXR0YWNobWVudElkczogb3B0aW9uczIuYXR0YWNobWVudElkc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVRocmVhZCh0aHJlYWRJZCkge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmRlbGV0ZVRocmVhZCh7IHJvb21JZCwgdGhyZWFkSWQgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZWRpdFRocmVhZE1ldGFkYXRhKHtcbiAgICBtZXRhZGF0YSxcbiAgICB0aHJlYWRJZFxuICB9KSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZWRpdFRocmVhZE1ldGFkYXRhKHsgcm9vbUlkLCB0aHJlYWRJZCwgbWV0YWRhdGEgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya1RocmVhZEFzUmVzb2x2ZWQodGhyZWFkSWQpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5tYXJrVGhyZWFkQXNSZXNvbHZlZCh7IHJvb21JZCwgdGhyZWFkSWQgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya1RocmVhZEFzVW5yZXNvbHZlZCh0aHJlYWRJZCkge1xuICAgIHJldHVybiBodHRwQ2xpZW50Lm1hcmtUaHJlYWRBc1VucmVzb2x2ZWQoe1xuICAgICAgcm9vbUlkLFxuICAgICAgdGhyZWFkSWRcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb21tZW50KG9wdGlvbnMyKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuY3JlYXRlQ29tbWVudCh7XG4gICAgICByb29tSWQsXG4gICAgICB0aHJlYWRJZDogb3B0aW9uczIudGhyZWFkSWQsXG4gICAgICBjb21tZW50SWQ6IG9wdGlvbnMyLmNvbW1lbnRJZCxcbiAgICAgIGJvZHk6IG9wdGlvbnMyLmJvZHksXG4gICAgICBhdHRhY2htZW50SWRzOiBvcHRpb25zMi5hdHRhY2htZW50SWRzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZWRpdENvbW1lbnQob3B0aW9uczIpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5lZGl0Q29tbWVudCh7XG4gICAgICByb29tSWQsXG4gICAgICB0aHJlYWRJZDogb3B0aW9uczIudGhyZWFkSWQsXG4gICAgICBjb21tZW50SWQ6IG9wdGlvbnMyLmNvbW1lbnRJZCxcbiAgICAgIGJvZHk6IG9wdGlvbnMyLmJvZHksXG4gICAgICBhdHRhY2htZW50SWRzOiBvcHRpb25zMi5hdHRhY2htZW50SWRzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQ29tbWVudCh7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkXG4gIH0pIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5kZWxldGVDb21tZW50KHsgcm9vbUlkLCB0aHJlYWRJZCwgY29tbWVudElkIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGFkZFJlYWN0aW9uKHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWQsXG4gICAgZW1vamlcbiAgfSkge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmFkZFJlYWN0aW9uKHsgcm9vbUlkLCB0aHJlYWRJZCwgY29tbWVudElkLCBlbW9qaSB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZW1vdmVSZWFjdGlvbih7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkLFxuICAgIGVtb2ppXG4gIH0pIHtcbiAgICByZXR1cm4gYXdhaXQgaHR0cENsaWVudC5yZW1vdmVSZWFjdGlvbih7XG4gICAgICByb29tSWQsXG4gICAgICB0aHJlYWRJZCxcbiAgICAgIGNvbW1lbnRJZCxcbiAgICAgIGVtb2ppXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcHJlcGFyZUF0dGFjaG1lbnQoZmlsZSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxvY2FsQXR0YWNobWVudFwiLFxuICAgICAgc3RhdHVzOiBcImlkbGVcIixcbiAgICAgIGlkOiBjcmVhdGVDb21tZW50QXR0YWNobWVudElkKCksXG4gICAgICBuYW1lOiBmaWxlLm5hbWUsXG4gICAgICBzaXplOiBmaWxlLnNpemUsXG4gICAgICBtaW1lVHlwZTogZmlsZS50eXBlLFxuICAgICAgZmlsZVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gdXBsb2FkQXR0YWNobWVudChhdHRhY2htZW50LCBvcHRpb25zMiA9IHt9KSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQudXBsb2FkQXR0YWNobWVudCh7XG4gICAgICByb29tSWQsXG4gICAgICBhdHRhY2htZW50LFxuICAgICAgc2lnbmFsOiBvcHRpb25zMi5zaWduYWxcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRBdHRhY2htZW50VXJsKGF0dGFjaG1lbnRJZCkge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmdldEF0dGFjaG1lbnRVcmwoeyByb29tSWQsIGF0dGFjaG1lbnRJZCB9KTtcbiAgfVxuICBmdW5jdGlvbiBnZXROb3RpZmljYXRpb25TZXR0aW5ncyhvcHRpb25zMikge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmdldE5vdGlmaWNhdGlvblNldHRpbmdzKHtcbiAgICAgIHJvb21JZCxcbiAgICAgIHNpZ25hbDogb3B0aW9uczI/LnNpZ25hbFxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQudXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3MoeyByb29tSWQsIHNldHRpbmdzIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5tYXJrUm9vbUluYm94Tm90aWZpY2F0aW9uQXNSZWFkKHtcbiAgICAgIHJvb21JZCxcbiAgICAgIGluYm94Tm90aWZpY2F0aW9uSWRcbiAgICB9KTtcbiAgfVxuICBjb25zdCBzeW5jU291cmNlRm9yWWpzID0gY29uZmlnLmNyZWF0ZVN5bmNTb3VyY2UoKTtcbiAgZnVuY3Rpb24geWpzU3RhdHVzRGlkQ2hhbmdlKHN0YXR1cykge1xuICAgIHJldHVybiBzeW5jU291cmNlRm9yWWpzLnNldFN5bmNTdGF0dXMoXG4gICAgICBzdGF0dXMgPT09IFwic3luY2hyb25pemluZ1wiID8gXCJzeW5jaHJvbml6aW5nXCIgOiBcInN5bmNocm9uaXplZFwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIHtcbiAgICAgIFtrSW50ZXJuYWxdOiB7XG4gICAgICAgIGdldCBwcmVzZW5jZUJ1ZmZlcigpIHtcbiAgICAgICAgICByZXR1cm4gZGVlcENsb25lKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcz8uZGF0YSA/PyBudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGdldCB1bmRvU3RhY2soKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZXBDbG9uZShjb250ZXh0LnVuZG9TdGFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBnZXQgbm9kZUNvdW50KCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LnBvb2wubm9kZXMuc2l6ZTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGdldFlqc1Byb3ZpZGVyKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Lnlqc1Byb3ZpZGVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXRZanNQcm92aWRlcihuZXdQcm92aWRlcikge1xuICAgICAgICAgIGNvbnRleHQueWpzUHJvdmlkZXI/Lm9mZihcInN0YXR1c1wiLCB5anNTdGF0dXNEaWRDaGFuZ2UpO1xuICAgICAgICAgIGNvbnRleHQueWpzUHJvdmlkZXIgPSBuZXdQcm92aWRlcjtcbiAgICAgICAgICBuZXdQcm92aWRlcj8ub24oXCJzdGF0dXNcIiwgeWpzU3RhdHVzRGlkQ2hhbmdlKTtcbiAgICAgICAgICBjb250ZXh0Lnlqc1Byb3ZpZGVyRGlkQ2hhbmdlLm5vdGlmeSgpO1xuICAgICAgICB9LFxuICAgICAgICB5anNQcm92aWRlckRpZENoYW5nZTogY29udGV4dC55anNQcm92aWRlckRpZENoYW5nZS5vYnNlcnZhYmxlLFxuICAgICAgICAvLyBzZW5kIG1ldGFkYXRhIHdoZW4gdXNpbmcgYSB0ZXh0IGVkaXRvclxuICAgICAgICByZXBvcnRUZXh0RWRpdG9yLFxuICAgICAgICAvLyBjcmVhdGUgYSB0ZXh0IG1lbnRpb24gd2hlbiB1c2luZyBhIHRleHQgZWRpdG9yXG4gICAgICAgIGNyZWF0ZVRleHRNZW50aW9uLFxuICAgICAgICAvLyBkZWxldGUgYSB0ZXh0IG1lbnRpb24gd2hlbiB1c2luZyBhIHRleHQgZWRpdG9yXG4gICAgICAgIGRlbGV0ZVRleHRNZW50aW9uLFxuICAgICAgICAvLyBsaXN0IHZlcnNpb25zIG9mIHRoZSBkb2N1bWVudFxuICAgICAgICBsaXN0VGV4dFZlcnNpb25zLFxuICAgICAgICAvLyBMaXN0IHZlcnNpb25zIG9mIHRoZSBkb2N1bWVudCBzaW5jZSB0aGUgc3BlY2lmaWVkIGRhdGVcbiAgICAgICAgbGlzdFRleHRWZXJzaW9uc1NpbmNlLFxuICAgICAgICAvLyBnZXQgYSBzcGVjaWZpYyB2ZXJzaW9uXG4gICAgICAgIGdldFRleHRWZXJzaW9uLFxuICAgICAgICAvLyBjcmVhdGUgYSB2ZXJzaW9uXG4gICAgICAgIGNyZWF0ZVRleHRWZXJzaW9uLFxuICAgICAgICAvLyBleGVjdXRlIGEgY29udGV4dHVhbCBwcm9tcHRcbiAgICAgICAgZXhlY3V0ZUNvbnRleHR1YWxQcm9tcHQsXG4gICAgICAgIC8vIFN1cHBvcnQgZm9yIHRoZSBMaXZlYmxvY2tzIGJyb3dzZXIgZXh0ZW5zaW9uXG4gICAgICAgIGdldFNlbGZfZm9yRGV2VG9vbHM6ICgpID0+IHNlbGZBc1RyZWVOb2RlLmdldCgpLFxuICAgICAgICBnZXRPdGhlcnNfZm9yRGV2VG9vbHM6ICgpID0+IG90aGVyc19mb3JEZXZUb29scy5nZXQoKSxcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHNpbXVsYXRlOiB7XG4gICAgICAgICAgLy8gVGhlc2UgZXhpc3Qgb25seSBmb3Igb3VyIEUyRSB0ZXN0aW5nIGFwcFxuICAgICAgICAgIGV4cGxpY2l0Q2xvc2U6IChldmVudCkgPT4gbWFuYWdlZFNvY2tldC5fcHJpdmF0ZVNlbmRNYWNoaW5lRXZlbnQoeyB0eXBlOiBcIkVYUExJQ0lUX1NPQ0tFVF9DTE9TRVwiLCBldmVudCB9KSxcbiAgICAgICAgICByYXdTZW5kOiAoZGF0YSkgPT4gbWFuYWdlZFNvY2tldC5zZW5kKGRhdGEpXG4gICAgICAgIH0sXG4gICAgICAgIGF0dGFjaG1lbnRVcmxzU3RvcmU6IGh0dHBDbGllbnQuZ2V0T3JDcmVhdGVBdHRhY2htZW50VXJsc1N0b3JlKHJvb21JZClcbiAgICAgIH0sXG4gICAgICBpZDogcm9vbUlkLFxuICAgICAgc3Vic2NyaWJlOiBtYWtlQ2xhc3NpY1N1YnNjcmliZUZuKFxuICAgICAgICByb29tSWQsXG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgY29uZmlnLmVycm9yRXZlbnRTb3VyY2VcbiAgICAgICksXG4gICAgICBjb25uZWN0OiAoKSA9PiBtYW5hZ2VkU29ja2V0LmNvbm5lY3QoKSxcbiAgICAgIHJlY29ubmVjdDogKCkgPT4gbWFuYWdlZFNvY2tldC5yZWNvbm5lY3QoKSxcbiAgICAgIGRpc2Nvbm5lY3Q6ICgpID0+IG1hbmFnZWRTb2NrZXQuZGlzY29ubmVjdCgpLFxuICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJvb21XaWxsRGVzdHJveSwgLi4uZXZlbnRzRXhjZXB0RGVzdHJveSB9ID0gZXZlbnRIdWI7XG4gICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIE9iamVjdC52YWx1ZXMoZXZlbnRzRXhjZXB0RGVzdHJveSkpIHtcbiAgICAgICAgICBzb3VyY2VbU3ltYm9sLmRpc3Bvc2VdKCk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRIdWIucm9vbVdpbGxEZXN0cm95Lm5vdGlmeSgpO1xuICAgICAgICBjb250ZXh0Lnlqc1Byb3ZpZGVyPy5vZmYoXCJzdGF0dXNcIiwgeWpzU3RhdHVzRGlkQ2hhbmdlKTtcbiAgICAgICAgc3luY1NvdXJjZUZvclN0b3JhZ2UuZGVzdHJveSgpO1xuICAgICAgICBzeW5jU291cmNlRm9yWWpzLmRlc3Ryb3koKTtcbiAgICAgICAgdW5pbnN0YWxsQmdUYWJTcHkoKTtcbiAgICAgICAgbWFuYWdlZFNvY2tldC5kZXN0cm95KCk7XG4gICAgICAgIHJvb21XaWxsRGVzdHJveVtTeW1ib2wuZGlzcG9zZV0oKTtcbiAgICAgIH0sXG4gICAgICAvLyBQcmVzZW5jZVxuICAgICAgdXBkYXRlUHJlc2VuY2UsXG4gICAgICB1cGRhdGVZRG9jLFxuICAgICAgYnJvYWRjYXN0RXZlbnQsXG4gICAgICAvLyBTdG9yYWdlXG4gICAgICBiYXRjaDogYmF0Y2gyLFxuICAgICAgaGlzdG9yeToge1xuICAgICAgICB1bmRvLFxuICAgICAgICByZWRvLFxuICAgICAgICBjYW5VbmRvLFxuICAgICAgICBjYW5SZWRvLFxuICAgICAgICBjbGVhcixcbiAgICAgICAgcGF1c2U6IHBhdXNlSGlzdG9yeSxcbiAgICAgICAgcmVzdW1lOiByZXN1bWVIaXN0b3J5XG4gICAgICB9LFxuICAgICAgZmV0Y2hZRG9jLFxuICAgICAgZ2V0U3RvcmFnZSxcbiAgICAgIGdldFN0b3JhZ2VTbmFwc2hvdCxcbiAgICAgIGdldFN0b3JhZ2VTdGF0dXMsXG4gICAgICBpc1ByZXNlbmNlUmVhZHksXG4gICAgICBpc1N0b3JhZ2VSZWFkeSxcbiAgICAgIHdhaXRVbnRpbFByZXNlbmNlUmVhZHk6IG1lbW9pemVPblN1Y2Nlc3Mod2FpdFVudGlsUHJlc2VuY2VSZWFkeSksXG4gICAgICB3YWl0VW50aWxTdG9yYWdlUmVhZHk6IG1lbW9pemVPblN1Y2Nlc3Mod2FpdFVudGlsU3RvcmFnZVJlYWR5KSxcbiAgICAgIGV2ZW50cyxcbiAgICAgIC8vIENvcmVcbiAgICAgIGdldFN0YXR1czogKCkgPT4gbWFuYWdlZFNvY2tldC5nZXRTdGF0dXMoKSxcbiAgICAgIGdldFNlbGY6ICgpID0+IHNlbGYuZ2V0KCksXG4gICAgICAvLyBQcmVzZW5jZVxuICAgICAgZ2V0UHJlc2VuY2U6ICgpID0+IGNvbnRleHQubXlQcmVzZW5jZS5nZXQoKSxcbiAgICAgIGdldE90aGVyczogKCkgPT4gY29udGV4dC5vdGhlcnMuZ2V0KCksXG4gICAgICAvLyBDb21tZW50c1xuICAgICAgZ2V0VGhyZWFkcyxcbiAgICAgIGdldFRocmVhZHNTaW5jZSxcbiAgICAgIGdldFRocmVhZCxcbiAgICAgIGNyZWF0ZVRocmVhZCxcbiAgICAgIGRlbGV0ZVRocmVhZCxcbiAgICAgIGVkaXRUaHJlYWRNZXRhZGF0YSxcbiAgICAgIG1hcmtUaHJlYWRBc1Jlc29sdmVkLFxuICAgICAgbWFya1RocmVhZEFzVW5yZXNvbHZlZCxcbiAgICAgIGNyZWF0ZUNvbW1lbnQsXG4gICAgICBlZGl0Q29tbWVudCxcbiAgICAgIGRlbGV0ZUNvbW1lbnQsXG4gICAgICBhZGRSZWFjdGlvbixcbiAgICAgIHJlbW92ZVJlYWN0aW9uLFxuICAgICAgcHJlcGFyZUF0dGFjaG1lbnQsXG4gICAgICB1cGxvYWRBdHRhY2htZW50LFxuICAgICAgZ2V0QXR0YWNobWVudFVybCxcbiAgICAgIC8vIE5vdGlmaWNhdGlvbnNcbiAgICAgIGdldE5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgICAgdXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgICBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRcbiAgICB9LFxuICAgIC8vIEV4cGxpY3RseSBtYWtlIHRoZSBpbnRlcm5hbCBmaWVsZCBub24tZW51bWVyYWJsZSwgdG8gYXZvaWQgYWdncmVzc2l2ZVxuICAgIC8vIGZyZWV6aW5nIHdoZW4gdXNlZCB3aXRoIEltbWVyXG4gICAga0ludGVybmFsLFxuICAgIHsgZW51bWVyYWJsZTogZmFsc2UgfVxuICApO1xufVxuZnVuY3Rpb24gbWFrZUNsYXNzaWNTdWJzY3JpYmVGbihyb29tSWQsIGV2ZW50cywgZXJyb3JFdmVudHMpIHtcbiAgZnVuY3Rpb24gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlRGVlcGx5KG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlQmF0Y2guc3Vic2NyaWJlKCh1cGRhdGVzKSA9PiB7XG4gICAgICBjb25zdCByZWxhdGVkVXBkYXRlcyA9IHVwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAodXBkYXRlKSA9PiBpc1NhbWVOb2RlT3JDaGlsZE9mKHVwZGF0ZS5ub2RlLCBub2RlKVxuICAgICAgKTtcbiAgICAgIGlmIChyZWxhdGVkVXBkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNhbGxiYWNrKHJlbGF0ZWRVcGRhdGVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmVUb0xpdmVTdHJ1Y3R1cmVTaGFsbG93bHkobm9kZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZXZlbnRzLnN0b3JhZ2VCYXRjaC5zdWJzY3JpYmUoKHVwZGF0ZXMpID0+IHtcbiAgICAgIGZvciAoY29uc3QgdXBkYXRlIG9mIHVwZGF0ZXMpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS5ub2RlLl9pZCA9PT0gbm9kZS5faWQpIHtcbiAgICAgICAgICBjYWxsYmFjayh1cGRhdGUubm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmUoZmlyc3QsIHNlY29uZCwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgZmlyc3QgPT09IFwic3RyaW5nXCIgJiYgaXNSb29tRXZlbnROYW1lKGZpcnN0KSkge1xuICAgICAgaWYgKHR5cGVvZiBzZWNvbmQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIGNhbGxiYWNrIGZ1bmN0aW9uXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FsbGJhY2sgPSBzZWNvbmQ7XG4gICAgICBzd2l0Y2ggKGZpcnN0KSB7XG4gICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuY3VzdG9tRXZlbnQuc3Vic2NyaWJlKFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwibXktcHJlc2VuY2VcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLm15UHJlc2VuY2Uuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICAgICAgY2FzZSBcIm90aGVyc1wiOiB7XG4gICAgICAgICAgY29uc3QgY2IgPSBjYWxsYmFjaztcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLm90aGVycy5zdWJzY3JpYmUoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG90aGVycywgLi4uaW50ZXJuYWxFdmVudCB9ID0gZXZlbnQ7XG4gICAgICAgICAgICByZXR1cm4gY2Iob3RoZXJzLCBpbnRlcm5hbEV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICAgIHJldHVybiBlcnJvckV2ZW50cy5zdWJzY3JpYmUoKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVyci5yb29tSWQgPT09IHJvb21JZCkge1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwic3RhdHVzXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5zdGF0dXMuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICAgICAgY2FzZSBcImxvc3QtY29ubmVjdGlvblwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMubG9zdENvbm5lY3Rpb24uc3Vic2NyaWJlKFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwiaGlzdG9yeVwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuaGlzdG9yeS5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICBjYXNlIFwic3RvcmFnZS1zdGF0dXNcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLnN0b3JhZ2VTdGF0dXMuc3Vic2NyaWJlKFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwiY29tbWVudHNcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmNvbW1lbnRzLnN1YnNjcmliZShcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIoXG4gICAgICAgICAgICBmaXJzdCxcbiAgICAgICAgICAgIGBcIiR7U3RyaW5nKGZpcnN0KX1cIiBpcyBub3QgYSB2YWxpZCBldmVudCBuYW1lYFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzZWNvbmQgPT09IHZvaWQgMCB8fCB0eXBlb2YgZmlyc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VDYWxsYmFjayA9IGZpcnN0O1xuICAgICAgICByZXR1cm4gZXZlbnRzLnN0b3JhZ2VCYXRjaC5zdWJzY3JpYmUoc3RvcmFnZUNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBzcGVjaWZ5IGEgbGlzdGVuZXIgY2FsbGJhY2tcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0xpdmVOb2RlKGZpcnN0KSkge1xuICAgICAgY29uc3Qgbm9kZSA9IGZpcnN0O1xuICAgICAgaWYgKG9wdGlvbnM/LmlzRGVlcCkge1xuICAgICAgICBjb25zdCBzdG9yYWdlQ2FsbGJhY2sgPSBzZWNvbmQ7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVUb0xpdmVTdHJ1Y3R1cmVEZWVwbHkobm9kZSwgc3RvcmFnZUNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5vZGVDYWxsYmFjayA9IHNlY29uZDtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZVRvTGl2ZVN0cnVjdHVyZVNoYWxsb3dseShub2RlLCBub2RlQ2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgJHtTdHJpbmcoZmlyc3QpfSBpcyBub3QgYSB2YWx1ZSB0aGF0IGNhbiBiZSBzdWJzY3JpYmVkIHRvLmBcbiAgICApO1xuICB9XG4gIHJldHVybiBzdWJzY3JpYmU7XG59XG5mdW5jdGlvbiBpc1Jvb21FdmVudE5hbWUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBcIm15LXByZXNlbmNlXCIgfHwgdmFsdWUgPT09IFwib3RoZXJzXCIgfHwgdmFsdWUgPT09IFwiZXZlbnRcIiB8fCB2YWx1ZSA9PT0gXCJlcnJvclwiIHx8IHZhbHVlID09PSBcImhpc3RvcnlcIiB8fCB2YWx1ZSA9PT0gXCJzdGF0dXNcIiB8fCB2YWx1ZSA9PT0gXCJzdG9yYWdlLXN0YXR1c1wiIHx8IHZhbHVlID09PSBcImxvc3QtY29ubmVjdGlvblwiIHx8IHZhbHVlID09PSBcImNvbm5lY3Rpb25cIiB8fCB2YWx1ZSA9PT0gXCJjb21tZW50c1wiO1xufVxuZnVuY3Rpb24gbWFrZUF1dGhEZWxlZ2F0ZUZvclJvb20ocm9vbUlkLCBhdXRoTWFuYWdlcikge1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIHJldHVybiBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJyb29tOnJlYWRcIiwgcm9vbUlkIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gbWFrZUNyZWF0ZVNvY2tldERlbGVnYXRlRm9yUm9vbShyb29tSWQsIGJhc2VVcmwsIFdlYlNvY2tldFBvbHlmaWxsKSB7XG4gIHJldHVybiAoYXV0aFZhbHVlKSA9PiB7XG4gICAgY29uc3Qgd3MgPSBXZWJTb2NrZXRQb2x5ZmlsbCA/PyAodHlwZW9mIFdlYlNvY2tldCA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IFdlYlNvY2tldCk7XG4gICAgaWYgKHdzID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgIFwiVG8gdXNlIExpdmVibG9ja3MgY2xpZW50IGluIGEgbm9uLURPTSBlbnZpcm9ubWVudCwgeW91IG5lZWQgdG8gcHJvdmlkZSBhIFdlYlNvY2tldCBwb2x5ZmlsbC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdXJsMiA9IG5ldyBVUkwoYmFzZVVybCk7XG4gICAgdXJsMi5wcm90b2NvbCA9IHVybDIucHJvdG9jb2wgPT09IFwiaHR0cDpcIiA/IFwid3NcIiA6IFwid3NzXCI7XG4gICAgdXJsMi5wYXRobmFtZSA9IFwiL3Y3XCI7XG4gICAgdXJsMi5zZWFyY2hQYXJhbXMuc2V0KFwicm9vbUlkXCIsIHJvb21JZCk7XG4gICAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInNlY3JldFwiKSB7XG4gICAgICB1cmwyLnNlYXJjaFBhcmFtcy5zZXQoXCJ0b2tcIiwgYXV0aFZhbHVlLnRva2VuLnJhdyk7XG4gICAgfSBlbHNlIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJwdWJsaWNcIikge1xuICAgICAgdXJsMi5zZWFyY2hQYXJhbXMuc2V0KFwicHVia2V5XCIsIGF1dGhWYWx1ZS5wdWJsaWNBcGlLZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIoYXV0aFZhbHVlLCBcIlVuaGFuZGxlZCBjYXNlXCIpO1xuICAgIH1cbiAgICB1cmwyLnNlYXJjaFBhcmFtcy5zZXQoXCJ2ZXJzaW9uXCIsIFBLR19WRVJTSU9OIHx8IFwiZGV2XCIpO1xuICAgIHJldHVybiBuZXcgd3ModXJsMi50b1N0cmluZygpKTtcbiAgfTtcbn1cblxuLy8gc3JjL2NsaWVudC50c1xudmFyIE1JTl9USFJPVFRMRSA9IDE2O1xudmFyIE1BWF9USFJPVFRMRSA9IDFlMztcbnZhciBERUZBVUxUX1RIUk9UVExFID0gMTAwO1xudmFyIE1JTl9CQUNLR1JPVU5EX0tFRVBfQUxJVkVfVElNRU9VVCA9IDE1ZTM7XG52YXIgTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUID0gMjAwO1xudmFyIFJFQ09NTUVOREVEX01JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDFlMztcbnZhciBNQVhfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQgPSAzZTQ7XG52YXIgREVGQVVMVF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDVlMztcbnZhciBSRVNPTFZFX1VTRVJTX0JBVENIX0RFTEFZID0gNTA7XG52YXIgUkVTT0xWRV9ST09NU19JTkZPX0JBVENIX0RFTEFZID0gNTA7XG5mdW5jdGlvbiBnZXRCYXNlVXJsKGJhc2VVcmwpIHtcbiAgaWYgKHR5cGVvZiBiYXNlVXJsID09PSBcInN0cmluZ1wiICYmIGJhc2VVcmwuc3RhcnRzV2l0aChcImh0dHBcIikpIHtcbiAgICByZXR1cm4gYmFzZVVybDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gREVGQVVMVF9CQVNFX1VSTDtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50KG9wdGlvbnMpIHtcbiAgY29uc3QgY2xpZW50T3B0aW9ucyA9IG9wdGlvbnM7XG4gIGNvbnN0IHRocm90dGxlRGVsYXkgPSBnZXRUaHJvdHRsZShjbGllbnRPcHRpb25zLnRocm90dGxlID8/IERFRkFVTFRfVEhST1RUTEUpO1xuICBjb25zdCBsb3N0Q29ubmVjdGlvblRpbWVvdXQgPSBnZXRMb3N0Q29ubmVjdGlvblRpbWVvdXQoXG4gICAgY2xpZW50T3B0aW9ucy5sb3N0Q29ubmVjdGlvblRpbWVvdXQgPz8gREVGQVVMVF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVFxuICApO1xuICBjb25zdCBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCA9IGdldEJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0KFxuICAgIGNsaWVudE9wdGlvbnMuYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXRcbiAgKTtcbiAgY29uc3QgYmFzZVVybCA9IGdldEJhc2VVcmwoY2xpZW50T3B0aW9ucy5iYXNlVXJsKTtcbiAgY29uc3QgY3VycmVudFVzZXJJZCA9IG5ldyBTaWduYWwodm9pZCAwKTtcbiAgY29uc3QgYXV0aE1hbmFnZXIgPSBjcmVhdGVBdXRoTWFuYWdlcihvcHRpb25zLCAodG9rZW4pID0+IHtcbiAgICBjb25zdCB1c2VySWQgPSB0b2tlbi5rID09PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovID8gdG9rZW4uaWQgOiB0b2tlbi51aWQ7XG4gICAgY3VycmVudFVzZXJJZC5zZXQoKCkgPT4gdXNlcklkKTtcbiAgfSk7XG4gIGNvbnN0IGZldGNoUG9seWZpbGwgPSBjbGllbnRPcHRpb25zLnBvbHlmaWxscz8uZmV0Y2ggfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2xvYmFsVGhpcy5mZXRjaD8uYmluZChnbG9iYWxUaGlzKTtcbiAgY29uc3QgaHR0cENsaWVudCA9IGNyZWF0ZUFwaUNsaWVudCh7XG4gICAgYmFzZVVybCxcbiAgICBmZXRjaFBvbHlmaWxsLFxuICAgIGF1dGhNYW5hZ2VyXG4gIH0pO1xuICBjb25zdCByb29tc0J5SWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiB0ZWFyZG93blJvb20ocm9vbSkge1xuICAgIHVubGlua0RldlRvb2xzKHJvb20uaWQpO1xuICAgIHJvb21zQnlJZC5kZWxldGUocm9vbS5pZCk7XG4gICAgcm9vbS5kZXN0cm95KCk7XG4gIH1cbiAgZnVuY3Rpb24gbGVhc2VSb29tKGRldGFpbHMpIHtcbiAgICBjb25zdCBsZWF2ZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGYgPSBsZWF2ZTtcbiAgICAgIGlmICghZGV0YWlscy51bnN1YnMuZGVsZXRlKHNlbGYpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJUaGlzIGxlYXZlIGZ1bmN0aW9uIHdhcyBhbHJlYWR5IGNhbGxlZC4gQ2FsbGluZyBpdCBtb3JlIHRoYW4gb25jZSBoYXMgbm8gZWZmZWN0LlwiXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZGV0YWlscy51bnN1YnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRlYXJkb3duUm9vbShkZXRhaWxzLnJvb20pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBkZXRhaWxzLnVuc3Vicy5hZGQobGVhdmUpO1xuICAgIHJldHVybiB7XG4gICAgICByb29tOiBkZXRhaWxzLnJvb20sXG4gICAgICBsZWF2ZVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZW50ZXJSb29tKHJvb21JZCwgLi4uYXJncykge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gcm9vbXNCeUlkLmdldChyb29tSWQpO1xuICAgIGlmIChleGlzdGluZyAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbGVhc2VSb29tKGV4aXN0aW5nKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9uczIgPSBhcmdzWzBdID8/IHt9O1xuICAgIGNvbnN0IGluaXRpYWxQcmVzZW5jZSA9ICh0eXBlb2Ygb3B0aW9uczIuaW5pdGlhbFByZXNlbmNlID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zMi5pbml0aWFsUHJlc2VuY2Uocm9vbUlkKSA6IG9wdGlvbnMyLmluaXRpYWxQcmVzZW5jZSkgPz8ge307XG4gICAgY29uc3QgaW5pdGlhbFN0b3JhZ2UgPSAodHlwZW9mIG9wdGlvbnMyLmluaXRpYWxTdG9yYWdlID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zMi5pbml0aWFsU3RvcmFnZShyb29tSWQpIDogb3B0aW9uczIuaW5pdGlhbFN0b3JhZ2UpID8/IHt9O1xuICAgIGNvbnN0IG5ld1Jvb20gPSBjcmVhdGVSb29tKFxuICAgICAgeyBpbml0aWFsUHJlc2VuY2UsIGluaXRpYWxTdG9yYWdlIH0sXG4gICAgICB7XG4gICAgICAgIHJvb21JZCxcbiAgICAgICAgdGhyb3R0bGVEZWxheSxcbiAgICAgICAgbG9zdENvbm5lY3Rpb25UaW1lb3V0LFxuICAgICAgICBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCxcbiAgICAgICAgcG9seWZpbGxzOiBjbGllbnRPcHRpb25zLnBvbHlmaWxscyxcbiAgICAgICAgZGVsZWdhdGVzOiBjbGllbnRPcHRpb25zLm1vY2tlZERlbGVnYXRlcyA/PyB7XG4gICAgICAgICAgY3JlYXRlU29ja2V0OiBtYWtlQ3JlYXRlU29ja2V0RGVsZWdhdGVGb3JSb29tKFxuICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgICAgYmFzZVVybCxcbiAgICAgICAgICAgIGNsaWVudE9wdGlvbnMucG9seWZpbGxzPy5XZWJTb2NrZXRcbiAgICAgICAgICApLFxuICAgICAgICAgIGF1dGhlbnRpY2F0ZTogbWFrZUF1dGhEZWxlZ2F0ZUZvclJvb20ocm9vbUlkLCBhdXRoTWFuYWdlcilcbiAgICAgICAgfSxcbiAgICAgICAgZW5hYmxlRGVidWdMb2dnaW5nOiBjbGllbnRPcHRpb25zLmVuYWJsZURlYnVnTG9nZ2luZyxcbiAgICAgICAgYmFzZVVybCxcbiAgICAgICAgZXJyb3JFdmVudFNvdXJjZTogbGl2ZWJsb2Nrc0Vycm9yU291cmNlLFxuICAgICAgICBsYXJnZU1lc3NhZ2VTdHJhdGVneTogY2xpZW50T3B0aW9ucy5sYXJnZU1lc3NhZ2VTdHJhdGVneSA/PyAoY2xpZW50T3B0aW9ucy51bnN0YWJsZV9mYWxsYmFja1RvSFRUUCA/IFwiZXhwZXJpbWVudGFsLWZhbGxiYWNrLXRvLWh0dHBcIiA6IHZvaWQgMCksXG4gICAgICAgIHVuc3RhYmxlX3N0cmVhbURhdGE6ICEhY2xpZW50T3B0aW9ucy51bnN0YWJsZV9zdHJlYW1EYXRhLFxuICAgICAgICByb29tSHR0cENsaWVudDogaHR0cENsaWVudCxcbiAgICAgICAgY3JlYXRlU3luY1NvdXJjZVxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgbmV3Um9vbURldGFpbHMgPSB7XG4gICAgICByb29tOiBuZXdSb29tLFxuICAgICAgdW5zdWJzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gICAgfTtcbiAgICByb29tc0J5SWQuc2V0KHJvb21JZCwgbmV3Um9vbURldGFpbHMpO1xuICAgIHNldHVwRGV2VG9vbHMoKCkgPT4gQXJyYXkuZnJvbShyb29tc0J5SWQua2V5cygpKSk7XG4gICAgbGlua0RldlRvb2xzKHJvb21JZCwgbmV3Um9vbSk7XG4gICAgY29uc3Qgc2hvdWxkQ29ubmVjdCA9IG9wdGlvbnMyLmF1dG9Db25uZWN0ID8/IHRydWU7XG4gICAgaWYgKHNob3VsZENvbm5lY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgYXRvYiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHM/LmF0b2IgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiWW91IG5lZWQgdG8gcG9seWZpbGwgYXRvYiB0byB1c2UgdGhlIGNsaWVudCBpbiB5b3VyIGVudmlyb25tZW50LiBQbGVhc2UgZm9sbG93IHRoZSBpbnN0cnVjdGlvbnMgYXQgaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2xpdmVibG9ja3MtY2xpZW50L2F0b2ItcG9seWZpbGxcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFsLmF0b2IgPSBjbGllbnRPcHRpb25zLnBvbHlmaWxscy5hdG9iO1xuICAgICAgfVxuICAgICAgbmV3Um9vbS5jb25uZWN0KCk7XG4gICAgfVxuICAgIHJldHVybiBsZWFzZVJvb20obmV3Um9vbURldGFpbHMpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFJvb20ocm9vbUlkKSB7XG4gICAgY29uc3Qgcm9vbSA9IHJvb21zQnlJZC5nZXQocm9vbUlkKT8ucm9vbTtcbiAgICByZXR1cm4gcm9vbSA/IHJvb20gOiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGxvZ291dCgpIHtcbiAgICBhdXRoTWFuYWdlci5yZXNldCgpO1xuICAgIGN1cnJlbnRVc2VySWQuc2V0KCgpID0+IHZvaWQgMCk7XG4gICAgZm9yIChjb25zdCB7IHJvb20gfSBvZiByb29tc0J5SWQudmFsdWVzKCkpIHtcbiAgICAgIGlmICghaXNJZGxlKHJvb20uZ2V0U3RhdHVzKCkpKSB7XG4gICAgICAgIHJvb20ucmVjb25uZWN0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc29sdmVVc2VycyA9IGNsaWVudE9wdGlvbnMucmVzb2x2ZVVzZXJzO1xuICBjb25zdCB3YXJuSWZOb1Jlc29sdmVVc2VycyA9IGNyZWF0ZURldmVsb3BtZW50V2FybmluZyhcbiAgICAoKSA9PiAhcmVzb2x2ZVVzZXJzLFxuICAgIFwiU2V0IHRoZSByZXNvbHZlVXNlcnMgb3B0aW9uIGluIGNyZWF0ZUNsaWVudCB0byBzcGVjaWZ5IHVzZXIgaW5mby5cIlxuICApO1xuICBjb25zdCBiYXRjaGVkUmVzb2x2ZVVzZXJzID0gbmV3IEJhdGNoKFxuICAgIGFzeW5jIChiYXRjaGVkVXNlcklkcykgPT4ge1xuICAgICAgY29uc3QgdXNlcklkcyA9IGJhdGNoZWRVc2VySWRzLmZsYXQoKTtcbiAgICAgIGNvbnN0IHVzZXJzID0gYXdhaXQgcmVzb2x2ZVVzZXJzPy4oeyB1c2VySWRzIH0pO1xuICAgICAgd2FybklmTm9SZXNvbHZlVXNlcnMoKTtcbiAgICAgIHJldHVybiB1c2VycyA/PyB1c2VySWRzLm1hcCgoKSA9PiB2b2lkIDApO1xuICAgIH0sXG4gICAgeyBkZWxheTogUkVTT0xWRV9VU0VSU19CQVRDSF9ERUxBWSB9XG4gICk7XG4gIGNvbnN0IHVzZXJzU3RvcmUgPSBjcmVhdGVCYXRjaFN0b3JlKGJhdGNoZWRSZXNvbHZlVXNlcnMpO1xuICBmdW5jdGlvbiBpbnZhbGlkYXRlUmVzb2x2ZWRVc2Vycyh1c2VySWRzKSB7XG4gICAgdXNlcnNTdG9yZS5pbnZhbGlkYXRlKHVzZXJJZHMpO1xuICB9XG4gIGNvbnN0IHJlc29sdmVSb29tc0luZm8gPSBjbGllbnRPcHRpb25zLnJlc29sdmVSb29tc0luZm87XG4gIGNvbnN0IHdhcm5JZk5vUmVzb2x2ZVJvb21zSW5mbyA9IGNyZWF0ZURldmVsb3BtZW50V2FybmluZyhcbiAgICAoKSA9PiAhcmVzb2x2ZVJvb21zSW5mbyxcbiAgICBcIlNldCB0aGUgcmVzb2x2ZVJvb21zSW5mbyBvcHRpb24gaW4gY3JlYXRlQ2xpZW50IHRvIHNwZWNpZnkgcm9vbSBpbmZvLlwiXG4gICk7XG4gIGNvbnN0IGJhdGNoZWRSZXNvbHZlUm9vbXNJbmZvID0gbmV3IEJhdGNoKFxuICAgIGFzeW5jIChiYXRjaGVkUm9vbUlkcykgPT4ge1xuICAgICAgY29uc3Qgcm9vbUlkcyA9IGJhdGNoZWRSb29tSWRzLmZsYXQoKTtcbiAgICAgIGNvbnN0IHJvb21zSW5mbyA9IGF3YWl0IHJlc29sdmVSb29tc0luZm8/Lih7IHJvb21JZHMgfSk7XG4gICAgICB3YXJuSWZOb1Jlc29sdmVSb29tc0luZm8oKTtcbiAgICAgIHJldHVybiByb29tc0luZm8gPz8gcm9vbUlkcy5tYXAoKCkgPT4gdm9pZCAwKTtcbiAgICB9LFxuICAgIHsgZGVsYXk6IFJFU09MVkVfUk9PTVNfSU5GT19CQVRDSF9ERUxBWSB9XG4gICk7XG4gIGNvbnN0IHJvb21zSW5mb1N0b3JlID0gY3JlYXRlQmF0Y2hTdG9yZShiYXRjaGVkUmVzb2x2ZVJvb21zSW5mbyk7XG4gIGZ1bmN0aW9uIGludmFsaWRhdGVSZXNvbHZlZFJvb21zSW5mbyhyb29tSWRzKSB7XG4gICAgcm9vbXNJbmZvU3RvcmUuaW52YWxpZGF0ZShyb29tSWRzKTtcbiAgfVxuICBjb25zdCBtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIGludmFsaWRhdGVSZXNvbHZlZE1lbnRpb25TdWdnZXN0aW9ucygpIHtcbiAgICBtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZS5jbGVhcigpO1xuICB9XG4gIGNvbnN0IHN5bmNTdGF0dXNTb3VyY2VzID0gW107XG4gIGNvbnN0IHN5bmNTdGF0dXNTaWduYWwgPSBuZXcgU2lnbmFsKFwic3luY2hyb25pemVkXCIpO1xuICBjb25zdCBsaXZlYmxvY2tzRXJyb3JTb3VyY2UgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgZnVuY3Rpb24gZ2V0U3luY1N0YXR1cygpIHtcbiAgICBjb25zdCBzdGF0dXMgPSBzeW5jU3RhdHVzU2lnbmFsLmdldCgpO1xuICAgIHJldHVybiBzdGF0dXMgPT09IFwic3luY2hyb25pemluZ1wiID8gc3RhdHVzIDogXCJzeW5jaHJvbml6ZWRcIjtcbiAgfVxuICBmdW5jdGlvbiByZWNvbXB1dGUoKSB7XG4gICAgc3luY1N0YXR1c1NpZ25hbC5zZXQoXG4gICAgICBzeW5jU3RhdHVzU291cmNlcy5zb21lKChzcmMpID0+IHNyYy5nZXQoKSA9PT0gXCJzeW5jaHJvbml6aW5nXCIpID8gXCJzeW5jaHJvbml6aW5nXCIgOiBzeW5jU3RhdHVzU291cmNlcy5zb21lKChzcmMpID0+IHNyYy5nZXQoKSA9PT0gXCJoYXMtbG9jYWwtY2hhbmdlc1wiKSA/IFwiaGFzLWxvY2FsLWNoYW5nZXNcIiA6IFwic3luY2hyb25pemVkXCJcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVN5bmNTb3VyY2UoKSB7XG4gICAgY29uc3Qgc291cmNlID0gbmV3IFNpZ25hbChcInN5bmNocm9uaXplZFwiKTtcbiAgICBzeW5jU3RhdHVzU291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgY29uc3QgdW5zdWIgPSBzb3VyY2Uuc3Vic2NyaWJlKCgpID0+IHJlY29tcHV0ZSgpKTtcbiAgICBmdW5jdGlvbiBzZXRTeW5jU3RhdHVzKHN0YXR1cykge1xuICAgICAgc291cmNlLnNldChzdGF0dXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdW5zdWIoKTtcbiAgICAgIGNvbnN0IGluZGV4ID0gc3luY1N0YXR1c1NvdXJjZXMuZmluZEluZGV4KChpdGVtKSA9PiBpdGVtID09PSBzb3VyY2UpO1xuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgY29uc3QgW3JlZl0gPSBzeW5jU3RhdHVzU291cmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBjb25zdCB3YXNTdGlsbFBlbmRpbmcgPSByZWYuZ2V0KCkgIT09IFwic3luY2hyb25pemVkXCI7XG4gICAgICAgIGlmICh3YXNTdGlsbFBlbmRpbmcpIHtcbiAgICAgICAgICByZWNvbXB1dGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzZXRTeW5jU3RhdHVzLCBkZXN0cm95IH07XG4gIH1cbiAge1xuICAgIGNvbnN0IG1heWJlUHJldmVudENsb3NlID0gKGUpID0+IHtcbiAgICAgIGlmIChjbGllbnRPcHRpb25zLnByZXZlbnRVbnNhdmVkQ2hhbmdlcyAmJiBzeW5jU3RhdHVzU2lnbmFsLmdldCgpICE9PSBcInN5bmNocm9uaXplZFwiKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB2b2lkIDA7XG4gICAgd2luPy5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIG1heWJlUHJldmVudENsb3NlKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXROb3RpZmljYXRpb25TZXR0aW5ncyhvcHRpb25zMikge1xuICAgIGNvbnN0IHBsYWluU2V0dGluZ3MgPSBhd2FpdCBodHRwQ2xpZW50LmdldFVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyhvcHRpb25zMik7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBjcmVhdGVVc2VyTm90aWZpY2F0aW9uU2V0dGluZ3MocGxhaW5TZXR0aW5ncyk7XG4gICAgcmV0dXJuIHNldHRpbmdzO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgY29uc3QgcGxhaW5TZXR0aW5ncyA9IGF3YWl0IGh0dHBDbGllbnQudXBkYXRlVXNlck5vdGlmaWNhdGlvblNldHRpbmdzKHNldHRpbmdzKTtcbiAgICBjb25zdCBzZXR0aW5nc09iamVjdCA9IGNyZWF0ZVVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyhwbGFpblNldHRpbmdzKTtcbiAgICByZXR1cm4gc2V0dGluZ3NPYmplY3Q7XG4gIH1cbiAgY29uc3QgY2xpZW50ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIHtcbiAgICAgIGVudGVyUm9vbSxcbiAgICAgIGdldFJvb20sXG4gICAgICBsb2dvdXQsXG4gICAgICAvLyBQdWJsaWMgaW5ib3ggbm90aWZpY2F0aW9ucyBBUElcbiAgICAgIGdldEluYm94Tm90aWZpY2F0aW9uczogaHR0cENsaWVudC5nZXRJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICBnZXRJbmJveE5vdGlmaWNhdGlvbnNTaW5jZTogaHR0cENsaWVudC5nZXRJbmJveE5vdGlmaWNhdGlvbnNTaW5jZSxcbiAgICAgIGdldFVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50OiBodHRwQ2xpZW50LmdldFVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50LFxuICAgICAgbWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZDogaHR0cENsaWVudC5tYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLFxuICAgICAgbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkOiBodHRwQ2xpZW50Lm1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCxcbiAgICAgIGRlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9uczogaHR0cENsaWVudC5kZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICBkZWxldGVJbmJveE5vdGlmaWNhdGlvbjogaHR0cENsaWVudC5kZWxldGVJbmJveE5vdGlmaWNhdGlvbixcbiAgICAgIC8vIFB1YmxpYyB1c2VyIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBBUElcbiAgICAgIGdldE5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgICAgdXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgICAvLyBBZHZhbmNlZCByZXNvbHZlcnMgQVBJc1xuICAgICAgcmVzb2x2ZXJzOiB7XG4gICAgICAgIGludmFsaWRhdGVVc2VyczogaW52YWxpZGF0ZVJlc29sdmVkVXNlcnMsXG4gICAgICAgIGludmFsaWRhdGVSb29tc0luZm86IGludmFsaWRhdGVSZXNvbHZlZFJvb21zSW5mbyxcbiAgICAgICAgaW52YWxpZGF0ZU1lbnRpb25TdWdnZXN0aW9uczogaW52YWxpZGF0ZVJlc29sdmVkTWVudGlvblN1Z2dlc3Rpb25zXG4gICAgICB9LFxuICAgICAgZ2V0U3luY1N0YXR1cyxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICBlcnJvcjogbGl2ZWJsb2Nrc0Vycm9yU291cmNlLFxuICAgICAgICBzeW5jU3RhdHVzOiBzeW5jU3RhdHVzU2lnbmFsXG4gICAgICB9LFxuICAgICAgLy8gSW50ZXJuYWxcbiAgICAgIFtrSW50ZXJuYWxdOiB7XG4gICAgICAgIGN1cnJlbnRVc2VySWQsXG4gICAgICAgIG1lbnRpb25TdWdnZXN0aW9uc0NhY2hlLFxuICAgICAgICByZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zOiBjbGllbnRPcHRpb25zLnJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMsXG4gICAgICAgIHVzZXJzU3RvcmUsXG4gICAgICAgIHJvb21zSW5mb1N0b3JlLFxuICAgICAgICBnZXRSb29tSWRzKCkge1xuICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHJvb21zQnlJZC5rZXlzKCkpO1xuICAgICAgICB9LFxuICAgICAgICBodHRwQ2xpZW50LFxuICAgICAgICAvLyBUeXBlLWxldmVsIGhlbHBlciBvbmx5LCBpdCdzIGVmZmVjdGl2ZWx5IG9ubHkgYW4gaWRlbnRpdHktZnVuY3Rpb24gYXQgcnVudGltZVxuICAgICAgICBhczogKCkgPT4gY2xpZW50LFxuICAgICAgICBjcmVhdGVTeW5jU291cmNlLFxuICAgICAgICBlbWl0RXJyb3I6IChjb250ZXh0LCBjYXVzZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGVycm9yMyA9IExpdmVibG9ja3NFcnJvci5mcm9tKGNvbnRleHQsIGNhdXNlKTtcbiAgICAgICAgICBjb25zdCBkaWROb3RpZnkgPSBsaXZlYmxvY2tzRXJyb3JTb3VyY2Uubm90aWZ5KGVycm9yMyk7XG4gICAgICAgICAgaWYgKCFkaWROb3RpZnkpIHtcbiAgICAgICAgICAgIGVycm9yMihlcnJvcjMubWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBrSW50ZXJuYWwsXG4gICAge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9XG4gICk7XG4gIHJldHVybiBjbGllbnQ7XG59XG5mdW5jdGlvbiBjaGVja0JvdW5kcyhvcHRpb24sIHZhbHVlLCBtaW4sIG1heCwgcmVjb21tZW5kZWRNaW4pIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIiB8fCB2YWx1ZSA8IG1pbiB8fCBtYXggIT09IHZvaWQgMCAmJiB2YWx1ZSA+IG1heCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIG1heCAhPT0gdm9pZCAwID8gYCR7b3B0aW9ufSBzaG91bGQgYmUgYmV0d2VlbiAke3JlY29tbWVuZGVkTWluID8/IG1pbn0gYW5kICR7bWF4fS5gIDogYCR7b3B0aW9ufSBzaG91bGQgYmUgYXQgbGVhc3QgJHtyZWNvbW1lbmRlZE1pbiA/PyBtaW59LmBcbiAgICApO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4gY2hlY2tCb3VuZHMoXG4gICAgXCJiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dFwiLFxuICAgIHZhbHVlLFxuICAgIE1JTl9CQUNLR1JPVU5EX0tFRVBfQUxJVkVfVElNRU9VVFxuICApO1xufVxuZnVuY3Rpb24gZ2V0VGhyb3R0bGUodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm91bmRzKFwidGhyb3R0bGVcIiwgdmFsdWUsIE1JTl9USFJPVFRMRSwgTUFYX1RIUk9UVExFKTtcbn1cbmZ1bmN0aW9uIGdldExvc3RDb25uZWN0aW9uVGltZW91dCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3VuZHMoXG4gICAgXCJsb3N0Q29ubmVjdGlvblRpbWVvdXRcIixcbiAgICB2YWx1ZSxcbiAgICBNSU5fTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQsXG4gICAgTUFYX0xPU1RfQ09OTkVDVElPTl9USU1FT1VULFxuICAgIFJFQ09NTUVOREVEX01JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVFxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlRGV2ZWxvcG1lbnRXYXJuaW5nKGNvbmRpdGlvbiwgLi4uYXJncykge1xuICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKCFoYXNXYXJuZWQgJiYgKHR5cGVvZiBjb25kaXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IGNvbmRpdGlvbigpIDogY29uZGl0aW9uKSkge1xuICAgICAgICB3YXJuKC4uLmFyZ3MpO1xuICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9jb21tZW50cy9jb21tZW50LWJvZHkudHNcbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlQYXJhZ3JhcGgoZWxlbWVudCkge1xuICByZXR1cm4gXCJ0eXBlXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09IFwicGFyYWdyYXBoXCI7XG59XG5mdW5jdGlvbiBpc0NvbW1lbnRCb2R5VGV4dChlbGVtZW50KSB7XG4gIHJldHVybiAhKFwidHlwZVwiIGluIGVsZW1lbnQpICYmIFwidGV4dFwiIGluIGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQudGV4dCA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlNZW50aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwidHlwZVwiIGluIGVsZW1lbnQgJiYgZWxlbWVudC50eXBlID09PSBcIm1lbnRpb25cIjtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlMaW5rKGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwidHlwZVwiIGluIGVsZW1lbnQgJiYgZWxlbWVudC50eXBlID09PSBcImxpbmtcIjtcbn1cbnZhciBjb21tZW50Qm9keUVsZW1lbnRzR3VhcmRzID0ge1xuICBwYXJhZ3JhcGg6IGlzQ29tbWVudEJvZHlQYXJhZ3JhcGgsXG4gIHRleHQ6IGlzQ29tbWVudEJvZHlUZXh0LFxuICBsaW5rOiBpc0NvbW1lbnRCb2R5TGluayxcbiAgbWVudGlvbjogaXNDb21tZW50Qm9keU1lbnRpb25cbn07XG52YXIgY29tbWVudEJvZHlFbGVtZW50c1R5cGVzID0ge1xuICBwYXJhZ3JhcGg6IFwiYmxvY2tcIixcbiAgdGV4dDogXCJpbmxpbmVcIixcbiAgbGluazogXCJpbmxpbmVcIixcbiAgbWVudGlvbjogXCJpbmxpbmVcIlxufTtcbmZ1bmN0aW9uIHRyYXZlcnNlQ29tbWVudEJvZHkoYm9keSwgZWxlbWVudE9yVmlzaXRvciwgcG9zc2libHlWaXNpdG9yKSB7XG4gIGlmICghYm9keSB8fCAhYm9keT8uY29udGVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBlbGVtZW50ID0gdHlwZW9mIGVsZW1lbnRPclZpc2l0b3IgPT09IFwic3RyaW5nXCIgPyBlbGVtZW50T3JWaXNpdG9yIDogdm9pZCAwO1xuICBjb25zdCB0eXBlID0gZWxlbWVudCA/IGNvbW1lbnRCb2R5RWxlbWVudHNUeXBlc1tlbGVtZW50XSA6IFwiYWxsXCI7XG4gIGNvbnN0IGd1YXJkID0gZWxlbWVudCA/IGNvbW1lbnRCb2R5RWxlbWVudHNHdWFyZHNbZWxlbWVudF0gOiAoKSA9PiB0cnVlO1xuICBjb25zdCB2aXNpdG9yID0gdHlwZW9mIGVsZW1lbnRPclZpc2l0b3IgPT09IFwiZnVuY3Rpb25cIiA/IGVsZW1lbnRPclZpc2l0b3IgOiBwb3NzaWJseVZpc2l0b3I7XG4gIGZvciAoY29uc3QgYmxvY2sgb2YgYm9keS5jb250ZW50KSB7XG4gICAgaWYgKHR5cGUgPT09IFwiYWxsXCIgfHwgdHlwZSA9PT0gXCJibG9ja1wiKSB7XG4gICAgICBpZiAoZ3VhcmQoYmxvY2spKSB7XG4gICAgICAgIHZpc2l0b3I/LihibG9jayk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImFsbFwiIHx8IHR5cGUgPT09IFwiaW5saW5lXCIpIHtcbiAgICAgIGZvciAoY29uc3QgaW5saW5lIG9mIGJsb2NrLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChndWFyZChpbmxpbmUpKSB7XG4gICAgICAgICAgdmlzaXRvcj8uKGlubGluZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keShib2R5KSB7XG4gIGNvbnN0IG1lbnRpb25lZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHRyYXZlcnNlQ29tbWVudEJvZHkoXG4gICAgYm9keSxcbiAgICBcIm1lbnRpb25cIixcbiAgICAobWVudGlvbikgPT4gbWVudGlvbmVkSWRzLmFkZChtZW50aW9uLmlkKVxuICApO1xuICByZXR1cm4gQXJyYXkuZnJvbShtZW50aW9uZWRJZHMpO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVVzZXJzSW5Db21tZW50Qm9keShib2R5LCByZXNvbHZlVXNlcnMpIHtcbiAgY29uc3QgcmVzb2x2ZWRVc2VycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGlmICghcmVzb2x2ZVVzZXJzKSB7XG4gICAgcmV0dXJuIHJlc29sdmVkVXNlcnM7XG4gIH1cbiAgY29uc3QgdXNlcklkcyA9IGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keShib2R5KTtcbiAgY29uc3QgdXNlcnMgPSBhd2FpdCByZXNvbHZlVXNlcnMoe1xuICAgIHVzZXJJZHNcbiAgfSk7XG4gIGZvciAoY29uc3QgW2luZGV4LCB1c2VySWRdIG9mIHVzZXJJZHMuZW50cmllcygpKSB7XG4gICAgY29uc3QgdXNlciA9IHVzZXJzPy5baW5kZXhdO1xuICAgIGlmICh1c2VyKSB7XG4gICAgICByZXNvbHZlZFVzZXJzLnNldCh1c2VySWQsIHVzZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzb2x2ZWRVc2Vycztcbn1cbnZhciBodG1sRXNjYXBhYmxlcyA9IHtcbiAgXCImXCI6IFwiJmFtcDtcIixcbiAgXCI8XCI6IFwiJmx0O1wiLFxuICBcIj5cIjogXCImZ3Q7XCIsXG4gICdcIic6IFwiJnF1b3Q7XCIsXG4gIFwiJ1wiOiBcIiYjMzk7XCJcbn07XG52YXIgaHRtbEVzY2FwYWJsZXNSZWdleCA9IG5ldyBSZWdFeHAoXG4gIE9iamVjdC5rZXlzKGh0bWxFc2NhcGFibGVzKS5tYXAoKGVudGl0eSkgPT4gYFxcXFwke2VudGl0eX1gKS5qb2luKFwifFwiKSxcbiAgXCJnXCJcbik7XG5mdW5jdGlvbiBodG1sU2FmZSh2YWx1ZSkge1xuICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKFtTdHJpbmcodmFsdWUpXSwgW10pO1xufVxuZnVuY3Rpb24gam9pbkh0bWwoc3RyaW5ncykge1xuICBpZiAoc3RyaW5ncy5sZW5ndGggPD0gMCkge1xuICAgIHJldHVybiBuZXcgSHRtbFNhZmVTdHJpbmcoW1wiXCJdLCBbXSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBIdG1sU2FmZVN0cmluZyhcbiAgICBbXCJcIiwgLi4uQXJyYXkoc3RyaW5ncy5sZW5ndGggLSAxKS5maWxsKFwiXCIpLCBcIlwiXSxcbiAgICBzdHJpbmdzXG4gICk7XG59XG5mdW5jdGlvbiBlc2NhcGVIdG1sKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEh0bWxTYWZlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGpvaW5IdG1sKHZhbHVlKS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiBTdHJpbmcodmFsdWUpLnJlcGxhY2UoXG4gICAgaHRtbEVzY2FwYWJsZXNSZWdleCxcbiAgICAoY2hhcmFjdGVyKSA9PiBodG1sRXNjYXBhYmxlc1tjaGFyYWN0ZXJdXG4gICk7XG59XG52YXIgSHRtbFNhZmVTdHJpbmcgPSBjbGFzcyB7XG4gICNzdHJpbmdzO1xuICAjdmFsdWVzO1xuICBjb25zdHJ1Y3RvcihzdHJpbmdzLCB2YWx1ZXMyKSB7XG4gICAgdGhpcy4jc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgdGhpcy4jdmFsdWVzID0gdmFsdWVzMjtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RyaW5ncy5yZWR1Y2UoKHJlc3VsdCwgc3RyLCBpKSA9PiB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgZXNjYXBlSHRtbChubih0aGlzLiN2YWx1ZXNbaSAtIDFdKSkgKyBzdHI7XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBodG1sKHN0cmluZ3MsIC4uLnZhbHVlczIpIHtcbiAgcmV0dXJuIG5ldyBIdG1sU2FmZVN0cmluZyhzdHJpbmdzLCB2YWx1ZXMyKTtcbn1cbnZhciBtYXJrZG93bkVzY2FwYWJsZXMgPSB7XG4gIF86IFwiXFxcXF9cIixcbiAgXCIqXCI6IFwiXFxcXCpcIixcbiAgXCIjXCI6IFwiXFxcXCNcIixcbiAgXCJgXCI6IFwiXFxcXGBcIixcbiAgXCJ+XCI6IFwiXFxcXH5cIixcbiAgXCIhXCI6IFwiXFxcXCFcIixcbiAgXCJ8XCI6IFwiXFxcXHxcIixcbiAgXCIoXCI6IFwiXFxcXChcIixcbiAgXCIpXCI6IFwiXFxcXClcIixcbiAgXCJ7XCI6IFwiXFxcXHtcIixcbiAgXCJ9XCI6IFwiXFxcXH1cIixcbiAgXCJbXCI6IFwiXFxcXFtcIixcbiAgXCJdXCI6IFwiXFxcXF1cIlxufTtcbnZhciBtYXJrZG93bkVzY2FwYWJsZXNSZWdleCA9IG5ldyBSZWdFeHAoXG4gIE9iamVjdC5rZXlzKG1hcmtkb3duRXNjYXBhYmxlcykubWFwKChlbnRpdHkpID0+IGBcXFxcJHtlbnRpdHl9YCkuam9pbihcInxcIiksXG4gIFwiZ1wiXG4pO1xuZnVuY3Rpb24gam9pbk1hcmtkb3duKHN0cmluZ3MpIHtcbiAgaWYgKHN0cmluZ3MubGVuZ3RoIDw9IDApIHtcbiAgICByZXR1cm4gbmV3IE1hcmtkb3duU2FmZVN0cmluZyhbXCJcIl0sIFtdKTtcbiAgfVxuICByZXR1cm4gbmV3IE1hcmtkb3duU2FmZVN0cmluZyhcbiAgICBbXCJcIiwgLi4uQXJyYXkoc3RyaW5ncy5sZW5ndGggLSAxKS5maWxsKFwiXCIpLCBcIlwiXSxcbiAgICBzdHJpbmdzXG4gICk7XG59XG5mdW5jdGlvbiBlc2NhcGVNYXJrZG93bih2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXJrZG93blNhZmVTdHJpbmcpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gam9pbk1hcmtkb3duKHZhbHVlKS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiBTdHJpbmcodmFsdWUpLnJlcGxhY2UoXG4gICAgbWFya2Rvd25Fc2NhcGFibGVzUmVnZXgsXG4gICAgKGNoYXJhY3RlcikgPT4gbWFya2Rvd25Fc2NhcGFibGVzW2NoYXJhY3Rlcl1cbiAgKTtcbn1cbnZhciBNYXJrZG93blNhZmVTdHJpbmcgPSBjbGFzcyB7XG4gICNzdHJpbmdzO1xuICAjdmFsdWVzO1xuICBjb25zdHJ1Y3RvcihzdHJpbmdzLCB2YWx1ZXMyKSB7XG4gICAgdGhpcy4jc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgdGhpcy4jdmFsdWVzID0gdmFsdWVzMjtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RyaW5ncy5yZWR1Y2UoKHJlc3VsdCwgc3RyLCBpKSA9PiB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgZXNjYXBlTWFya2Rvd24obm4odGhpcy4jdmFsdWVzW2kgLSAxXSkpICsgc3RyO1xuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gbWFya2Rvd24oc3RyaW5ncywgLi4udmFsdWVzMikge1xuICByZXR1cm4gbmV3IE1hcmtkb3duU2FmZVN0cmluZyhzdHJpbmdzLCB2YWx1ZXMyKTtcbn1cbmZ1bmN0aW9uIHRvQWJzb2x1dGVVcmwodXJsMikge1xuICBpZiAodXJsMi5zdGFydHNXaXRoKFwiaHR0cDovL1wiKSB8fCB1cmwyLnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKSkge1xuICAgIHJldHVybiB1cmwyO1xuICB9IGVsc2UgaWYgKHVybDIuc3RhcnRzV2l0aChcInd3dy5cIikpIHtcbiAgICByZXR1cm4gXCJodHRwczovL1wiICsgdXJsMjtcbiAgfVxuICByZXR1cm47XG59XG52YXIgc3RyaW5naWZ5Q29tbWVudEJvZHlQbGFpbkVsZW1lbnRzID0ge1xuICBwYXJhZ3JhcGg6ICh7IGNoaWxkcmVuIH0pID0+IGNoaWxkcmVuLFxuICB0ZXh0OiAoeyBlbGVtZW50IH0pID0+IGVsZW1lbnQudGV4dCxcbiAgbGluazogKHsgZWxlbWVudCB9KSA9PiBlbGVtZW50LnRleHQgPz8gZWxlbWVudC51cmwsXG4gIG1lbnRpb246ICh7IGVsZW1lbnQsIHVzZXIgfSkgPT4ge1xuICAgIHJldHVybiBgQCR7dXNlcj8ubmFtZSA/PyBlbGVtZW50LmlkfWA7XG4gIH1cbn07XG52YXIgc3RyaW5naWZ5Q29tbWVudEJvZHlIdG1sRWxlbWVudHMgPSB7XG4gIHBhcmFncmFwaDogKHsgY2hpbGRyZW4gfSkgPT4ge1xuICAgIHJldHVybiBjaGlsZHJlbiA/IGh0bWxgPHA+JHtodG1sU2FmZShjaGlsZHJlbil9PC9wPmAgOiBjaGlsZHJlbjtcbiAgfSxcbiAgdGV4dDogKHsgZWxlbWVudCB9KSA9PiB7XG4gICAgbGV0IGNoaWxkcmVuID0gZWxlbWVudC50ZXh0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBodG1sYCR7Y2hpbGRyZW59YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuYm9sZCkge1xuICAgICAgY2hpbGRyZW4gPSBodG1sYDxzdHJvbmc+JHtjaGlsZHJlbn08L3N0cm9uZz5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5pdGFsaWMpIHtcbiAgICAgIGNoaWxkcmVuID0gaHRtbGA8ZW0+JHtjaGlsZHJlbn08L2VtPmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnN0cmlrZXRocm91Z2gpIHtcbiAgICAgIGNoaWxkcmVuID0gaHRtbGA8cz4ke2NoaWxkcmVufTwvcz5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5jb2RlKSB7XG4gICAgICBjaGlsZHJlbiA9IGh0bWxgPGNvZGU+JHtjaGlsZHJlbn08L2NvZGU+YDtcbiAgICB9XG4gICAgcmV0dXJuIGh0bWxgJHtjaGlsZHJlbn1gO1xuICB9LFxuICBsaW5rOiAoeyBlbGVtZW50LCBocmVmIH0pID0+IHtcbiAgICByZXR1cm4gaHRtbGA8YSBocmVmPVwiJHtocmVmfVwiIHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIj4ke2VsZW1lbnQudGV4dCA/IGh0bWxgJHtlbGVtZW50LnRleHR9YCA6IGVsZW1lbnQudXJsfTwvYT5gO1xuICB9LFxuICBtZW50aW9uOiAoeyBlbGVtZW50LCB1c2VyIH0pID0+IHtcbiAgICByZXR1cm4gaHRtbGA8c3BhbiBkYXRhLW1lbnRpb24+QCR7dXNlcj8ubmFtZSA/IGh0bWxgJHt1c2VyPy5uYW1lfWAgOiBlbGVtZW50LmlkfTwvc3Bhbj5gO1xuICB9XG59O1xudmFyIHN0cmluZ2lmeUNvbW1lbnRCb2R5TWFya2Rvd25FbGVtZW50cyA9IHtcbiAgcGFyYWdyYXBoOiAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9LFxuICB0ZXh0OiAoeyBlbGVtZW50IH0pID0+IHtcbiAgICBsZXQgY2hpbGRyZW4gPSBlbGVtZW50LnRleHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5ib2xkKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYCoqJHtjaGlsZHJlbn0qKmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50Lml0YWxpYykge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmBfJHtjaGlsZHJlbn1fYDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuc3RyaWtldGhyb3VnaCkge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmB+fiR7Y2hpbGRyZW59fn5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5jb2RlKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYFxcYCR7Y2hpbGRyZW59XFxgYDtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9LFxuICBsaW5rOiAoeyBlbGVtZW50LCBocmVmIH0pID0+IHtcbiAgICByZXR1cm4gbWFya2Rvd25gWyR7ZWxlbWVudC50ZXh0ID8/IGVsZW1lbnQudXJsfV0oJHtocmVmfSlgO1xuICB9LFxuICBtZW50aW9uOiAoeyBlbGVtZW50LCB1c2VyIH0pID0+IHtcbiAgICByZXR1cm4gbWFya2Rvd25gQCR7dXNlcj8ubmFtZSA/PyBlbGVtZW50LmlkfWA7XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiBzdHJpbmdpZnlDb21tZW50Qm9keShib2R5LCBvcHRpb25zKSB7XG4gIGNvbnN0IGZvcm1hdCA9IG9wdGlvbnM/LmZvcm1hdCA/PyBcInBsYWluXCI7XG4gIGNvbnN0IHNlcGFyYXRvciA9IG9wdGlvbnM/LnNlcGFyYXRvciA/PyAoZm9ybWF0ID09PSBcIm1hcmtkb3duXCIgPyBcIlxcblxcblwiIDogXCJcXG5cIik7XG4gIGNvbnN0IGVsZW1lbnRzID0ge1xuICAgIC4uLmZvcm1hdCA9PT0gXCJodG1sXCIgPyBzdHJpbmdpZnlDb21tZW50Qm9keUh0bWxFbGVtZW50cyA6IGZvcm1hdCA9PT0gXCJtYXJrZG93blwiID8gc3RyaW5naWZ5Q29tbWVudEJvZHlNYXJrZG93bkVsZW1lbnRzIDogc3RyaW5naWZ5Q29tbWVudEJvZHlQbGFpbkVsZW1lbnRzLFxuICAgIC4uLm9wdGlvbnM/LmVsZW1lbnRzXG4gIH07XG4gIGNvbnN0IHJlc29sdmVkVXNlcnMgPSBhd2FpdCByZXNvbHZlVXNlcnNJbkNvbW1lbnRCb2R5KFxuICAgIGJvZHksXG4gICAgb3B0aW9ucz8ucmVzb2x2ZVVzZXJzXG4gICk7XG4gIGNvbnN0IGJsb2NrcyA9IGJvZHkuY29udGVudC5mbGF0TWFwKChibG9jaywgYmxvY2tJbmRleCkgPT4ge1xuICAgIHN3aXRjaCAoYmxvY2sudHlwZSkge1xuICAgICAgY2FzZSBcInBhcmFncmFwaFwiOiB7XG4gICAgICAgIGNvbnN0IGlubGluZXMgPSBibG9jay5jaGlsZHJlbi5mbGF0TWFwKChpbmxpbmUsIGlubGluZUluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKGlzQ29tbWVudEJvZHlNZW50aW9uKGlubGluZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmxpbmUuaWQgPyBbXG4gICAgICAgICAgICAgIGVsZW1lbnRzLm1lbnRpb24oXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudDogaW5saW5lLFxuICAgICAgICAgICAgICAgICAgdXNlcjogcmVzb2x2ZWRVc2Vycy5nZXQoaW5saW5lLmlkKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5saW5lSW5kZXhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXSA6IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNDb21tZW50Qm9keUxpbmsoaW5saW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgZWxlbWVudHMubGluayhcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50OiBpbmxpbmUsXG4gICAgICAgICAgICAgICAgICBocmVmOiB0b0Fic29sdXRlVXJsKGlubGluZS51cmwpID8/IGlubGluZS51cmxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlubGluZUluZGV4XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0NvbW1lbnRCb2R5VGV4dChpbmxpbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW2VsZW1lbnRzLnRleHQoeyBlbGVtZW50OiBpbmxpbmUgfSwgaW5saW5lSW5kZXgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBlbGVtZW50cy5wYXJhZ3JhcGgoXG4gICAgICAgICAgICB7IGVsZW1lbnQ6IGJsb2NrLCBjaGlsZHJlbjogaW5saW5lcy5qb2luKFwiXCIpIH0sXG4gICAgICAgICAgICBibG9ja0luZGV4XG4gICAgICAgICAgKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBibG9ja3Muam9pbihzZXBhcmF0b3IpO1xufVxuXG4vLyBzcmMvY29tbWVudHMvY29tbWVudC11cmwudHNcbnZhciBQTEFDRUhPTERFUl9CQVNFX1VSTCA9IFwiaHR0cHM6Ly9sb2NhbGhvc3Q6OTk5OVwiO1xudmFyIEFCU09MVVRFX1VSTF9SRUdFWCA9IC9eW2EtekEtWl1bYS16QS1aXFxkK1xcLS5dKj86LztcbmZ1bmN0aW9uIGdlbmVyYXRlQ29tbWVudFVybCh7XG4gIHJvb21VcmwsXG4gIGNvbW1lbnRJZFxufSkge1xuICBjb25zdCBpc0Fic29sdXRlID0gQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3Qocm9vbVVybCk7XG4gIGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwoXG4gICAgcm9vbVVybCxcbiAgICBpc0Fic29sdXRlID8gdm9pZCAwIDogUExBQ0VIT0xERVJfQkFTRV9VUkxcbiAgKTtcbiAgdXJsT2JqZWN0Lmhhc2ggPSBgIyR7Y29tbWVudElkfWA7XG4gIHJldHVybiBpc0Fic29sdXRlID8gdXJsT2JqZWN0LmhyZWYgOiB1cmxPYmplY3QuaHJlZi5yZXBsYWNlKFBMQUNFSE9MREVSX0JBU0VfVVJMLCBcIlwiKTtcbn1cblxuLy8gc3JjL2NyZHRzL3V0aWxzLnRzXG5mdW5jdGlvbiB0b1BsYWluTHNvbihsc29uKSB7XG4gIGlmIChsc29uIGluc3RhbmNlb2YgTGl2ZU9iamVjdCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXZlYmxvY2tzVHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICBkYXRhOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGxzb24udG9PYmplY3QoKSkuZmxhdE1hcChcbiAgICAgICAgICAoW2tleSwgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gdm9pZCAwID8gW1trZXksIHRvUGxhaW5Mc29uKHZhbHVlKV1dIDogW11cbiAgICAgICAgKVxuICAgICAgKVxuICAgIH07XG4gIH0gZWxzZSBpZiAobHNvbiBpbnN0YW5jZW9mIExpdmVNYXApIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl2ZWJsb2Nrc1R5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgZGF0YTogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBbLi4ubHNvbl0ubWFwKChba2V5LCB2YWx1ZV0pID0+IFtrZXksIHRvUGxhaW5Mc29uKHZhbHVlKV0pXG4gICAgICApXG4gICAgfTtcbiAgfSBlbHNlIGlmIChsc29uIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl2ZWJsb2Nrc1R5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICAgIGRhdGE6IFsuLi5sc29uXS5tYXAoKGl0ZW0pID0+IHRvUGxhaW5Mc29uKGl0ZW0pKVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxzb247XG4gIH1cbn1cblxuLy8gc3JjL2ltbXV0YWJsZS50c1xuZnVuY3Rpb24gbHNvbk9iamVjdFRvSnNvbihvYmopIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGNvbnN0IHZhbCA9IG9ialtrZXldO1xuICAgIGlmICh2YWwgIT09IHZvaWQgMCkge1xuICAgICAgcmVzdWx0W2tleV0gPSBsc29uVG9Kc29uKHZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBsaXZlT2JqZWN0VG9Kc29uKGxpdmVPYmplY3QpIHtcbiAgcmV0dXJuIGxzb25PYmplY3RUb0pzb24obGl2ZU9iamVjdC50b09iamVjdCgpKTtcbn1cbmZ1bmN0aW9uIGxpdmVNYXBUb0pzb24obWFwKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXAuZW50cmllcygpKSB7XG4gICAgcmVzdWx0W2tleV0gPSBsc29uVG9Kc29uKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbHNvbkxpc3RUb0pzb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLm1hcChsc29uVG9Kc29uKTtcbn1cbmZ1bmN0aW9uIGxpdmVMaXN0VG9Kc29uKHZhbHVlKSB7XG4gIHJldHVybiBsc29uTGlzdFRvSnNvbih2YWx1ZS50b0FycmF5KCkpO1xufVxuZnVuY3Rpb24gbHNvblRvSnNvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlT2JqZWN0KSB7XG4gICAgcmV0dXJuIGxpdmVPYmplY3RUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4gbGl2ZUxpc3RUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZU1hcCkge1xuICAgIHJldHVybiBsaXZlTWFwVG9Kc29uKHZhbHVlKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVSZWdpc3Rlcikge1xuICAgIHJldHVybiB2YWx1ZS5kYXRhO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBsc29uTGlzdFRvSnNvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbHNvbk9iamVjdFRvSnNvbih2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZGVlcExpdmVpZnkodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlTGlzdCh2YWx1ZS5tYXAoZGVlcExpdmVpZnkpKTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIGNvbnN0IGluaXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgY29uc3QgdmFsID0gdmFsdWVba2V5XTtcbiAgICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGluaXRba2V5XSA9IGRlZXBMaXZlaWZ5KHZhbCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGl2ZU9iamVjdChpbml0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTGl2ZUxpc3QobGl2ZUxpc3QsIHByZXYsIG5leHQpIHtcbiAgbGV0IGkgPSAwO1xuICBsZXQgcHJldkVuZCA9IHByZXYubGVuZ3RoIC0gMTtcbiAgbGV0IG5leHRFbmQgPSBuZXh0Lmxlbmd0aCAtIDE7XG4gIGxldCBwcmV2Tm9kZSA9IHByZXZbMF07XG4gIGxldCBuZXh0Tm9kZSA9IG5leHRbMF07XG4gIG91dGVyOiB7XG4gICAgd2hpbGUgKHByZXZOb2RlID09PSBuZXh0Tm9kZSkge1xuICAgICAgKytpO1xuICAgICAgaWYgKGkgPiBwcmV2RW5kIHx8IGkgPiBuZXh0RW5kKSB7XG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfVxuICAgICAgcHJldk5vZGUgPSBwcmV2W2ldO1xuICAgICAgbmV4dE5vZGUgPSBuZXh0W2ldO1xuICAgIH1cbiAgICBwcmV2Tm9kZSA9IHByZXZbcHJldkVuZF07XG4gICAgbmV4dE5vZGUgPSBuZXh0W25leHRFbmRdO1xuICAgIHdoaWxlIChwcmV2Tm9kZSA9PT0gbmV4dE5vZGUpIHtcbiAgICAgIHByZXZFbmQtLTtcbiAgICAgIG5leHRFbmQtLTtcbiAgICAgIGlmIChpID4gcHJldkVuZCB8fCBpID4gbmV4dEVuZCkge1xuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cbiAgICAgIHByZXZOb2RlID0gcHJldltwcmV2RW5kXTtcbiAgICAgIG5leHROb2RlID0gbmV4dFtuZXh0RW5kXTtcbiAgICB9XG4gIH1cbiAgaWYgKGkgPiBwcmV2RW5kKSB7XG4gICAgaWYgKGkgPD0gbmV4dEVuZCkge1xuICAgICAgd2hpbGUgKGkgPD0gbmV4dEVuZCkge1xuICAgICAgICBsaXZlTGlzdC5pbnNlcnQoZGVlcExpdmVpZnkobmV4dFtpXSksIGkpO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGkgPiBuZXh0RW5kKSB7XG4gICAgbGV0IGxvY2FsSSA9IGk7XG4gICAgd2hpbGUgKGxvY2FsSSA8PSBwcmV2RW5kKSB7XG4gICAgICBsaXZlTGlzdC5kZWxldGUoaSk7XG4gICAgICBsb2NhbEkrKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGkgPD0gcHJldkVuZCAmJiBpIDw9IG5leHRFbmQpIHtcbiAgICAgIHByZXZOb2RlID0gcHJldltpXTtcbiAgICAgIG5leHROb2RlID0gbmV4dFtpXTtcbiAgICAgIGNvbnN0IGxpdmVMaXN0Tm9kZSA9IGxpdmVMaXN0LmdldChpKTtcbiAgICAgIGlmIChpc0xpdmVPYmplY3QobGl2ZUxpc3ROb2RlKSAmJiBpc1BsYWluT2JqZWN0KHByZXZOb2RlKSAmJiBpc1BsYWluT2JqZWN0KG5leHROb2RlKSkge1xuICAgICAgICBwYXRjaExpdmVPYmplY3QobGl2ZUxpc3ROb2RlLCBwcmV2Tm9kZSwgbmV4dE5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGl2ZUxpc3Quc2V0KGksIGRlZXBMaXZlaWZ5KG5leHROb2RlKSk7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHdoaWxlIChpIDw9IG5leHRFbmQpIHtcbiAgICAgIGxpdmVMaXN0Lmluc2VydChkZWVwTGl2ZWlmeShuZXh0W2ldKSwgaSk7XG4gICAgICBpKys7XG4gICAgfVxuICAgIGxldCBsb2NhbEkgPSBpO1xuICAgIHdoaWxlIChsb2NhbEkgPD0gcHJldkVuZCkge1xuICAgICAgbGl2ZUxpc3QuZGVsZXRlKGkpO1xuICAgICAgbG9jYWxJKys7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwYXRjaExpdmVPYmplY3RLZXkobGl2ZU9iamVjdCwga2V5LCBwcmV2LCBuZXh0KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zdCBub25TZXJpYWxpemFibGVWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShuZXh0KTtcbiAgICBpZiAobm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcbiAgICAgIGVycm9yMihcbiAgICAgICAgYE5ldyBzdGF0ZSBwYXRoOiAnJHtub25TZXJpYWxpemFibGVWYWx1ZS5wYXRofScgdmFsdWU6ICcke1N0cmluZyhcbiAgICAgICAgICBub25TZXJpYWxpemFibGVWYWx1ZS52YWx1ZVxuICAgICAgICApfScgaXMgbm90IHNlcmlhbGl6YWJsZS5cbk9ubHkgc2VyaWFsaXphYmxlIHZhbHVlIGNhbiBiZSBzeW5jZWQgd2l0aCBMaXZlYmxvY2tzLmBcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGNvbnN0IHZhbHVlID0gbGl2ZU9iamVjdC5nZXQoa2V5KTtcbiAgaWYgKG5leHQgPT09IHZvaWQgMCkge1xuICAgIGxpdmVPYmplY3QuZGVsZXRlKGtleSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgIGxpdmVPYmplY3Quc2V0KGtleSwgZGVlcExpdmVpZnkobmV4dCkpO1xuICB9IGVsc2UgaWYgKHByZXYgPT09IG5leHQpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoaXNMaXZlTGlzdCh2YWx1ZSkgJiYgQXJyYXkuaXNBcnJheShwcmV2KSAmJiBBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgcGF0Y2hMaXZlTGlzdCh2YWx1ZSwgcHJldiwgbmV4dCk7XG4gIH0gZWxzZSBpZiAoaXNMaXZlT2JqZWN0KHZhbHVlKSAmJiBpc1BsYWluT2JqZWN0KHByZXYpICYmIGlzUGxhaW5PYmplY3QobmV4dCkpIHtcbiAgICBwYXRjaExpdmVPYmplY3QodmFsdWUsIHByZXYsIG5leHQpO1xuICB9IGVsc2Uge1xuICAgIGxpdmVPYmplY3Quc2V0KGtleSwgZGVlcExpdmVpZnkobmV4dCkpO1xuICB9XG59XG5mdW5jdGlvbiBwYXRjaExpdmVPYmplY3Qocm9vdCwgcHJldiwgbmV4dCkge1xuICBjb25zdCB1cGRhdGVzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcbiAgICBwYXRjaExpdmVPYmplY3RLZXkocm9vdCwga2V5LCBwcmV2W2tleV0sIG5leHRba2V5XSk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gcHJldikge1xuICAgIGlmIChuZXh0W2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgcm9vdC5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH1cbiAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICByb290LnVwZGF0ZSh1cGRhdGVzKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UGFyZW50c1BhdGgobm9kZSkge1xuICBjb25zdCBwYXRoID0gW107XG4gIHdoaWxlIChub2RlLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgaWYgKGlzTGl2ZUxpc3Qobm9kZS5wYXJlbnQubm9kZSkpIHtcbiAgICAgIHBhdGgucHVzaChub2RlLnBhcmVudC5ub2RlLl9pbmRleE9mUG9zaXRpb24obm9kZS5wYXJlbnQua2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGgucHVzaChub2RlLnBhcmVudC5rZXkpO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnQubm9kZTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbmZ1bmN0aW9uIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU9iamVjdChzdGF0ZSwgdXBkYXRlcykge1xuICByZXR1cm4gdXBkYXRlcy5yZWR1Y2UoXG4gICAgKHN0YXRlMiwgdXBkYXRlKSA9PiBsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3RXaXRoVXBkYXRlKHN0YXRlMiwgdXBkYXRlKSxcbiAgICBzdGF0ZVxuICApO1xufVxuZnVuY3Rpb24gbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0V2l0aFVwZGF0ZShzdGF0ZSwgdXBkYXRlKSB7XG4gIGNvbnN0IHBhdGggPSBnZXRQYXJlbnRzUGF0aCh1cGRhdGUubm9kZSk7XG4gIHJldHVybiBsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlKHN0YXRlLCBwYXRoLCB1cGRhdGUpO1xufVxuZnVuY3Rpb24gbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShzdGF0ZSwgcGF0aCwgdXBkYXRlKSB7XG4gIGNvbnN0IHBhdGhJdGVtID0gcGF0aC5wb3AoKTtcbiAgaWYgKHBhdGhJdGVtID09PSB2b2lkIDApIHtcbiAgICBzd2l0Y2ggKHVwZGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIFwiTGl2ZU9iamVjdFwiOiB7XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KHN0YXRlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiSW50ZXJuYWw6IHJlY2VpdmVkIHVwZGF0ZSBvbiBMaXZlT2JqZWN0IGJ1dCBzdGF0ZSB3YXMgbm90IGFuIG9iamVjdFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdXBkYXRlLnVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAodXBkYXRlLnVwZGF0ZXNba2V5XT8udHlwZSA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gdXBkYXRlLm5vZGUuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGVba2V5XSA9IGxzb25Ub0pzb24odmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdTdGF0ZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgICBjYXNlIFwiTGl2ZUxpc3RcIjoge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3RhdGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJJbnRlcm5hbDogcmVjZWl2ZWQgdXBkYXRlIG9uIExpdmVMaXN0IGJ1dCBzdGF0ZSB3YXMgbm90IGFuIGFycmF5XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdTdGF0ZSA9IHN0YXRlLm1hcCgoeCkgPT4geCk7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdFVwZGF0ZSBvZiB1cGRhdGUudXBkYXRlcykge1xuICAgICAgICAgIGlmIChsaXN0VXBkYXRlLnR5cGUgPT09IFwic2V0XCIpIHtcbiAgICAgICAgICAgIG5ld1N0YXRlID0gbmV3U3RhdGUubWFwKFxuICAgICAgICAgICAgICAoaXRlbSwgaW5kZXgpID0+IGluZGV4ID09PSBsaXN0VXBkYXRlLmluZGV4ID8gbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pIDogaXRlbVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJpbnNlcnRcIikge1xuICAgICAgICAgICAgaWYgKGxpc3RVcGRhdGUuaW5kZXggPT09IG5ld1N0YXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZS5wdXNoKGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdTdGF0ZSA9IFtcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZSgwLCBsaXN0VXBkYXRlLmluZGV4KSxcbiAgICAgICAgICAgICAgICBsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5pbmRleClcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgbmV3U3RhdGUuc3BsaWNlKGxpc3RVcGRhdGUuaW5kZXgsIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGlzdFVwZGF0ZS50eXBlID09PSBcIm1vdmVcIikge1xuICAgICAgICAgICAgaWYgKGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCA+IGxpc3RVcGRhdGUuaW5kZXgpIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGUgPSBbXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoMCwgbGlzdFVwZGF0ZS5pbmRleCksXG4gICAgICAgICAgICAgICAgbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKGxpc3RVcGRhdGUuaW5kZXgsIGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4ICsgMSlcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gW1xuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKDAsIGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoXG4gICAgICAgICAgICAgICAgICBsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXggKyAxLFxuICAgICAgICAgICAgICAgICAgbGlzdFVwZGF0ZS5pbmRleCArIDFcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShsaXN0VXBkYXRlLmluZGV4ICsgMSlcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfVxuICAgICAgY2FzZSBcIkxpdmVNYXBcIjoge1xuICAgICAgICBpZiAoIWlzSnNvbk9iamVjdChzdGF0ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkludGVybmFsOiByZWNlaXZlZCB1cGRhdGUgb24gTGl2ZU1hcCBidXQgc3RhdGUgd2FzIG5vdCBhbiBvYmplY3RcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHVwZGF0ZS51cGRhdGVzKSB7XG4gICAgICAgICAgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwidXBkYXRlXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdXBkYXRlLm5vZGUuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gbHNvblRvSnNvbih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh1cGRhdGUudXBkYXRlc1trZXldPy50eXBlID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICAgICAgICBkZWxldGUgbmV3U3RhdGVba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICBjb25zdCBuZXdBcnJheSA9IFsuLi5zdGF0ZV07XG4gICAgbmV3QXJyYXlbcGF0aEl0ZW1dID0gbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShcbiAgICAgIHN0YXRlW3BhdGhJdGVtXSxcbiAgICAgIHBhdGgsXG4gICAgICB1cGRhdGVcbiAgICApO1xuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfSBlbHNlIGlmIChpc0pzb25PYmplY3Qoc3RhdGUpKSB7XG4gICAgY29uc3Qgbm9kZSA9IHN0YXRlW3BhdGhJdGVtXTtcbiAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0YXRlQXNPYmogPSBzdGF0ZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlQXNPYmosXG4gICAgICAgIFtwYXRoSXRlbV06IGxlZ2FjeV9wYXRjaEltbXV0YWJsZU5vZGUobm9kZSwgcGF0aCwgdXBkYXRlKVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbi8vIHNyYy9saWIvYWJvcnRDb250cm9sbGVyLnRzXG5mdW5jdGlvbiBtYWtlQWJvcnRDb250cm9sbGVyKGV4dGVybmFsU2lnbmFsKSB7XG4gIGNvbnN0IGN0bCA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgcmV0dXJuIHtcbiAgICBzaWduYWw6IGV4dGVybmFsU2lnbmFsID8gQWJvcnRTaWduYWwuYW55KFtjdGwuc2lnbmFsLCBleHRlcm5hbFNpZ25hbF0pIDogY3RsLnNpZ25hbCxcbiAgICBhYm9ydDogY3RsLmFib3J0LmJpbmQoY3RsKVxuICB9O1xufVxuXG4vLyBzcmMvbGliL2RlcHJlY2F0aW9uLnRzXG52YXIgX2VtaXR0ZWREZXByZWNhdGlvbldhcm5pbmdzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbmZ1bmN0aW9uIGRlcHJlY2F0ZShtZXNzYWdlLCBrZXkgPSBtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIV9lbWl0dGVkRGVwcmVjYXRpb25XYXJuaW5ncy5oYXMoa2V5KSkge1xuICAgICAgX2VtaXR0ZWREZXByZWNhdGlvbldhcm5pbmdzLmFkZChrZXkpO1xuICAgICAgZXJyb3JXaXRoVGl0bGUoXCJEZXByZWNhdGlvbiB3YXJuaW5nXCIsIG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGVwcmVjYXRlSWYoY29uZGl0aW9uLCBtZXNzYWdlLCBrZXkgPSBtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICBkZXByZWNhdGUobWVzc2FnZSwga2V5KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRocm93VXNhZ2VFcnJvcihtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zdCB1c2FnZUVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIHVzYWdlRXJyb3IubmFtZSA9IFwiVXNhZ2UgZXJyb3JcIjtcbiAgICBlcnJvcldpdGhUaXRsZShcIlVzYWdlIGVycm9yXCIsIG1lc3NhZ2UpO1xuICAgIHRocm93IHVzYWdlRXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9ySWYoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICB0aHJvd1VzYWdlRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9saWIvUG9sbGVyLnRzXG52YXIgQkFDS09GRl9ERUxBWVMyID0gWzFlMywgMmUzLCA0ZTMsIDhlMywgMWU0XTtcbmZ1bmN0aW9uIG1ha2VQb2xsZXIoY2FsbGJhY2ssIGludGVydmFsTXMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gIGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogdm9pZCAwO1xuICBjb25zdCB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdm9pZCAwO1xuICBjb25zdCBtYXhTdGFsZVRpbWVNcyA9IG9wdGlvbnM/Lm1heFN0YWxlVGltZU1zID8/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgY29uc3QgY29udGV4dCA9IHtcbiAgICBpbkZvcmVncm91bmQ6IGRvYz8udmlzaWJpbGl0eVN0YXRlICE9PSBcImhpZGRlblwiLFxuICAgIGxhc3RTdWNjZXNzZnVsUG9sbEF0OiBzdGFydFRpbWUsXG4gICAgY291bnQ6IDAsXG4gICAgYmFja29mZjogMFxuICB9O1xuICBmdW5jdGlvbiBtYXlQb2xsKCkge1xuICAgIHJldHVybiBjb250ZXh0LmNvdW50ID4gMCAmJiBjb250ZXh0LmluRm9yZWdyb3VuZDtcbiAgfVxuICBjb25zdCBmc20gPSBuZXcgRlNNKHt9KS5hZGRTdGF0ZShcIkBpZGxlXCIpLmFkZFN0YXRlKFwiQGVuYWJsZWRcIikuYWRkU3RhdGUoXCJAcG9sbGluZ1wiKTtcbiAgZnNtLmFkZFRyYW5zaXRpb25zKFwiQGlkbGVcIiwgeyBTVEFSVDogXCJAZW5hYmxlZFwiIH0pO1xuICBmc20uYWRkVHJhbnNpdGlvbnMoXCJAZW5hYmxlZFwiLCB7IFNUT1A6IFwiQGlkbGVcIiwgUE9MTDogXCJAcG9sbGluZ1wiIH0pO1xuICBmc20uYWRkVGltZWRUcmFuc2l0aW9uKFxuICAgIFwiQGVuYWJsZWRcIixcbiAgICAoKSA9PiB7XG4gICAgICBjb25zdCBsYXN0UG9sbCA9IGNvbnRleHQubGFzdFN1Y2Nlc3NmdWxQb2xsQXQ7XG4gICAgICBjb25zdCBuZXh0UG9sbCA9IGxhc3RQb2xsICsgaW50ZXJ2YWxNcztcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBuZXh0UG9sbCAtIHBlcmZvcm1hbmNlLm5vdygpKSArIGNvbnRleHQuYmFja29mZjtcbiAgICB9LFxuICAgIFwiQHBvbGxpbmdcIlxuICApO1xuICBmc20ub25FbnRlckFzeW5jKFxuICAgIFwiQHBvbGxpbmdcIixcbiAgICBhc3luYyAoX2N0eCwgc2lnbmFsKSA9PiB7XG4gICAgICBhd2FpdCBjYWxsYmFjayhzaWduYWwpO1xuICAgICAgaWYgKCFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICBjb250ZXh0Lmxhc3RTdWNjZXNzZnVsUG9sbEF0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBXaGVuIE9LXG4gICAgKCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBtYXlQb2xsKCkgPyBcIkBlbmFibGVkXCIgOiBcIkBpZGxlXCIsXG4gICAgICAgIGVmZmVjdDogKCkgPT4ge1xuICAgICAgICAgIGNvbnRleHQuYmFja29mZiA9IDA7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBXaGVuIGVycm9yXG4gICAgKCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBtYXlQb2xsKCkgPyBcIkBlbmFibGVkXCIgOiBcIkBpZGxlXCIsXG4gICAgICAgIGVmZmVjdDogKCkgPT4ge1xuICAgICAgICAgIGNvbnRleHQuYmFja29mZiA9IEJBQ0tPRkZfREVMQVlTMi5maW5kKChkZWxheSkgPT4gZGVsYXkgPiBjb250ZXh0LmJhY2tvZmYpID8/IEJBQ0tPRkZfREVMQVlTMltCQUNLT0ZGX0RFTEFZUzIubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICAzZTRcbiAgICAvLyBBYm9ydCB0aGUgcG9sbCBpZiB0aGUgY2FsbGJhY2sgdGFrZXMgbW9yZSB0aGFuIDMwIHNlY29uZHMgdG8gY29tcGxldGVcbiAgKTtcbiAgZnVuY3Rpb24gc3RhcnRPclN0b3AoKSB7XG4gICAgaWYgKG1heVBvbGwoKSkge1xuICAgICAgZnNtLnNlbmQoeyB0eXBlOiBcIlNUQVJUXCIgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZzbS5zZW5kKHsgdHlwZTogXCJTVE9QXCIgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGluYygpIHtcbiAgICBjb250ZXh0LmNvdW50Kys7XG4gICAgc3RhcnRPclN0b3AoKTtcbiAgfVxuICBmdW5jdGlvbiBkZWMoKSB7XG4gICAgY29udGV4dC5jb3VudC0tO1xuICAgIGlmIChjb250ZXh0LmNvdW50IDwgMCkge1xuICAgICAgY29udGV4dC5jb3VudCA9IDA7XG4gICAgfVxuICAgIHN0YXJ0T3JTdG9wKCk7XG4gIH1cbiAgZnVuY3Rpb24gcG9sbE5vd0lmU3RhbGUoKSB7XG4gICAgaWYgKHBlcmZvcm1hbmNlLm5vdygpIC0gY29udGV4dC5sYXN0U3VjY2Vzc2Z1bFBvbGxBdCA+IG1heFN0YWxlVGltZU1zKSB7XG4gICAgICBmc20uc2VuZCh7IHR5cGU6IFwiUE9MTFwiIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRJbkZvcmVncm91bmQoaW5Gb3JlZ3JvdW5kKSB7XG4gICAgY29udGV4dC5pbkZvcmVncm91bmQgPSBpbkZvcmVncm91bmQ7XG4gICAgc3RhcnRPclN0b3AoKTtcbiAgICBwb2xsTm93SWZTdGFsZSgpO1xuICB9XG4gIGZ1bmN0aW9uIG9uVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICBzZXRJbkZvcmVncm91bmQoZG9jPy52aXNpYmlsaXR5U3RhdGUgIT09IFwiaGlkZGVuXCIpO1xuICB9XG4gIGRvYz8uYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgd2luPy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gIHdpbj8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHBvbGxOb3dJZlN0YWxlKTtcbiAgZnNtLnN0YXJ0KCk7XG4gIHJldHVybiB7XG4gICAgaW5jLFxuICAgIGRlYyxcbiAgICBwb2xsTm93SWZTdGFsZSxcbiAgICAvLyBJbnRlcm5hbCBBUEksIHVzZWQgYnkgdW5pdCB0ZXN0cyBvbmx5IHRvIHNpbXVsYXRlIHZpc2liaWxpdHkgZXZlbnRzXG4gICAgc2V0SW5Gb3JlZ3JvdW5kXG4gIH07XG59XG5cbi8vIHNyYy9saWIvc2hhbGxvdy50c1xuZnVuY3Rpb24gc2hhbGxvd0FycmF5KHhzLCB5cykge1xuICBpZiAoeHMubGVuZ3RoICE9PSB5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0LmlzKHhzW2ldLCB5c1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzaGFsbG93T2JqKG9iakEsIG9iakIpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KG9iakEpIHx8ICFpc1BsYWluT2JqZWN0KG9iakIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG9iakIpLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4ga2V5c0EuZXZlcnkoXG4gICAgKGtleSkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleSkgJiYgT2JqZWN0LmlzKG9iakFba2V5XSwgb2JqQltrZXldKVxuICApO1xufVxuZnVuY3Rpb24gc2hhbGxvdyhhLCBiKSB7XG4gIGlmIChPYmplY3QuaXMoYSwgYikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gIGNvbnN0IGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgaWYgKGlzQXJyYXlBIHx8IGlzQXJyYXlCKSB7XG4gICAgaWYgKCFpc0FycmF5QSB8fCAhaXNBcnJheUIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWxsb3dBcnJheShhLCBiKTtcbiAgfVxuICByZXR1cm4gc2hhbGxvd09iaihhLCBiKTtcbn1cblxuLy8gc3JjL2xpYi9Tb3J0ZWRMaXN0LnRzXG5mdW5jdGlvbiBiaXNlY3RSaWdodChhcnIsIHgsIGx0KSB7XG4gIGxldCBsbyA9IDA7XG4gIGxldCBoaSA9IGFyci5sZW5ndGg7XG4gIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgY29uc3QgbWlkID0gbG8gKyAoaGkgLSBsbyA+PiAxKTtcbiAgICBpZiAobHQoeCwgYXJyW21pZF0pKSB7XG4gICAgICBoaSA9IG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG8gPSBtaWQgKyAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbG87XG59XG52YXIgU29ydGVkTGlzdCA9IGNsYXNzIF9Tb3J0ZWRMaXN0IHtcbiAgI2RhdGE7XG4gICNsdDtcbiAgY29uc3RydWN0b3IoYWxyZWFkeVNvcnRlZExpc3QsIGx0KSB7XG4gICAgdGhpcy4jbHQgPSBsdDtcbiAgICB0aGlzLiNkYXRhID0gYWxyZWFkeVNvcnRlZExpc3Q7XG4gIH1cbiAgc3RhdGljIGZyb20oYXJyLCBsdCkge1xuICAgIGNvbnN0IHNvcnRlZCA9IG5ldyBfU29ydGVkTGlzdChbXSwgbHQpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgIHNvcnRlZC5hZGQoaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBzb3J0ZWQ7XG4gIH1cbiAgc3RhdGljIGZyb21BbHJlYWR5U29ydGVkKGFscmVhZHlTb3J0ZWQsIGx0KSB7XG4gICAgcmV0dXJuIG5ldyBfU29ydGVkTGlzdChhbHJlYWR5U29ydGVkLCBsdCk7XG4gIH1cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgc29ydGVkIGxpc3QgdG8gYSBuZXcgaW5zdGFuY2UuXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9Tb3J0ZWRMaXN0KHRoaXMuI2RhdGEuc2xpY2UoKSwgdGhpcy4jbHQpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IGl0ZW0gdG8gdGhlIHNvcnRlZCBsaXN0LCBzdWNoIHRoYXQgaXQgcmVtYWlucyBzb3J0ZWQuXG4gICAqL1xuICBhZGQodmFsdWUpIHtcbiAgICBjb25zdCBpZHggPSBiaXNlY3RSaWdodCh0aGlzLiNkYXRhLCB2YWx1ZSwgdGhpcy4jbHQpO1xuICAgIHRoaXMuI2RhdGEuc3BsaWNlKGlkeCwgMCwgdmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBnaXZlbiB2YWx1ZSBmcm9tIHRoZSBzb3J0ZWQgbGlzdCwgaWYgaXQgZXhpc3RzLiBUaGUgZ2l2ZW5cbiAgICogdmFsdWUgbXVzdCBiZSBgPT09YCB0byBvbmUgb2YgdGhlIGxpc3QgaXRlbXMuIE9ubHkgdGhlIGZpcnN0IGVudHJ5IHdpbGwgYmVcbiAgICogcmVtb3ZlZCBpZiB0aGUgZWxlbWVudCBleGlzdHMgaW4gdGhlIHNvcnRlZCBsaXN0IG11bHRpcGxlIHRpbWVzLlxuICAgKi9cbiAgcmVtb3ZlKHZhbHVlKSB7XG4gICAgY29uc3QgaWR4ID0gdGhpcy4jZGF0YS5pbmRleE9mKHZhbHVlKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIHRoaXMuI2RhdGEuc3BsaWNlKGlkeCwgMSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RhdGEubGVuZ3RoO1xuICB9XG4gICpmaWx0ZXIocHJlZGljYXRlKSB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuI2RhdGEpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoaXRlbSkpIHtcbiAgICAgICAgeWllbGQgaXRlbTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RhdGFbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICB9XG59O1xuXG4vLyBzcmMvdHlwZXMvT3RoZXJzLnRzXG52YXIgVGV4dEVkaXRvclR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChUZXh0RWRpdG9yVHlwZTIpID0+IHtcbiAgVGV4dEVkaXRvclR5cGUyW1wiTGV4aWNhbFwiXSA9IFwibGV4aWNhbFwiO1xuICBUZXh0RWRpdG9yVHlwZTJbXCJUaXBUYXBcIl0gPSBcInRpcHRhcFwiO1xuICByZXR1cm4gVGV4dEVkaXRvclR5cGUyO1xufSkoVGV4dEVkaXRvclR5cGUgfHwge30pO1xuXG4vLyBzcmMvaW5kZXgudHNcbmRldGVjdER1cGVzKFBLR19OQU1FLCBQS0dfVkVSU0lPTiwgUEtHX0ZPUk1BVCk7XG52YXIgQ29tbWVudHNBcGlFcnJvciA9IEh0dHBFcnJvcjtcbnZhciBOb3RpZmljYXRpb25zQXBpRXJyb3IgPSBIdHRwRXJyb3I7XG5leHBvcnQge1xuICBDbGllbnRNc2dDb2RlLFxuICBDb21tZW50c0FwaUVycm9yLFxuICBDcmR0VHlwZSxcbiAgRGVmYXVsdE1hcCxcbiAgRGVyaXZlZFNpZ25hbCxcbiAgSHR0cEVycm9yLFxuICBMaXZlTGlzdCxcbiAgTGl2ZU1hcCxcbiAgTGl2ZU9iamVjdCxcbiAgTGl2ZWJsb2Nrc0Vycm9yLFxuICBNdXRhYmxlU2lnbmFsLFxuICBOb3RpZmljYXRpb25zQXBpRXJyb3IsXG4gIE9wQ29kZSxcbiAgUGVybWlzc2lvbixcbiAgUHJvbWlzZV93aXRoUmVzb2x2ZXJzLFxuICBTZXJ2ZXJNc2dDb2RlLFxuICBTaWduYWwsXG4gIFNvcnRlZExpc3QsXG4gIFRleHRFZGl0b3JUeXBlLFxuICBXZWJzb2NrZXRDbG9zZUNvZGVzLFxuICBhY2tPcCxcbiAgYXNQb3MsXG4gIGFzc2VydCxcbiAgYXNzZXJ0TmV2ZXIsXG4gIGF1dG9SZXRyeSxcbiAgYjY0ZGVjb2RlLFxuICBiYXRjaCxcbiAgY2hlY2tCb3VuZHMsXG4gIGNodW5rLFxuICBjbG9uZUxzb24sXG4gIGNvbXBhY3RPYmplY3QsXG4gIGZhbmN5X2NvbnNvbGVfZXhwb3J0cyBhcyBjb25zb2xlLFxuICBjb252ZXJ0VG9Db21tZW50RGF0YSxcbiAgY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbixcbiAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhLFxuICBjb252ZXJ0VG9UaHJlYWREYXRhLFxuICBjcmVhdGVDbGllbnQsXG4gIGNyZWF0ZUNvbW1lbnRBdHRhY2htZW50SWQsXG4gIGNyZWF0ZUNvbW1lbnRJZCxcbiAgY3JlYXRlSW5ib3hOb3RpZmljYXRpb25JZCxcbiAgY3JlYXRlTWFuYWdlZFBvb2wsXG4gIGNyZWF0ZVRocmVhZElkLFxuICBjcmVhdGVVc2VyTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gIGRlcHJlY2F0ZSxcbiAgZGVwcmVjYXRlSWYsXG4gIGRldGVjdER1cGVzLFxuICBlbnRyaWVzLFxuICBlcnJvcklmLFxuICBmcmVlemUsXG4gIGdlbmVyYXRlQ29tbWVudFVybCxcbiAgZ2V0TWVudGlvbmVkSWRzRnJvbUNvbW1lbnRCb2R5LFxuICBodG1sLFxuICBodG1sU2FmZSxcbiAgaXNDaGlsZENyZHQsXG4gIGlzQ29tbWVudEJvZHlMaW5rLFxuICBpc0NvbW1lbnRCb2R5TWVudGlvbixcbiAgaXNDb21tZW50Qm9keVRleHQsXG4gIGlzSnNvbkFycmF5LFxuICBpc0pzb25PYmplY3QsXG4gIGlzSnNvblNjYWxhcixcbiAgaXNMaXZlTm9kZSxcbiAgaXNOb3RpZmljYXRpb25DaGFubmVsRW5hYmxlZCxcbiAgaXNQbGFpbk9iamVjdCxcbiAgaXNSb290Q3JkdCxcbiAgaXNTdGFydHNXaXRoT3BlcmF0b3IsXG4gIGtJbnRlcm5hbCxcbiAga2V5cyxcbiAgbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0LFxuICBsc29uVG9Kc29uLFxuICBtYWtlQWJvcnRDb250cm9sbGVyLFxuICBtYWtlRXZlbnRTb3VyY2UsXG4gIG1ha2VQb2xsZXIsXG4gIG1ha2VQb3NpdGlvbixcbiAgbWFwVmFsdWVzLFxuICBtZW1vaXplT25TdWNjZXNzLFxuICBuYW5vaWQsXG4gIG5uLFxuICBvYmplY3RUb1F1ZXJ5LFxuICBwYXRjaExpdmVPYmplY3RLZXksXG4gIHBhdGNoVXNlck5vdGlmaWNhdGlvblNldHRpbmdzLFxuICByYWlzZSxcbiAgcmVzb2x2ZVVzZXJzSW5Db21tZW50Qm9keSxcbiAgc2hhbGxvdyxcbiAgc3RhYmxlU3RyaW5naWZ5LFxuICBzdHJpbmdpZnlDb21tZW50Qm9keSxcbiAgdGhyb3dVc2FnZUVycm9yLFxuICB0b0Fic29sdXRlVXJsLFxuICB0b1BsYWluTHNvbixcbiAgdHJ5UGFyc2VKc29uLFxuICB1cmwsXG4gIHVybGpvaW4sXG4gIHdhaXQsXG4gIHdpdGhUaW1lb3V0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/core/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react/dist/chunk-URVBSXYW.js":
/*!***************************************************************!*\
  !*** ./node_modules/@liveblocks/react/dist/chunk-URVBSXYW.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientContext: () => (/* binding */ ClientContext),\n/* harmony export */   LiveblocksProvider: () => (/* binding */ LiveblocksProvider),\n/* harmony export */   RoomContext: () => (/* binding */ RoomContext),\n/* harmony export */   _RoomProvider: () => (/* binding */ _RoomProvider),\n/* harmony export */   _useAddReaction: () => (/* binding */ _useAddReaction),\n/* harmony export */   _useBroadcastEvent: () => (/* binding */ _useBroadcastEvent),\n/* harmony export */   _useCreateThread: () => (/* binding */ _useCreateThread),\n/* harmony export */   _useDeleteThread: () => (/* binding */ _useDeleteThread),\n/* harmony export */   _useEditThreadMetadata: () => (/* binding */ _useEditThreadMetadata),\n/* harmony export */   _useEventListener: () => (/* binding */ _useEventListener),\n/* harmony export */   _useHistoryVersions: () => (/* binding */ _useHistoryVersions),\n/* harmony export */   _useHistoryVersionsSuspense: () => (/* binding */ _useHistoryVersionsSuspense),\n/* harmony export */   _useInboxNotificationThread: () => (/* binding */ _useInboxNotificationThread),\n/* harmony export */   _useIsInsideRoom: () => (/* binding */ _useIsInsideRoom),\n/* harmony export */   _useMutation: () => (/* binding */ _useMutation),\n/* harmony export */   _useMyPresence: () => (/* binding */ _useMyPresence),\n/* harmony export */   _useOther: () => (/* binding */ _useOther),\n/* harmony export */   _useOtherSuspense: () => (/* binding */ _useOtherSuspense),\n/* harmony export */   _useOthers: () => (/* binding */ _useOthers),\n/* harmony export */   _useOthersListener: () => (/* binding */ _useOthersListener),\n/* harmony export */   _useOthersMapped: () => (/* binding */ _useOthersMapped),\n/* harmony export */   _useOthersMappedSuspense: () => (/* binding */ _useOthersMappedSuspense),\n/* harmony export */   _useOthersSuspense: () => (/* binding */ _useOthersSuspense),\n/* harmony export */   _useRoom: () => (/* binding */ _useRoom),\n/* harmony export */   _useRoomNotificationSettings: () => (/* binding */ _useRoomNotificationSettings),\n/* harmony export */   _useRoomNotificationSettingsSuspense: () => (/* binding */ _useRoomNotificationSettingsSuspense),\n/* harmony export */   _useSelf: () => (/* binding */ _useSelf),\n/* harmony export */   _useSelfSuspense: () => (/* binding */ _useSelfSuspense),\n/* harmony export */   _useStorage: () => (/* binding */ _useStorage),\n/* harmony export */   _useStorageRoot: () => (/* binding */ _useStorageRoot),\n/* harmony export */   _useStorageSuspense: () => (/* binding */ _useStorageSuspense),\n/* harmony export */   _useThreads: () => (/* binding */ _useThreads),\n/* harmony export */   _useThreadsSuspense: () => (/* binding */ _useThreadsSuspense),\n/* harmony export */   _useUpdateMyPresence: () => (/* binding */ _useUpdateMyPresence),\n/* harmony export */   _useUser: () => (/* binding */ _useUser),\n/* harmony export */   _useUserSuspense: () => (/* binding */ _useUserSuspense),\n/* harmony export */   _useUserThreadsSuspense_experimental: () => (/* binding */ _useUserThreadsSuspense_experimental),\n/* harmony export */   _useUserThreads_experimental: () => (/* binding */ _useUserThreads_experimental),\n/* harmony export */   createLiveblocksContext: () => (/* binding */ createLiveblocksContext),\n/* harmony export */   createRoomContext: () => (/* binding */ createRoomContext),\n/* harmony export */   getUmbrellaStoreForClient: () => (/* binding */ getUmbrellaStoreForClient),\n/* harmony export */   useAddRoomCommentReaction: () => (/* binding */ useAddRoomCommentReaction),\n/* harmony export */   useAttachmentUrl: () => (/* binding */ useAttachmentUrl),\n/* harmony export */   useAttachmentUrlSuspense: () => (/* binding */ useAttachmentUrlSuspense),\n/* harmony export */   useBatch: () => (/* binding */ useBatch),\n/* harmony export */   useCanRedo: () => (/* binding */ useCanRedo),\n/* harmony export */   useCanUndo: () => (/* binding */ useCanUndo),\n/* harmony export */   useClient: () => (/* binding */ useClient),\n/* harmony export */   useClientOrNull: () => (/* binding */ useClientOrNull),\n/* harmony export */   useCreateComment: () => (/* binding */ useCreateComment),\n/* harmony export */   useCreateRoomComment: () => (/* binding */ useCreateRoomComment),\n/* harmony export */   useCreateRoomThread: () => (/* binding */ useCreateRoomThread),\n/* harmony export */   useCreateTextMention: () => (/* binding */ useCreateTextMention),\n/* harmony export */   useDeleteAllInboxNotifications: () => (/* binding */ useDeleteAllInboxNotifications),\n/* harmony export */   useDeleteComment: () => (/* binding */ useDeleteComment),\n/* harmony export */   useDeleteInboxNotification: () => (/* binding */ useDeleteInboxNotification),\n/* harmony export */   useDeleteRoomComment: () => (/* binding */ useDeleteRoomComment),\n/* harmony export */   useDeleteRoomThread: () => (/* binding */ useDeleteRoomThread),\n/* harmony export */   useDeleteTextMention: () => (/* binding */ useDeleteTextMention),\n/* harmony export */   useEditComment: () => (/* binding */ useEditComment),\n/* harmony export */   useEditRoomComment: () => (/* binding */ useEditRoomComment),\n/* harmony export */   useEditRoomThreadMetadata: () => (/* binding */ useEditRoomThreadMetadata),\n/* harmony export */   useErrorListener: () => (/* binding */ useErrorListener),\n/* harmony export */   useHistory: () => (/* binding */ useHistory),\n/* harmony export */   useHistoryVersionData: () => (/* binding */ useHistoryVersionData),\n/* harmony export */   useInboxNotifications: () => (/* binding */ useInboxNotifications),\n/* harmony export */   useInboxNotificationsSuspense: () => (/* binding */ useInboxNotificationsSuspense),\n/* harmony export */   useLostConnectionListener: () => (/* binding */ useLostConnectionListener),\n/* harmony export */   useMarkAllInboxNotificationsAsRead: () => (/* binding */ useMarkAllInboxNotificationsAsRead),\n/* harmony export */   useMarkInboxNotificationAsRead: () => (/* binding */ useMarkInboxNotificationAsRead),\n/* harmony export */   useMarkRoomThreadAsRead: () => (/* binding */ useMarkRoomThreadAsRead),\n/* harmony export */   useMarkRoomThreadAsResolved: () => (/* binding */ useMarkRoomThreadAsResolved),\n/* harmony export */   useMarkRoomThreadAsUnresolved: () => (/* binding */ useMarkRoomThreadAsUnresolved),\n/* harmony export */   useMarkThreadAsRead: () => (/* binding */ useMarkThreadAsRead),\n/* harmony export */   useMarkThreadAsResolved: () => (/* binding */ useMarkThreadAsResolved),\n/* harmony export */   useMarkThreadAsUnresolved: () => (/* binding */ useMarkThreadAsUnresolved),\n/* harmony export */   useMentionSuggestionsCache: () => (/* binding */ useMentionSuggestionsCache),\n/* harmony export */   useNotificationSettings: () => (/* binding */ useNotificationSettings),\n/* harmony export */   useNotificationSettingsSuspense: () => (/* binding */ useNotificationSettingsSuspense),\n/* harmony export */   useOthersConnectionIds: () => (/* binding */ useOthersConnectionIds),\n/* harmony export */   useOthersConnectionIdsSuspense: () => (/* binding */ useOthersConnectionIdsSuspense),\n/* harmony export */   useRedo: () => (/* binding */ useRedo),\n/* harmony export */   useRemoveReaction: () => (/* binding */ useRemoveReaction),\n/* harmony export */   useRemoveRoomCommentReaction: () => (/* binding */ useRemoveRoomCommentReaction),\n/* harmony export */   useReportTextEditor: () => (/* binding */ useReportTextEditor),\n/* harmony export */   useResolveMentionSuggestions: () => (/* binding */ useResolveMentionSuggestions),\n/* harmony export */   useRoomAttachmentUrl: () => (/* binding */ useRoomAttachmentUrl),\n/* harmony export */   useRoomInfo: () => (/* binding */ useRoomInfo),\n/* harmony export */   useRoomInfoSuspense: () => (/* binding */ useRoomInfoSuspense),\n/* harmony export */   useRoomPermissions: () => (/* binding */ useRoomPermissions),\n/* harmony export */   useSignal: () => (/* binding */ useSignal),\n/* harmony export */   useStatus: () => (/* binding */ useStatus),\n/* harmony export */   useStorageStatus: () => (/* binding */ useStorageStatus),\n/* harmony export */   useStorageStatusSuspense: () => (/* binding */ useStorageStatusSuspense),\n/* harmony export */   useSyncExternalStoreWithSelector: () => (/* binding */ useSyncExternalStoreWithSelector),\n/* harmony export */   useSyncStatus: () => (/* binding */ useSyncStatus),\n/* harmony export */   useThreadSubscription: () => (/* binding */ useThreadSubscription),\n/* harmony export */   useUndo: () => (/* binding */ useUndo),\n/* harmony export */   useUnreadInboxNotificationsCount: () => (/* binding */ useUnreadInboxNotificationsCount),\n/* harmony export */   useUnreadInboxNotificationsCountSuspense: () => (/* binding */ useUnreadInboxNotificationsCountSuspense),\n/* harmony export */   useUpdateNotificationSettings: () => (/* binding */ useUpdateNotificationSettings),\n/* harmony export */   useUpdateRoomNotificationSettings: () => (/* binding */ useUpdateRoomNotificationSettings),\n/* harmony export */   useYjsProvider: () => (/* binding */ useYjsProvider)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n// src/contexts.ts\n\nvar RoomContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction useRoomOrNull() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RoomContext);\n}\nfunction useIsInsideRoom() {\n  const room = useRoomOrNull();\n  return room !== null;\n}\n\n// src/use-sync-external-store-with-selector.ts\n\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;\n}\nfunction useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n  const instRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  let inst;\n  if (instRef.current === null) {\n    inst = {\n      hasValue: false,\n      value: null\n    };\n    instRef.current = inst;\n  } else {\n    inst = instRef.current;\n  }\n  const [getSelection, getServerSelection] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    let hasMemo = false;\n    let memoizedSnapshot;\n    let memoizedSelection;\n    const memoizedSelector = (nextSnapshot) => {\n      if (!hasMemo) {\n        hasMemo = true;\n        memoizedSnapshot = nextSnapshot;\n        const nextSelection2 = selector(nextSnapshot);\n        if (isEqual !== void 0) {\n          if (inst.hasValue) {\n            const currentSelection = inst.value;\n            if (isEqual(currentSelection, nextSelection2)) {\n              memoizedSelection = currentSelection;\n              return currentSelection;\n            }\n          }\n        }\n        memoizedSelection = nextSelection2;\n        return nextSelection2;\n      }\n      const prevSnapshot = memoizedSnapshot;\n      const prevSelection = memoizedSelection;\n      if (is(prevSnapshot, nextSnapshot)) {\n        return prevSelection;\n      }\n      const nextSelection = selector(nextSnapshot);\n      if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {\n        memoizedSnapshot = nextSnapshot;\n        return prevSelection;\n      }\n      memoizedSnapshot = nextSnapshot;\n      memoizedSelection = nextSelection;\n      return nextSelection;\n    };\n    const maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;\n    const getSnapshotWithSelector = () => memoizedSelector(getSnapshot());\n    const getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : () => memoizedSelector(maybeGetServerSnapshot());\n    return [getSnapshotWithSelector, getServerSnapshotWithSelector];\n  }, [getSnapshot, getServerSnapshot, selector, isEqual]);\n  const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(\n    subscribe,\n    getSelection,\n    getServerSelection\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    inst.hasValue = true;\n    inst.value = value;\n  }, [value]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(value);\n  return value;\n}\n\n// src/use-signal.ts\nvar identity = (value) => value;\nfunction useSignal(signal, selector, isEqual) {\n  return useSyncExternalStoreWithSelector(\n    signal.subscribe,\n    signal.get,\n    signal.get,\n    selector ?? identity,\n    isEqual\n  );\n}\n\n// src/liveblocks.tsx\n\n\n\n\n// src/config.ts\nvar SECONDS = 1e3;\nvar MINUTES = 60 * SECONDS;\nvar config = {\n  SMOOTH_DELAY: 1 * SECONDS,\n  NOTIFICATIONS_POLL_INTERVAL: 1 * MINUTES,\n  NOTIFICATIONS_MAX_STALE_TIME: 5 * SECONDS,\n  ROOM_THREADS_POLL_INTERVAL: 5 * MINUTES,\n  ROOM_THREADS_MAX_STALE_TIME: 5 * SECONDS,\n  USER_THREADS_POLL_INTERVAL: 1 * MINUTES,\n  USER_THREADS_MAX_STALE_TIME: 30 * SECONDS,\n  HISTORY_VERSIONS_POLL_INTERVAL: 1 * MINUTES,\n  HISTORY_VERSIONS_MAX_STALE_TIME: 5 * SECONDS,\n  NOTIFICATION_SETTINGS_POLL_INTERVAL: 1 * MINUTES,\n  NOTIFICATION_SETTINGS_MAX_STALE_TIME: 5 * SECONDS,\n  USER_NOTIFICATION_SETTINGS_INTERVAL: 5 * MINUTES,\n  USER_NOTIFICATION_SETTINGS_MAX_STALE_TIME: 1 * MINUTES\n};\n\n// src/lib/AsyncResult.ts\nvar ASYNC_LOADING = Object.freeze({ isLoading: true });\nvar ASYNC_ERR = (error) => Object.freeze({ isLoading: false, error });\nfunction ASYNC_OK(fieldOrData, data) {\n  if (arguments.length === 1) {\n    return Object.freeze({ isLoading: false, data: fieldOrData });\n  } else {\n    return Object.freeze({ isLoading: false, [fieldOrData]: data });\n  }\n}\n\n// src/lib/itertools.ts\nfunction find(it, predicate) {\n  for (const item of it) {\n    if (predicate(item)) return item;\n  }\n  return void 0;\n}\nfunction count(it, predicate) {\n  let total = 0;\n  for (const item of it) {\n    if (predicate(item)) total++;\n  }\n  return total;\n}\n\n// src/lib/ssr.ts\nfunction ensureNotServerSide() {\n  if (typeof window === \"undefined\") {\n    throw new Error(\n      \"You cannot use the Suspense version of Liveblocks hooks server side. Make sure to only call them client side by using a ClientSideSuspense wrapper.\\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#ClientSideSuspense\"\n    );\n  }\n}\n\n// src/lib/use-initial.ts\n\n\n// src/lib/use-latest.ts\n\nfunction useLatest(value) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    ref.current = value;\n  }, [value]);\n  return ref;\n}\n\n// src/lib/use-initial.ts\nvar noop = (state) => state;\nfunction useInitial(value) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(noop, value)[0];\n}\nfunction useInitialUnlessFunction(latestValue) {\n  const frozenValue = useInitial(latestValue);\n  if (typeof frozenValue === \"function\") {\n    const ref = useLatest(latestValue);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args) => ref.current(...args), [\n      ref\n    ]);\n  } else {\n    return frozenValue;\n  }\n}\n\n// src/lib/use-polyfill.ts\nvar use = (\n  // React.use ||\n  (promise) => {\n    if (promise.status === \"pending\") {\n      throw promise;\n    } else if (promise.status === \"fulfilled\") {\n      return promise.value;\n    } else if (promise.status === \"rejected\") {\n      throw promise.reason;\n    } else {\n      promise.status = \"pending\";\n      promise.then(\n        (v) => {\n          promise.status = \"fulfilled\";\n          promise.value = v;\n        },\n        (e) => {\n          promise.status = \"rejected\";\n          promise.reason = e;\n        }\n      );\n      throw promise;\n    }\n  }\n);\n\n// src/umbrella-store.ts\n\n\n// src/lib/autobind.ts\nfunction autobind(self) {\n  const seen = /* @__PURE__ */ new Set();\n  seen.add(\"constructor\");\n  let obj = self.constructor.prototype;\n  do {\n    for (const key of Reflect.ownKeys(obj)) {\n      if (seen.has(key)) continue;\n      const descriptor = Reflect.getOwnPropertyDescriptor(obj, key);\n      if (typeof descriptor?.value === \"function\") {\n        seen.add(key);\n        self[key] = self[key].bind(self);\n      }\n    }\n  } while ((obj = Reflect.getPrototypeOf(obj)) && obj !== Object.prototype);\n}\n\n// src/lib/shallow2.ts\n\nfunction shallow2(a, b) {\n  if (!(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(a) || !(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(b)) {\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow)(a, b);\n  }\n  const keysA = Object.keys(a);\n  if (keysA.length !== Object.keys(b).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(b, key) && (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow)(a[key], b[key])\n  );\n}\n\n// src/ThreadDB.ts\n\n\n// src/lib/querying.ts\n\nfunction makeThreadsFilter(query) {\n  return (thread) => matchesQuery(thread, query) && matchesMetadata(thread, query);\n}\nfunction matchesQuery(thread, q) {\n  return q.resolved === void 0 || thread.resolved === q.resolved;\n}\nfunction matchesMetadata(thread, q) {\n  const metadata = thread.metadata;\n  return q.metadata === void 0 || Object.entries(q.metadata).every(\n    ([key, op]) => (\n      // Ignore explicit-undefined filters\n      // Boolean logic: op? => value matches the operator\n      op === void 0 || matchesOperator(metadata[key], op)\n    )\n  );\n}\nfunction matchesOperator(value, op) {\n  if (op === null) {\n    return value === void 0;\n  } else if ((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.isStartsWithOperator)(op)) {\n    return typeof value === \"string\" && value.startsWith(op.startsWith);\n  } else {\n    return value === op;\n  }\n}\n\n// src/ThreadDB.ts\nfunction sanitizeThread(thread) {\n  if (thread.deletedAt) {\n    if (thread.comments.length > 0) {\n      return { ...thread, comments: [] };\n    }\n  }\n  const hasComment = thread.comments.some((c) => !c.deletedAt);\n  if (!hasComment) {\n    return { ...thread, deletedAt: /* @__PURE__ */ new Date(), comments: [] };\n  }\n  return thread;\n}\nvar ThreadDB = class _ThreadDB {\n  #byId;\n  #asc;\n  #desc;\n  // This signal will be notified on every mutation\n  signal;\n  constructor() {\n    this.#asc = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.SortedList.from([], (t1, t2) => {\n      const d1 = t1.createdAt;\n      const d2 = t2.createdAt;\n      return d1 < d2 ? true : d1 === d2 ? t1.id < t2.id : false;\n    });\n    this.#desc = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.SortedList.from([], (t1, t2) => {\n      const d2 = t2.updatedAt;\n      const d1 = t1.updatedAt;\n      return d2 < d1 ? true : d2 === d1 ? t2.id < t1.id : false;\n    });\n    this.#byId = /* @__PURE__ */ new Map();\n    this.signal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.MutableSignal(this);\n  }\n  //\n  // Public APIs\n  //\n  clone() {\n    const newPool = new _ThreadDB();\n    newPool.#byId = new Map(this.#byId);\n    newPool.#asc = this.#asc.clone();\n    newPool.#desc = this.#desc.clone();\n    return newPool;\n  }\n  /** Returns an existing thread by ID. Will never return a deleted thread. */\n  get(threadId) {\n    const thread = this.getEvenIfDeleted(threadId);\n    return thread?.deletedAt ? void 0 : thread;\n  }\n  /** Returns the (possibly deleted) thread by ID. */\n  getEvenIfDeleted(threadId) {\n    return this.#byId.get(threadId);\n  }\n  /** Adds or updates a thread in the DB. If the newly given thread is a deleted one, it will get deleted. */\n  upsert(thread) {\n    this.signal.mutate(() => {\n      thread = sanitizeThread(thread);\n      const id = thread.id;\n      const toRemove = this.#byId.get(id);\n      if (toRemove) {\n        if (toRemove.deletedAt) return false;\n        this.#asc.remove(toRemove);\n        this.#desc.remove(toRemove);\n      }\n      if (!thread.deletedAt) {\n        this.#asc.add(thread);\n        this.#desc.add(thread);\n      }\n      this.#byId.set(id, thread);\n      return true;\n    });\n  }\n  /** Like .upsert(), except it won't update if a thread by this ID already exists. */\n  // TODO Consider renaming this to just .upsert(). I'm not sure if we really\n  // TODO need the raw .upsert(). Would be nice if this behavior was the default.\n  upsertIfNewer(thread) {\n    const existing = this.get(thread.id);\n    if (!existing || thread.updatedAt >= existing.updatedAt) {\n      this.upsert(thread);\n    }\n  }\n  applyDelta(newThreads, deletedThreads) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      for (const thread of newThreads) {\n        this.upsertIfNewer(thread);\n      }\n      for (const { id, deletedAt } of deletedThreads) {\n        const existing = this.getEvenIfDeleted(id);\n        if (!existing) continue;\n        this.delete(id, deletedAt);\n      }\n    });\n  }\n  /**\n   * Marks a thread as deleted. It will no longer pop up in .findMany()\n   * queries, but it can still be accessed via `.getEvenIfDeleted()`.\n   */\n  delete(threadId, deletedAt) {\n    const existing = this.#byId.get(threadId);\n    if (existing && !existing.deletedAt) {\n      this.upsert({ ...existing, deletedAt, updatedAt: deletedAt });\n    }\n  }\n  /**\n   * Returns all threads matching a given roomId and query. If roomId is not\n   * specified, it will return all threads matching the query, across all\n   * rooms.\n   *\n   * Returns the results in the requested order. Please note:\n   *   'asc'  means by createdAt ASC\n   *   'desc' means by updatedAt DESC\n   *\n   * Will never return deleted threads in the result.\n   */\n  findMany(roomId, query, direction) {\n    const index = direction === \"desc\" ? this.#desc : this.#asc;\n    const crit = [];\n    if (roomId !== void 0) {\n      crit.push((t) => t.roomId === roomId);\n    }\n    crit.push(makeThreadsFilter(query));\n    return Array.from(index.filter((t) => crit.every((pred) => pred(t))));\n  }\n};\n\n// src/umbrella-store.ts\nfunction makeRoomThreadsQueryKey(roomId, query) {\n  return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.stableStringify)([roomId, query ?? {}]);\n}\nfunction makeUserThreadsQueryKey(query) {\n  return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.stableStringify)(query ?? {});\n}\nfunction usify(promise) {\n  if (\"status\" in promise) {\n    return promise;\n  }\n  const usable = promise;\n  usable.status = \"pending\";\n  usable.then(\n    (value) => {\n      usable.status = \"fulfilled\";\n      usable.value = value;\n    },\n    (err) => {\n      usable.status = \"rejected\";\n      usable.reason = err;\n    }\n  );\n  return usable;\n}\nvar noop2 = Promise.resolve();\nvar PaginatedResource = class {\n  #signal;\n  signal;\n  #fetchPage;\n  #pendingFetchMore;\n  constructor(fetchPage) {\n    this.#signal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.Signal(ASYNC_LOADING);\n    this.#fetchPage = fetchPage;\n    this.#pendingFetchMore = null;\n    this.signal = this.#signal.asReadonly();\n    autobind(this);\n  }\n  get() {\n    return this.#signal.get();\n  }\n  #patch(patch) {\n    const state = this.#signal.get();\n    if (state.data === void 0) return;\n    this.#signal.set(ASYNC_OK({ ...state.data, ...patch }));\n  }\n  async #fetchMore() {\n    const state = this.#signal.get();\n    if (!state.data?.cursor || state.data.isFetchingMore) {\n      return;\n    }\n    this.#patch({ isFetchingMore: true });\n    try {\n      const nextCursor = await this.#fetchPage(state.data.cursor);\n      this.#patch({\n        cursor: nextCursor,\n        hasFetchedAll: nextCursor === null,\n        fetchMoreError: void 0,\n        isFetchingMore: false\n      });\n    } catch (err) {\n      this.#patch({\n        isFetchingMore: false,\n        fetchMoreError: err\n      });\n    }\n  }\n  fetchMore() {\n    const state = this.#signal.get();\n    if (!state.data?.cursor) return noop2;\n    if (!this.#pendingFetchMore) {\n      this.#pendingFetchMore = this.#fetchMore().finally(() => {\n        this.#pendingFetchMore = null;\n      });\n    }\n    return this.#pendingFetchMore;\n  }\n  #cachedPromise = null;\n  waitUntilLoaded() {\n    if (this.#cachedPromise) {\n      return this.#cachedPromise;\n    }\n    const initialPageFetch$ = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.autoRetry)(\n      () => this.#fetchPage(\n        /* cursor */\n        void 0\n      ),\n      5,\n      [5e3, 5e3, 1e4, 15e3]\n    );\n    const promise = usify(initialPageFetch$);\n    promise.then(\n      (cursor) => {\n        this.#signal.set(\n          ASYNC_OK({\n            cursor,\n            hasFetchedAll: cursor === null,\n            isFetchingMore: false,\n            fetchMoreError: void 0,\n            fetchMore: this.fetchMore\n          })\n        );\n      },\n      (err) => {\n        this.#signal.set(ASYNC_ERR(err));\n        setTimeout(() => {\n          this.#cachedPromise = null;\n          this.#signal.set(ASYNC_LOADING);\n        }, 5e3);\n      }\n    );\n    this.#cachedPromise = promise;\n    return this.#cachedPromise;\n  }\n};\nvar SinglePageResource = class {\n  #signal;\n  signal;\n  #fetchPage;\n  constructor(fetchPage) {\n    this.#signal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.Signal(ASYNC_LOADING);\n    this.signal = this.#signal.asReadonly();\n    this.#fetchPage = fetchPage;\n    autobind(this);\n  }\n  get() {\n    return this.#signal.get();\n  }\n  #cachedPromise = null;\n  waitUntilLoaded() {\n    if (this.#cachedPromise) {\n      return this.#cachedPromise;\n    }\n    const initialFetcher$ = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.autoRetry)(\n      () => this.#fetchPage(),\n      5,\n      [5e3, 5e3, 1e4, 15e3]\n    );\n    const promise = usify(initialFetcher$);\n    promise.then(\n      () => {\n        this.#signal.set(ASYNC_OK(void 0));\n      },\n      (err) => {\n        this.#signal.set(ASYNC_ERR(err));\n        setTimeout(() => {\n          this.#cachedPromise = null;\n          this.#signal.set(ASYNC_LOADING);\n        }, 5e3);\n      }\n    );\n    this.#cachedPromise = promise;\n    return promise;\n  }\n};\nfunction createStore_forNotifications() {\n  const signal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.MutableSignal(/* @__PURE__ */ new Map());\n  function markRead(notificationId, readAt) {\n    signal.mutate((lut) => {\n      const existing = lut.get(notificationId);\n      if (!existing) {\n        return false;\n      }\n      lut.set(notificationId, { ...existing, readAt });\n      return true;\n    });\n  }\n  function markAllRead(readAt) {\n    signal.mutate((lut) => {\n      for (const n of lut.values()) {\n        n.readAt = readAt;\n      }\n    });\n  }\n  function deleteOne(inboxNotificationId) {\n    signal.mutate((lut) => lut.delete(inboxNotificationId));\n  }\n  function clear() {\n    signal.mutate((lut) => lut.clear());\n  }\n  function applyDelta(newNotifications, deletedNotifications) {\n    signal.mutate((lut) => {\n      let mutated = false;\n      for (const n of newNotifications) {\n        const existing = lut.get(n.id);\n        if (existing) {\n          const result = compareInboxNotifications(existing, n);\n          if (result === 1) continue;\n        }\n        lut.set(n.id, n);\n        mutated = true;\n      }\n      for (const n of deletedNotifications) {\n        lut.delete(n.id);\n        mutated = true;\n      }\n      return mutated;\n    });\n  }\n  function updateAssociatedNotification(newComment) {\n    signal.mutate((lut) => {\n      const existing = find(\n        lut.values(),\n        (notification) => notification.kind === \"thread\" && notification.threadId === newComment.threadId\n      );\n      if (!existing) return false;\n      lut.set(existing.id, {\n        ...existing,\n        notifiedAt: newComment.createdAt,\n        readAt: newComment.createdAt\n      });\n      return true;\n    });\n  }\n  function upsert(notification) {\n    signal.mutate((lut) => {\n      lut.set(notification.id, notification);\n    });\n  }\n  return {\n    signal: signal.asReadonly(),\n    // Mutations\n    markAllRead,\n    markRead,\n    delete: deleteOne,\n    applyDelta,\n    clear,\n    updateAssociatedNotification,\n    upsert\n  };\n}\nfunction createStore_forRoomNotificationSettings(updates) {\n  const baseSignal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.MutableSignal(/* @__PURE__ */ new Map());\n  function update(roomId, settings) {\n    baseSignal.mutate((lut) => {\n      lut.set(roomId, settings);\n    });\n  }\n  return {\n    signal: _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(\n      baseSignal,\n      updates,\n      (base, updates2) => applyOptimisticUpdates_forSettings(base, updates2)\n    ),\n    // Mutations\n    update\n  };\n}\nfunction createStore_forHistoryVersions() {\n  const baseSignal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.MutableSignal(\n    new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(() => /* @__PURE__ */ new Map())\n  );\n  function update(roomId, versions) {\n    baseSignal.mutate((lut) => {\n      const versionsById = lut.getOrCreate(roomId);\n      for (const version of versions) {\n        versionsById.set(version.id, version);\n      }\n    });\n  }\n  return {\n    signal: _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(\n      baseSignal,\n      (hv) => Object.fromEntries(\n        [...hv].map(([roomId, versions]) => [\n          roomId,\n          Object.fromEntries(versions)\n        ])\n      )\n    ),\n    // Mutations\n    update\n  };\n}\nfunction createStore_forPermissionHints() {\n  const signal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.MutableSignal(\n    new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(() => /* @__PURE__ */ new Set())\n  );\n  function update(newHints) {\n    signal.mutate((lut) => {\n      for (const [roomId, newPermissions] of Object.entries(newHints)) {\n        const existing = lut.getOrCreate(roomId);\n        for (const permission of newPermissions) {\n          existing.add(permission);\n        }\n      }\n    });\n  }\n  return {\n    signal: signal.asReadonly(),\n    // Mutations\n    update\n  };\n}\nfunction createStore_forUserNotificationSettings(updates) {\n  const signal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.Signal(\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.createUserNotificationSettings)({})\n  );\n  function update(settings) {\n    signal.set(settings);\n  }\n  return {\n    signal: _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(\n      signal,\n      updates,\n      (base, updates2) => applyOptimisticUpdates_forUserNotificationSettings(base, updates2)\n    ),\n    // Mutations\n    update\n  };\n}\nfunction createStore_forOptimistic(client) {\n  const signal = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.Signal([]);\n  const syncSource = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].createSyncSource();\n  signal.subscribe(\n    () => syncSource.setSyncStatus(\n      signal.get().length > 0 ? \"synchronizing\" : \"synchronized\"\n    )\n  );\n  function add(optimisticUpdate) {\n    const id = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nanoid)();\n    const newUpdate = { ...optimisticUpdate, id };\n    signal.set((state) => [...state, newUpdate]);\n    return id;\n  }\n  function remove(optimisticId) {\n    signal.set((state) => state.filter((ou) => ou.id !== optimisticId));\n  }\n  return {\n    signal: signal.asReadonly(),\n    // Mutations\n    add,\n    remove\n  };\n}\nvar UmbrellaStore = class {\n  #client;\n  //\n  // Internally, the UmbrellaStore keeps track of a few source signals that can\n  // be set and mutated individually. When any of those are mutated then the\n  // clean \"external state\" is recomputed.\n  //\n  //   Mutate inputs...                                             ...observe clean/consistent output!\n  //\n  //            .-> Base ThreadDB ---------+                 +----> Clean threads by ID           (Part 1)\n  //           /                           |                 |\n  //   mutate ----> Base Notifications --+ |                 | +--> Clean notifications           (Part 1)\n  //          \\                          | |                 | |    & notifications by ID\n  //         | \\                         | |      Apply      | |\n  //         |   `-> OptimisticUpdates --+--+--> Optimistic --+-+--> Room Notification Settings   (Part 2)\n  //          \\                          |        Updates    |  |\n  //           `------- etc etc ---------+                   |  +--> History Versions             (Part 3)\n  //                       ^                                 |\n  //                       |                                 +-----> User Notification Settings   (Part 4)\n  //                       |\n  //                       |\n  //                       |                        ^                  ^\n  //                    Signal                      |                  |\n  //                      or                   DerivedSignal      DerivedSignals\n  //                  MutableSignal\n  //\n  //\n  // Input signals.\n  // (Can be mutated directly.)\n  //\n  // XXX_vincent Now that we have createStore_forX, we should probably also change\n  // `threads` to this pattern, ie create a createStore_forThreads helper as\n  // well. It almost works like that already anyway!\n  threads;\n  // Exposes its signal under `.signal` prop\n  notifications;\n  roomNotificationSettings;\n  // prettier-ignore\n  historyVersions;\n  permissionHints;\n  userNotificationSettings;\n  optimisticUpdates;\n  //\n  // Output signals.\n  // (Readonly, clean, consistent. With optimistic updates applied.)\n  //\n  // Note that the output of threadifications signal is the same as the ones for\n  // threads and notifications separately, but the threadifications signal will\n  // be updated whenever either of them change.\n  //\n  outputs;\n  // Notifications\n  #notificationsLastRequestedAt = null;\n  // Keeps track of when we successfully requested an inbox notifications update for the last time. Will be `null` as long as the first successful fetch hasn't happened yet.\n  #notificationsPaginationState;\n  // Room Threads\n  #roomThreadsLastRequestedAtByRoom = /* @__PURE__ */ new Map();\n  // User Threads\n  #userThreadsLastRequestedAt = null;\n  // Room versions\n  #roomVersionsLastRequestedAtByRoom = /* @__PURE__ */ new Map();\n  // User Notification Settings\n  #userNotificationSettings;\n  constructor(client) {\n    this.#client = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].as();\n    this.optimisticUpdates = createStore_forOptimistic(this.#client);\n    this.permissionHints = createStore_forPermissionHints();\n    this.#notificationsPaginationState = new PaginatedResource(\n      async (cursor) => {\n        const result = await this.#client.getInboxNotifications({ cursor });\n        this.updateThreadifications(result.threads, result.inboxNotifications);\n        if (this.#notificationsLastRequestedAt === null) {\n          this.#notificationsLastRequestedAt = result.requestedAt;\n        }\n        const nextCursor = result.nextCursor;\n        return nextCursor;\n      }\n    );\n    const userNotificationSettingsFetcher = async () => {\n      const result = await this.#client.getNotificationSettings();\n      this.userNotificationSettings.update(result);\n    };\n    this.userNotificationSettings = createStore_forUserNotificationSettings(\n      this.optimisticUpdates.signal\n    );\n    this.#userNotificationSettings = new SinglePageResource(\n      userNotificationSettingsFetcher\n    );\n    this.threads = new ThreadDB();\n    this.notifications = createStore_forNotifications();\n    this.roomNotificationSettings = createStore_forRoomNotificationSettings(\n      this.optimisticUpdates.signal\n    );\n    this.historyVersions = createStore_forHistoryVersions();\n    const threadifications = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(\n      this.threads.signal,\n      this.notifications.signal,\n      this.optimisticUpdates.signal,\n      (ts, ns, updates) => applyOptimisticUpdates_forThreadifications(ts, ns, updates)\n    );\n    const threads = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(threadifications, (s) => s.threadsDB);\n    const notifications = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(\n      threadifications,\n      (s) => ({\n        sortedNotifications: s.sortedNotifications,\n        notificationsById: s.notificationsById\n      }),\n      _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n    );\n    const loadingUserThreads = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n      (queryKey) => {\n        const query = JSON.parse(queryKey);\n        const resource = new PaginatedResource(async (cursor) => {\n          const result = await this.#client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.getUserThreads_experimental({\n            cursor,\n            query\n          });\n          this.updateThreadifications(\n            result.threads,\n            result.inboxNotifications\n          );\n          this.permissionHints.update(result.permissionHints);\n          if (this.#userThreadsLastRequestedAt === null) {\n            this.#userThreadsLastRequestedAt = result.requestedAt;\n          }\n          return result.nextCursor;\n        });\n        const signal = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          }\n          const threads2 = this.outputs.threads.get().findMany(\n            void 0,\n            // Do _not_ filter by roomId\n            query ?? {},\n            \"desc\"\n          );\n          const page = result.data;\n          return {\n            isLoading: false,\n            threads: threads2,\n            hasFetchedAll: page.hasFetchedAll,\n            isFetchingMore: page.isFetchingMore,\n            fetchMoreError: page.fetchMoreError,\n            fetchMore: page.fetchMore\n          };\n        }, shallow2);\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n    const loadingRoomThreads = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n      (queryKey) => {\n        const [roomId, query] = JSON.parse(queryKey);\n        const resource = new PaginatedResource(async (cursor) => {\n          const result = await this.#client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.getThreads({\n            roomId,\n            cursor,\n            query\n          });\n          this.updateThreadifications(\n            result.threads,\n            result.inboxNotifications\n          );\n          this.permissionHints.update(result.permissionHints);\n          const lastRequestedAt = this.#roomThreadsLastRequestedAtByRoom.get(roomId);\n          if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {\n            this.#roomThreadsLastRequestedAtByRoom.set(\n              roomId,\n              result.requestedAt\n            );\n          }\n          return result.nextCursor;\n        });\n        const signal = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          }\n          const threads2 = this.outputs.threads.get().findMany(roomId, query ?? {}, \"asc\");\n          const page = result.data;\n          return {\n            isLoading: false,\n            threads: threads2,\n            hasFetchedAll: page.hasFetchedAll,\n            isFetchingMore: page.isFetchingMore,\n            fetchMoreError: page.fetchMoreError,\n            fetchMore: page.fetchMore\n          };\n        }, shallow2);\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n    const loadingNotifications = {\n      signal: _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n        const resource = this.#notificationsPaginationState;\n        const result = resource.get();\n        if (result.isLoading || result.error) {\n          return result;\n        }\n        const page = result.data;\n        return {\n          isLoading: false,\n          inboxNotifications: this.outputs.notifications.get().sortedNotifications,\n          hasFetchedAll: page.hasFetchedAll,\n          isFetchingMore: page.isFetchingMore,\n          fetchMoreError: page.fetchMoreError,\n          fetchMore: page.fetchMore\n        };\n      }),\n      waitUntilLoaded: this.#notificationsPaginationState.waitUntilLoaded\n    };\n    const settingsByRoomId = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap((roomId) => {\n      const resource = new SinglePageResource(async () => {\n        const room = this.#client.getRoom(roomId);\n        if (room === null) {\n          throw new Error(`Room '${roomId}' is not available on client`);\n        }\n        const result = await room.getNotificationSettings();\n        this.roomNotificationSettings.update(roomId, result);\n      });\n      const signal = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n        const result = resource.get();\n        if (result.isLoading || result.error) {\n          return result;\n        } else {\n          return ASYNC_OK(\n            \"settings\",\n            (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(this.roomNotificationSettings.signal.get()[roomId])\n          );\n        }\n      }, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow);\n      return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n    });\n    const versionsByRoomId = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n      (roomId) => {\n        const resource = new SinglePageResource(async () => {\n          const room = this.#client.getRoom(roomId);\n          if (room === null) {\n            throw new Error(`Room '${roomId}' is not available on client`);\n          }\n          const result = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].listTextVersions();\n          this.historyVersions.update(roomId, result.versions);\n          const lastRequestedAt = this.#roomVersionsLastRequestedAtByRoom.get(roomId);\n          if (lastRequestedAt === void 0 || lastRequestedAt > result.requestedAt) {\n            this.#roomVersionsLastRequestedAtByRoom.set(\n              roomId,\n              result.requestedAt\n            );\n          }\n        });\n        const signal = _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n          const result = resource.get();\n          if (result.isLoading || result.error) {\n            return result;\n          } else {\n            return ASYNC_OK(\n              \"versions\",\n              Object.values(this.historyVersions.signal.get()[roomId] ?? {})\n            );\n          }\n        }, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow);\n        return { signal, waitUntilLoaded: resource.waitUntilLoaded };\n      }\n    );\n    const userNotificationSettings = {\n      signal: _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DerivedSignal.from(() => {\n        const result = this.#userNotificationSettings.get();\n        if (result.isLoading || result.error) {\n          return result;\n        }\n        return ASYNC_OK(\n          \"settings\",\n          (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(this.userNotificationSettings.signal.get())\n        );\n      }, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow),\n      waitUntilLoaded: this.#userNotificationSettings.waitUntilLoaded\n    };\n    this.outputs = {\n      threadifications,\n      threads,\n      loadingRoomThreads,\n      loadingUserThreads,\n      notifications,\n      loadingNotifications,\n      settingsByRoomId,\n      versionsByRoomId,\n      userNotificationSettings\n    };\n    autobind(this);\n  }\n  /**\n   * Updates an existing inbox notification with a new value, replacing the\n   * corresponding optimistic update.\n   *\n   * This will not update anything if the inbox notification ID isn't found.\n   */\n  markInboxNotificationRead(inboxNotificationId, readAt, optimisticId) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.markRead(inboxNotificationId, readAt);\n    });\n  }\n  markAllInboxNotificationsRead(optimisticId, readAt) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.markAllRead(readAt);\n    });\n  }\n  /**\n   * Deletes an existing inbox notification, replacing the corresponding\n   * optimistic update.\n   */\n  deleteInboxNotification(inboxNotificationId, optimisticId) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.delete(inboxNotificationId);\n    });\n  }\n  /**\n   * Deletes *all* inbox notifications, replacing the corresponding optimistic\n   * update.\n   */\n  deleteAllInboxNotifications(optimisticId) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.notifications.clear();\n    });\n  }\n  /**\n   * Creates an new thread, replacing the corresponding optimistic update.\n   */\n  createThread(optimisticId, thread) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.threads.upsert(thread);\n    });\n  }\n  /**\n   * Updates an existing thread with a new value, replacing the corresponding\n   * optimistic update.\n   *\n   * This will not update anything if:\n   * - The thread ID isn't found; or\n   * - The thread ID was already deleted; or\n   * - The thread ID was updated more recently than the optimistic update's\n   *   timestamp (if given)\n   */\n  #updateThread(threadId, optimisticId, callback, updatedAt) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      if (optimisticId !== null) {\n        this.optimisticUpdates.remove(optimisticId);\n      }\n      const db = this.threads;\n      const existing = db.get(threadId);\n      if (!existing) return;\n      if (!!updatedAt && existing.updatedAt > updatedAt) return;\n      db.upsert(callback(existing));\n    });\n  }\n  patchThread(threadId, optimisticId, patch, updatedAt) {\n    return this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => ({ ...thread, ...(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.compactObject)(patch) }),\n      updatedAt\n    );\n  }\n  addReaction(threadId, optimisticId, commentId, reaction, createdAt) {\n    this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => applyAddReaction(thread, commentId, reaction),\n      createdAt\n    );\n  }\n  removeReaction(threadId, optimisticId, commentId, emoji, userId, removedAt) {\n    this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => applyRemoveReaction(thread, commentId, emoji, userId, removedAt),\n      removedAt\n    );\n  }\n  /**\n   * Soft-deletes an existing thread by setting its `deletedAt` value,\n   * replacing the corresponding optimistic update.\n   *\n   * This will not update anything if:\n   * - The thread ID isn't found; or\n   * - The thread ID was already deleted\n   */\n  deleteThread(threadId, optimisticId) {\n    return this.#updateThread(\n      threadId,\n      optimisticId,\n      // A deletion is actually an update of the deletedAt property internally\n      (thread) => ({ ...thread, updatedAt: /* @__PURE__ */ new Date(), deletedAt: /* @__PURE__ */ new Date() })\n    );\n  }\n  /**\n   * Creates an existing comment and ensures the associated notification is\n   * updated correctly, replacing the corresponding optimistic update.\n   */\n  createComment(newComment, optimisticId) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      const existingThread = this.threads.get(newComment.threadId);\n      if (!existingThread) {\n        return;\n      }\n      this.threads.upsert(applyUpsertComment(existingThread, newComment));\n      this.notifications.updateAssociatedNotification(newComment);\n    });\n  }\n  editComment(threadId, optimisticId, editedComment) {\n    return this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => applyUpsertComment(thread, editedComment)\n    );\n  }\n  deleteComment(threadId, optimisticId, commentId, deletedAt) {\n    return this.#updateThread(\n      threadId,\n      optimisticId,\n      (thread) => applyDeleteComment(thread, commentId, deletedAt),\n      deletedAt\n    );\n  }\n  updateThreadifications(threads, notifications, deletedThreads = [], deletedNotifications = []) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.threads.applyDelta(threads, deletedThreads);\n      this.notifications.applyDelta(notifications, deletedNotifications);\n    });\n  }\n  /**\n   * Updates existing notification setting for a room with a new value,\n   * replacing the corresponding optimistic update.\n   */\n  updateRoomNotificationSettings(roomId, optimisticId, settings) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticId);\n      this.roomNotificationSettings.update(roomId, settings);\n    });\n  }\n  async fetchNotificationsDeltaUpdate(signal) {\n    const lastRequestedAt = this.#notificationsLastRequestedAt;\n    if (lastRequestedAt === null) {\n      return;\n    }\n    const result = await this.#client.getInboxNotificationsSince({\n      since: lastRequestedAt,\n      signal\n    });\n    if (lastRequestedAt < result.requestedAt) {\n      this.#notificationsLastRequestedAt = result.requestedAt;\n    }\n    this.updateThreadifications(\n      result.threads.updated,\n      result.inboxNotifications.updated,\n      result.threads.deleted,\n      result.inboxNotifications.deleted\n    );\n  }\n  async fetchRoomThreadsDeltaUpdate(roomId, signal) {\n    const lastRequestedAt = this.#roomThreadsLastRequestedAtByRoom.get(roomId);\n    if (lastRequestedAt === void 0) {\n      return;\n    }\n    const updates = await this.#client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.getThreadsSince({\n      roomId,\n      since: lastRequestedAt,\n      signal\n    });\n    this.updateThreadifications(\n      updates.threads.updated,\n      updates.inboxNotifications.updated,\n      updates.threads.deleted,\n      updates.inboxNotifications.deleted\n    );\n    this.permissionHints.update(updates.permissionHints);\n    if (lastRequestedAt < updates.requestedAt) {\n      this.#roomThreadsLastRequestedAtByRoom.set(roomId, updates.requestedAt);\n    }\n  }\n  async fetchUserThreadsDeltaUpdate(signal) {\n    const lastRequestedAt = this.#userThreadsLastRequestedAt;\n    if (lastRequestedAt === null) {\n      return;\n    }\n    const result = await this.#client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.getUserThreadsSince_experimental({\n      since: lastRequestedAt,\n      signal\n    });\n    if (lastRequestedAt < result.requestedAt) {\n      this.#notificationsLastRequestedAt = result.requestedAt;\n    }\n    this.updateThreadifications(\n      result.threads.updated,\n      result.inboxNotifications.updated,\n      result.threads.deleted,\n      result.inboxNotifications.deleted\n    );\n    this.permissionHints.update(result.permissionHints);\n  }\n  async fetchRoomVersionsDeltaUpdate(roomId, signal) {\n    const lastRequestedAt = this.#roomVersionsLastRequestedAtByRoom.get(roomId);\n    if (lastRequestedAt === void 0) {\n      return;\n    }\n    const room = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(\n      this.#client.getRoom(roomId),\n      `Room with id ${roomId} is not available on client`\n    );\n    const updates = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].listTextVersionsSince({\n      since: lastRequestedAt,\n      signal\n    });\n    this.historyVersions.update(roomId, updates.versions);\n    if (lastRequestedAt < updates.requestedAt) {\n      this.#roomVersionsLastRequestedAtByRoom.set(roomId, updates.requestedAt);\n    }\n  }\n  async refreshRoomNotificationSettings(roomId, signal) {\n    const room = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.nn)(\n      this.#client.getRoom(roomId),\n      `Room with id ${roomId} is not available on client`\n    );\n    const result = await room.getNotificationSettings({ signal });\n    this.roomNotificationSettings.update(roomId, result);\n  }\n  /**\n   * Refresh User Notification Settings from poller\n   */\n  async refreshUserNotificationSettings(signal) {\n    const result = await this.#client.getNotificationSettings({\n      signal\n    });\n    this.userNotificationSettings.update(result);\n  }\n  /**\n   * Updates user notification settings with a new value, replacing the\n   * corresponding optimistic update.\n   */\n  updateUserNotificationSettings_confirmOptimisticUpdate(settings, optimisticUpdateId) {\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.batch)(() => {\n      this.optimisticUpdates.remove(optimisticUpdateId);\n      this.userNotificationSettings.update(settings);\n    });\n  }\n};\nfunction applyOptimisticUpdates_forThreadifications(baseThreadsDB, notificationsLUT, optimisticUpdates) {\n  const threadsDB = baseThreadsDB.clone();\n  let notificationsById = Object.fromEntries(notificationsLUT);\n  for (const optimisticUpdate of optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"create-thread\": {\n        threadsDB.upsert(optimisticUpdate.thread);\n        break;\n      }\n      case \"edit-thread-metadata\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        if (thread.updatedAt > optimisticUpdate.updatedAt) {\n          break;\n        }\n        threadsDB.upsert({\n          ...thread,\n          updatedAt: optimisticUpdate.updatedAt,\n          metadata: {\n            ...thread.metadata,\n            ...optimisticUpdate.metadata\n          }\n        });\n        break;\n      }\n      case \"mark-thread-as-resolved\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert({ ...thread, resolved: true });\n        break;\n      }\n      case \"mark-thread-as-unresolved\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert({ ...thread, resolved: false });\n        break;\n      }\n      case \"create-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.comment.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));\n        const inboxNotification = Object.values(notificationsById).find(\n          (notification) => notification.kind === \"thread\" && notification.threadId === thread.id\n        );\n        if (inboxNotification === void 0) {\n          break;\n        }\n        notificationsById[inboxNotification.id] = {\n          ...inboxNotification,\n          notifiedAt: optimisticUpdate.comment.createdAt,\n          readAt: optimisticUpdate.comment.createdAt\n        };\n        break;\n      }\n      case \"edit-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.comment.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));\n        break;\n      }\n      case \"delete-comment\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(\n          applyDeleteComment(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.deletedAt\n          )\n        );\n        break;\n      }\n      case \"delete-thread\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert({\n          ...thread,\n          deletedAt: optimisticUpdate.deletedAt,\n          updatedAt: optimisticUpdate.deletedAt,\n          comments: []\n        });\n        break;\n      }\n      case \"add-reaction\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(\n          applyAddReaction(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.reaction\n          )\n        );\n        break;\n      }\n      case \"remove-reaction\": {\n        const thread = threadsDB.get(optimisticUpdate.threadId);\n        if (thread === void 0) break;\n        threadsDB.upsert(\n          applyRemoveReaction(\n            thread,\n            optimisticUpdate.commentId,\n            optimisticUpdate.emoji,\n            optimisticUpdate.userId,\n            optimisticUpdate.removedAt\n          )\n        );\n        break;\n      }\n      case \"mark-inbox-notification-as-read\": {\n        const ibn = notificationsById[optimisticUpdate.inboxNotificationId];\n        if (ibn === void 0) {\n          break;\n        }\n        notificationsById[optimisticUpdate.inboxNotificationId] = {\n          ...ibn,\n          readAt: optimisticUpdate.readAt\n        };\n        break;\n      }\n      case \"mark-all-inbox-notifications-as-read\": {\n        for (const id in notificationsById) {\n          const ibn = notificationsById[id];\n          if (ibn === void 0) {\n            break;\n          }\n          notificationsById[id] = {\n            ...ibn,\n            readAt: optimisticUpdate.readAt\n          };\n        }\n        break;\n      }\n      case \"delete-inbox-notification\": {\n        delete notificationsById[optimisticUpdate.inboxNotificationId];\n        break;\n      }\n      case \"delete-all-inbox-notifications\": {\n        notificationsById = {};\n        break;\n      }\n    }\n  }\n  const sortedNotifications = (\n    // Sort so that the most recent notifications are first\n    Object.values(notificationsById).filter(\n      (ibn) => ibn.kind === \"thread\" ? threadsDB.get(ibn.threadId) !== void 0 : true\n    ).sort((a, b) => b.notifiedAt.getTime() - a.notifiedAt.getTime())\n  );\n  return {\n    sortedNotifications,\n    notificationsById,\n    threadsDB\n  };\n}\nfunction applyOptimisticUpdates_forSettings(settingsLUT, optimisticUpdates) {\n  const settingsByRoomId = Object.fromEntries(settingsLUT);\n  for (const optimisticUpdate of optimisticUpdates) {\n    switch (optimisticUpdate.type) {\n      case \"update-notification-settings\": {\n        const settings = settingsByRoomId[optimisticUpdate.roomId];\n        if (settings === void 0) {\n          break;\n        }\n        settingsByRoomId[optimisticUpdate.roomId] = {\n          ...settings,\n          ...optimisticUpdate.settings\n        };\n      }\n    }\n  }\n  return settingsByRoomId;\n}\nfunction applyOptimisticUpdates_forUserNotificationSettings(settings, optimisticUpdates) {\n  let outcoming = settings;\n  for (const update of optimisticUpdates) {\n    if (update.type === \"update-user-notification-settings\") {\n      outcoming = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.patchUserNotificationSettings)(outcoming, update.settings);\n    }\n  }\n  return outcoming;\n}\nfunction compareInboxNotifications(inboxNotificationA, inboxNotificationB) {\n  if (inboxNotificationA.notifiedAt > inboxNotificationB.notifiedAt) {\n    return 1;\n  } else if (inboxNotificationA.notifiedAt < inboxNotificationB.notifiedAt) {\n    return -1;\n  }\n  if (inboxNotificationA.readAt && inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt > inboxNotificationB.readAt ? 1 : inboxNotificationA.readAt < inboxNotificationB.readAt ? -1 : 0;\n  } else if (inboxNotificationA.readAt || inboxNotificationB.readAt) {\n    return inboxNotificationA.readAt ? 1 : -1;\n  }\n  return 0;\n}\nfunction applyUpsertComment(thread, comment) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  if (comment.threadId !== thread.id) {\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(\n      `Comment ${comment.id} does not belong to thread ${thread.id}`\n    );\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (existingComment2) => existingComment2.id === comment.id\n  );\n  if (existingComment === void 0) {\n    const updatedAt = new Date(\n      Math.max(thread.updatedAt.getTime(), comment.createdAt.getTime())\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt,\n      comments: [...thread.comments, comment]\n    };\n    return updatedThread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  if (existingComment.editedAt === void 0 || comment.editedAt === void 0 || existingComment.editedAt <= comment.editedAt) {\n    const updatedComments = thread.comments.map(\n      (existingComment2) => existingComment2.id === comment.id ? comment : existingComment2\n    );\n    const updatedThread = {\n      ...thread,\n      updatedAt: new Date(\n        Math.max(\n          thread.updatedAt.getTime(),\n          comment.editedAt?.getTime() || comment.createdAt.getTime()\n        )\n      ),\n      comments: updatedComments\n    };\n    return updatedThread;\n  }\n  return thread;\n}\nfunction applyDeleteComment(thread, commentId, deletedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      deletedAt,\n      // We optimistically remove the comment body and attachments when marking it as deleted\n      body: void 0,\n      attachments: []\n    } : comment\n  );\n  if (updatedComments.every((comment) => comment.deletedAt !== void 0)) {\n    return {\n      ...thread,\n      deletedAt,\n      updatedAt: deletedAt\n    };\n  }\n  return {\n    ...thread,\n    updatedAt: deletedAt,\n    comments: updatedComments\n  };\n}\nfunction applyAddReaction(thread, commentId, reaction) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: upsertReaction(comment.reactions, reaction)\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(reaction.createdAt.getTime(), thread.updatedAt.getTime())\n    ),\n    comments: updatedComments\n  };\n}\nfunction applyRemoveReaction(thread, commentId, emoji, userId, removedAt) {\n  if (thread.deletedAt !== void 0) {\n    return thread;\n  }\n  const existingComment = thread.comments.find(\n    (comment) => comment.id === commentId\n  );\n  if (existingComment === void 0) {\n    return thread;\n  }\n  if (existingComment.deletedAt !== void 0) {\n    return thread;\n  }\n  const updatedComments = thread.comments.map(\n    (comment) => comment.id === commentId ? {\n      ...comment,\n      reactions: comment.reactions.map(\n        (reaction) => reaction.emoji === emoji ? {\n          ...reaction,\n          users: reaction.users.filter((user) => user.id !== userId)\n        } : reaction\n      ).filter((reaction) => reaction.users.length > 0)\n      // Remove reactions with no users left\n    } : comment\n  );\n  return {\n    ...thread,\n    updatedAt: new Date(\n      Math.max(removedAt.getTime(), thread.updatedAt.getTime())\n    ),\n    comments: updatedComments\n  };\n}\nfunction upsertReaction(reactions, reaction) {\n  const existingReaction = reactions.find(\n    (existingReaction2) => existingReaction2.emoji === reaction.emoji\n  );\n  if (existingReaction === void 0) {\n    return [\n      ...reactions,\n      {\n        emoji: reaction.emoji,\n        createdAt: reaction.createdAt,\n        users: [{ id: reaction.userId }]\n      }\n    ];\n  }\n  if (existingReaction.users.some((user) => user.id === reaction.userId) === false) {\n    return reactions.map(\n      (existingReaction2) => existingReaction2.emoji === reaction.emoji ? {\n        ...existingReaction2,\n        users: [...existingReaction2.users, { id: reaction.userId }]\n      } : existingReaction2\n    );\n  }\n  return reactions;\n}\n\n// src/liveblocks.tsx\n\nvar ClientContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction missingUserError(userId) {\n  return new Error(`resolveUsers didn't return anything for user '${userId}'`);\n}\nfunction missingRoomInfoError(roomId) {\n  return new Error(\n    `resolveRoomsInfo didn't return anything for room '${roomId}'`\n  );\n}\nfunction identity2(x) {\n  return x;\n}\nvar _umbrellaStores = /* @__PURE__ */ new WeakMap();\nvar _extras = /* @__PURE__ */ new WeakMap();\nvar _bundles = /* @__PURE__ */ new WeakMap();\nfunction selectorFor_useUnreadInboxNotificationsCount(result) {\n  if (!result.inboxNotifications) {\n    return result;\n  }\n  return ASYNC_OK(\n    \"count\",\n    count(\n      result.inboxNotifications,\n      (n) => n.readAt === null || n.readAt < n.notifiedAt\n    )\n  );\n}\nfunction selectorFor_useUser(state, userId) {\n  if (state === void 0 || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n  if (state.error) {\n    return state;\n  }\n  if (!state.data) {\n    return {\n      isLoading: false,\n      error: missingUserError(userId)\n    };\n  }\n  return {\n    isLoading: false,\n    user: state.data\n  };\n}\nfunction selectorFor_useRoomInfo(state, roomId) {\n  if (state === void 0 || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n  if (state.error) {\n    return state;\n  }\n  if (!state.data) {\n    return {\n      isLoading: false,\n      error: missingRoomInfoError(roomId)\n    };\n  }\n  return {\n    isLoading: false,\n    info: state.data\n  };\n}\nfunction getOrCreateContextBundle(client) {\n  let bundle = _bundles.get(client);\n  if (!bundle) {\n    bundle = makeLiveblocksContextBundle(client);\n    _bundles.set(client, bundle);\n  }\n  return bundle;\n}\nfunction getUmbrellaStoreForClient(client) {\n  let store = _umbrellaStores.get(client);\n  if (!store) {\n    store = new UmbrellaStore(client);\n    _umbrellaStores.set(client, store);\n  }\n  return store;\n}\nfunction getLiveblocksExtrasForClient(client) {\n  let extras = _extras.get(client);\n  if (!extras) {\n    extras = makeLiveblocksExtrasForClient(client);\n    _extras.set(client, extras);\n  }\n  return extras;\n}\nfunction makeLiveblocksExtrasForClient(client) {\n  const store = getUmbrellaStoreForClient(client);\n  const notificationsPoller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makePoller)(\n    async (signal) => {\n      try {\n        return await store.fetchNotificationsDeltaUpdate(signal);\n      } catch (err) {\n        console.warn(`Polling new inbox notifications failed: ${String(err)}`);\n        throw err;\n      }\n    },\n    config.NOTIFICATIONS_POLL_INTERVAL,\n    { maxStaleTimeMs: config.NOTIFICATIONS_MAX_STALE_TIME }\n  );\n  const userThreadsPoller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makePoller)(\n    async (signal) => {\n      try {\n        return await store.fetchUserThreadsDeltaUpdate(signal);\n      } catch (err) {\n        console.warn(`Polling new user threads failed: ${String(err)}`);\n        throw err;\n      }\n    },\n    config.USER_THREADS_POLL_INTERVAL,\n    { maxStaleTimeMs: config.USER_THREADS_MAX_STALE_TIME }\n  );\n  const userNotificationSettingsPoller = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makePoller)(\n    async (signal) => {\n      try {\n        return await store.refreshUserNotificationSettings(signal);\n      } catch (err) {\n        console.warn(\n          `Polling new user notification settings failed: ${String(err)}`\n        );\n        throw err;\n      }\n    },\n    config.USER_NOTIFICATION_SETTINGS_INTERVAL,\n    { maxStaleTimeMs: config.USER_NOTIFICATION_SETTINGS_MAX_STALE_TIME }\n  );\n  return {\n    store,\n    notificationsPoller,\n    userThreadsPoller,\n    userNotificationSettingsPoller\n  };\n}\nfunction makeLiveblocksContextBundle(client) {\n  const useInboxNotificationThread2 = (inboxNotificationId) => useInboxNotificationThread_withClient(client, inboxNotificationId);\n  const useMarkInboxNotificationAsRead2 = () => useMarkInboxNotificationAsRead_withClient(client);\n  const useMarkAllInboxNotificationsAsRead2 = () => useMarkAllInboxNotificationsAsRead_withClient(client);\n  const useDeleteInboxNotification2 = () => useDeleteInboxNotification_withClient(client);\n  const useDeleteAllInboxNotifications2 = () => useDeleteAllInboxNotifications_withClient(client);\n  const useUpdateNotificationSettings2 = () => useUpdateNotificationSettings_withClient(client);\n  function LiveblocksProvider2(props) {\n    useEnsureNoLiveblocksProvider();\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ClientContext.Provider, { value: client, children: props.children });\n  }\n  const shared = createSharedContext(client);\n  const bundle = {\n    LiveblocksProvider: LiveblocksProvider2,\n    useInboxNotifications: () => useInboxNotifications_withClient(client, identity2, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow),\n    useUnreadInboxNotificationsCount: () => useUnreadInboxNotificationsCount_withClient(client),\n    useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,\n    useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,\n    useDeleteInboxNotification: useDeleteInboxNotification2,\n    useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,\n    useNotificationSettings: () => useNotificationSettings_withClient(client),\n    useUpdateNotificationSettings: useUpdateNotificationSettings2,\n    useInboxNotificationThread: useInboxNotificationThread2,\n    useUserThreads_experimental,\n    ...shared.classic,\n    suspense: {\n      LiveblocksProvider: LiveblocksProvider2,\n      useInboxNotifications: () => useInboxNotificationsSuspense_withClient(client),\n      useUnreadInboxNotificationsCount: () => useUnreadInboxNotificationsCountSuspense_withClient(client),\n      useMarkInboxNotificationAsRead: useMarkInboxNotificationAsRead2,\n      useMarkAllInboxNotificationsAsRead: useMarkAllInboxNotificationsAsRead2,\n      useDeleteInboxNotification: useDeleteInboxNotification2,\n      useDeleteAllInboxNotifications: useDeleteAllInboxNotifications2,\n      useInboxNotificationThread: useInboxNotificationThread2,\n      useNotificationSettings: () => useNotificationSettingsSuspense_withClient(client),\n      useUpdateNotificationSettings: useUpdateNotificationSettings2,\n      useUserThreads_experimental: useUserThreadsSuspense_experimental,\n      ...shared.suspense\n    }\n  };\n  return bundle;\n}\nfunction useInboxNotifications_withClient(client, selector, isEqual) {\n  const { store, notificationsPoller: poller } = getLiveblocksExtrasForClient(client);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void store.outputs.loadingNotifications.waitUntilLoaded()\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n  return useSignal(\n    store.outputs.loadingNotifications.signal,\n    selector,\n    isEqual\n  );\n}\nfunction useInboxNotificationsSuspense_withClient(client) {\n  ensureNotServerSide();\n  const store = getLiveblocksExtrasForClient(client).store;\n  use(store.outputs.loadingNotifications.waitUntilLoaded());\n  const result = useInboxNotifications_withClient(client, identity2, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction useUnreadInboxNotificationsCount_withClient(client) {\n  return useInboxNotifications_withClient(\n    client,\n    selectorFor_useUnreadInboxNotificationsCount,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n  );\n}\nfunction useUnreadInboxNotificationsCountSuspense_withClient(client) {\n  ensureNotServerSide();\n  const store = getLiveblocksExtrasForClient(client).store;\n  use(store.outputs.loadingNotifications.waitUntilLoaded());\n  const result = useUnreadInboxNotificationsCount_withClient(client);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  return result;\n}\nfunction useMarkInboxNotificationAsRead_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (inboxNotificationId) => {\n      const { store } = getLiveblocksExtrasForClient(client);\n      const readAt = /* @__PURE__ */ new Date();\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-inbox-notification-as-read\",\n        inboxNotificationId,\n        readAt\n      });\n      client.markInboxNotificationAsRead(inboxNotificationId).then(\n        () => {\n          store.markInboxNotificationRead(\n            inboxNotificationId,\n            readAt,\n            optimisticId\n          );\n        },\n        (err) => {\n          store.optimisticUpdates.remove(optimisticId);\n          client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].emitError(\n            {\n              type: \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\",\n              inboxNotificationId\n            },\n            err\n          );\n        }\n      );\n    },\n    [client]\n  );\n}\nfunction useMarkAllInboxNotificationsAsRead_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const { store } = getLiveblocksExtrasForClient(client);\n    const readAt = /* @__PURE__ */ new Date();\n    const optimisticId = store.optimisticUpdates.add({\n      type: \"mark-all-inbox-notifications-as-read\",\n      readAt\n    });\n    client.markAllInboxNotificationsAsRead().then(\n      () => {\n        store.markAllInboxNotificationsRead(optimisticId, readAt);\n      },\n      (err) => {\n        store.optimisticUpdates.remove(optimisticId);\n        client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].emitError(\n          // No roomId, threadId, commentId to include for this error\n          { type: \"MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR\" },\n          err\n        );\n      }\n    );\n  }, [client]);\n}\nfunction useDeleteInboxNotification_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (inboxNotificationId) => {\n      const { store } = getLiveblocksExtrasForClient(client);\n      const deletedAt = /* @__PURE__ */ new Date();\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"delete-inbox-notification\",\n        inboxNotificationId,\n        deletedAt\n      });\n      client.deleteInboxNotification(inboxNotificationId).then(\n        () => {\n          store.deleteInboxNotification(inboxNotificationId, optimisticId);\n        },\n        (err) => {\n          store.optimisticUpdates.remove(optimisticId);\n          client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].emitError(\n            { type: \"DELETE_INBOX_NOTIFICATION_ERROR\", inboxNotificationId },\n            err\n          );\n        }\n      );\n    },\n    [client]\n  );\n}\nfunction useDeleteAllInboxNotifications_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const { store } = getLiveblocksExtrasForClient(client);\n    const deletedAt = /* @__PURE__ */ new Date();\n    const optimisticId = store.optimisticUpdates.add({\n      type: \"delete-all-inbox-notifications\",\n      deletedAt\n    });\n    client.deleteAllInboxNotifications().then(\n      () => {\n        store.deleteAllInboxNotifications(optimisticId);\n      },\n      (err) => {\n        store.optimisticUpdates.remove(optimisticId);\n        client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].emitError(\n          { type: \"DELETE_ALL_INBOX_NOTIFICATIONS_ERROR\" },\n          err\n        );\n      }\n    );\n  }, [client]);\n}\nfunction useInboxNotificationThread_withClient(client, inboxNotificationId) {\n  const { store } = getLiveblocksExtrasForClient(client);\n  return useSignal(\n    store.outputs.threadifications,\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n      (state) => {\n        const inboxNotification = state.notificationsById[inboxNotificationId] ?? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.raise)(\n          `Inbox notification with ID \"${inboxNotificationId}\" not found`\n        );\n        if (inboxNotification.kind !== \"thread\") {\n          (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.raise)(\n            `Inbox notification with ID \"${inboxNotificationId}\" is not of kind \"thread\"`\n          );\n        }\n        const thread = state.threadsDB.get(inboxNotification.threadId) ?? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.raise)(\n          `Thread with ID \"${inboxNotification.threadId}\" not found, this inbox notification might not be of kind \"thread\"`\n        );\n        return thread;\n      },\n      [inboxNotificationId]\n    )\n  );\n}\nfunction useUpdateNotificationSettings_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (settings) => {\n      const { store } = getLiveblocksExtrasForClient(client);\n      const optimisticUpdateId = store.optimisticUpdates.add({\n        type: \"update-user-notification-settings\",\n        settings\n      });\n      client.updateNotificationSettings(settings).then(\n        (settings2) => {\n          store.updateUserNotificationSettings_confirmOptimisticUpdate(\n            settings2,\n            optimisticUpdateId\n          );\n        },\n        (err) => {\n          store.optimisticUpdates.remove(optimisticUpdateId);\n          if (err instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.HttpError) {\n            if (err.status === 422) {\n              const msg = [err.details?.error, err.details?.reason].filter(Boolean).join(\"\\n\");\n              console.error(msg);\n            }\n            client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].emitError(\n              {\n                type: \"UPDATE_USER_NOTIFICATION_SETTINGS_ERROR\"\n              },\n              err\n            );\n          } else {\n            throw err;\n          }\n        }\n      );\n    },\n    [client]\n  );\n}\nfunction useNotificationSettings_withClient(client) {\n  const updateNotificationSettings = useUpdateNotificationSettings_withClient(client);\n  const { store, userNotificationSettingsPoller: poller } = getLiveblocksExtrasForClient(client);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    void store.outputs.userNotificationSettings.waitUntilLoaded();\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n  const result = useSignal(store.outputs.userNotificationSettings.signal);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return [result, updateNotificationSettings];\n  }, [result, updateNotificationSettings]);\n}\nfunction useNotificationSettingsSuspense_withClient(client) {\n  ensureNotServerSide();\n  const store = getLiveblocksExtrasForClient(client).store;\n  use(store.outputs.userNotificationSettings.waitUntilLoaded());\n  const [result, updateNotificationSettings] = useNotificationSettings_withClient(client);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return [result, updateNotificationSettings];\n  }, [result, updateNotificationSettings]);\n}\nfunction useUser_withClient(client, userId) {\n  const usersStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].usersStore;\n  const getUserState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => usersStore.getItemState(userId),\n    [usersStore, userId]\n  );\n  const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (state) => selectorFor_useUser(state, userId),\n    [userId]\n  );\n  const result = useSyncExternalStoreWithSelector(\n    usersStore.subscribe,\n    getUserState,\n    getUserState,\n    selector,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void usersStore.enqueue(userId)\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call usersStore.enqueue on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger evaluation\n    //    of the userId.\n    // 2. All other subsequent renders now are a no-op (from the implementation\n    //    of .enqueue)\n    // 3. If ever the userId gets invalidated, the user would be fetched again.\n  );\n  return result;\n}\nfunction useUserSuspense_withClient(client, userId) {\n  const usersStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].usersStore;\n  const getUserState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => usersStore.getItemState(userId),\n    [usersStore, userId]\n  );\n  const userState = getUserState();\n  if (!userState || userState.isLoading) {\n    throw usersStore.enqueue(userId);\n  }\n  if (userState.error) {\n    throw userState.error;\n  }\n  if (!userState.data) {\n    throw missingUserError(userId);\n  }\n  const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(\n    usersStore.subscribe,\n    getUserState,\n    getUserState\n  );\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(state !== void 0, \"Unexpected missing state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.isLoading, \"Unexpected loading state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.error, \"Unexpected error state\");\n  return {\n    isLoading: false,\n    user: state.data,\n    error: void 0\n  };\n}\nfunction useRoomInfo_withClient(client, roomId) {\n  const roomsInfoStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].roomsInfoStore;\n  const getRoomInfoState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => roomsInfoStore.getItemState(roomId),\n    [roomsInfoStore, roomId]\n  );\n  const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (state) => selectorFor_useRoomInfo(state, roomId),\n    [roomId]\n  );\n  const result = useSyncExternalStoreWithSelector(\n    roomsInfoStore.subscribe,\n    getRoomInfoState,\n    getRoomInfoState,\n    selector,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void roomsInfoStore.enqueue(roomId)\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call roomsInfoStore.enqueue on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger evaluation\n    //    of the roomId.\n    // 2. All other subsequent renders now are a no-op (from the implementation\n    //    of .enqueue)\n    // 3. If ever the roomId gets invalidated, the room info would be fetched again.\n  );\n  return result;\n}\nfunction useRoomInfoSuspense_withClient(client, roomId) {\n  const roomsInfoStore = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].roomsInfoStore;\n  const getRoomInfoState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => roomsInfoStore.getItemState(roomId),\n    [roomsInfoStore, roomId]\n  );\n  const roomInfoState = getRoomInfoState();\n  if (!roomInfoState || roomInfoState.isLoading) {\n    throw roomsInfoStore.enqueue(roomId);\n  }\n  if (roomInfoState.error) {\n    throw roomInfoState.error;\n  }\n  if (!roomInfoState.data) {\n    throw missingRoomInfoError(roomId);\n  }\n  const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(\n    roomsInfoStore.subscribe,\n    getRoomInfoState,\n    getRoomInfoState\n  );\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(state !== void 0, \"Unexpected missing state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.isLoading, \"Unexpected loading state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.error, \"Unexpected error state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(state.data !== void 0, \"Unexpected missing room info data\");\n  return {\n    isLoading: false,\n    info: state.data,\n    error: void 0\n  };\n}\nfunction createSharedContext(client) {\n  const useClient2 = () => client;\n  function useSyncStatus2(options) {\n    return useSyncStatus_withClient(client, options);\n  }\n  return {\n    classic: {\n      useClient: useClient2,\n      useUser: (userId) => useUser_withClient(client, userId),\n      useRoomInfo: (roomId) => useRoomInfo_withClient(client, roomId),\n      useIsInsideRoom,\n      useErrorListener,\n      useSyncStatus: useSyncStatus2\n    },\n    suspense: {\n      useClient: useClient2,\n      useUser: (userId) => useUserSuspense_withClient(client, userId),\n      useRoomInfo: (roomId) => useRoomInfoSuspense_withClient(client, roomId),\n      useIsInsideRoom,\n      useErrorListener,\n      useSyncStatus: useSyncStatus2\n    }\n  };\n}\nfunction useEnsureNoLiveblocksProvider(options) {\n  const existing = useClientOrNull();\n  if (!options?.allowNesting && existing !== null) {\n    throw new Error(\n      \"You cannot nest multiple LiveblocksProvider instances in the same React tree.\"\n    );\n  }\n}\nfunction useClientOrNull() {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ClientContext);\n}\nfunction useClient() {\n  return useClientOrNull() ?? (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.raise)(\"LiveblocksProvider is missing from the React tree.\");\n}\nfunction LiveblocksProviderWithClient(props) {\n  useEnsureNoLiveblocksProvider(props);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ClientContext.Provider, { value: props.client, children: props.children });\n}\nfunction LiveblocksProvider(props) {\n  const { children, ...o } = props;\n  const options = {\n    publicApiKey: useInitial(o.publicApiKey),\n    throttle: useInitial(o.throttle),\n    lostConnectionTimeout: useInitial(o.lostConnectionTimeout),\n    backgroundKeepAliveTimeout: useInitial(o.backgroundKeepAliveTimeout),\n    polyfills: useInitial(o.polyfills),\n    largeMessageStrategy: useInitial(o.largeMessageStrategy),\n    unstable_fallbackToHTTP: useInitial(o.unstable_fallbackToHTTP),\n    unstable_streamData: useInitial(o.unstable_streamData),\n    preventUnsavedChanges: useInitial(o.preventUnsavedChanges),\n    authEndpoint: useInitialUnlessFunction(o.authEndpoint),\n    resolveMentionSuggestions: useInitialUnlessFunction(\n      o.resolveMentionSuggestions\n    ),\n    resolveUsers: useInitialUnlessFunction(o.resolveUsers),\n    resolveRoomsInfo: useInitialUnlessFunction(o.resolveRoomsInfo),\n    baseUrl: useInitial(\n      // @ts-expect-error - Hidden config options\n      o.baseUrl\n    ),\n    enableDebugLogging: useInitial(\n      // @ts-expect-error - Hidden config options\n      o.enableDebugLogging\n    )\n  };\n  const client = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.createClient)(options), []);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LiveblocksProviderWithClient, { client, children });\n}\nfunction createLiveblocksContext(client) {\n  return getOrCreateContextBundle(client);\n}\nfunction useUserThreads_experimental(options = {}) {\n  const client = useClient();\n  const { store, userThreadsPoller: poller } = getLiveblocksExtrasForClient(client);\n  const queryKey = makeUserThreadsQueryKey(options.query);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void store.outputs.loadingUserThreads.getOrCreate(queryKey).waitUntilLoaded()\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n  return useSignal(\n    store.outputs.loadingUserThreads.getOrCreate(queryKey).signal\n  );\n}\nfunction useUserThreadsSuspense_experimental(options = {}) {\n  ensureNotServerSide();\n  const client = useClient();\n  const { store } = getLiveblocksExtrasForClient(client);\n  const queryKey = makeUserThreadsQueryKey(options.query);\n  use(store.outputs.loadingUserThreads.getOrCreate(queryKey).waitUntilLoaded());\n  const result = useUserThreads_experimental(options);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction useInboxNotifications() {\n  return useInboxNotifications_withClient(useClient(), identity2, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow);\n}\nfunction useInboxNotificationsSuspense() {\n  return useInboxNotificationsSuspense_withClient(useClient());\n}\nfunction useInboxNotificationThread(inboxNotificationId) {\n  return useInboxNotificationThread_withClient(\n    useClient(),\n    inboxNotificationId\n  );\n}\nfunction useMarkAllInboxNotificationsAsRead() {\n  return useMarkAllInboxNotificationsAsRead_withClient(useClient());\n}\nfunction useMarkInboxNotificationAsRead() {\n  return useMarkInboxNotificationAsRead_withClient(useClient());\n}\nfunction useDeleteAllInboxNotifications() {\n  return useDeleteAllInboxNotifications_withClient(useClient());\n}\nfunction useDeleteInboxNotification() {\n  return useDeleteInboxNotification_withClient(useClient());\n}\nfunction useUnreadInboxNotificationsCount() {\n  return useUnreadInboxNotificationsCount_withClient(useClient());\n}\nfunction useUnreadInboxNotificationsCountSuspense() {\n  return useUnreadInboxNotificationsCountSuspense_withClient(useClient());\n}\nfunction useNotificationSettings() {\n  return useNotificationSettings_withClient(useClient());\n}\nfunction useNotificationSettingsSuspense() {\n  return useNotificationSettingsSuspense_withClient(useClient());\n}\nfunction useUpdateNotificationSettings() {\n  return useUpdateNotificationSettings_withClient(useClient());\n}\nfunction useUser(userId) {\n  const client = useClient();\n  return useUser_withClient(client, userId);\n}\nfunction useUserSuspense(userId) {\n  const client = useClient();\n  return useUserSuspense_withClient(client, userId);\n}\nfunction useRoomInfo(roomId) {\n  return useRoomInfo_withClient(useClient(), roomId);\n}\nfunction useRoomInfoSuspense(roomId) {\n  return useRoomInfoSuspense_withClient(useClient(), roomId);\n}\nvar _useInboxNotificationThread = useInboxNotificationThread;\nvar _useUser = useUser;\nvar _useUserSuspense = useUserSuspense;\nvar _useUserThreads_experimental = useUserThreads_experimental;\nvar _useUserThreadsSuspense_experimental = useUserThreadsSuspense_experimental;\nfunction useSyncStatus_withClient(client, options) {\n  const smooth = useInitial(options?.smooth ?? false);\n  if (smooth) {\n    return useSyncStatusSmooth_withClient(client);\n  } else {\n    return useSyncStatusImmediate_withClient(client);\n  }\n}\nfunction useSyncStatusImmediate_withClient(client) {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(\n    client.events.syncStatus.subscribe,\n    client.getSyncStatus,\n    client.getSyncStatus\n  );\n}\nfunction useSyncStatusSmooth_withClient(client) {\n  const getter = client.getSyncStatus;\n  const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(getter);\n  const oldStatus = useLatest(getter());\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    let timeoutId;\n    const unsub = client.events.syncStatus.subscribe(() => {\n      const newStatus = getter();\n      if (oldStatus.current === \"synchronizing\" && newStatus === \"synchronized\") {\n        timeoutId = setTimeout(() => setStatus(newStatus), config.SMOOTH_DELAY);\n      } else {\n        clearTimeout(timeoutId);\n        setStatus(newStatus);\n      }\n    });\n    return () => {\n      clearTimeout(timeoutId);\n      unsub();\n    };\n  }, [client, getter, oldStatus]);\n  return status;\n}\nfunction useSyncStatus(options) {\n  return useSyncStatus_withClient(useClient(), options);\n}\nfunction useErrorListener(callback) {\n  const client = useClient();\n  const savedCallback = useLatest(callback);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => client.events.error.subscribe((e) => savedCallback.current(e)),\n    [client, savedCallback]\n  );\n}\n\n// src/room.tsx\n\n\n\n\n// src/use-scroll-to-comment-on-load-effect.ts\n\nfunction handleScrollToCommentOnLoad(shouldScrollOnLoad, state) {\n  if (shouldScrollOnLoad === false) return;\n  if (!state.threads) return;\n  const isWindowDefined = typeof window !== \"undefined\";\n  if (!isWindowDefined) return;\n  const hash = window.location.hash;\n  const commentId = hash.slice(1);\n  if (!commentId.startsWith(\"cm_\")) return;\n  const comment = document.getElementById(commentId);\n  if (comment === null) return;\n  const comments = state.threads.flatMap((thread) => thread.comments);\n  const isCommentInThreads = comments.some(\n    (comment2) => comment2.id === commentId\n  );\n  if (!isCommentInThreads) return;\n  comment.scrollIntoView();\n}\nfunction useScrollToCommentOnLoadEffect(shouldScrollOnLoad, state) {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => {\n      handleScrollToCommentOnLoad(shouldScrollOnLoad, state);\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps -- We only want to run this effect once\n    [state.isLoading]\n  );\n}\n\n// src/room.tsx\n\nvar noop3 = () => {\n};\nvar identity3 = (x) => x;\nvar STABLE_EMPTY_LIST = Object.freeze([]);\nfunction alwaysEmptyList() {\n  return STABLE_EMPTY_LIST;\n}\nfunction alwaysNull() {\n  return null;\n}\nfunction selectorFor_useOthersConnectionIds(others) {\n  return others.map((user) => user.connectionId);\n}\nfunction makeMutationContext(room) {\n  const cannotUseUntil = \"This mutation cannot be used until\";\n  const needsPresence = `${cannotUseUntil} connected to the Liveblocks room`;\n  const needsStorage = `${cannotUseUntil} storage has been loaded`;\n  return {\n    get storage() {\n      const mutableRoot = room.getStorageSnapshot();\n      if (mutableRoot === null) {\n        throw new Error(needsStorage);\n      }\n      return mutableRoot;\n    },\n    get self() {\n      const self = room.getSelf();\n      if (self === null) {\n        throw new Error(needsPresence);\n      }\n      return self;\n    },\n    get others() {\n      const others = room.getOthers();\n      if (room.getSelf() === null) {\n        throw new Error(needsPresence);\n      }\n      return others;\n    },\n    setMyPresence: room.updatePresence\n  };\n}\nfunction getCurrentUserId(client) {\n  const userId = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].currentUserId.get();\n  if (userId === void 0) {\n    return \"anonymous\";\n  }\n  return userId;\n}\nvar _extras2 = /* @__PURE__ */ new WeakMap();\nvar _bundles2 = /* @__PURE__ */ new WeakMap();\nfunction getOrCreateRoomContextBundle(client) {\n  let bundle = _bundles2.get(client);\n  if (!bundle) {\n    bundle = makeRoomContextBundle(client);\n    _bundles2.set(client, bundle);\n  }\n  return bundle;\n}\nfunction getRoomExtrasForClient(client) {\n  let extras = _extras2.get(client);\n  if (!extras) {\n    extras = makeRoomExtrasForClient(client);\n    _extras2.set(client, extras);\n  }\n  return extras;\n}\nfunction makeRoomExtrasForClient(client) {\n  const store = getUmbrellaStoreForClient(client);\n  function onMutationFailure(optimisticId, context, innerError) {\n    store.optimisticUpdates.remove(optimisticId);\n    if (innerError instanceof _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.HttpError) {\n      if (innerError.status === 403) {\n        const detailedMessage = [\n          innerError.message,\n          innerError.details?.suggestion,\n          innerError.details?.docs\n        ].filter(Boolean).join(\"\\n\");\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.error(detailedMessage);\n      }\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].emitError(context, innerError);\n    } else {\n      throw innerError;\n    }\n  }\n  const threadsPollersByRoomId = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n    (roomId) => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makePoller)(\n      async (signal) => {\n        try {\n          return await store.fetchRoomThreadsDeltaUpdate(roomId, signal);\n        } catch (err) {\n          _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(`Polling new threads for '${roomId}' failed: ${String(err)}`);\n          throw err;\n        }\n      },\n      config.ROOM_THREADS_POLL_INTERVAL,\n      { maxStaleTimeMs: config.ROOM_THREADS_MAX_STALE_TIME }\n    )\n  );\n  const versionsPollersByRoomId = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n    (roomId) => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makePoller)(\n      async (signal) => {\n        try {\n          return await store.fetchRoomVersionsDeltaUpdate(roomId, signal);\n        } catch (err) {\n          _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(`Polling new history versions for '${roomId}' failed: ${String(err)}`);\n          throw err;\n        }\n      },\n      config.HISTORY_VERSIONS_POLL_INTERVAL,\n      { maxStaleTimeMs: config.HISTORY_VERSIONS_MAX_STALE_TIME }\n    )\n  );\n  const roomNotificationSettingsPollersByRoomId = new _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.DefaultMap(\n    (roomId) => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.makePoller)(\n      async (signal) => {\n        try {\n          return await store.refreshRoomNotificationSettings(roomId, signal);\n        } catch (err) {\n          _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(`Polling notification settings for '${roomId}' failed: ${String(err)}`);\n          throw err;\n        }\n      },\n      config.NOTIFICATION_SETTINGS_POLL_INTERVAL,\n      { maxStaleTimeMs: config.NOTIFICATION_SETTINGS_MAX_STALE_TIME }\n    )\n  );\n  return {\n    store,\n    onMutationFailure,\n    getOrCreateThreadsPollerForRoomId: threadsPollersByRoomId.getOrCreate.bind(\n      threadsPollersByRoomId\n    ),\n    getOrCreateVersionsPollerForRoomId: versionsPollersByRoomId.getOrCreate.bind(versionsPollersByRoomId),\n    getOrCreateNotificationsSettingsPollerForRoomId: roomNotificationSettingsPollersByRoomId.getOrCreate.bind(\n      roomNotificationSettingsPollersByRoomId\n    )\n  };\n}\nfunction makeRoomContextBundle(client) {\n  function RoomProvider_withImplicitLiveblocksProvider(props) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(LiveblocksProviderWithClient, { client, allowNesting: true, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RoomProvider, { ...props }) });\n  }\n  const shared = createSharedContext(client);\n  const bundle = {\n    RoomContext,\n    RoomProvider: RoomProvider_withImplicitLiveblocksProvider,\n    useRoom,\n    useStatus,\n    useStorageStatus,\n    useBatch,\n    useBroadcastEvent,\n    useOthersListener,\n    useLostConnectionListener,\n    useEventListener,\n    useHistory,\n    useUndo,\n    useRedo,\n    useCanRedo,\n    useCanUndo,\n    useStorageRoot,\n    useStorage,\n    useSelf,\n    useMyPresence,\n    useUpdateMyPresence,\n    useOthers,\n    useOthersMapped,\n    useOthersConnectionIds,\n    useOther,\n    useMutation,\n    useThreads,\n    useCreateThread,\n    useDeleteThread,\n    useEditThreadMetadata,\n    useMarkThreadAsResolved,\n    useMarkThreadAsUnresolved,\n    useCreateComment,\n    useEditComment,\n    useDeleteComment,\n    useAddReaction,\n    useRemoveReaction,\n    useMarkThreadAsRead,\n    useThreadSubscription,\n    useAttachmentUrl,\n    useHistoryVersions,\n    useHistoryVersionData,\n    useRoomNotificationSettings,\n    useUpdateRoomNotificationSettings,\n    ...shared.classic,\n    suspense: {\n      RoomContext,\n      RoomProvider: RoomProvider_withImplicitLiveblocksProvider,\n      useRoom,\n      useStatus,\n      useStorageStatus: useStorageStatusSuspense,\n      useBatch,\n      useBroadcastEvent,\n      useOthersListener,\n      useLostConnectionListener,\n      useEventListener,\n      useHistory,\n      useUndo,\n      useRedo,\n      useCanRedo,\n      useCanUndo,\n      useStorageRoot,\n      useStorage: useStorageSuspense,\n      useSelf: useSelfSuspense,\n      useMyPresence,\n      useUpdateMyPresence,\n      useOthers: useOthersSuspense,\n      useOthersMapped: useOthersMappedSuspense,\n      useOthersConnectionIds: useOthersConnectionIdsSuspense,\n      useOther: useOtherSuspense,\n      useMutation,\n      useThreads: useThreadsSuspense,\n      useCreateThread,\n      useDeleteThread,\n      useEditThreadMetadata,\n      useMarkThreadAsResolved,\n      useMarkThreadAsUnresolved,\n      useCreateComment,\n      useEditComment,\n      useDeleteComment,\n      useAddReaction,\n      useRemoveReaction,\n      useMarkThreadAsRead,\n      useThreadSubscription,\n      useAttachmentUrl: useAttachmentUrlSuspense,\n      // TODO: useHistoryVersionData: useHistoryVersionDataSuspense,\n      useHistoryVersions: useHistoryVersionsSuspense,\n      useRoomNotificationSettings: useRoomNotificationSettingsSuspense,\n      useUpdateRoomNotificationSettings,\n      ...shared.suspense\n    }\n  };\n  return Object.defineProperty(bundle, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal, {\n    enumerable: false\n  });\n}\nfunction RoomProvider(props) {\n  const client = useClient();\n  const [cache] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    () => /* @__PURE__ */ new Map()\n  );\n  const stableEnterRoom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (roomId, options) => {\n      const cached = cache.get(roomId);\n      if (cached) return cached;\n      const rv = client.enterRoom(roomId, options);\n      const origLeave = rv.leave;\n      rv.leave = () => {\n        origLeave();\n        cache.delete(roomId);\n      };\n      cache.set(roomId, rv);\n      return rv;\n    },\n    [client, cache]\n  );\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\n    RoomProviderInner,\n    {\n      ...props,\n      stableEnterRoom\n    }\n  );\n}\nfunction RoomProviderInner(props) {\n  const client = useClient();\n  const { id: roomId, stableEnterRoom } = props;\n  if (true) {\n    if (!roomId) {\n      throw new Error(\n        \"RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required\"\n      );\n    }\n    if (typeof roomId !== \"string\") {\n      throw new Error(\"RoomProvider id property should be a string.\");\n    }\n    const majorReactVersion = parseInt(react__WEBPACK_IMPORTED_MODULE_0__.version) || 1;\n    const requiredVersion = 18;\n    (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.errorIf)(\n      majorReactVersion < requiredVersion,\n      `React ${requiredVersion} or higher is required (you\\u2019re on ${react__WEBPACK_IMPORTED_MODULE_0__.version})`\n    );\n  }\n  const frozenProps = useInitial({\n    initialPresence: props.initialPresence,\n    initialStorage: props.initialStorage,\n    autoConnect: props.autoConnect ?? typeof window !== \"undefined\"\n  });\n  const [{ room }, setRoomLeavePair] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    () => stableEnterRoom(roomId, {\n      ...frozenProps,\n      autoConnect: false\n      // Deliberately using false here on the first render, see below\n    })\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const { store } = getRoomExtrasForClient(client);\n    async function handleCommentEvent(message) {\n      if (message.type === _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.THREAD_DELETED) {\n        store.deleteThread(message.threadId, null);\n        return;\n      }\n      const info = await room.getThread(message.threadId);\n      if (!info.thread) {\n        store.deleteThread(message.threadId, null);\n        return;\n      }\n      const { thread, inboxNotification: maybeNotification } = info;\n      const existingThread = store.outputs.threads.get().getEvenIfDeleted(message.threadId);\n      switch (message.type) {\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.COMMENT_EDITED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.THREAD_METADATA_UPDATED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.THREAD_UPDATED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.COMMENT_REACTION_ADDED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.COMMENT_REACTION_REMOVED:\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.COMMENT_DELETED:\n          if (!existingThread) break;\n          store.updateThreadifications(\n            [thread],\n            maybeNotification ? [maybeNotification] : []\n          );\n          break;\n        case _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.ServerMsgCode.COMMENT_CREATED:\n          store.updateThreadifications(\n            [thread],\n            maybeNotification ? [maybeNotification] : []\n          );\n          break;\n        default:\n          break;\n      }\n    }\n    return room.events.comments.subscribe(\n      (message) => void handleCommentEvent(message)\n    );\n  }, [client, room]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const pair = stableEnterRoom(roomId, frozenProps);\n    setRoomLeavePair(pair);\n    const { room: room2, leave } = pair;\n    if (frozenProps.autoConnect) {\n      room2.connect();\n    }\n    return () => {\n      leave();\n    };\n  }, [roomId, frozenProps, stableEnterRoom]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(RoomContext.Provider, { value: room, children: props.children });\n}\nfunction useRoom(options) {\n  const room = useRoomOrNull();\n  if (room === null && !options?.allowOutsideRoom) {\n    throw new Error(\"RoomProvider is missing from the React tree.\");\n  }\n  return room;\n}\nfunction useStatus() {\n  const room = useRoom();\n  const subscribe = room.events.status.subscribe;\n  const getSnapshot = room.getStatus;\n  const getServerSnapshot = room.getStatus;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useReportTextEditor(editor, rootKey) {\n  const isReported = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  const room = useRoom();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (isReported.current) {\n      return;\n    }\n    const unsubscribe = room.events.status.subscribe((status) => {\n      if (status === \"connected\" && !isReported.current) {\n        isReported.current = true;\n        void room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].reportTextEditor(editor, rootKey);\n      }\n    });\n    return unsubscribe;\n  }, [room, editor, rootKey]);\n}\nfunction useYjsProvider() {\n  const room = useRoom();\n  const subscribe = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (onStoreChange) => {\n      return room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].yjsProviderDidChange.subscribe(onStoreChange);\n    },\n    [room]\n  );\n  const getSnapshot = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    return room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].getYjsProvider();\n  }, [room]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribe, getSnapshot, getSnapshot);\n}\nfunction useCreateTextMention() {\n  const room = useRoom();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (userId, mentionId) => {\n      room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].createTextMention(userId, mentionId).catch((err) => {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.error(\n          `Cannot create text mention for user '${userId}' and mention '${mentionId}'`,\n          err\n        );\n      });\n    },\n    [room]\n  );\n}\nfunction useDeleteTextMention() {\n  const room = useRoom();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (mentionId) => {\n      room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].deleteTextMention(mentionId).catch((err) => {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.error(`Cannot delete text mention '${mentionId}'`, err);\n      });\n    },\n    [room]\n  );\n}\nfunction useResolveMentionSuggestions() {\n  const client = useClient();\n  return client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].resolveMentionSuggestions;\n}\nfunction useMentionSuggestionsCache() {\n  const client = useClient();\n  return client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].mentionSuggestionsCache;\n}\nfunction useStorageStatus(options) {\n  const smooth = useInitial(options?.smooth ?? false);\n  if (smooth) {\n    return useStorageStatusSmooth();\n  } else {\n    return useStorageStatusImmediate();\n  }\n}\nfunction useStorageStatusImmediate() {\n  const room = useRoom();\n  const subscribe = room.events.storageStatus.subscribe;\n  const getSnapshot = room.getStorageStatus;\n  const getServerSnapshot = room.getStorageStatus;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useStorageStatusSmooth() {\n  const room = useRoom();\n  const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(room.getStorageStatus);\n  const oldStatus = useLatest(room.getStorageStatus());\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    let timeoutId;\n    const unsub = room.events.storageStatus.subscribe((newStatus) => {\n      if (oldStatus.current === \"synchronizing\" && newStatus === \"synchronized\") {\n        timeoutId = setTimeout(() => setStatus(newStatus), config.SMOOTH_DELAY);\n      } else {\n        clearTimeout(timeoutId);\n        setStatus(newStatus);\n      }\n    });\n    return () => {\n      clearTimeout(timeoutId);\n      unsub();\n    };\n  }, [room, oldStatus]);\n  return status;\n}\nfunction useBatch() {\n  return useRoom().batch;\n}\nfunction useBroadcastEvent() {\n  const room = useRoom();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (event, options = { shouldQueueEventIfNotReady: false }) => {\n      room.broadcastEvent(event, options);\n    },\n    [room]\n  );\n}\nfunction useOthersListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => room.events.others.subscribe((event) => savedCallback.current(event)),\n    [room, savedCallback]\n  );\n}\nfunction useLostConnectionListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => room.events.lostConnection.subscribe(\n      (event) => savedCallback.current(event)\n    ),\n    [room, savedCallback]\n  );\n}\nfunction useEventListener(callback) {\n  const room = useRoom();\n  const savedCallback = useLatest(callback);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const listener = (eventData) => {\n      savedCallback.current(eventData);\n    };\n    return room.events.customEvent.subscribe(listener);\n  }, [room, savedCallback]);\n}\nfunction useHistory() {\n  return useRoom().history;\n}\nfunction useUndo() {\n  return useHistory().undo;\n}\nfunction useRedo() {\n  return useHistory().redo;\n}\nfunction useCanUndo() {\n  const room = useRoom();\n  const subscribe = room.events.history.subscribe;\n  const canUndo = room.history.canUndo;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribe, canUndo, canUndo);\n}\nfunction useCanRedo() {\n  const room = useRoom();\n  const subscribe = room.events.history.subscribe;\n  const canRedo = room.history.canRedo;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribe, canRedo, canRedo);\n}\nfunction useSelf(maybeSelector, isEqual) {\n  const room = useRoom();\n  const subscribe = room.events.self.subscribe;\n  const getSnapshot = room.getSelf;\n  const selector = maybeSelector ?? identity3;\n  const wrappedSelector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (me) => me !== null ? selector(me) : null,\n    [selector]\n  );\n  const getServerSnapshot = alwaysNull;\n  return useSyncExternalStoreWithSelector(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    wrappedSelector,\n    isEqual\n  );\n}\nfunction useMyPresence() {\n  const room = useRoom();\n  const subscribe = room.events.myPresence.subscribe;\n  const getSnapshot = room.getPresence;\n  const presence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribe, getSnapshot, getSnapshot);\n  const setPresence = room.updatePresence;\n  return [presence, setPresence];\n}\nfunction useUpdateMyPresence() {\n  return useRoom().updatePresence;\n}\nfunction useOthers(selector, isEqual) {\n  const room = useRoom();\n  const subscribe = room.events.others.subscribe;\n  const getSnapshot = room.getOthers;\n  const getServerSnapshot = alwaysEmptyList;\n  return useSyncExternalStoreWithSelector(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    selector ?? identity3,\n    isEqual\n  );\n}\nfunction useOthersMapped(itemSelector, itemIsEqual) {\n  const wrappedSelector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (others) => others.map((other) => [other.connectionId, itemSelector(other)]),\n    [itemSelector]\n  );\n  const wrappedIsEqual = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (a, b) => {\n      const eq = itemIsEqual ?? Object.is;\n      return a.length === b.length && a.every((atuple, index) => {\n        const btuple = b[index];\n        return atuple[0] === btuple[0] && eq(atuple[1], btuple[1]);\n      });\n    },\n    [itemIsEqual]\n  );\n  return useOthers(wrappedSelector, wrappedIsEqual);\n}\nfunction useOthersConnectionIds() {\n  return useOthers(selectorFor_useOthersConnectionIds, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow);\n}\nvar NOT_FOUND = Symbol();\nfunction useOther(connectionId, selector, isEqual) {\n  const wrappedSelector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (others) => {\n      const other2 = others.find((other3) => other3.connectionId === connectionId);\n      return other2 !== void 0 ? selector(other2) : NOT_FOUND;\n    },\n    [connectionId, selector]\n  );\n  const wrappedIsEqual = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (prev, curr) => {\n      if (prev === NOT_FOUND || curr === NOT_FOUND) {\n        return prev === curr;\n      }\n      const eq = isEqual ?? Object.is;\n      return eq(prev, curr);\n    },\n    [isEqual]\n  );\n  const other = useOthers(wrappedSelector, wrappedIsEqual);\n  if (other === NOT_FOUND) {\n    throw new Error(\n      `No such other user with connection id ${connectionId} exists`\n    );\n  }\n  return other;\n}\nfunction useMutableStorageRoot() {\n  const room = useRoom();\n  const subscribe = room.events.storageDidLoad.subscribeOnce;\n  const getSnapshot = room.getStorageSnapshot;\n  const getServerSnapshot = alwaysNull;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribe, getSnapshot, getServerSnapshot);\n}\nfunction useStorageRoot() {\n  return [useMutableStorageRoot()];\n}\nfunction useStorage(selector, isEqual) {\n  const room = useRoom();\n  const rootOrNull = useMutableStorageRoot();\n  const wrappedSelector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (rootOrNull2) => rootOrNull2 !== null ? selector(rootOrNull2) : null,\n    [selector]\n  );\n  const subscribe = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (onStoreChange) => rootOrNull !== null ? room.subscribe(rootOrNull, onStoreChange, { isDeep: true }) : noop3,\n    [room, rootOrNull]\n  );\n  const getSnapshot = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    if (rootOrNull === null) {\n      return null;\n    } else {\n      const root = rootOrNull;\n      const imm = root.toImmutable();\n      return imm;\n    }\n  }, [rootOrNull]);\n  const getServerSnapshot = alwaysNull;\n  return useSyncExternalStoreWithSelector(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n    wrappedSelector,\n    isEqual\n  );\n}\nfunction useMutation(callback, deps) {\n  const room = useRoom();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(\n    () => {\n      return (...args) => (\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        room.batch(\n          () => (\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            callback(\n              makeMutationContext(room),\n              ...args\n            )\n          )\n        )\n      );\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [room, ...deps]\n  );\n}\nfunction useThreads(options = {}) {\n  const { scrollOnLoad = true } = options;\n  const client = useClient();\n  const room = useRoom();\n  const { store, getOrCreateThreadsPollerForRoomId } = getRoomExtrasForClient(client);\n  const queryKey = makeRoomThreadsQueryKey(room.id, options.query);\n  const poller = getOrCreateThreadsPollerForRoomId(room.id);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void store.outputs.loadingRoomThreads.getOrCreate(queryKey).waitUntilLoaded()\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => poller.dec();\n  }, [poller]);\n  const result = useSignal(\n    store.outputs.loadingRoomThreads.getOrCreate(queryKey).signal\n  );\n  useScrollToCommentOnLoadEffect(scrollOnLoad, result);\n  return result;\n}\nfunction useCreateThread() {\n  return useCreateRoomThread(useRoom().id);\n}\nfunction useCreateRoomThread(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (options) => {\n      const body = options.body;\n      const metadata = options.metadata ?? {};\n      const attachments = options.attachments;\n      const threadId = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.createThreadId)();\n      const commentId = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.createCommentId)();\n      const createdAt = /* @__PURE__ */ new Date();\n      const newComment = {\n        id: commentId,\n        threadId,\n        roomId,\n        createdAt,\n        type: \"comment\",\n        userId: getCurrentUserId(client),\n        body,\n        reactions: [],\n        attachments: attachments ?? []\n      };\n      const newThread = {\n        id: threadId,\n        type: \"thread\",\n        createdAt,\n        updatedAt: createdAt,\n        roomId,\n        metadata,\n        comments: [newComment],\n        resolved: false\n      };\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"create-thread\",\n        thread: newThread,\n        roomId\n      });\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.createThread({\n        roomId,\n        threadId,\n        commentId,\n        body,\n        metadata,\n        attachmentIds\n      }).then(\n        (thread) => {\n          store.createThread(optimisticId, thread);\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          {\n            type: \"CREATE_THREAD_ERROR\",\n            roomId,\n            threadId,\n            commentId,\n            body,\n            metadata\n          },\n          err\n        )\n      );\n      return newThread;\n    },\n    [client, roomId]\n  );\n}\nfunction useDeleteThread() {\n  return useDeleteRoomThread(useRoom().id);\n}\nfunction useDeleteRoomThread(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (threadId) => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const userId = getCurrentUserId(client);\n      const existing = store.outputs.threads.get().get(threadId);\n      if (existing?.comments?.[0]?.userId !== userId) {\n        throw new Error(\"Only the thread creator can delete the thread\");\n      }\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"delete-thread\",\n        roomId,\n        threadId,\n        deletedAt: /* @__PURE__ */ new Date()\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.deleteThread({ roomId, threadId }).then(\n        () => {\n          store.deleteThread(threadId, optimisticId);\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          { type: \"DELETE_THREAD_ERROR\", roomId, threadId },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useEditThreadMetadata() {\n  return useEditRoomThreadMetadata(useRoom().id);\n}\nfunction useEditRoomThreadMetadata(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (options) => {\n      if (!options.metadata) {\n        return;\n      }\n      const threadId = options.threadId;\n      const metadata = options.metadata;\n      const updatedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"edit-thread-metadata\",\n        metadata,\n        threadId,\n        updatedAt\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.editThreadMetadata({ roomId, threadId, metadata }).then(\n        (metadata2) => (\n          // Replace the optimistic update by the real thing\n          store.patchThread(threadId, optimisticId, { metadata: metadata2 }, updatedAt)\n        ),\n        (err) => onMutationFailure(\n          optimisticId,\n          {\n            type: \"EDIT_THREAD_METADATA_ERROR\",\n            roomId,\n            threadId,\n            metadata\n          },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useCreateComment() {\n  return useCreateRoomComment(useRoom().id);\n}\nfunction useCreateRoomComment(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    ({ threadId, body, attachments }) => {\n      const commentId = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.createCommentId)();\n      const createdAt = /* @__PURE__ */ new Date();\n      const comment = {\n        id: commentId,\n        threadId,\n        roomId,\n        type: \"comment\",\n        createdAt,\n        userId: getCurrentUserId(client),\n        body,\n        reactions: [],\n        attachments: attachments ?? []\n      };\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"create-comment\",\n        comment\n      });\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.createComment({ roomId, threadId, commentId, body, attachmentIds }).then(\n        (newComment) => {\n          store.createComment(newComment, optimisticId);\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          {\n            type: \"CREATE_COMMENT_ERROR\",\n            roomId,\n            threadId,\n            commentId,\n            body\n          },\n          err\n        )\n      );\n      return comment;\n    },\n    [client, roomId]\n  );\n}\nfunction useEditComment() {\n  return useEditRoomComment(useRoom().id);\n}\nfunction useEditRoomComment(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    ({ threadId, commentId, body, attachments }) => {\n      const editedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const existing = store.outputs.threads.get().getEvenIfDeleted(threadId);\n      if (existing === void 0) {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(\n          `Internal unexpected behavior. Cannot edit comment in thread \"${threadId}\" because the thread does not exist in the cache.`\n        );\n        return;\n      }\n      const comment = existing.comments.find(\n        (comment2) => comment2.id === commentId\n      );\n      if (comment === void 0 || comment.deletedAt !== void 0) {\n        _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.console.warn(\n          `Internal unexpected behavior. Cannot edit comment \"${commentId}\" in thread \"${threadId}\" because the comment does not exist in the cache.`\n        );\n        return;\n      }\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"edit-comment\",\n        comment: {\n          ...comment,\n          editedAt,\n          body,\n          attachments: attachments ?? []\n        }\n      });\n      const attachmentIds = attachments?.map((attachment) => attachment.id);\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.editComment({ roomId, threadId, commentId, body, attachmentIds }).then(\n        (editedComment) => {\n          store.editComment(threadId, optimisticId, editedComment);\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          { type: \"EDIT_COMMENT_ERROR\", roomId, threadId, commentId, body },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useDeleteComment() {\n  return useDeleteRoomComment(useRoom().id);\n}\nfunction useDeleteRoomComment(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    ({ threadId, commentId }) => {\n      const deletedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"delete-comment\",\n        threadId,\n        commentId,\n        deletedAt,\n        roomId\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.deleteComment({ roomId, threadId, commentId }).then(\n        () => {\n          store.deleteComment(threadId, optimisticId, commentId, deletedAt);\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          { type: \"DELETE_COMMENT_ERROR\", roomId, threadId, commentId },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useAddReaction() {\n  return useAddRoomCommentReaction(useRoom().id);\n}\nfunction useAddRoomCommentReaction(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    ({ threadId, commentId, emoji }) => {\n      const createdAt = /* @__PURE__ */ new Date();\n      const userId = getCurrentUserId(client);\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"add-reaction\",\n        threadId,\n        commentId,\n        reaction: {\n          emoji,\n          userId,\n          createdAt\n        }\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.addReaction({ roomId, threadId, commentId, emoji }).then(\n        (addedReaction) => {\n          store.addReaction(\n            threadId,\n            optimisticId,\n            commentId,\n            addedReaction,\n            createdAt\n          );\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          {\n            type: \"ADD_REACTION_ERROR\",\n            roomId,\n            threadId,\n            commentId,\n            emoji\n          },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useRemoveReaction() {\n  return useRemoveRoomCommentReaction(useRoom().id);\n}\nfunction useRemoveRoomCommentReaction(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    ({ threadId, commentId, emoji }) => {\n      const userId = getCurrentUserId(client);\n      const removedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"remove-reaction\",\n        threadId,\n        commentId,\n        emoji,\n        userId,\n        removedAt\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.removeReaction({ roomId, threadId, commentId, emoji }).then(\n        () => {\n          store.removeReaction(\n            threadId,\n            optimisticId,\n            commentId,\n            emoji,\n            userId,\n            removedAt\n          );\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          {\n            type: \"REMOVE_REACTION_ERROR\",\n            roomId,\n            threadId,\n            commentId,\n            emoji\n          },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useMarkThreadAsRead() {\n  return useMarkRoomThreadAsRead(useRoom().id);\n}\nfunction useMarkRoomThreadAsRead(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (threadId) => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const inboxNotification = Object.values(\n        store.outputs.notifications.get().notificationsById\n      ).find(\n        (inboxNotification2) => inboxNotification2.kind === \"thread\" && inboxNotification2.threadId === threadId\n      );\n      if (!inboxNotification) return;\n      const now = /* @__PURE__ */ new Date();\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-inbox-notification-as-read\",\n        inboxNotificationId: inboxNotification.id,\n        readAt: now\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.markRoomInboxNotificationAsRead({\n        roomId,\n        inboxNotificationId: inboxNotification.id\n      }).then(\n        () => {\n          store.markInboxNotificationRead(\n            inboxNotification.id,\n            now,\n            optimisticId\n          );\n        },\n        (err) => {\n          onMutationFailure(\n            optimisticId,\n            {\n              type: \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\",\n              roomId,\n              inboxNotificationId: inboxNotification.id\n            },\n            err\n          );\n          return;\n        }\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useMarkThreadAsResolved() {\n  return useMarkRoomThreadAsResolved(useRoom().id);\n}\nfunction useMarkRoomThreadAsResolved(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (threadId) => {\n      const updatedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-thread-as-resolved\",\n        threadId,\n        updatedAt\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.markThreadAsResolved({ roomId, threadId }).then(\n        () => {\n          store.patchThread(\n            threadId,\n            optimisticId,\n            { resolved: true },\n            updatedAt\n          );\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          { type: \"MARK_THREAD_AS_RESOLVED_ERROR\", roomId, threadId },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useMarkThreadAsUnresolved() {\n  return useMarkRoomThreadAsUnresolved(useRoom().id);\n}\nfunction useMarkRoomThreadAsUnresolved(roomId) {\n  const client = useClient();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (threadId) => {\n      const updatedAt = /* @__PURE__ */ new Date();\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"mark-thread-as-unresolved\",\n        threadId,\n        updatedAt\n      });\n      client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.markThreadAsUnresolved({ roomId, threadId }).then(\n        () => {\n          store.patchThread(\n            threadId,\n            optimisticId,\n            { resolved: false },\n            updatedAt\n          );\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          { type: \"MARK_THREAD_AS_UNRESOLVED_ERROR\", roomId, threadId },\n          err\n        )\n      );\n    },\n    [client, roomId]\n  );\n}\nfunction useThreadSubscription(threadId) {\n  const client = useClient();\n  const { store } = getRoomExtrasForClient(client);\n  const signal = store.outputs.threadifications;\n  const selector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (state) => {\n      const notification = state.sortedNotifications.find(\n        (inboxNotification) => inboxNotification.kind === \"thread\" && inboxNotification.threadId === threadId\n      );\n      const thread = state.threadsDB.get(threadId);\n      if (notification === void 0 || thread === void 0) {\n        return { status: \"not-subscribed\" };\n      }\n      return {\n        status: \"subscribed\",\n        unreadSince: notification.readAt\n      };\n    },\n    [threadId]\n  );\n  return useSignal(signal, selector, _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow);\n}\nfunction useRoomNotificationSettings() {\n  const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();\n  const client = useClient();\n  const room = useRoom();\n  const { store, getOrCreateNotificationsSettingsPollerForRoomId } = getRoomExtrasForClient(client);\n  const poller = getOrCreateNotificationsSettingsPollerForRoomId(room.id);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void store.outputs.settingsByRoomId.getOrCreate(room.id).waitUntilLoaded()\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => {\n      poller.dec();\n    };\n  }, [poller]);\n  const settings = useSignal(\n    store.outputs.settingsByRoomId.getOrCreate(room.id).signal\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return [settings, updateRoomNotificationSettings];\n  }, [settings, updateRoomNotificationSettings]);\n}\nfunction useRoomNotificationSettingsSuspense() {\n  ensureNotServerSide();\n  const client = useClient();\n  const store = getRoomExtrasForClient(client).store;\n  const room = useRoom();\n  use(store.outputs.settingsByRoomId.getOrCreate(room.id).waitUntilLoaded());\n  const [settings, updateRoomNotificationSettings] = useRoomNotificationSettings();\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!settings.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!settings.isLoading, \"Did not expect loading\");\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return [settings, updateRoomNotificationSettings];\n  }, [settings, updateRoomNotificationSettings]);\n}\nfunction useHistoryVersionData(versionId) {\n  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n    isLoading: true\n  });\n  const room = useRoom();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    setState({ isLoading: true });\n    const load = async () => {\n      try {\n        const response = await room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].getTextVersion(versionId);\n        const buffer = await response.arrayBuffer();\n        const data = new Uint8Array(buffer);\n        setState({\n          isLoading: false,\n          data\n        });\n      } catch (error) {\n        setState({\n          isLoading: false,\n          error: error instanceof Error ? error : new Error(\n            \"An unknown error occurred while loading this version\"\n          )\n        });\n      }\n    };\n    void load();\n  }, [room, versionId]);\n  return state;\n}\nfunction useHistoryVersions() {\n  const client = useClient();\n  const room = useRoom();\n  const { store, getOrCreateVersionsPollerForRoomId } = getRoomExtrasForClient(client);\n  const poller = getOrCreateVersionsPollerForRoomId(room.id);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    poller.inc();\n    poller.pollNowIfStale();\n    return () => poller.dec();\n  }, [poller]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(\n    () => void store.outputs.versionsByRoomId.getOrCreate(room.id).waitUntilLoaded()\n    // NOTE: Deliberately *not* using a dependency array here!\n    //\n    // It is important to call waitUntil on *every* render.\n    // This is harmless though, on most renders, except:\n    // 1. The very first render, in which case we'll want to trigger the initial page fetch.\n    // 2. All other subsequent renders now \"just\" return the same promise (a quick operation).\n    // 3. If ever the promise would fail, then after 5 seconds it would reset, and on the very\n    //    *next* render after that, a *new* fetch/promise will get created.\n  );\n  return useSignal(store.outputs.versionsByRoomId.getOrCreate(room.id).signal);\n}\nfunction useHistoryVersionsSuspense() {\n  ensureNotServerSide();\n  const client = useClient();\n  const room = useRoom();\n  const store = getRoomExtrasForClient(client).store;\n  use(store.outputs.versionsByRoomId.getOrCreate(room.id).waitUntilLoaded());\n  const result = useHistoryVersions();\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction useUpdateRoomNotificationSettings() {\n  const client = useClient();\n  const room = useRoom();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (settings) => {\n      const { store, onMutationFailure } = getRoomExtrasForClient(client);\n      const optimisticId = store.optimisticUpdates.add({\n        type: \"update-notification-settings\",\n        roomId: room.id,\n        settings\n      });\n      room.updateNotificationSettings(settings).then(\n        (settings2) => {\n          store.updateRoomNotificationSettings(room.id, optimisticId, settings2);\n        },\n        (err) => onMutationFailure(\n          optimisticId,\n          { type: \"UPDATE_NOTIFICATION_SETTINGS_ERROR\", roomId: room.id },\n          err\n        )\n      );\n    },\n    [client, room]\n  );\n}\nfunction useSuspendUntilPresenceReady() {\n  ensureNotServerSide();\n  const room = useRoom();\n  use(room.waitUntilPresenceReady());\n}\nfunction useSelfSuspense(selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useSelf(\n    selector,\n    isEqual\n  );\n}\nfunction useOthersSuspense(selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useOthers(\n    selector,\n    isEqual\n  );\n}\nfunction useOthersConnectionIdsSuspense() {\n  useSuspendUntilPresenceReady();\n  return useOthersConnectionIds();\n}\nfunction useOthersMappedSuspense(itemSelector, itemIsEqual) {\n  useSuspendUntilPresenceReady();\n  return useOthersMapped(itemSelector, itemIsEqual);\n}\nfunction useOtherSuspense(connectionId, selector, isEqual) {\n  useSuspendUntilPresenceReady();\n  return useOther(connectionId, selector, isEqual);\n}\nfunction useSuspendUntilStorageReady() {\n  ensureNotServerSide();\n  const room = useRoom();\n  use(room.waitUntilStorageReady());\n}\nfunction useStorageSuspense(selector, isEqual) {\n  useSuspendUntilStorageReady();\n  return useStorage(\n    selector,\n    isEqual\n  );\n}\nfunction useStorageStatusSuspense(options) {\n  useSuspendUntilStorageReady();\n  return useStorageStatus(options);\n}\nfunction useThreadsSuspense(options = {}) {\n  ensureNotServerSide();\n  const client = useClient();\n  const room = useRoom();\n  const { store } = getRoomExtrasForClient(client);\n  const queryKey = makeRoomThreadsQueryKey(room.id, options.query);\n  use(store.outputs.loadingRoomThreads.getOrCreate(queryKey).waitUntilLoaded());\n  const result = useThreads(options);\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.error, \"Did not expect error\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!result.isLoading, \"Did not expect loading\");\n  return result;\n}\nfunction selectorFor_useAttachmentUrl(state) {\n  if (state === void 0 || state?.isLoading) {\n    return state ?? { isLoading: true };\n  }\n  if (state.error) {\n    return state;\n  }\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(state.data !== void 0, \"Unexpected missing attachment URL\");\n  return {\n    isLoading: false,\n    url: state.data\n  };\n}\nfunction useAttachmentUrl(attachmentId) {\n  const room = useRoom();\n  return useRoomAttachmentUrl(attachmentId, room.id);\n}\nfunction useRoomAttachmentUrl(attachmentId, roomId) {\n  const client = useClient();\n  const store = client[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal].httpClient.getOrCreateAttachmentUrlsStore(roomId);\n  const getAttachmentUrlState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => store.getItemState(attachmentId),\n    [store, attachmentId]\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    void store.enqueue(attachmentId);\n  }, [store, attachmentId]);\n  return useSyncExternalStoreWithSelector(\n    store.subscribe,\n    getAttachmentUrlState,\n    getAttachmentUrlState,\n    selectorFor_useAttachmentUrl,\n    _liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.shallow\n  );\n}\nfunction useAttachmentUrlSuspense(attachmentId) {\n  const room = useRoom();\n  const { attachmentUrlsStore } = room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.kInternal];\n  const getAttachmentUrlState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    () => attachmentUrlsStore.getItemState(attachmentId),\n    [attachmentUrlsStore, attachmentId]\n  );\n  const attachmentUrlState = getAttachmentUrlState();\n  if (!attachmentUrlState || attachmentUrlState.isLoading) {\n    throw attachmentUrlsStore.enqueue(attachmentId);\n  }\n  if (attachmentUrlState.error) {\n    throw attachmentUrlState.error;\n  }\n  const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(\n    attachmentUrlsStore.subscribe,\n    getAttachmentUrlState,\n    getAttachmentUrlState\n  );\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(state !== void 0, \"Unexpected missing state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.isLoading, \"Unexpected loading state\");\n  (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_1__.assert)(!state.error, \"Unexpected error state\");\n  return {\n    isLoading: false,\n    url: state.data,\n    error: void 0\n  };\n}\nvar NO_PERMISSIONS = /* @__PURE__ */ new Set();\nfunction useRoomPermissions(roomId) {\n  const client = useClient();\n  const store = getRoomExtrasForClient(client).store;\n  return useSignal(\n    store.permissionHints.signal,\n    (hints) => hints.get(roomId) ?? NO_PERMISSIONS\n  );\n}\nfunction createRoomContext(client) {\n  return getOrCreateRoomContextBundle(client);\n}\nvar _RoomProvider = RoomProvider;\nvar _useBroadcastEvent = useBroadcastEvent;\nvar _useOthersListener = useOthersListener;\nvar _useRoom = useRoom;\nvar _useIsInsideRoom = useIsInsideRoom;\nvar _useAddReaction = useAddReaction;\nvar _useMutation = useMutation;\nvar _useCreateThread = useCreateThread;\nvar _useDeleteThread = useDeleteThread;\nvar _useEditThreadMetadata = useEditThreadMetadata;\nvar _useEventListener = useEventListener;\nvar _useMyPresence = useMyPresence;\nvar _useOthersMapped = useOthersMapped;\nvar _useOthersMappedSuspense = useOthersMappedSuspense;\nvar _useThreads = useThreads;\nvar _useThreadsSuspense = useThreadsSuspense;\nvar _useRoomNotificationSettings = useRoomNotificationSettings;\nvar _useRoomNotificationSettingsSuspense = useRoomNotificationSettingsSuspense;\nvar _useHistoryVersions = useHistoryVersions;\nvar _useHistoryVersionsSuspense = useHistoryVersionsSuspense;\nvar _useOther = useOther;\nfunction _useOthers(...args) {\n  return useOthers(...args);\n}\nvar _useOtherSuspense = useOtherSuspense;\nfunction _useOthersSuspense(...args) {\n  return useOthersSuspense(...args);\n}\nvar _useStorage = useStorage;\nvar _useStorageSuspense = useStorageSuspense;\nfunction _useSelf(...args) {\n  return useSelf(...args);\n}\nfunction _useSelfSuspense(...args) {\n  return useSelfSuspense(...args);\n}\nvar _useStorageRoot = useStorageRoot;\nvar _useUpdateMyPresence = useUpdateMyPresence;\n\n\n//# sourceMappingURL=chunk-URVBSXYW.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QvZGlzdC9jaHVuay1VUlZCU1hZVy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDa0Q7QUFDbEQsa0JBQWtCLG9EQUFhO0FBQy9CO0FBQ0EsU0FBUyxpREFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBT2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2Q0FBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsNkNBQTZDLDhDQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZ0JBQWdCLDJEQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsb0RBQWE7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFHMEI7QUFRQTtBQVNYOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxpQkFB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QUNuQjtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0Esd0RBQXdELFFBQVE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdURBQU07QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDRCQUE0QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtFQUE2QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFEQUFRO0FBQ1osaUJBQWlCLFlBQVksNEJBQTRCLFVBQVU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTBHRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVhcm4tcmwvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QvZGlzdC9jaHVuay1VUlZCU1hZVy5qcz8xMmEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb250ZXh0cy50c1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCB9IGZyb20gXCJyZWFjdFwiO1xudmFyIFJvb21Db250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmZ1bmN0aW9uIHVzZVJvb21Pck51bGwoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KFJvb21Db250ZXh0KTtcbn1cbmZ1bmN0aW9uIHVzZUlzSW5zaWRlUm9vbSgpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb21Pck51bGwoKTtcbiAgcmV0dXJuIHJvb20gIT09IG51bGw7XG59XG5cbi8vIHNyYy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS13aXRoLXNlbGVjdG9yLnRzXG5pbXBvcnQge1xuICB1c2VEZWJ1Z1ZhbHVlLFxuICB1c2VFZmZlY3QsXG4gIHVzZU1lbW8sXG4gIHVzZVJlZixcbiAgdXNlU3luY0V4dGVybmFsU3RvcmVcbn0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIHJldHVybiB4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkgfHwgeCAhPT0geCAmJiB5ICE9PSB5O1xufVxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3Ioc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QsIHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gIGNvbnN0IGluc3RSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGxldCBpbnN0O1xuICBpZiAoaW5zdFJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgaW5zdCA9IHtcbiAgICAgIGhhc1ZhbHVlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfTtcbiAgICBpbnN0UmVmLmN1cnJlbnQgPSBpbnN0O1xuICB9IGVsc2Uge1xuICAgIGluc3QgPSBpbnN0UmVmLmN1cnJlbnQ7XG4gIH1cbiAgY29uc3QgW2dldFNlbGVjdGlvbiwgZ2V0U2VydmVyU2VsZWN0aW9uXSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCBoYXNNZW1vID0gZmFsc2U7XG4gICAgbGV0IG1lbW9pemVkU25hcHNob3Q7XG4gICAgbGV0IG1lbW9pemVkU2VsZWN0aW9uO1xuICAgIGNvbnN0IG1lbW9pemVkU2VsZWN0b3IgPSAobmV4dFNuYXBzaG90KSA9PiB7XG4gICAgICBpZiAoIWhhc01lbW8pIHtcbiAgICAgICAgaGFzTWVtbyA9IHRydWU7XG4gICAgICAgIG1lbW9pemVkU25hcHNob3QgPSBuZXh0U25hcHNob3Q7XG4gICAgICAgIGNvbnN0IG5leHRTZWxlY3Rpb24yID0gc2VsZWN0b3IobmV4dFNuYXBzaG90KTtcbiAgICAgICAgaWYgKGlzRXF1YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGlmIChpbnN0Lmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U2VsZWN0aW9uID0gaW5zdC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChpc0VxdWFsKGN1cnJlbnRTZWxlY3Rpb24sIG5leHRTZWxlY3Rpb24yKSkge1xuICAgICAgICAgICAgICBtZW1vaXplZFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgICAgICAgIHJldHVybiBjdXJyZW50U2VsZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZW1vaXplZFNlbGVjdGlvbiA9IG5leHRTZWxlY3Rpb24yO1xuICAgICAgICByZXR1cm4gbmV4dFNlbGVjdGlvbjI7XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2U25hcHNob3QgPSBtZW1vaXplZFNuYXBzaG90O1xuICAgICAgY29uc3QgcHJldlNlbGVjdGlvbiA9IG1lbW9pemVkU2VsZWN0aW9uO1xuICAgICAgaWYgKGlzKHByZXZTbmFwc2hvdCwgbmV4dFNuYXBzaG90KSkge1xuICAgICAgICByZXR1cm4gcHJldlNlbGVjdGlvbjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRTZWxlY3Rpb24gPSBzZWxlY3RvcihuZXh0U25hcHNob3QpO1xuICAgICAgaWYgKGlzRXF1YWwgIT09IHZvaWQgMCAmJiBpc0VxdWFsKHByZXZTZWxlY3Rpb24sIG5leHRTZWxlY3Rpb24pKSB7XG4gICAgICAgIG1lbW9pemVkU25hcHNob3QgPSBuZXh0U25hcHNob3Q7XG4gICAgICAgIHJldHVybiBwcmV2U2VsZWN0aW9uO1xuICAgICAgfVxuICAgICAgbWVtb2l6ZWRTbmFwc2hvdCA9IG5leHRTbmFwc2hvdDtcbiAgICAgIG1lbW9pemVkU2VsZWN0aW9uID0gbmV4dFNlbGVjdGlvbjtcbiAgICAgIHJldHVybiBuZXh0U2VsZWN0aW9uO1xuICAgIH07XG4gICAgY29uc3QgbWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCA9IGdldFNlcnZlclNuYXBzaG90ID09PSB2b2lkIDAgPyBudWxsIDogZ2V0U2VydmVyU25hcHNob3Q7XG4gICAgY29uc3QgZ2V0U25hcHNob3RXaXRoU2VsZWN0b3IgPSAoKSA9PiBtZW1vaXplZFNlbGVjdG9yKGdldFNuYXBzaG90KCkpO1xuICAgIGNvbnN0IGdldFNlcnZlclNuYXBzaG90V2l0aFNlbGVjdG9yID0gbWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCA9PT0gbnVsbCA/IHZvaWQgMCA6ICgpID0+IG1lbW9pemVkU2VsZWN0b3IobWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCgpKTtcbiAgICByZXR1cm4gW2dldFNuYXBzaG90V2l0aFNlbGVjdG9yLCBnZXRTZXJ2ZXJTbmFwc2hvdFdpdGhTZWxlY3Rvcl07XG4gIH0sIFtnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QsIHNlbGVjdG9yLCBpc0VxdWFsXSk7XG4gIGNvbnN0IHZhbHVlID0gdXNlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgc3Vic2NyaWJlLFxuICAgIGdldFNlbGVjdGlvbixcbiAgICBnZXRTZXJ2ZXJTZWxlY3Rpb25cbiAgKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpbnN0Lmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICBpbnN0LnZhbHVlID0gdmFsdWU7XG4gIH0sIFt2YWx1ZV0pO1xuICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBzcmMvdXNlLXNpZ25hbC50c1xudmFyIGlkZW50aXR5ID0gKHZhbHVlKSA9PiB2YWx1ZTtcbmZ1bmN0aW9uIHVzZVNpZ25hbChzaWduYWwsIHNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICBzaWduYWwuc3Vic2NyaWJlLFxuICAgIHNpZ25hbC5nZXQsXG4gICAgc2lnbmFsLmdldCxcbiAgICBzZWxlY3RvciA/PyBpZGVudGl0eSxcbiAgICBpc0VxdWFsXG4gICk7XG59XG5cbi8vIHNyYy9saXZlYmxvY2tzLnRzeFxuaW1wb3J0IHtcbiAgSHR0cEVycm9yXG59IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5pbXBvcnQge1xuICBhc3NlcnQsXG4gIGNyZWF0ZUNsaWVudCxcbiAga0ludGVybmFsIGFzIGtJbnRlcm5hbDIsXG4gIG1ha2VQb2xsZXIsXG4gIHJhaXNlLFxuICBzaGFsbG93IGFzIHNoYWxsb3c0XG59IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5pbXBvcnQge1xuICBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQyLFxuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazIsXG4gIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDIsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QzLFxuICB1c2VNZW1vIGFzIHVzZU1lbW8yLFxuICB1c2VTdGF0ZSxcbiAgdXNlU3luY0V4dGVybmFsU3RvcmUgYXMgdXNlU3luY0V4dGVybmFsU3RvcmUyXG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvY29uZmlnLnRzXG52YXIgU0VDT05EUyA9IDFlMztcbnZhciBNSU5VVEVTID0gNjAgKiBTRUNPTkRTO1xudmFyIGNvbmZpZyA9IHtcbiAgU01PT1RIX0RFTEFZOiAxICogU0VDT05EUyxcbiAgTk9USUZJQ0FUSU9OU19QT0xMX0lOVEVSVkFMOiAxICogTUlOVVRFUyxcbiAgTk9USUZJQ0FUSU9OU19NQVhfU1RBTEVfVElNRTogNSAqIFNFQ09ORFMsXG4gIFJPT01fVEhSRUFEU19QT0xMX0lOVEVSVkFMOiA1ICogTUlOVVRFUyxcbiAgUk9PTV9USFJFQURTX01BWF9TVEFMRV9USU1FOiA1ICogU0VDT05EUyxcbiAgVVNFUl9USFJFQURTX1BPTExfSU5URVJWQUw6IDEgKiBNSU5VVEVTLFxuICBVU0VSX1RIUkVBRFNfTUFYX1NUQUxFX1RJTUU6IDMwICogU0VDT05EUyxcbiAgSElTVE9SWV9WRVJTSU9OU19QT0xMX0lOVEVSVkFMOiAxICogTUlOVVRFUyxcbiAgSElTVE9SWV9WRVJTSU9OU19NQVhfU1RBTEVfVElNRTogNSAqIFNFQ09ORFMsXG4gIE5PVElGSUNBVElPTl9TRVRUSU5HU19QT0xMX0lOVEVSVkFMOiAxICogTUlOVVRFUyxcbiAgTk9USUZJQ0FUSU9OX1NFVFRJTkdTX01BWF9TVEFMRV9USU1FOiA1ICogU0VDT05EUyxcbiAgVVNFUl9OT1RJRklDQVRJT05fU0VUVElOR1NfSU5URVJWQUw6IDUgKiBNSU5VVEVTLFxuICBVU0VSX05PVElGSUNBVElPTl9TRVRUSU5HU19NQVhfU1RBTEVfVElNRTogMSAqIE1JTlVURVNcbn07XG5cbi8vIHNyYy9saWIvQXN5bmNSZXN1bHQudHNcbnZhciBBU1lOQ19MT0FESU5HID0gT2JqZWN0LmZyZWV6ZSh7IGlzTG9hZGluZzogdHJ1ZSB9KTtcbnZhciBBU1lOQ19FUlIgPSAoZXJyb3IpID0+IE9iamVjdC5mcmVlemUoeyBpc0xvYWRpbmc6IGZhbHNlLCBlcnJvciB9KTtcbmZ1bmN0aW9uIEFTWU5DX09LKGZpZWxkT3JEYXRhLCBkYXRhKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBpc0xvYWRpbmc6IGZhbHNlLCBkYXRhOiBmaWVsZE9yRGF0YSB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGlzTG9hZGluZzogZmFsc2UsIFtmaWVsZE9yRGF0YV06IGRhdGEgfSk7XG4gIH1cbn1cblxuLy8gc3JjL2xpYi9pdGVydG9vbHMudHNcbmZ1bmN0aW9uIGZpbmQoaXQsIHByZWRpY2F0ZSkge1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXQpIHtcbiAgICBpZiAocHJlZGljYXRlKGl0ZW0pKSByZXR1cm4gaXRlbTtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gY291bnQoaXQsIHByZWRpY2F0ZSkge1xuICBsZXQgdG90YWwgPSAwO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXQpIHtcbiAgICBpZiAocHJlZGljYXRlKGl0ZW0pKSB0b3RhbCsrO1xuICB9XG4gIHJldHVybiB0b3RhbDtcbn1cblxuLy8gc3JjL2xpYi9zc3IudHNcbmZ1bmN0aW9uIGVuc3VyZU5vdFNlcnZlclNpZGUoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJZb3UgY2Fubm90IHVzZSB0aGUgU3VzcGVuc2UgdmVyc2lvbiBvZiBMaXZlYmxvY2tzIGhvb2tzIHNlcnZlciBzaWRlLiBNYWtlIHN1cmUgdG8gb25seSBjYWxsIHRoZW0gY2xpZW50IHNpZGUgYnkgdXNpbmcgYSBDbGllbnRTaWRlU3VzcGVuc2Ugd3JhcHBlci5cXG5Gb3IgdGlwcywgc2VlIGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1yZWFjdCNDbGllbnRTaWRlU3VzcGVuc2VcIlxuICAgICk7XG4gIH1cbn1cblxuLy8gc3JjL2xpYi91c2UtaW5pdGlhbC50c1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZHVjZXIgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2xpYi91c2UtbGF0ZXN0LnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MiwgdXNlUmVmIGFzIHVzZVJlZjIgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHVzZUxhdGVzdCh2YWx1ZSkge1xuICBjb25zdCByZWYgPSB1c2VSZWYyKHZhbHVlKTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSwgW3ZhbHVlXSk7XG4gIHJldHVybiByZWY7XG59XG5cbi8vIHNyYy9saWIvdXNlLWluaXRpYWwudHNcbnZhciBub29wID0gKHN0YXRlKSA9PiBzdGF0ZTtcbmZ1bmN0aW9uIHVzZUluaXRpYWwodmFsdWUpIHtcbiAgcmV0dXJuIHVzZVJlZHVjZXIobm9vcCwgdmFsdWUpWzBdO1xufVxuZnVuY3Rpb24gdXNlSW5pdGlhbFVubGVzc0Z1bmN0aW9uKGxhdGVzdFZhbHVlKSB7XG4gIGNvbnN0IGZyb3plblZhbHVlID0gdXNlSW5pdGlhbChsYXRlc3RWYWx1ZSk7XG4gIGlmICh0eXBlb2YgZnJvemVuVmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnN0IHJlZiA9IHVzZUxhdGVzdChsYXRlc3RWYWx1ZSk7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKCguLi5hcmdzKSA9PiByZWYuY3VycmVudCguLi5hcmdzKSwgW1xuICAgICAgcmVmXG4gICAgXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZyb3plblZhbHVlO1xuICB9XG59XG5cbi8vIHNyYy9saWIvdXNlLXBvbHlmaWxsLnRzXG52YXIgdXNlID0gKFxuICAvLyBSZWFjdC51c2UgfHxcbiAgKHByb21pc2UpID0+IHtcbiAgICBpZiAocHJvbWlzZS5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICB0aHJvdyBwcm9taXNlO1xuICAgIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIpIHtcbiAgICAgIHJldHVybiBwcm9taXNlLnZhbHVlO1xuICAgIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0dXMgPT09IFwicmVqZWN0ZWRcIikge1xuICAgICAgdGhyb3cgcHJvbWlzZS5yZWFzb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2Uuc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgICBwcm9taXNlLnRoZW4oXG4gICAgICAgICh2KSA9PiB7XG4gICAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICAgIHByb21pc2UudmFsdWUgPSB2O1xuICAgICAgICB9LFxuICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgIHByb21pc2Uuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgIHByb21pc2UucmVhc29uID0gZTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHRocm93IHByb21pc2U7XG4gICAgfVxuICB9XG4pO1xuXG4vLyBzcmMvdW1icmVsbGEtc3RvcmUudHNcbmltcG9ydCB7XG4gIGF1dG9SZXRyeSxcbiAgYmF0Y2ggYXMgYmF0Y2gyLFxuICBjb21wYWN0T2JqZWN0LFxuICBjb25zb2xlIGFzIGNvbnNvbGUyLFxuICBjcmVhdGVVc2VyTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gIERlZmF1bHRNYXAsXG4gIERlcml2ZWRTaWduYWwsXG4gIGtJbnRlcm5hbCxcbiAgTXV0YWJsZVNpZ25hbCBhcyBNdXRhYmxlU2lnbmFsMixcbiAgbmFub2lkLFxuICBubixcbiAgcGF0Y2hVc2VyTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gIHNoYWxsb3cgYXMgc2hhbGxvdzMsXG4gIFNpZ25hbCxcbiAgc3RhYmxlU3RyaW5naWZ5XG59IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5cbi8vIHNyYy9saWIvYXV0b2JpbmQudHNcbmZ1bmN0aW9uIGF1dG9iaW5kKHNlbGYpIHtcbiAgY29uc3Qgc2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHNlZW4uYWRkKFwiY29uc3RydWN0b3JcIik7XG4gIGxldCBvYmogPSBzZWxmLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgZG8ge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIFJlZmxlY3Qub3duS2V5cyhvYmopKSB7XG4gICAgICBpZiAoc2Vlbi5oYXMoa2V5KSkgY29udGludWU7XG4gICAgICBjb25zdCBkZXNjcmlwdG9yID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yPy52YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHNlZW4uYWRkKGtleSk7XG4gICAgICAgIHNlbGZba2V5XSA9IHNlbGZba2V5XS5iaW5kKHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgfSB3aGlsZSAoKG9iaiA9IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSkgJiYgb2JqICE9PSBPYmplY3QucHJvdG90eXBlKTtcbn1cblxuLy8gc3JjL2xpYi9zaGFsbG93Mi50c1xuaW1wb3J0IHsgaXNQbGFpbk9iamVjdCwgc2hhbGxvdyB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5mdW5jdGlvbiBzaGFsbG93MihhLCBiKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdChhKSB8fCAhaXNQbGFpbk9iamVjdChiKSkge1xuICAgIHJldHVybiBzaGFsbG93KGEsIGIpO1xuICB9XG4gIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4ga2V5c0EuZXZlcnkoXG4gICAgKGtleSkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleSkgJiYgc2hhbGxvdyhhW2tleV0sIGJba2V5XSlcbiAgKTtcbn1cblxuLy8gc3JjL1RocmVhZERCLnRzXG5pbXBvcnQgeyBiYXRjaCwgTXV0YWJsZVNpZ25hbCwgU29ydGVkTGlzdCB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5cbi8vIHNyYy9saWIvcXVlcnlpbmcudHNcbmltcG9ydCB7IGlzU3RhcnRzV2l0aE9wZXJhdG9yIH0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmZ1bmN0aW9uIG1ha2VUaHJlYWRzRmlsdGVyKHF1ZXJ5KSB7XG4gIHJldHVybiAodGhyZWFkKSA9PiBtYXRjaGVzUXVlcnkodGhyZWFkLCBxdWVyeSkgJiYgbWF0Y2hlc01ldGFkYXRhKHRocmVhZCwgcXVlcnkpO1xufVxuZnVuY3Rpb24gbWF0Y2hlc1F1ZXJ5KHRocmVhZCwgcSkge1xuICByZXR1cm4gcS5yZXNvbHZlZCA9PT0gdm9pZCAwIHx8IHRocmVhZC5yZXNvbHZlZCA9PT0gcS5yZXNvbHZlZDtcbn1cbmZ1bmN0aW9uIG1hdGNoZXNNZXRhZGF0YSh0aHJlYWQsIHEpIHtcbiAgY29uc3QgbWV0YWRhdGEgPSB0aHJlYWQubWV0YWRhdGE7XG4gIHJldHVybiBxLm1ldGFkYXRhID09PSB2b2lkIDAgfHwgT2JqZWN0LmVudHJpZXMocS5tZXRhZGF0YSkuZXZlcnkoXG4gICAgKFtrZXksIG9wXSkgPT4gKFxuICAgICAgLy8gSWdub3JlIGV4cGxpY2l0LXVuZGVmaW5lZCBmaWx0ZXJzXG4gICAgICAvLyBCb29sZWFuIGxvZ2ljOiBvcD8gPT4gdmFsdWUgbWF0Y2hlcyB0aGUgb3BlcmF0b3JcbiAgICAgIG9wID09PSB2b2lkIDAgfHwgbWF0Y2hlc09wZXJhdG9yKG1ldGFkYXRhW2tleV0sIG9wKVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIG1hdGNoZXNPcGVyYXRvcih2YWx1ZSwgb3ApIHtcbiAgaWYgKG9wID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDA7XG4gIH0gZWxzZSBpZiAoaXNTdGFydHNXaXRoT3BlcmF0b3Iob3ApKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdGFydHNXaXRoKG9wLnN0YXJ0c1dpdGgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gb3A7XG4gIH1cbn1cblxuLy8gc3JjL1RocmVhZERCLnRzXG5mdW5jdGlvbiBzYW5pdGl6ZVRocmVhZCh0aHJlYWQpIHtcbiAgaWYgKHRocmVhZC5kZWxldGVkQXQpIHtcbiAgICBpZiAodGhyZWFkLmNvbW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB7IC4uLnRocmVhZCwgY29tbWVudHM6IFtdIH07XG4gICAgfVxuICB9XG4gIGNvbnN0IGhhc0NvbW1lbnQgPSB0aHJlYWQuY29tbWVudHMuc29tZSgoYykgPT4gIWMuZGVsZXRlZEF0KTtcbiAgaWYgKCFoYXNDb21tZW50KSB7XG4gICAgcmV0dXJuIHsgLi4udGhyZWFkLCBkZWxldGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCBjb21tZW50czogW10gfTtcbiAgfVxuICByZXR1cm4gdGhyZWFkO1xufVxudmFyIFRocmVhZERCID0gY2xhc3MgX1RocmVhZERCIHtcbiAgI2J5SWQ7XG4gICNhc2M7XG4gICNkZXNjO1xuICAvLyBUaGlzIHNpZ25hbCB3aWxsIGJlIG5vdGlmaWVkIG9uIGV2ZXJ5IG11dGF0aW9uXG4gIHNpZ25hbDtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy4jYXNjID0gU29ydGVkTGlzdC5mcm9tKFtdLCAodDEsIHQyKSA9PiB7XG4gICAgICBjb25zdCBkMSA9IHQxLmNyZWF0ZWRBdDtcbiAgICAgIGNvbnN0IGQyID0gdDIuY3JlYXRlZEF0O1xuICAgICAgcmV0dXJuIGQxIDwgZDIgPyB0cnVlIDogZDEgPT09IGQyID8gdDEuaWQgPCB0Mi5pZCA6IGZhbHNlO1xuICAgIH0pO1xuICAgIHRoaXMuI2Rlc2MgPSBTb3J0ZWRMaXN0LmZyb20oW10sICh0MSwgdDIpID0+IHtcbiAgICAgIGNvbnN0IGQyID0gdDIudXBkYXRlZEF0O1xuICAgICAgY29uc3QgZDEgPSB0MS51cGRhdGVkQXQ7XG4gICAgICByZXR1cm4gZDIgPCBkMSA/IHRydWUgOiBkMiA9PT0gZDEgPyB0Mi5pZCA8IHQxLmlkIDogZmFsc2U7XG4gICAgfSk7XG4gICAgdGhpcy4jYnlJZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5zaWduYWwgPSBuZXcgTXV0YWJsZVNpZ25hbCh0aGlzKTtcbiAgfVxuICAvL1xuICAvLyBQdWJsaWMgQVBJc1xuICAvL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBuZXdQb29sID0gbmV3IF9UaHJlYWREQigpO1xuICAgIG5ld1Bvb2wuI2J5SWQgPSBuZXcgTWFwKHRoaXMuI2J5SWQpO1xuICAgIG5ld1Bvb2wuI2FzYyA9IHRoaXMuI2FzYy5jbG9uZSgpO1xuICAgIG5ld1Bvb2wuI2Rlc2MgPSB0aGlzLiNkZXNjLmNsb25lKCk7XG4gICAgcmV0dXJuIG5ld1Bvb2w7XG4gIH1cbiAgLyoqIFJldHVybnMgYW4gZXhpc3RpbmcgdGhyZWFkIGJ5IElELiBXaWxsIG5ldmVyIHJldHVybiBhIGRlbGV0ZWQgdGhyZWFkLiAqL1xuICBnZXQodGhyZWFkSWQpIHtcbiAgICBjb25zdCB0aHJlYWQgPSB0aGlzLmdldEV2ZW5JZkRlbGV0ZWQodGhyZWFkSWQpO1xuICAgIHJldHVybiB0aHJlYWQ/LmRlbGV0ZWRBdCA/IHZvaWQgMCA6IHRocmVhZDtcbiAgfVxuICAvKiogUmV0dXJucyB0aGUgKHBvc3NpYmx5IGRlbGV0ZWQpIHRocmVhZCBieSBJRC4gKi9cbiAgZ2V0RXZlbklmRGVsZXRlZCh0aHJlYWRJZCkge1xuICAgIHJldHVybiB0aGlzLiNieUlkLmdldCh0aHJlYWRJZCk7XG4gIH1cbiAgLyoqIEFkZHMgb3IgdXBkYXRlcyBhIHRocmVhZCBpbiB0aGUgREIuIElmIHRoZSBuZXdseSBnaXZlbiB0aHJlYWQgaXMgYSBkZWxldGVkIG9uZSwgaXQgd2lsbCBnZXQgZGVsZXRlZC4gKi9cbiAgdXBzZXJ0KHRocmVhZCkge1xuICAgIHRoaXMuc2lnbmFsLm11dGF0ZSgoKSA9PiB7XG4gICAgICB0aHJlYWQgPSBzYW5pdGl6ZVRocmVhZCh0aHJlYWQpO1xuICAgICAgY29uc3QgaWQgPSB0aHJlYWQuaWQ7XG4gICAgICBjb25zdCB0b1JlbW92ZSA9IHRoaXMuI2J5SWQuZ2V0KGlkKTtcbiAgICAgIGlmICh0b1JlbW92ZSkge1xuICAgICAgICBpZiAodG9SZW1vdmUuZGVsZXRlZEF0KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuI2FzYy5yZW1vdmUodG9SZW1vdmUpO1xuICAgICAgICB0aGlzLiNkZXNjLnJlbW92ZSh0b1JlbW92ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRocmVhZC5kZWxldGVkQXQpIHtcbiAgICAgICAgdGhpcy4jYXNjLmFkZCh0aHJlYWQpO1xuICAgICAgICB0aGlzLiNkZXNjLmFkZCh0aHJlYWQpO1xuICAgICAgfVxuICAgICAgdGhpcy4jYnlJZC5zZXQoaWQsIHRocmVhZCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuICAvKiogTGlrZSAudXBzZXJ0KCksIGV4Y2VwdCBpdCB3b24ndCB1cGRhdGUgaWYgYSB0aHJlYWQgYnkgdGhpcyBJRCBhbHJlYWR5IGV4aXN0cy4gKi9cbiAgLy8gVE9ETyBDb25zaWRlciByZW5hbWluZyB0aGlzIHRvIGp1c3QgLnVwc2VydCgpLiBJJ20gbm90IHN1cmUgaWYgd2UgcmVhbGx5XG4gIC8vIFRPRE8gbmVlZCB0aGUgcmF3IC51cHNlcnQoKS4gV291bGQgYmUgbmljZSBpZiB0aGlzIGJlaGF2aW9yIHdhcyB0aGUgZGVmYXVsdC5cbiAgdXBzZXJ0SWZOZXdlcih0aHJlYWQpIHtcbiAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuZ2V0KHRocmVhZC5pZCk7XG4gICAgaWYgKCFleGlzdGluZyB8fCB0aHJlYWQudXBkYXRlZEF0ID49IGV4aXN0aW5nLnVwZGF0ZWRBdCkge1xuICAgICAgdGhpcy51cHNlcnQodGhyZWFkKTtcbiAgICB9XG4gIH1cbiAgYXBwbHlEZWx0YShuZXdUaHJlYWRzLCBkZWxldGVkVGhyZWFkcykge1xuICAgIGJhdGNoKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgdGhyZWFkIG9mIG5ld1RocmVhZHMpIHtcbiAgICAgICAgdGhpcy51cHNlcnRJZk5ld2VyKHRocmVhZCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHsgaWQsIGRlbGV0ZWRBdCB9IG9mIGRlbGV0ZWRUaHJlYWRzKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5nZXRFdmVuSWZEZWxldGVkKGlkKTtcbiAgICAgICAgaWYgKCFleGlzdGluZykgY29udGludWU7XG4gICAgICAgIHRoaXMuZGVsZXRlKGlkLCBkZWxldGVkQXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBNYXJrcyBhIHRocmVhZCBhcyBkZWxldGVkLiBJdCB3aWxsIG5vIGxvbmdlciBwb3AgdXAgaW4gLmZpbmRNYW55KClcbiAgICogcXVlcmllcywgYnV0IGl0IGNhbiBzdGlsbCBiZSBhY2Nlc3NlZCB2aWEgYC5nZXRFdmVuSWZEZWxldGVkKClgLlxuICAgKi9cbiAgZGVsZXRlKHRocmVhZElkLCBkZWxldGVkQXQpIHtcbiAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuI2J5SWQuZ2V0KHRocmVhZElkKTtcbiAgICBpZiAoZXhpc3RpbmcgJiYgIWV4aXN0aW5nLmRlbGV0ZWRBdCkge1xuICAgICAgdGhpcy51cHNlcnQoeyAuLi5leGlzdGluZywgZGVsZXRlZEF0LCB1cGRhdGVkQXQ6IGRlbGV0ZWRBdCB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIHRocmVhZHMgbWF0Y2hpbmcgYSBnaXZlbiByb29tSWQgYW5kIHF1ZXJ5LiBJZiByb29tSWQgaXMgbm90XG4gICAqIHNwZWNpZmllZCwgaXQgd2lsbCByZXR1cm4gYWxsIHRocmVhZHMgbWF0Y2hpbmcgdGhlIHF1ZXJ5LCBhY3Jvc3MgYWxsXG4gICAqIHJvb21zLlxuICAgKlxuICAgKiBSZXR1cm5zIHRoZSByZXN1bHRzIGluIHRoZSByZXF1ZXN0ZWQgb3JkZXIuIFBsZWFzZSBub3RlOlxuICAgKiAgICdhc2MnICBtZWFucyBieSBjcmVhdGVkQXQgQVNDXG4gICAqICAgJ2Rlc2MnIG1lYW5zIGJ5IHVwZGF0ZWRBdCBERVNDXG4gICAqXG4gICAqIFdpbGwgbmV2ZXIgcmV0dXJuIGRlbGV0ZWQgdGhyZWFkcyBpbiB0aGUgcmVzdWx0LlxuICAgKi9cbiAgZmluZE1hbnkocm9vbUlkLCBxdWVyeSwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgaW5kZXggPSBkaXJlY3Rpb24gPT09IFwiZGVzY1wiID8gdGhpcy4jZGVzYyA6IHRoaXMuI2FzYztcbiAgICBjb25zdCBjcml0ID0gW107XG4gICAgaWYgKHJvb21JZCAhPT0gdm9pZCAwKSB7XG4gICAgICBjcml0LnB1c2goKHQpID0+IHQucm9vbUlkID09PSByb29tSWQpO1xuICAgIH1cbiAgICBjcml0LnB1c2gobWFrZVRocmVhZHNGaWx0ZXIocXVlcnkpKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShpbmRleC5maWx0ZXIoKHQpID0+IGNyaXQuZXZlcnkoKHByZWQpID0+IHByZWQodCkpKSk7XG4gIH1cbn07XG5cbi8vIHNyYy91bWJyZWxsYS1zdG9yZS50c1xuZnVuY3Rpb24gbWFrZVJvb21UaHJlYWRzUXVlcnlLZXkocm9vbUlkLCBxdWVyeSkge1xuICByZXR1cm4gc3RhYmxlU3RyaW5naWZ5KFtyb29tSWQsIHF1ZXJ5ID8/IHt9XSk7XG59XG5mdW5jdGlvbiBtYWtlVXNlclRocmVhZHNRdWVyeUtleShxdWVyeSkge1xuICByZXR1cm4gc3RhYmxlU3RyaW5naWZ5KHF1ZXJ5ID8/IHt9KTtcbn1cbmZ1bmN0aW9uIHVzaWZ5KHByb21pc2UpIHtcbiAgaWYgKFwic3RhdHVzXCIgaW4gcHJvbWlzZSkge1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGNvbnN0IHVzYWJsZSA9IHByb21pc2U7XG4gIHVzYWJsZS5zdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgdXNhYmxlLnRoZW4oXG4gICAgKHZhbHVlKSA9PiB7XG4gICAgICB1c2FibGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgIHVzYWJsZS52YWx1ZSA9IHZhbHVlO1xuICAgIH0sXG4gICAgKGVycikgPT4ge1xuICAgICAgdXNhYmxlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgIHVzYWJsZS5yZWFzb24gPSBlcnI7XG4gICAgfVxuICApO1xuICByZXR1cm4gdXNhYmxlO1xufVxudmFyIG5vb3AyID0gUHJvbWlzZS5yZXNvbHZlKCk7XG52YXIgUGFnaW5hdGVkUmVzb3VyY2UgPSBjbGFzcyB7XG4gICNzaWduYWw7XG4gIHNpZ25hbDtcbiAgI2ZldGNoUGFnZTtcbiAgI3BlbmRpbmdGZXRjaE1vcmU7XG4gIGNvbnN0cnVjdG9yKGZldGNoUGFnZSkge1xuICAgIHRoaXMuI3NpZ25hbCA9IG5ldyBTaWduYWwoQVNZTkNfTE9BRElORyk7XG4gICAgdGhpcy4jZmV0Y2hQYWdlID0gZmV0Y2hQYWdlO1xuICAgIHRoaXMuI3BlbmRpbmdGZXRjaE1vcmUgPSBudWxsO1xuICAgIHRoaXMuc2lnbmFsID0gdGhpcy4jc2lnbmFsLmFzUmVhZG9ubHkoKTtcbiAgICBhdXRvYmluZCh0aGlzKTtcbiAgfVxuICBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NpZ25hbC5nZXQoKTtcbiAgfVxuICAjcGF0Y2gocGF0Y2gpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuI3NpZ25hbC5nZXQoKTtcbiAgICBpZiAoc3RhdGUuZGF0YSA9PT0gdm9pZCAwKSByZXR1cm47XG4gICAgdGhpcy4jc2lnbmFsLnNldChBU1lOQ19PSyh7IC4uLnN0YXRlLmRhdGEsIC4uLnBhdGNoIH0pKTtcbiAgfVxuICBhc3luYyAjZmV0Y2hNb3JlKCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy4jc2lnbmFsLmdldCgpO1xuICAgIGlmICghc3RhdGUuZGF0YT8uY3Vyc29yIHx8IHN0YXRlLmRhdGEuaXNGZXRjaGluZ01vcmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jcGF0Y2goeyBpc0ZldGNoaW5nTW9yZTogdHJ1ZSB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbmV4dEN1cnNvciA9IGF3YWl0IHRoaXMuI2ZldGNoUGFnZShzdGF0ZS5kYXRhLmN1cnNvcik7XG4gICAgICB0aGlzLiNwYXRjaCh7XG4gICAgICAgIGN1cnNvcjogbmV4dEN1cnNvcixcbiAgICAgICAgaGFzRmV0Y2hlZEFsbDogbmV4dEN1cnNvciA9PT0gbnVsbCxcbiAgICAgICAgZmV0Y2hNb3JlRXJyb3I6IHZvaWQgMCxcbiAgICAgICAgaXNGZXRjaGluZ01vcmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuI3BhdGNoKHtcbiAgICAgICAgaXNGZXRjaGluZ01vcmU6IGZhbHNlLFxuICAgICAgICBmZXRjaE1vcmVFcnJvcjogZXJyXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZmV0Y2hNb3JlKCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy4jc2lnbmFsLmdldCgpO1xuICAgIGlmICghc3RhdGUuZGF0YT8uY3Vyc29yKSByZXR1cm4gbm9vcDI7XG4gICAgaWYgKCF0aGlzLiNwZW5kaW5nRmV0Y2hNb3JlKSB7XG4gICAgICB0aGlzLiNwZW5kaW5nRmV0Y2hNb3JlID0gdGhpcy4jZmV0Y2hNb3JlKCkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHRoaXMuI3BlbmRpbmdGZXRjaE1vcmUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNwZW5kaW5nRmV0Y2hNb3JlO1xuICB9XG4gICNjYWNoZWRQcm9taXNlID0gbnVsbDtcbiAgd2FpdFVudGlsTG9hZGVkKCkge1xuICAgIGlmICh0aGlzLiNjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy4jY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgaW5pdGlhbFBhZ2VGZXRjaCQgPSBhdXRvUmV0cnkoXG4gICAgICAoKSA9PiB0aGlzLiNmZXRjaFBhZ2UoXG4gICAgICAgIC8qIGN1cnNvciAqL1xuICAgICAgICB2b2lkIDBcbiAgICAgICksXG4gICAgICA1LFxuICAgICAgWzVlMywgNWUzLCAxZTQsIDE1ZTNdXG4gICAgKTtcbiAgICBjb25zdCBwcm9taXNlID0gdXNpZnkoaW5pdGlhbFBhZ2VGZXRjaCQpO1xuICAgIHByb21pc2UudGhlbihcbiAgICAgIChjdXJzb3IpID0+IHtcbiAgICAgICAgdGhpcy4jc2lnbmFsLnNldChcbiAgICAgICAgICBBU1lOQ19PSyh7XG4gICAgICAgICAgICBjdXJzb3IsXG4gICAgICAgICAgICBoYXNGZXRjaGVkQWxsOiBjdXJzb3IgPT09IG51bGwsXG4gICAgICAgICAgICBpc0ZldGNoaW5nTW9yZTogZmFsc2UsXG4gICAgICAgICAgICBmZXRjaE1vcmVFcnJvcjogdm9pZCAwLFxuICAgICAgICAgICAgZmV0Y2hNb3JlOiB0aGlzLmZldGNoTW9yZVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgKGVycikgPT4ge1xuICAgICAgICB0aGlzLiNzaWduYWwuc2V0KEFTWU5DX0VSUihlcnIpKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy4jY2FjaGVkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgdGhpcy4jc2lnbmFsLnNldChBU1lOQ19MT0FESU5HKTtcbiAgICAgICAgfSwgNWUzKTtcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuI2NhY2hlZFByb21pc2UgPSBwcm9taXNlO1xuICAgIHJldHVybiB0aGlzLiNjYWNoZWRQcm9taXNlO1xuICB9XG59O1xudmFyIFNpbmdsZVBhZ2VSZXNvdXJjZSA9IGNsYXNzIHtcbiAgI3NpZ25hbDtcbiAgc2lnbmFsO1xuICAjZmV0Y2hQYWdlO1xuICBjb25zdHJ1Y3RvcihmZXRjaFBhZ2UpIHtcbiAgICB0aGlzLiNzaWduYWwgPSBuZXcgU2lnbmFsKEFTWU5DX0xPQURJTkcpO1xuICAgIHRoaXMuc2lnbmFsID0gdGhpcy4jc2lnbmFsLmFzUmVhZG9ubHkoKTtcbiAgICB0aGlzLiNmZXRjaFBhZ2UgPSBmZXRjaFBhZ2U7XG4gICAgYXV0b2JpbmQodGhpcyk7XG4gIH1cbiAgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLiNzaWduYWwuZ2V0KCk7XG4gIH1cbiAgI2NhY2hlZFByb21pc2UgPSBudWxsO1xuICB3YWl0VW50aWxMb2FkZWQoKSB7XG4gICAgaWYgKHRoaXMuI2NhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLiNjYWNoZWRQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBpbml0aWFsRmV0Y2hlciQgPSBhdXRvUmV0cnkoXG4gICAgICAoKSA9PiB0aGlzLiNmZXRjaFBhZ2UoKSxcbiAgICAgIDUsXG4gICAgICBbNWUzLCA1ZTMsIDFlNCwgMTVlM11cbiAgICApO1xuICAgIGNvbnN0IHByb21pc2UgPSB1c2lmeShpbml0aWFsRmV0Y2hlciQpO1xuICAgIHByb21pc2UudGhlbihcbiAgICAgICgpID0+IHtcbiAgICAgICAgdGhpcy4jc2lnbmFsLnNldChBU1lOQ19PSyh2b2lkIDApKTtcbiAgICAgIH0sXG4gICAgICAoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMuI3NpZ25hbC5zZXQoQVNZTkNfRVJSKGVycikpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLiNjYWNoZWRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLiNzaWduYWwuc2V0KEFTWU5DX0xPQURJTkcpO1xuICAgICAgICB9LCA1ZTMpO1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy4jY2FjaGVkUHJvbWlzZSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVTdG9yZV9mb3JOb3RpZmljYXRpb25zKCkge1xuICBjb25zdCBzaWduYWwgPSBuZXcgTXV0YWJsZVNpZ25hbDIoLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIGZ1bmN0aW9uIG1hcmtSZWFkKG5vdGlmaWNhdGlvbklkLCByZWFkQXQpIHtcbiAgICBzaWduYWwubXV0YXRlKChsdXQpID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gbHV0LmdldChub3RpZmljYXRpb25JZCk7XG4gICAgICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGx1dC5zZXQobm90aWZpY2F0aW9uSWQsIHsgLi4uZXhpc3RpbmcsIHJlYWRBdCB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIG1hcmtBbGxSZWFkKHJlYWRBdCkge1xuICAgIHNpZ25hbC5tdXRhdGUoKGx1dCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBuIG9mIGx1dC52YWx1ZXMoKSkge1xuICAgICAgICBuLnJlYWRBdCA9IHJlYWRBdDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBkZWxldGVPbmUoaW5ib3hOb3RpZmljYXRpb25JZCkge1xuICAgIHNpZ25hbC5tdXRhdGUoKGx1dCkgPT4gbHV0LmRlbGV0ZShpbmJveE5vdGlmaWNhdGlvbklkKSk7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgc2lnbmFsLm11dGF0ZSgobHV0KSA9PiBsdXQuY2xlYXIoKSk7XG4gIH1cbiAgZnVuY3Rpb24gYXBwbHlEZWx0YShuZXdOb3RpZmljYXRpb25zLCBkZWxldGVkTm90aWZpY2F0aW9ucykge1xuICAgIHNpZ25hbC5tdXRhdGUoKGx1dCkgPT4ge1xuICAgICAgbGV0IG11dGF0ZWQgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgbiBvZiBuZXdOb3RpZmljYXRpb25zKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gbHV0LmdldChuLmlkKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGFyZUluYm94Tm90aWZpY2F0aW9ucyhleGlzdGluZywgbik7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gMSkgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbHV0LnNldChuLmlkLCBuKTtcbiAgICAgICAgbXV0YXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IG4gb2YgZGVsZXRlZE5vdGlmaWNhdGlvbnMpIHtcbiAgICAgICAgbHV0LmRlbGV0ZShuLmlkKTtcbiAgICAgICAgbXV0YXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbXV0YXRlZDtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVBc3NvY2lhdGVkTm90aWZpY2F0aW9uKG5ld0NvbW1lbnQpIHtcbiAgICBzaWduYWwubXV0YXRlKChsdXQpID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gZmluZChcbiAgICAgICAgbHV0LnZhbHVlcygpLFxuICAgICAgICAobm90aWZpY2F0aW9uKSA9PiBub3RpZmljYXRpb24ua2luZCA9PT0gXCJ0aHJlYWRcIiAmJiBub3RpZmljYXRpb24udGhyZWFkSWQgPT09IG5ld0NvbW1lbnQudGhyZWFkSWRcbiAgICAgICk7XG4gICAgICBpZiAoIWV4aXN0aW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICBsdXQuc2V0KGV4aXN0aW5nLmlkLCB7XG4gICAgICAgIC4uLmV4aXN0aW5nLFxuICAgICAgICBub3RpZmllZEF0OiBuZXdDb21tZW50LmNyZWF0ZWRBdCxcbiAgICAgICAgcmVhZEF0OiBuZXdDb21tZW50LmNyZWF0ZWRBdFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiB1cHNlcnQobm90aWZpY2F0aW9uKSB7XG4gICAgc2lnbmFsLm11dGF0ZSgobHV0KSA9PiB7XG4gICAgICBsdXQuc2V0KG5vdGlmaWNhdGlvbi5pZCwgbm90aWZpY2F0aW9uKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNpZ25hbDogc2lnbmFsLmFzUmVhZG9ubHkoKSxcbiAgICAvLyBNdXRhdGlvbnNcbiAgICBtYXJrQWxsUmVhZCxcbiAgICBtYXJrUmVhZCxcbiAgICBkZWxldGU6IGRlbGV0ZU9uZSxcbiAgICBhcHBseURlbHRhLFxuICAgIGNsZWFyLFxuICAgIHVwZGF0ZUFzc29jaWF0ZWROb3RpZmljYXRpb24sXG4gICAgdXBzZXJ0XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTdG9yZV9mb3JSb29tTm90aWZpY2F0aW9uU2V0dGluZ3ModXBkYXRlcykge1xuICBjb25zdCBiYXNlU2lnbmFsID0gbmV3IE11dGFibGVTaWduYWwyKC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICBmdW5jdGlvbiB1cGRhdGUocm9vbUlkLCBzZXR0aW5ncykge1xuICAgIGJhc2VTaWduYWwubXV0YXRlKChsdXQpID0+IHtcbiAgICAgIGx1dC5zZXQocm9vbUlkLCBzZXR0aW5ncyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzaWduYWw6IERlcml2ZWRTaWduYWwuZnJvbShcbiAgICAgIGJhc2VTaWduYWwsXG4gICAgICB1cGRhdGVzLFxuICAgICAgKGJhc2UsIHVwZGF0ZXMyKSA9PiBhcHBseU9wdGltaXN0aWNVcGRhdGVzX2ZvclNldHRpbmdzKGJhc2UsIHVwZGF0ZXMyKVxuICAgICksXG4gICAgLy8gTXV0YXRpb25zXG4gICAgdXBkYXRlXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTdG9yZV9mb3JIaXN0b3J5VmVyc2lvbnMoKSB7XG4gIGNvbnN0IGJhc2VTaWduYWwgPSBuZXcgTXV0YWJsZVNpZ25hbDIoXG4gICAgbmV3IERlZmF1bHRNYXAoKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSlcbiAgKTtcbiAgZnVuY3Rpb24gdXBkYXRlKHJvb21JZCwgdmVyc2lvbnMpIHtcbiAgICBiYXNlU2lnbmFsLm11dGF0ZSgobHV0KSA9PiB7XG4gICAgICBjb25zdCB2ZXJzaW9uc0J5SWQgPSBsdXQuZ2V0T3JDcmVhdGUocm9vbUlkKTtcbiAgICAgIGZvciAoY29uc3QgdmVyc2lvbiBvZiB2ZXJzaW9ucykge1xuICAgICAgICB2ZXJzaW9uc0J5SWQuc2V0KHZlcnNpb24uaWQsIHZlcnNpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2lnbmFsOiBEZXJpdmVkU2lnbmFsLmZyb20oXG4gICAgICBiYXNlU2lnbmFsLFxuICAgICAgKGh2KSA9PiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIFsuLi5odl0ubWFwKChbcm9vbUlkLCB2ZXJzaW9uc10pID0+IFtcbiAgICAgICAgICByb29tSWQsXG4gICAgICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKHZlcnNpb25zKVxuICAgICAgICBdKVxuICAgICAgKVxuICAgICksXG4gICAgLy8gTXV0YXRpb25zXG4gICAgdXBkYXRlXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTdG9yZV9mb3JQZXJtaXNzaW9uSGludHMoKSB7XG4gIGNvbnN0IHNpZ25hbCA9IG5ldyBNdXRhYmxlU2lnbmFsMihcbiAgICBuZXcgRGVmYXVsdE1hcCgoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKVxuICApO1xuICBmdW5jdGlvbiB1cGRhdGUobmV3SGludHMpIHtcbiAgICBzaWduYWwubXV0YXRlKChsdXQpID0+IHtcbiAgICAgIGZvciAoY29uc3QgW3Jvb21JZCwgbmV3UGVybWlzc2lvbnNdIG9mIE9iamVjdC5lbnRyaWVzKG5ld0hpbnRzKSkge1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IGx1dC5nZXRPckNyZWF0ZShyb29tSWQpO1xuICAgICAgICBmb3IgKGNvbnN0IHBlcm1pc3Npb24gb2YgbmV3UGVybWlzc2lvbnMpIHtcbiAgICAgICAgICBleGlzdGluZy5hZGQocGVybWlzc2lvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNpZ25hbDogc2lnbmFsLmFzUmVhZG9ubHkoKSxcbiAgICAvLyBNdXRhdGlvbnNcbiAgICB1cGRhdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlX2ZvclVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyh1cGRhdGVzKSB7XG4gIGNvbnN0IHNpZ25hbCA9IG5ldyBTaWduYWwoXG4gICAgY3JlYXRlVXNlck5vdGlmaWNhdGlvblNldHRpbmdzKHt9KVxuICApO1xuICBmdW5jdGlvbiB1cGRhdGUoc2V0dGluZ3MpIHtcbiAgICBzaWduYWwuc2V0KHNldHRpbmdzKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNpZ25hbDogRGVyaXZlZFNpZ25hbC5mcm9tKFxuICAgICAgc2lnbmFsLFxuICAgICAgdXBkYXRlcyxcbiAgICAgIChiYXNlLCB1cGRhdGVzMikgPT4gYXBwbHlPcHRpbWlzdGljVXBkYXRlc19mb3JVc2VyTm90aWZpY2F0aW9uU2V0dGluZ3MoYmFzZSwgdXBkYXRlczIpXG4gICAgKSxcbiAgICAvLyBNdXRhdGlvbnNcbiAgICB1cGRhdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlX2Zvck9wdGltaXN0aWMoY2xpZW50KSB7XG4gIGNvbnN0IHNpZ25hbCA9IG5ldyBTaWduYWwoW10pO1xuICBjb25zdCBzeW5jU291cmNlID0gY2xpZW50W2tJbnRlcm5hbF0uY3JlYXRlU3luY1NvdXJjZSgpO1xuICBzaWduYWwuc3Vic2NyaWJlKFxuICAgICgpID0+IHN5bmNTb3VyY2Uuc2V0U3luY1N0YXR1cyhcbiAgICAgIHNpZ25hbC5nZXQoKS5sZW5ndGggPiAwID8gXCJzeW5jaHJvbml6aW5nXCIgOiBcInN5bmNocm9uaXplZFwiXG4gICAgKVxuICApO1xuICBmdW5jdGlvbiBhZGQob3B0aW1pc3RpY1VwZGF0ZSkge1xuICAgIGNvbnN0IGlkID0gbmFub2lkKCk7XG4gICAgY29uc3QgbmV3VXBkYXRlID0geyAuLi5vcHRpbWlzdGljVXBkYXRlLCBpZCB9O1xuICAgIHNpZ25hbC5zZXQoKHN0YXRlKSA9PiBbLi4uc3RhdGUsIG5ld1VwZGF0ZV0pO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmUob3B0aW1pc3RpY0lkKSB7XG4gICAgc2lnbmFsLnNldCgoc3RhdGUpID0+IHN0YXRlLmZpbHRlcigob3UpID0+IG91LmlkICE9PSBvcHRpbWlzdGljSWQpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNpZ25hbDogc2lnbmFsLmFzUmVhZG9ubHkoKSxcbiAgICAvLyBNdXRhdGlvbnNcbiAgICBhZGQsXG4gICAgcmVtb3ZlXG4gIH07XG59XG52YXIgVW1icmVsbGFTdG9yZSA9IGNsYXNzIHtcbiAgI2NsaWVudDtcbiAgLy9cbiAgLy8gSW50ZXJuYWxseSwgdGhlIFVtYnJlbGxhU3RvcmUga2VlcHMgdHJhY2sgb2YgYSBmZXcgc291cmNlIHNpZ25hbHMgdGhhdCBjYW5cbiAgLy8gYmUgc2V0IGFuZCBtdXRhdGVkIGluZGl2aWR1YWxseS4gV2hlbiBhbnkgb2YgdGhvc2UgYXJlIG11dGF0ZWQgdGhlbiB0aGVcbiAgLy8gY2xlYW4gXCJleHRlcm5hbCBzdGF0ZVwiIGlzIHJlY29tcHV0ZWQuXG4gIC8vXG4gIC8vICAgTXV0YXRlIGlucHV0cy4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9ic2VydmUgY2xlYW4vY29uc2lzdGVudCBvdXRwdXQhXG4gIC8vXG4gIC8vICAgICAgICAgICAgLi0+IEJhc2UgVGhyZWFkREIgLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgKy0tLS0+IENsZWFuIHRocmVhZHMgYnkgSUQgICAgICAgICAgIChQYXJ0IDEpXG4gIC8vICAgICAgICAgICAvICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgfFxuICAvLyAgIG11dGF0ZSAtLS0tPiBCYXNlIE5vdGlmaWNhdGlvbnMgLS0rIHwgICAgICAgICAgICAgICAgIHwgKy0tPiBDbGVhbiBub3RpZmljYXRpb25zICAgICAgICAgICAoUGFydCAxKVxuICAvLyAgICAgICAgICBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgfCB8ICAgICAgICAgICAgICAgICB8IHwgICAgJiBub3RpZmljYXRpb25zIGJ5IElEXG4gIC8vICAgICAgICAgfCBcXCAgICAgICAgICAgICAgICAgICAgICAgICB8IHwgICAgICBBcHBseSAgICAgIHwgfFxuICAvLyAgICAgICAgIHwgICBgLT4gT3B0aW1pc3RpY1VwZGF0ZXMgLS0rLS0rLS0+IE9wdGltaXN0aWMgLS0rLSstLT4gUm9vbSBOb3RpZmljYXRpb24gU2V0dGluZ3MgICAoUGFydCAyKVxuICAvLyAgICAgICAgICBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgVXBkYXRlcyAgICB8ICB8XG4gIC8vICAgICAgICAgICBgLS0tLS0tLSBldGMgZXRjIC0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgfCAgKy0tPiBIaXN0b3J5IFZlcnNpb25zICAgICAgICAgICAgIChQYXJ0IDMpXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICBeICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLT4gVXNlciBOb3RpZmljYXRpb24gU2V0dGluZ3MgICAoUGFydCA0KVxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgfFxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgfFxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIF4gICAgICAgICAgICAgICAgICBeXG4gIC8vICAgICAgICAgICAgICAgICAgICBTaWduYWwgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgIHxcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgb3IgICAgICAgICAgICAgICAgICAgRGVyaXZlZFNpZ25hbCAgICAgIERlcml2ZWRTaWduYWxzXG4gIC8vICAgICAgICAgICAgICAgICAgTXV0YWJsZVNpZ25hbFxuICAvL1xuICAvL1xuICAvLyBJbnB1dCBzaWduYWxzLlxuICAvLyAoQ2FuIGJlIG11dGF0ZWQgZGlyZWN0bHkuKVxuICAvL1xuICAvLyBYWFhfdmluY2VudCBOb3cgdGhhdCB3ZSBoYXZlIGNyZWF0ZVN0b3JlX2ZvclgsIHdlIHNob3VsZCBwcm9iYWJseSBhbHNvIGNoYW5nZVxuICAvLyBgdGhyZWFkc2AgdG8gdGhpcyBwYXR0ZXJuLCBpZSBjcmVhdGUgYSBjcmVhdGVTdG9yZV9mb3JUaHJlYWRzIGhlbHBlciBhc1xuICAvLyB3ZWxsLiBJdCBhbG1vc3Qgd29ya3MgbGlrZSB0aGF0IGFscmVhZHkgYW55d2F5IVxuICB0aHJlYWRzO1xuICAvLyBFeHBvc2VzIGl0cyBzaWduYWwgdW5kZXIgYC5zaWduYWxgIHByb3BcbiAgbm90aWZpY2F0aW9ucztcbiAgcm9vbU5vdGlmaWNhdGlvblNldHRpbmdzO1xuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgaGlzdG9yeVZlcnNpb25zO1xuICBwZXJtaXNzaW9uSGludHM7XG4gIHVzZXJOb3RpZmljYXRpb25TZXR0aW5ncztcbiAgb3B0aW1pc3RpY1VwZGF0ZXM7XG4gIC8vXG4gIC8vIE91dHB1dCBzaWduYWxzLlxuICAvLyAoUmVhZG9ubHksIGNsZWFuLCBjb25zaXN0ZW50LiBXaXRoIG9wdGltaXN0aWMgdXBkYXRlcyBhcHBsaWVkLilcbiAgLy9cbiAgLy8gTm90ZSB0aGF0IHRoZSBvdXRwdXQgb2YgdGhyZWFkaWZpY2F0aW9ucyBzaWduYWwgaXMgdGhlIHNhbWUgYXMgdGhlIG9uZXMgZm9yXG4gIC8vIHRocmVhZHMgYW5kIG5vdGlmaWNhdGlvbnMgc2VwYXJhdGVseSwgYnV0IHRoZSB0aHJlYWRpZmljYXRpb25zIHNpZ25hbCB3aWxsXG4gIC8vIGJlIHVwZGF0ZWQgd2hlbmV2ZXIgZWl0aGVyIG9mIHRoZW0gY2hhbmdlLlxuICAvL1xuICBvdXRwdXRzO1xuICAvLyBOb3RpZmljYXRpb25zXG4gICNub3RpZmljYXRpb25zTGFzdFJlcXVlc3RlZEF0ID0gbnVsbDtcbiAgLy8gS2VlcHMgdHJhY2sgb2Ygd2hlbiB3ZSBzdWNjZXNzZnVsbHkgcmVxdWVzdGVkIGFuIGluYm94IG5vdGlmaWNhdGlvbnMgdXBkYXRlIGZvciB0aGUgbGFzdCB0aW1lLiBXaWxsIGJlIGBudWxsYCBhcyBsb25nIGFzIHRoZSBmaXJzdCBzdWNjZXNzZnVsIGZldGNoIGhhc24ndCBoYXBwZW5lZCB5ZXQuXG4gICNub3RpZmljYXRpb25zUGFnaW5hdGlvblN0YXRlO1xuICAvLyBSb29tIFRocmVhZHNcbiAgI3Jvb21UaHJlYWRzTGFzdFJlcXVlc3RlZEF0QnlSb29tID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgLy8gVXNlciBUaHJlYWRzXG4gICN1c2VyVGhyZWFkc0xhc3RSZXF1ZXN0ZWRBdCA9IG51bGw7XG4gIC8vIFJvb20gdmVyc2lvbnNcbiAgI3Jvb21WZXJzaW9uc0xhc3RSZXF1ZXN0ZWRBdEJ5Um9vbSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIC8vIFVzZXIgTm90aWZpY2F0aW9uIFNldHRpbmdzXG4gICN1c2VyTm90aWZpY2F0aW9uU2V0dGluZ3M7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHRoaXMuI2NsaWVudCA9IGNsaWVudFtrSW50ZXJuYWxdLmFzKCk7XG4gICAgdGhpcy5vcHRpbWlzdGljVXBkYXRlcyA9IGNyZWF0ZVN0b3JlX2Zvck9wdGltaXN0aWModGhpcy4jY2xpZW50KTtcbiAgICB0aGlzLnBlcm1pc3Npb25IaW50cyA9IGNyZWF0ZVN0b3JlX2ZvclBlcm1pc3Npb25IaW50cygpO1xuICAgIHRoaXMuI25vdGlmaWNhdGlvbnNQYWdpbmF0aW9uU3RhdGUgPSBuZXcgUGFnaW5hdGVkUmVzb3VyY2UoXG4gICAgICBhc3luYyAoY3Vyc29yKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI2NsaWVudC5nZXRJbmJveE5vdGlmaWNhdGlvbnMoeyBjdXJzb3IgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlVGhyZWFkaWZpY2F0aW9ucyhyZXN1bHQudGhyZWFkcywgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLiNub3RpZmljYXRpb25zTGFzdFJlcXVlc3RlZEF0ID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy4jbm90aWZpY2F0aW9uc0xhc3RSZXF1ZXN0ZWRBdCA9IHJlc3VsdC5yZXF1ZXN0ZWRBdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0Q3Vyc29yID0gcmVzdWx0Lm5leHRDdXJzb3I7XG4gICAgICAgIHJldHVybiBuZXh0Q3Vyc29yO1xuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgdXNlck5vdGlmaWNhdGlvblNldHRpbmdzRmV0Y2hlciA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI2NsaWVudC5nZXROb3RpZmljYXRpb25TZXR0aW5ncygpO1xuICAgICAgdGhpcy51c2VyTm90aWZpY2F0aW9uU2V0dGluZ3MudXBkYXRlKHJlc3VsdCk7XG4gICAgfTtcbiAgICB0aGlzLnVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyA9IGNyZWF0ZVN0b3JlX2ZvclVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyhcbiAgICAgIHRoaXMub3B0aW1pc3RpY1VwZGF0ZXMuc2lnbmFsXG4gICAgKTtcbiAgICB0aGlzLiN1c2VyTm90aWZpY2F0aW9uU2V0dGluZ3MgPSBuZXcgU2luZ2xlUGFnZVJlc291cmNlKFxuICAgICAgdXNlck5vdGlmaWNhdGlvblNldHRpbmdzRmV0Y2hlclxuICAgICk7XG4gICAgdGhpcy50aHJlYWRzID0gbmV3IFRocmVhZERCKCk7XG4gICAgdGhpcy5ub3RpZmljYXRpb25zID0gY3JlYXRlU3RvcmVfZm9yTm90aWZpY2F0aW9ucygpO1xuICAgIHRoaXMucm9vbU5vdGlmaWNhdGlvblNldHRpbmdzID0gY3JlYXRlU3RvcmVfZm9yUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKFxuICAgICAgdGhpcy5vcHRpbWlzdGljVXBkYXRlcy5zaWduYWxcbiAgICApO1xuICAgIHRoaXMuaGlzdG9yeVZlcnNpb25zID0gY3JlYXRlU3RvcmVfZm9ySGlzdG9yeVZlcnNpb25zKCk7XG4gICAgY29uc3QgdGhyZWFkaWZpY2F0aW9ucyA9IERlcml2ZWRTaWduYWwuZnJvbShcbiAgICAgIHRoaXMudGhyZWFkcy5zaWduYWwsXG4gICAgICB0aGlzLm5vdGlmaWNhdGlvbnMuc2lnbmFsLFxuICAgICAgdGhpcy5vcHRpbWlzdGljVXBkYXRlcy5zaWduYWwsXG4gICAgICAodHMsIG5zLCB1cGRhdGVzKSA9PiBhcHBseU9wdGltaXN0aWNVcGRhdGVzX2ZvclRocmVhZGlmaWNhdGlvbnModHMsIG5zLCB1cGRhdGVzKVxuICAgICk7XG4gICAgY29uc3QgdGhyZWFkcyA9IERlcml2ZWRTaWduYWwuZnJvbSh0aHJlYWRpZmljYXRpb25zLCAocykgPT4gcy50aHJlYWRzREIpO1xuICAgIGNvbnN0IG5vdGlmaWNhdGlvbnMgPSBEZXJpdmVkU2lnbmFsLmZyb20oXG4gICAgICB0aHJlYWRpZmljYXRpb25zLFxuICAgICAgKHMpID0+ICh7XG4gICAgICAgIHNvcnRlZE5vdGlmaWNhdGlvbnM6IHMuc29ydGVkTm90aWZpY2F0aW9ucyxcbiAgICAgICAgbm90aWZpY2F0aW9uc0J5SWQ6IHMubm90aWZpY2F0aW9uc0J5SWRcbiAgICAgIH0pLFxuICAgICAgc2hhbGxvdzNcbiAgICApO1xuICAgIGNvbnN0IGxvYWRpbmdVc2VyVGhyZWFkcyA9IG5ldyBEZWZhdWx0TWFwKFxuICAgICAgKHF1ZXJ5S2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gSlNPTi5wYXJzZShxdWVyeUtleSk7XG4gICAgICAgIGNvbnN0IHJlc291cmNlID0gbmV3IFBhZ2luYXRlZFJlc291cmNlKGFzeW5jIChjdXJzb3IpID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNjbGllbnRba0ludGVybmFsXS5odHRwQ2xpZW50LmdldFVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbCh7XG4gICAgICAgICAgICBjdXJzb3IsXG4gICAgICAgICAgICBxdWVyeVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMudXBkYXRlVGhyZWFkaWZpY2F0aW9ucyhcbiAgICAgICAgICAgIHJlc3VsdC50aHJlYWRzLFxuICAgICAgICAgICAgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5wZXJtaXNzaW9uSGludHMudXBkYXRlKHJlc3VsdC5wZXJtaXNzaW9uSGludHMpO1xuICAgICAgICAgIGlmICh0aGlzLiN1c2VyVGhyZWFkc0xhc3RSZXF1ZXN0ZWRBdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy4jdXNlclRocmVhZHNMYXN0UmVxdWVzdGVkQXQgPSByZXN1bHQucmVxdWVzdGVkQXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQubmV4dEN1cnNvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNpZ25hbCA9IERlcml2ZWRTaWduYWwuZnJvbSgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzb3VyY2UuZ2V0KCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pc0xvYWRpbmcgfHwgcmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0aHJlYWRzMiA9IHRoaXMub3V0cHV0cy50aHJlYWRzLmdldCgpLmZpbmRNYW55KFxuICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgLy8gRG8gX25vdF8gZmlsdGVyIGJ5IHJvb21JZFxuICAgICAgICAgICAgcXVlcnkgPz8ge30sXG4gICAgICAgICAgICBcImRlc2NcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgcGFnZSA9IHJlc3VsdC5kYXRhO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgdGhyZWFkczogdGhyZWFkczIsXG4gICAgICAgICAgICBoYXNGZXRjaGVkQWxsOiBwYWdlLmhhc0ZldGNoZWRBbGwsXG4gICAgICAgICAgICBpc0ZldGNoaW5nTW9yZTogcGFnZS5pc0ZldGNoaW5nTW9yZSxcbiAgICAgICAgICAgIGZldGNoTW9yZUVycm9yOiBwYWdlLmZldGNoTW9yZUVycm9yLFxuICAgICAgICAgICAgZmV0Y2hNb3JlOiBwYWdlLmZldGNoTW9yZVxuICAgICAgICAgIH07XG4gICAgICAgIH0sIHNoYWxsb3cyKTtcbiAgICAgICAgcmV0dXJuIHsgc2lnbmFsLCB3YWl0VW50aWxMb2FkZWQ6IHJlc291cmNlLndhaXRVbnRpbExvYWRlZCB9O1xuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgbG9hZGluZ1Jvb21UaHJlYWRzID0gbmV3IERlZmF1bHRNYXAoXG4gICAgICAocXVlcnlLZXkpID0+IHtcbiAgICAgICAgY29uc3QgW3Jvb21JZCwgcXVlcnldID0gSlNPTi5wYXJzZShxdWVyeUtleSk7XG4gICAgICAgIGNvbnN0IHJlc291cmNlID0gbmV3IFBhZ2luYXRlZFJlc291cmNlKGFzeW5jIChjdXJzb3IpID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNjbGllbnRba0ludGVybmFsXS5odHRwQ2xpZW50LmdldFRocmVhZHMoe1xuICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgICAgY3Vyc29yLFxuICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVRocmVhZGlmaWNhdGlvbnMoXG4gICAgICAgICAgICByZXN1bHQudGhyZWFkcyxcbiAgICAgICAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMucGVybWlzc2lvbkhpbnRzLnVwZGF0ZShyZXN1bHQucGVybWlzc2lvbkhpbnRzKTtcbiAgICAgICAgICBjb25zdCBsYXN0UmVxdWVzdGVkQXQgPSB0aGlzLiNyb29tVGhyZWFkc0xhc3RSZXF1ZXN0ZWRBdEJ5Um9vbS5nZXQocm9vbUlkKTtcbiAgICAgICAgICBpZiAobGFzdFJlcXVlc3RlZEF0ID09PSB2b2lkIDAgfHwgbGFzdFJlcXVlc3RlZEF0ID4gcmVzdWx0LnJlcXVlc3RlZEF0KSB7XG4gICAgICAgICAgICB0aGlzLiNyb29tVGhyZWFkc0xhc3RSZXF1ZXN0ZWRBdEJ5Um9vbS5zZXQoXG4gICAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgICAgcmVzdWx0LnJlcXVlc3RlZEF0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0Lm5leHRDdXJzb3I7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaWduYWwgPSBEZXJpdmVkU2lnbmFsLmZyb20oKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc291cmNlLmdldCgpO1xuICAgICAgICAgIGlmIChyZXN1bHQuaXNMb2FkaW5nIHx8IHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdGhyZWFkczIgPSB0aGlzLm91dHB1dHMudGhyZWFkcy5nZXQoKS5maW5kTWFueShyb29tSWQsIHF1ZXJ5ID8/IHt9LCBcImFzY1wiKTtcbiAgICAgICAgICBjb25zdCBwYWdlID0gcmVzdWx0LmRhdGE7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICB0aHJlYWRzOiB0aHJlYWRzMixcbiAgICAgICAgICAgIGhhc0ZldGNoZWRBbGw6IHBhZ2UuaGFzRmV0Y2hlZEFsbCxcbiAgICAgICAgICAgIGlzRmV0Y2hpbmdNb3JlOiBwYWdlLmlzRmV0Y2hpbmdNb3JlLFxuICAgICAgICAgICAgZmV0Y2hNb3JlRXJyb3I6IHBhZ2UuZmV0Y2hNb3JlRXJyb3IsXG4gICAgICAgICAgICBmZXRjaE1vcmU6IHBhZ2UuZmV0Y2hNb3JlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgc2hhbGxvdzIpO1xuICAgICAgICByZXR1cm4geyBzaWduYWwsIHdhaXRVbnRpbExvYWRlZDogcmVzb3VyY2Uud2FpdFVudGlsTG9hZGVkIH07XG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCBsb2FkaW5nTm90aWZpY2F0aW9ucyA9IHtcbiAgICAgIHNpZ25hbDogRGVyaXZlZFNpZ25hbC5mcm9tKCgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzb3VyY2UgPSB0aGlzLiNub3RpZmljYXRpb25zUGFnaW5hdGlvblN0YXRlO1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZXNvdXJjZS5nZXQoKTtcbiAgICAgICAgaWYgKHJlc3VsdC5pc0xvYWRpbmcgfHwgcmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWdlID0gcmVzdWx0LmRhdGE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHRoaXMub3V0cHV0cy5ub3RpZmljYXRpb25zLmdldCgpLnNvcnRlZE5vdGlmaWNhdGlvbnMsXG4gICAgICAgICAgaGFzRmV0Y2hlZEFsbDogcGFnZS5oYXNGZXRjaGVkQWxsLFxuICAgICAgICAgIGlzRmV0Y2hpbmdNb3JlOiBwYWdlLmlzRmV0Y2hpbmdNb3JlLFxuICAgICAgICAgIGZldGNoTW9yZUVycm9yOiBwYWdlLmZldGNoTW9yZUVycm9yLFxuICAgICAgICAgIGZldGNoTW9yZTogcGFnZS5mZXRjaE1vcmVcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgd2FpdFVudGlsTG9hZGVkOiB0aGlzLiNub3RpZmljYXRpb25zUGFnaW5hdGlvblN0YXRlLndhaXRVbnRpbExvYWRlZFxuICAgIH07XG4gICAgY29uc3Qgc2V0dGluZ3NCeVJvb21JZCA9IG5ldyBEZWZhdWx0TWFwKChyb29tSWQpID0+IHtcbiAgICAgIGNvbnN0IHJlc291cmNlID0gbmV3IFNpbmdsZVBhZ2VSZXNvdXJjZShhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJvb20gPSB0aGlzLiNjbGllbnQuZ2V0Um9vbShyb29tSWQpO1xuICAgICAgICBpZiAocm9vbSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUm9vbSAnJHtyb29tSWR9JyBpcyBub3QgYXZhaWxhYmxlIG9uIGNsaWVudGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJvb20uZ2V0Tm90aWZpY2F0aW9uU2V0dGluZ3MoKTtcbiAgICAgICAgdGhpcy5yb29tTm90aWZpY2F0aW9uU2V0dGluZ3MudXBkYXRlKHJvb21JZCwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc2lnbmFsID0gRGVyaXZlZFNpZ25hbC5mcm9tKCgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzb3VyY2UuZ2V0KCk7XG4gICAgICAgIGlmIChyZXN1bHQuaXNMb2FkaW5nIHx8IHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIEFTWU5DX09LKFxuICAgICAgICAgICAgXCJzZXR0aW5nc1wiLFxuICAgICAgICAgICAgbm4odGhpcy5yb29tTm90aWZpY2F0aW9uU2V0dGluZ3Muc2lnbmFsLmdldCgpW3Jvb21JZF0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSwgc2hhbGxvdzMpO1xuICAgICAgcmV0dXJuIHsgc2lnbmFsLCB3YWl0VW50aWxMb2FkZWQ6IHJlc291cmNlLndhaXRVbnRpbExvYWRlZCB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHZlcnNpb25zQnlSb29tSWQgPSBuZXcgRGVmYXVsdE1hcChcbiAgICAgIChyb29tSWQpID0+IHtcbiAgICAgICAgY29uc3QgcmVzb3VyY2UgPSBuZXcgU2luZ2xlUGFnZVJlc291cmNlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjb25zdCByb29tID0gdGhpcy4jY2xpZW50LmdldFJvb20ocm9vbUlkKTtcbiAgICAgICAgICBpZiAocm9vbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSb29tICcke3Jvb21JZH0nIGlzIG5vdCBhdmFpbGFibGUgb24gY2xpZW50YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJvb21ba0ludGVybmFsXS5saXN0VGV4dFZlcnNpb25zKCk7XG4gICAgICAgICAgdGhpcy5oaXN0b3J5VmVyc2lvbnMudXBkYXRlKHJvb21JZCwgcmVzdWx0LnZlcnNpb25zKTtcbiAgICAgICAgICBjb25zdCBsYXN0UmVxdWVzdGVkQXQgPSB0aGlzLiNyb29tVmVyc2lvbnNMYXN0UmVxdWVzdGVkQXRCeVJvb20uZ2V0KHJvb21JZCk7XG4gICAgICAgICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA9PT0gdm9pZCAwIHx8IGxhc3RSZXF1ZXN0ZWRBdCA+IHJlc3VsdC5yZXF1ZXN0ZWRBdCkge1xuICAgICAgICAgICAgdGhpcy4jcm9vbVZlcnNpb25zTGFzdFJlcXVlc3RlZEF0QnlSb29tLnNldChcbiAgICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgICAgICByZXN1bHQucmVxdWVzdGVkQXRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gRGVyaXZlZFNpZ25hbC5mcm9tKCgpID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXNvdXJjZS5nZXQoKTtcbiAgICAgICAgICBpZiAocmVzdWx0LmlzTG9hZGluZyB8fCByZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBBU1lOQ19PSyhcbiAgICAgICAgICAgICAgXCJ2ZXJzaW9uc1wiLFxuICAgICAgICAgICAgICBPYmplY3QudmFsdWVzKHRoaXMuaGlzdG9yeVZlcnNpb25zLnNpZ25hbC5nZXQoKVtyb29tSWRdID8/IHt9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHNoYWxsb3czKTtcbiAgICAgICAgcmV0dXJuIHsgc2lnbmFsLCB3YWl0VW50aWxMb2FkZWQ6IHJlc291cmNlLndhaXRVbnRpbExvYWRlZCB9O1xuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgdXNlck5vdGlmaWNhdGlvblNldHRpbmdzID0ge1xuICAgICAgc2lnbmFsOiBEZXJpdmVkU2lnbmFsLmZyb20oKCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiN1c2VyTm90aWZpY2F0aW9uU2V0dGluZ3MuZ2V0KCk7XG4gICAgICAgIGlmIChyZXN1bHQuaXNMb2FkaW5nIHx8IHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFTWU5DX09LKFxuICAgICAgICAgIFwic2V0dGluZ3NcIixcbiAgICAgICAgICBubih0aGlzLnVzZXJOb3RpZmljYXRpb25TZXR0aW5ncy5zaWduYWwuZ2V0KCkpXG4gICAgICAgICk7XG4gICAgICB9LCBzaGFsbG93MyksXG4gICAgICB3YWl0VW50aWxMb2FkZWQ6IHRoaXMuI3VzZXJOb3RpZmljYXRpb25TZXR0aW5ncy53YWl0VW50aWxMb2FkZWRcbiAgICB9O1xuICAgIHRoaXMub3V0cHV0cyA9IHtcbiAgICAgIHRocmVhZGlmaWNhdGlvbnMsXG4gICAgICB0aHJlYWRzLFxuICAgICAgbG9hZGluZ1Jvb21UaHJlYWRzLFxuICAgICAgbG9hZGluZ1VzZXJUaHJlYWRzLFxuICAgICAgbm90aWZpY2F0aW9ucyxcbiAgICAgIGxvYWRpbmdOb3RpZmljYXRpb25zLFxuICAgICAgc2V0dGluZ3NCeVJvb21JZCxcbiAgICAgIHZlcnNpb25zQnlSb29tSWQsXG4gICAgICB1c2VyTm90aWZpY2F0aW9uU2V0dGluZ3NcbiAgICB9O1xuICAgIGF1dG9iaW5kKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGFuIGV4aXN0aW5nIGluYm94IG5vdGlmaWNhdGlvbiB3aXRoIGEgbmV3IHZhbHVlLCByZXBsYWNpbmcgdGhlXG4gICAqIGNvcnJlc3BvbmRpbmcgb3B0aW1pc3RpYyB1cGRhdGUuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgdXBkYXRlIGFueXRoaW5nIGlmIHRoZSBpbmJveCBub3RpZmljYXRpb24gSUQgaXNuJ3QgZm91bmQuXG4gICAqL1xuICBtYXJrSW5ib3hOb3RpZmljYXRpb25SZWFkKGluYm94Tm90aWZpY2F0aW9uSWQsIHJlYWRBdCwgb3B0aW1pc3RpY0lkKSB7XG4gICAgYmF0Y2gyKCgpID0+IHtcbiAgICAgIHRoaXMub3B0aW1pc3RpY1VwZGF0ZXMucmVtb3ZlKG9wdGltaXN0aWNJZCk7XG4gICAgICB0aGlzLm5vdGlmaWNhdGlvbnMubWFya1JlYWQoaW5ib3hOb3RpZmljYXRpb25JZCwgcmVhZEF0KTtcbiAgICB9KTtcbiAgfVxuICBtYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zUmVhZChvcHRpbWlzdGljSWQsIHJlYWRBdCkge1xuICAgIGJhdGNoMigoKSA9PiB7XG4gICAgICB0aGlzLm9wdGltaXN0aWNVcGRhdGVzLnJlbW92ZShvcHRpbWlzdGljSWQpO1xuICAgICAgdGhpcy5ub3RpZmljYXRpb25zLm1hcmtBbGxSZWFkKHJlYWRBdCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYW4gZXhpc3RpbmcgaW5ib3ggbm90aWZpY2F0aW9uLCByZXBsYWNpbmcgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICogb3B0aW1pc3RpYyB1cGRhdGUuXG4gICAqL1xuICBkZWxldGVJbmJveE5vdGlmaWNhdGlvbihpbmJveE5vdGlmaWNhdGlvbklkLCBvcHRpbWlzdGljSWQpIHtcbiAgICBiYXRjaDIoKCkgPT4ge1xuICAgICAgdGhpcy5vcHRpbWlzdGljVXBkYXRlcy5yZW1vdmUob3B0aW1pc3RpY0lkKTtcbiAgICAgIHRoaXMubm90aWZpY2F0aW9ucy5kZWxldGUoaW5ib3hOb3RpZmljYXRpb25JZCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgKmFsbCogaW5ib3ggbm90aWZpY2F0aW9ucywgcmVwbGFjaW5nIHRoZSBjb3JyZXNwb25kaW5nIG9wdGltaXN0aWNcbiAgICogdXBkYXRlLlxuICAgKi9cbiAgZGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zKG9wdGltaXN0aWNJZCkge1xuICAgIGJhdGNoMigoKSA9PiB7XG4gICAgICB0aGlzLm9wdGltaXN0aWNVcGRhdGVzLnJlbW92ZShvcHRpbWlzdGljSWQpO1xuICAgICAgdGhpcy5ub3RpZmljYXRpb25zLmNsZWFyKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gbmV3IHRocmVhZCwgcmVwbGFjaW5nIHRoZSBjb3JyZXNwb25kaW5nIG9wdGltaXN0aWMgdXBkYXRlLlxuICAgKi9cbiAgY3JlYXRlVGhyZWFkKG9wdGltaXN0aWNJZCwgdGhyZWFkKSB7XG4gICAgYmF0Y2gyKCgpID0+IHtcbiAgICAgIHRoaXMub3B0aW1pc3RpY1VwZGF0ZXMucmVtb3ZlKG9wdGltaXN0aWNJZCk7XG4gICAgICB0aGlzLnRocmVhZHMudXBzZXJ0KHRocmVhZCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYW4gZXhpc3RpbmcgdGhyZWFkIHdpdGggYSBuZXcgdmFsdWUsIHJlcGxhY2luZyB0aGUgY29ycmVzcG9uZGluZ1xuICAgKiBvcHRpbWlzdGljIHVwZGF0ZS5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCB1cGRhdGUgYW55dGhpbmcgaWY6XG4gICAqIC0gVGhlIHRocmVhZCBJRCBpc24ndCBmb3VuZDsgb3JcbiAgICogLSBUaGUgdGhyZWFkIElEIHdhcyBhbHJlYWR5IGRlbGV0ZWQ7IG9yXG4gICAqIC0gVGhlIHRocmVhZCBJRCB3YXMgdXBkYXRlZCBtb3JlIHJlY2VudGx5IHRoYW4gdGhlIG9wdGltaXN0aWMgdXBkYXRlJ3NcbiAgICogICB0aW1lc3RhbXAgKGlmIGdpdmVuKVxuICAgKi9cbiAgI3VwZGF0ZVRocmVhZCh0aHJlYWRJZCwgb3B0aW1pc3RpY0lkLCBjYWxsYmFjaywgdXBkYXRlZEF0KSB7XG4gICAgYmF0Y2gyKCgpID0+IHtcbiAgICAgIGlmIChvcHRpbWlzdGljSWQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5vcHRpbWlzdGljVXBkYXRlcy5yZW1vdmUob3B0aW1pc3RpY0lkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRiID0gdGhpcy50aHJlYWRzO1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBkYi5nZXQodGhyZWFkSWQpO1xuICAgICAgaWYgKCFleGlzdGluZykgcmV0dXJuO1xuICAgICAgaWYgKCEhdXBkYXRlZEF0ICYmIGV4aXN0aW5nLnVwZGF0ZWRBdCA+IHVwZGF0ZWRBdCkgcmV0dXJuO1xuICAgICAgZGIudXBzZXJ0KGNhbGxiYWNrKGV4aXN0aW5nKSk7XG4gICAgfSk7XG4gIH1cbiAgcGF0Y2hUaHJlYWQodGhyZWFkSWQsIG9wdGltaXN0aWNJZCwgcGF0Y2gsIHVwZGF0ZWRBdCkge1xuICAgIHJldHVybiB0aGlzLiN1cGRhdGVUaHJlYWQoXG4gICAgICB0aHJlYWRJZCxcbiAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICh0aHJlYWQpID0+ICh7IC4uLnRocmVhZCwgLi4uY29tcGFjdE9iamVjdChwYXRjaCkgfSksXG4gICAgICB1cGRhdGVkQXRcbiAgICApO1xuICB9XG4gIGFkZFJlYWN0aW9uKHRocmVhZElkLCBvcHRpbWlzdGljSWQsIGNvbW1lbnRJZCwgcmVhY3Rpb24sIGNyZWF0ZWRBdCkge1xuICAgIHRoaXMuI3VwZGF0ZVRocmVhZChcbiAgICAgIHRocmVhZElkLFxuICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgKHRocmVhZCkgPT4gYXBwbHlBZGRSZWFjdGlvbih0aHJlYWQsIGNvbW1lbnRJZCwgcmVhY3Rpb24pLFxuICAgICAgY3JlYXRlZEF0XG4gICAgKTtcbiAgfVxuICByZW1vdmVSZWFjdGlvbih0aHJlYWRJZCwgb3B0aW1pc3RpY0lkLCBjb21tZW50SWQsIGVtb2ppLCB1c2VySWQsIHJlbW92ZWRBdCkge1xuICAgIHRoaXMuI3VwZGF0ZVRocmVhZChcbiAgICAgIHRocmVhZElkLFxuICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgKHRocmVhZCkgPT4gYXBwbHlSZW1vdmVSZWFjdGlvbih0aHJlYWQsIGNvbW1lbnRJZCwgZW1vamksIHVzZXJJZCwgcmVtb3ZlZEF0KSxcbiAgICAgIHJlbW92ZWRBdFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFNvZnQtZGVsZXRlcyBhbiBleGlzdGluZyB0aHJlYWQgYnkgc2V0dGluZyBpdHMgYGRlbGV0ZWRBdGAgdmFsdWUsXG4gICAqIHJlcGxhY2luZyB0aGUgY29ycmVzcG9uZGluZyBvcHRpbWlzdGljIHVwZGF0ZS5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCB1cGRhdGUgYW55dGhpbmcgaWY6XG4gICAqIC0gVGhlIHRocmVhZCBJRCBpc24ndCBmb3VuZDsgb3JcbiAgICogLSBUaGUgdGhyZWFkIElEIHdhcyBhbHJlYWR5IGRlbGV0ZWRcbiAgICovXG4gIGRlbGV0ZVRocmVhZCh0aHJlYWRJZCwgb3B0aW1pc3RpY0lkKSB7XG4gICAgcmV0dXJuIHRoaXMuI3VwZGF0ZVRocmVhZChcbiAgICAgIHRocmVhZElkLFxuICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgLy8gQSBkZWxldGlvbiBpcyBhY3R1YWxseSBhbiB1cGRhdGUgb2YgdGhlIGRlbGV0ZWRBdCBwcm9wZXJ0eSBpbnRlcm5hbGx5XG4gICAgICAodGhyZWFkKSA9PiAoeyAuLi50aHJlYWQsIHVwZGF0ZWRBdDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIGRlbGV0ZWRBdDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkgfSlcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGV4aXN0aW5nIGNvbW1lbnQgYW5kIGVuc3VyZXMgdGhlIGFzc29jaWF0ZWQgbm90aWZpY2F0aW9uIGlzXG4gICAqIHVwZGF0ZWQgY29ycmVjdGx5LCByZXBsYWNpbmcgdGhlIGNvcnJlc3BvbmRpbmcgb3B0aW1pc3RpYyB1cGRhdGUuXG4gICAqL1xuICBjcmVhdGVDb21tZW50KG5ld0NvbW1lbnQsIG9wdGltaXN0aWNJZCkge1xuICAgIGJhdGNoMigoKSA9PiB7XG4gICAgICB0aGlzLm9wdGltaXN0aWNVcGRhdGVzLnJlbW92ZShvcHRpbWlzdGljSWQpO1xuICAgICAgY29uc3QgZXhpc3RpbmdUaHJlYWQgPSB0aGlzLnRocmVhZHMuZ2V0KG5ld0NvbW1lbnQudGhyZWFkSWQpO1xuICAgICAgaWYgKCFleGlzdGluZ1RocmVhZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnRocmVhZHMudXBzZXJ0KGFwcGx5VXBzZXJ0Q29tbWVudChleGlzdGluZ1RocmVhZCwgbmV3Q29tbWVudCkpO1xuICAgICAgdGhpcy5ub3RpZmljYXRpb25zLnVwZGF0ZUFzc29jaWF0ZWROb3RpZmljYXRpb24obmV3Q29tbWVudCk7XG4gICAgfSk7XG4gIH1cbiAgZWRpdENvbW1lbnQodGhyZWFkSWQsIG9wdGltaXN0aWNJZCwgZWRpdGVkQ29tbWVudCkge1xuICAgIHJldHVybiB0aGlzLiN1cGRhdGVUaHJlYWQoXG4gICAgICB0aHJlYWRJZCxcbiAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICh0aHJlYWQpID0+IGFwcGx5VXBzZXJ0Q29tbWVudCh0aHJlYWQsIGVkaXRlZENvbW1lbnQpXG4gICAgKTtcbiAgfVxuICBkZWxldGVDb21tZW50KHRocmVhZElkLCBvcHRpbWlzdGljSWQsIGNvbW1lbnRJZCwgZGVsZXRlZEF0KSB7XG4gICAgcmV0dXJuIHRoaXMuI3VwZGF0ZVRocmVhZChcbiAgICAgIHRocmVhZElkLFxuICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgKHRocmVhZCkgPT4gYXBwbHlEZWxldGVDb21tZW50KHRocmVhZCwgY29tbWVudElkLCBkZWxldGVkQXQpLFxuICAgICAgZGVsZXRlZEF0XG4gICAgKTtcbiAgfVxuICB1cGRhdGVUaHJlYWRpZmljYXRpb25zKHRocmVhZHMsIG5vdGlmaWNhdGlvbnMsIGRlbGV0ZWRUaHJlYWRzID0gW10sIGRlbGV0ZWROb3RpZmljYXRpb25zID0gW10pIHtcbiAgICBiYXRjaDIoKCkgPT4ge1xuICAgICAgdGhpcy50aHJlYWRzLmFwcGx5RGVsdGEodGhyZWFkcywgZGVsZXRlZFRocmVhZHMpO1xuICAgICAgdGhpcy5ub3RpZmljYXRpb25zLmFwcGx5RGVsdGEobm90aWZpY2F0aW9ucywgZGVsZXRlZE5vdGlmaWNhdGlvbnMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGVzIGV4aXN0aW5nIG5vdGlmaWNhdGlvbiBzZXR0aW5nIGZvciBhIHJvb20gd2l0aCBhIG5ldyB2YWx1ZSxcbiAgICogcmVwbGFjaW5nIHRoZSBjb3JyZXNwb25kaW5nIG9wdGltaXN0aWMgdXBkYXRlLlxuICAgKi9cbiAgdXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKHJvb21JZCwgb3B0aW1pc3RpY0lkLCBzZXR0aW5ncykge1xuICAgIGJhdGNoMigoKSA9PiB7XG4gICAgICB0aGlzLm9wdGltaXN0aWNVcGRhdGVzLnJlbW92ZShvcHRpbWlzdGljSWQpO1xuICAgICAgdGhpcy5yb29tTm90aWZpY2F0aW9uU2V0dGluZ3MudXBkYXRlKHJvb21JZCwgc2V0dGluZ3MpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZldGNoTm90aWZpY2F0aW9uc0RlbHRhVXBkYXRlKHNpZ25hbCkge1xuICAgIGNvbnN0IGxhc3RSZXF1ZXN0ZWRBdCA9IHRoaXMuI25vdGlmaWNhdGlvbnNMYXN0UmVxdWVzdGVkQXQ7XG4gICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNjbGllbnQuZ2V0SW5ib3hOb3RpZmljYXRpb25zU2luY2Uoe1xuICAgICAgc2luY2U6IGxhc3RSZXF1ZXN0ZWRBdCxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGlmIChsYXN0UmVxdWVzdGVkQXQgPCByZXN1bHQucmVxdWVzdGVkQXQpIHtcbiAgICAgIHRoaXMuI25vdGlmaWNhdGlvbnNMYXN0UmVxdWVzdGVkQXQgPSByZXN1bHQucmVxdWVzdGVkQXQ7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlVGhyZWFkaWZpY2F0aW9ucyhcbiAgICAgIHJlc3VsdC50aHJlYWRzLnVwZGF0ZWQsXG4gICAgICByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zLnVwZGF0ZWQsXG4gICAgICByZXN1bHQudGhyZWFkcy5kZWxldGVkLFxuICAgICAgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucy5kZWxldGVkXG4gICAgKTtcbiAgfVxuICBhc3luYyBmZXRjaFJvb21UaHJlYWRzRGVsdGFVcGRhdGUocm9vbUlkLCBzaWduYWwpIHtcbiAgICBjb25zdCBsYXN0UmVxdWVzdGVkQXQgPSB0aGlzLiNyb29tVGhyZWFkc0xhc3RSZXF1ZXN0ZWRBdEJ5Um9vbS5nZXQocm9vbUlkKTtcbiAgICBpZiAobGFzdFJlcXVlc3RlZEF0ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlcyA9IGF3YWl0IHRoaXMuI2NsaWVudFtrSW50ZXJuYWxdLmh0dHBDbGllbnQuZ2V0VGhyZWFkc1NpbmNlKHtcbiAgICAgIHJvb21JZCxcbiAgICAgIHNpbmNlOiBsYXN0UmVxdWVzdGVkQXQsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZVRocmVhZGlmaWNhdGlvbnMoXG4gICAgICB1cGRhdGVzLnRocmVhZHMudXBkYXRlZCxcbiAgICAgIHVwZGF0ZXMuaW5ib3hOb3RpZmljYXRpb25zLnVwZGF0ZWQsXG4gICAgICB1cGRhdGVzLnRocmVhZHMuZGVsZXRlZCxcbiAgICAgIHVwZGF0ZXMuaW5ib3hOb3RpZmljYXRpb25zLmRlbGV0ZWRcbiAgICApO1xuICAgIHRoaXMucGVybWlzc2lvbkhpbnRzLnVwZGF0ZSh1cGRhdGVzLnBlcm1pc3Npb25IaW50cyk7XG4gICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA8IHVwZGF0ZXMucmVxdWVzdGVkQXQpIHtcbiAgICAgIHRoaXMuI3Jvb21UaHJlYWRzTGFzdFJlcXVlc3RlZEF0QnlSb29tLnNldChyb29tSWQsIHVwZGF0ZXMucmVxdWVzdGVkQXQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmZXRjaFVzZXJUaHJlYWRzRGVsdGFVcGRhdGUoc2lnbmFsKSB7XG4gICAgY29uc3QgbGFzdFJlcXVlc3RlZEF0ID0gdGhpcy4jdXNlclRocmVhZHNMYXN0UmVxdWVzdGVkQXQ7XG4gICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNjbGllbnRba0ludGVybmFsXS5odHRwQ2xpZW50LmdldFVzZXJUaHJlYWRzU2luY2VfZXhwZXJpbWVudGFsKHtcbiAgICAgIHNpbmNlOiBsYXN0UmVxdWVzdGVkQXQsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBpZiAobGFzdFJlcXVlc3RlZEF0IDwgcmVzdWx0LnJlcXVlc3RlZEF0KSB7XG4gICAgICB0aGlzLiNub3RpZmljYXRpb25zTGFzdFJlcXVlc3RlZEF0ID0gcmVzdWx0LnJlcXVlc3RlZEF0O1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVRocmVhZGlmaWNhdGlvbnMoXG4gICAgICByZXN1bHQudGhyZWFkcy51cGRhdGVkLFxuICAgICAgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucy51cGRhdGVkLFxuICAgICAgcmVzdWx0LnRocmVhZHMuZGVsZXRlZCxcbiAgICAgIHJlc3VsdC5pbmJveE5vdGlmaWNhdGlvbnMuZGVsZXRlZFxuICAgICk7XG4gICAgdGhpcy5wZXJtaXNzaW9uSGludHMudXBkYXRlKHJlc3VsdC5wZXJtaXNzaW9uSGludHMpO1xuICB9XG4gIGFzeW5jIGZldGNoUm9vbVZlcnNpb25zRGVsdGFVcGRhdGUocm9vbUlkLCBzaWduYWwpIHtcbiAgICBjb25zdCBsYXN0UmVxdWVzdGVkQXQgPSB0aGlzLiNyb29tVmVyc2lvbnNMYXN0UmVxdWVzdGVkQXRCeVJvb20uZ2V0KHJvb21JZCk7XG4gICAgaWYgKGxhc3RSZXF1ZXN0ZWRBdCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJvb20gPSBubihcbiAgICAgIHRoaXMuI2NsaWVudC5nZXRSb29tKHJvb21JZCksXG4gICAgICBgUm9vbSB3aXRoIGlkICR7cm9vbUlkfSBpcyBub3QgYXZhaWxhYmxlIG9uIGNsaWVudGBcbiAgICApO1xuICAgIGNvbnN0IHVwZGF0ZXMgPSBhd2FpdCByb29tW2tJbnRlcm5hbF0ubGlzdFRleHRWZXJzaW9uc1NpbmNlKHtcbiAgICAgIHNpbmNlOiBsYXN0UmVxdWVzdGVkQXQsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmhpc3RvcnlWZXJzaW9ucy51cGRhdGUocm9vbUlkLCB1cGRhdGVzLnZlcnNpb25zKTtcbiAgICBpZiAobGFzdFJlcXVlc3RlZEF0IDwgdXBkYXRlcy5yZXF1ZXN0ZWRBdCkge1xuICAgICAgdGhpcy4jcm9vbVZlcnNpb25zTGFzdFJlcXVlc3RlZEF0QnlSb29tLnNldChyb29tSWQsIHVwZGF0ZXMucmVxdWVzdGVkQXQpO1xuICAgIH1cbiAgfVxuICBhc3luYyByZWZyZXNoUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKHJvb21JZCwgc2lnbmFsKSB7XG4gICAgY29uc3Qgcm9vbSA9IG5uKFxuICAgICAgdGhpcy4jY2xpZW50LmdldFJvb20ocm9vbUlkKSxcbiAgICAgIGBSb29tIHdpdGggaWQgJHtyb29tSWR9IGlzIG5vdCBhdmFpbGFibGUgb24gY2xpZW50YFxuICAgICk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcm9vbS5nZXROb3RpZmljYXRpb25TZXR0aW5ncyh7IHNpZ25hbCB9KTtcbiAgICB0aGlzLnJvb21Ob3RpZmljYXRpb25TZXR0aW5ncy51cGRhdGUocm9vbUlkLCByZXN1bHQpO1xuICB9XG4gIC8qKlxuICAgKiBSZWZyZXNoIFVzZXIgTm90aWZpY2F0aW9uIFNldHRpbmdzIGZyb20gcG9sbGVyXG4gICAqL1xuICBhc3luYyByZWZyZXNoVXNlck5vdGlmaWNhdGlvblNldHRpbmdzKHNpZ25hbCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI2NsaWVudC5nZXROb3RpZmljYXRpb25TZXR0aW5ncyh7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLnVzZXJOb3RpZmljYXRpb25TZXR0aW5ncy51cGRhdGUocmVzdWx0KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB1c2VyIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyB3aXRoIGEgbmV3IHZhbHVlLCByZXBsYWNpbmcgdGhlXG4gICAqIGNvcnJlc3BvbmRpbmcgb3B0aW1pc3RpYyB1cGRhdGUuXG4gICAqL1xuICB1cGRhdGVVc2VyTm90aWZpY2F0aW9uU2V0dGluZ3NfY29uZmlybU9wdGltaXN0aWNVcGRhdGUoc2V0dGluZ3MsIG9wdGltaXN0aWNVcGRhdGVJZCkge1xuICAgIGJhdGNoMigoKSA9PiB7XG4gICAgICB0aGlzLm9wdGltaXN0aWNVcGRhdGVzLnJlbW92ZShvcHRpbWlzdGljVXBkYXRlSWQpO1xuICAgICAgdGhpcy51c2VyTm90aWZpY2F0aW9uU2V0dGluZ3MudXBkYXRlKHNldHRpbmdzKTtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGFwcGx5T3B0aW1pc3RpY1VwZGF0ZXNfZm9yVGhyZWFkaWZpY2F0aW9ucyhiYXNlVGhyZWFkc0RCLCBub3RpZmljYXRpb25zTFVULCBvcHRpbWlzdGljVXBkYXRlcykge1xuICBjb25zdCB0aHJlYWRzREIgPSBiYXNlVGhyZWFkc0RCLmNsb25lKCk7XG4gIGxldCBub3RpZmljYXRpb25zQnlJZCA9IE9iamVjdC5mcm9tRW50cmllcyhub3RpZmljYXRpb25zTFVUKTtcbiAgZm9yIChjb25zdCBvcHRpbWlzdGljVXBkYXRlIG9mIG9wdGltaXN0aWNVcGRhdGVzKSB7XG4gICAgc3dpdGNoIChvcHRpbWlzdGljVXBkYXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJjcmVhdGUtdGhyZWFkXCI6IHtcbiAgICAgICAgdGhyZWFkc0RCLnVwc2VydChvcHRpbWlzdGljVXBkYXRlLnRocmVhZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImVkaXQtdGhyZWFkLW1ldGFkYXRhXCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gdGhyZWFkc0RCLmdldChvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkKTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSBicmVhaztcbiAgICAgICAgaWYgKHRocmVhZC51cGRhdGVkQXQgPiBvcHRpbWlzdGljVXBkYXRlLnVwZGF0ZWRBdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRocmVhZHNEQi51cHNlcnQoe1xuICAgICAgICAgIC4uLnRocmVhZCxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG9wdGltaXN0aWNVcGRhdGUudXBkYXRlZEF0LFxuICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAuLi50aHJlYWQubWV0YWRhdGEsXG4gICAgICAgICAgICAuLi5vcHRpbWlzdGljVXBkYXRlLm1ldGFkYXRhXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwibWFyay10aHJlYWQtYXMtcmVzb2x2ZWRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSB0aHJlYWRzREIuZ2V0KG9wdGltaXN0aWNVcGRhdGUudGhyZWFkSWQpO1xuICAgICAgICBpZiAodGhyZWFkID09PSB2b2lkIDApIGJyZWFrO1xuICAgICAgICB0aHJlYWRzREIudXBzZXJ0KHsgLi4udGhyZWFkLCByZXNvbHZlZDogdHJ1ZSB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwibWFyay10aHJlYWQtYXMtdW5yZXNvbHZlZFwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHRocmVhZHNEQi5nZXQob3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZCk7XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkgYnJlYWs7XG4gICAgICAgIHRocmVhZHNEQi51cHNlcnQoeyAuLi50aHJlYWQsIHJlc29sdmVkOiBmYWxzZSB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiY3JlYXRlLWNvbW1lbnRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSB0aHJlYWRzREIuZ2V0KG9wdGltaXN0aWNVcGRhdGUuY29tbWVudC50aHJlYWRJZCk7XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkgYnJlYWs7XG4gICAgICAgIHRocmVhZHNEQi51cHNlcnQoYXBwbHlVcHNlcnRDb21tZW50KHRocmVhZCwgb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50KSk7XG4gICAgICAgIGNvbnN0IGluYm94Tm90aWZpY2F0aW9uID0gT2JqZWN0LnZhbHVlcyhub3RpZmljYXRpb25zQnlJZCkuZmluZChcbiAgICAgICAgICAobm90aWZpY2F0aW9uKSA9PiBub3RpZmljYXRpb24ua2luZCA9PT0gXCJ0aHJlYWRcIiAmJiBub3RpZmljYXRpb24udGhyZWFkSWQgPT09IHRocmVhZC5pZFxuICAgICAgICApO1xuICAgICAgICBpZiAoaW5ib3hOb3RpZmljYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vdGlmaWNhdGlvbnNCeUlkW2luYm94Tm90aWZpY2F0aW9uLmlkXSA9IHtcbiAgICAgICAgICAuLi5pbmJveE5vdGlmaWNhdGlvbixcbiAgICAgICAgICBub3RpZmllZEF0OiBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnQuY3JlYXRlZEF0LFxuICAgICAgICAgIHJlYWRBdDogb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50LmNyZWF0ZWRBdFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJlZGl0LWNvbW1lbnRcIjoge1xuICAgICAgICBjb25zdCB0aHJlYWQgPSB0aHJlYWRzREIuZ2V0KG9wdGltaXN0aWNVcGRhdGUuY29tbWVudC50aHJlYWRJZCk7XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkgYnJlYWs7XG4gICAgICAgIHRocmVhZHNEQi51cHNlcnQoYXBwbHlVcHNlcnRDb21tZW50KHRocmVhZCwgb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRlbGV0ZS1jb21tZW50XCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gdGhyZWFkc0RCLmdldChvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkKTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSBicmVhaztcbiAgICAgICAgdGhyZWFkc0RCLnVwc2VydChcbiAgICAgICAgICBhcHBseURlbGV0ZUNvbW1lbnQoXG4gICAgICAgICAgICB0aHJlYWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmNvbW1lbnRJZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuZGVsZXRlZEF0XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkZWxldGUtdGhyZWFkXCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gdGhyZWFkc0RCLmdldChvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkKTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSBicmVhaztcbiAgICAgICAgdGhyZWFkc0RCLnVwc2VydCh7XG4gICAgICAgICAgLi4udGhyZWFkLFxuICAgICAgICAgIGRlbGV0ZWRBdDogb3B0aW1pc3RpY1VwZGF0ZS5kZWxldGVkQXQsXG4gICAgICAgICAgdXBkYXRlZEF0OiBvcHRpbWlzdGljVXBkYXRlLmRlbGV0ZWRBdCxcbiAgICAgICAgICBjb21tZW50czogW11cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImFkZC1yZWFjdGlvblwiOiB7XG4gICAgICAgIGNvbnN0IHRocmVhZCA9IHRocmVhZHNEQi5nZXQob3B0aW1pc3RpY1VwZGF0ZS50aHJlYWRJZCk7XG4gICAgICAgIGlmICh0aHJlYWQgPT09IHZvaWQgMCkgYnJlYWs7XG4gICAgICAgIHRocmVhZHNEQi51cHNlcnQoXG4gICAgICAgICAgYXBwbHlBZGRSZWFjdGlvbihcbiAgICAgICAgICAgIHRocmVhZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGUuY29tbWVudElkLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5yZWFjdGlvblxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwicmVtb3ZlLXJlYWN0aW9uXCI6IHtcbiAgICAgICAgY29uc3QgdGhyZWFkID0gdGhyZWFkc0RCLmdldChvcHRpbWlzdGljVXBkYXRlLnRocmVhZElkKTtcbiAgICAgICAgaWYgKHRocmVhZCA9PT0gdm9pZCAwKSBicmVhaztcbiAgICAgICAgdGhyZWFkc0RCLnVwc2VydChcbiAgICAgICAgICBhcHBseVJlbW92ZVJlYWN0aW9uKFxuICAgICAgICAgICAgdGhyZWFkLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS5jb21tZW50SWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLmVtb2ppLFxuICAgICAgICAgICAgb3B0aW1pc3RpY1VwZGF0ZS51c2VySWQsXG4gICAgICAgICAgICBvcHRpbWlzdGljVXBkYXRlLnJlbW92ZWRBdFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwibWFyay1pbmJveC1ub3RpZmljYXRpb24tYXMtcmVhZFwiOiB7XG4gICAgICAgIGNvbnN0IGlibiA9IG5vdGlmaWNhdGlvbnNCeUlkW29wdGltaXN0aWNVcGRhdGUuaW5ib3hOb3RpZmljYXRpb25JZF07XG4gICAgICAgIGlmIChpYm4gPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vdGlmaWNhdGlvbnNCeUlkW29wdGltaXN0aWNVcGRhdGUuaW5ib3hOb3RpZmljYXRpb25JZF0gPSB7XG4gICAgICAgICAgLi4uaWJuLFxuICAgICAgICAgIHJlYWRBdDogb3B0aW1pc3RpY1VwZGF0ZS5yZWFkQXRcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwibWFyay1hbGwtaW5ib3gtbm90aWZpY2F0aW9ucy1hcy1yZWFkXCI6IHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBpbiBub3RpZmljYXRpb25zQnlJZCkge1xuICAgICAgICAgIGNvbnN0IGlibiA9IG5vdGlmaWNhdGlvbnNCeUlkW2lkXTtcbiAgICAgICAgICBpZiAoaWJuID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub3RpZmljYXRpb25zQnlJZFtpZF0gPSB7XG4gICAgICAgICAgICAuLi5pYm4sXG4gICAgICAgICAgICByZWFkQXQ6IG9wdGltaXN0aWNVcGRhdGUucmVhZEF0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkZWxldGUtaW5ib3gtbm90aWZpY2F0aW9uXCI6IHtcbiAgICAgICAgZGVsZXRlIG5vdGlmaWNhdGlvbnNCeUlkW29wdGltaXN0aWNVcGRhdGUuaW5ib3hOb3RpZmljYXRpb25JZF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImRlbGV0ZS1hbGwtaW5ib3gtbm90aWZpY2F0aW9uc1wiOiB7XG4gICAgICAgIG5vdGlmaWNhdGlvbnNCeUlkID0ge307XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBzb3J0ZWROb3RpZmljYXRpb25zID0gKFxuICAgIC8vIFNvcnQgc28gdGhhdCB0aGUgbW9zdCByZWNlbnQgbm90aWZpY2F0aW9ucyBhcmUgZmlyc3RcbiAgICBPYmplY3QudmFsdWVzKG5vdGlmaWNhdGlvbnNCeUlkKS5maWx0ZXIoXG4gICAgICAoaWJuKSA9PiBpYm4ua2luZCA9PT0gXCJ0aHJlYWRcIiA/IHRocmVhZHNEQi5nZXQoaWJuLnRocmVhZElkKSAhPT0gdm9pZCAwIDogdHJ1ZVxuICAgICkuc29ydCgoYSwgYikgPT4gYi5ub3RpZmllZEF0LmdldFRpbWUoKSAtIGEubm90aWZpZWRBdC5nZXRUaW1lKCkpXG4gICk7XG4gIHJldHVybiB7XG4gICAgc29ydGVkTm90aWZpY2F0aW9ucyxcbiAgICBub3RpZmljYXRpb25zQnlJZCxcbiAgICB0aHJlYWRzREJcbiAgfTtcbn1cbmZ1bmN0aW9uIGFwcGx5T3B0aW1pc3RpY1VwZGF0ZXNfZm9yU2V0dGluZ3Moc2V0dGluZ3NMVVQsIG9wdGltaXN0aWNVcGRhdGVzKSB7XG4gIGNvbnN0IHNldHRpbmdzQnlSb29tSWQgPSBPYmplY3QuZnJvbUVudHJpZXMoc2V0dGluZ3NMVVQpO1xuICBmb3IgKGNvbnN0IG9wdGltaXN0aWNVcGRhdGUgb2Ygb3B0aW1pc3RpY1VwZGF0ZXMpIHtcbiAgICBzd2l0Y2ggKG9wdGltaXN0aWNVcGRhdGUudHlwZSkge1xuICAgICAgY2FzZSBcInVwZGF0ZS1ub3RpZmljYXRpb24tc2V0dGluZ3NcIjoge1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHNldHRpbmdzQnlSb29tSWRbb3B0aW1pc3RpY1VwZGF0ZS5yb29tSWRdO1xuICAgICAgICBpZiAoc2V0dGluZ3MgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNldHRpbmdzQnlSb29tSWRbb3B0aW1pc3RpY1VwZGF0ZS5yb29tSWRdID0ge1xuICAgICAgICAgIC4uLnNldHRpbmdzLFxuICAgICAgICAgIC4uLm9wdGltaXN0aWNVcGRhdGUuc2V0dGluZ3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNldHRpbmdzQnlSb29tSWQ7XG59XG5mdW5jdGlvbiBhcHBseU9wdGltaXN0aWNVcGRhdGVzX2ZvclVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyhzZXR0aW5ncywgb3B0aW1pc3RpY1VwZGF0ZXMpIHtcbiAgbGV0IG91dGNvbWluZyA9IHNldHRpbmdzO1xuICBmb3IgKGNvbnN0IHVwZGF0ZSBvZiBvcHRpbWlzdGljVXBkYXRlcykge1xuICAgIGlmICh1cGRhdGUudHlwZSA9PT0gXCJ1cGRhdGUtdXNlci1ub3RpZmljYXRpb24tc2V0dGluZ3NcIikge1xuICAgICAgb3V0Y29taW5nID0gcGF0Y2hVc2VyTm90aWZpY2F0aW9uU2V0dGluZ3Mob3V0Y29taW5nLCB1cGRhdGUuc2V0dGluZ3MpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0Y29taW5nO1xufVxuZnVuY3Rpb24gY29tcGFyZUluYm94Tm90aWZpY2F0aW9ucyhpbmJveE5vdGlmaWNhdGlvbkEsIGluYm94Tm90aWZpY2F0aW9uQikge1xuICBpZiAoaW5ib3hOb3RpZmljYXRpb25BLm5vdGlmaWVkQXQgPiBpbmJveE5vdGlmaWNhdGlvbkIubm90aWZpZWRBdCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGluYm94Tm90aWZpY2F0aW9uQS5ub3RpZmllZEF0IDwgaW5ib3hOb3RpZmljYXRpb25CLm5vdGlmaWVkQXQpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKGluYm94Tm90aWZpY2F0aW9uQS5yZWFkQXQgJiYgaW5ib3hOb3RpZmljYXRpb25CLnJlYWRBdCkge1xuICAgIHJldHVybiBpbmJveE5vdGlmaWNhdGlvbkEucmVhZEF0ID4gaW5ib3hOb3RpZmljYXRpb25CLnJlYWRBdCA/IDEgOiBpbmJveE5vdGlmaWNhdGlvbkEucmVhZEF0IDwgaW5ib3hOb3RpZmljYXRpb25CLnJlYWRBdCA/IC0xIDogMDtcbiAgfSBlbHNlIGlmIChpbmJveE5vdGlmaWNhdGlvbkEucmVhZEF0IHx8IGluYm94Tm90aWZpY2F0aW9uQi5yZWFkQXQpIHtcbiAgICByZXR1cm4gaW5ib3hOb3RpZmljYXRpb25BLnJlYWRBdCA/IDEgOiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGFwcGx5VXBzZXJ0Q29tbWVudCh0aHJlYWQsIGNvbW1lbnQpIHtcbiAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgaWYgKGNvbW1lbnQudGhyZWFkSWQgIT09IHRocmVhZC5pZCkge1xuICAgIGNvbnNvbGUyLndhcm4oXG4gICAgICBgQ29tbWVudCAke2NvbW1lbnQuaWR9IGRvZXMgbm90IGJlbG9uZyB0byB0aHJlYWQgJHt0aHJlYWQuaWR9YFxuICAgICk7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCBleGlzdGluZ0NvbW1lbnQgPSB0aHJlYWQuY29tbWVudHMuZmluZChcbiAgICAoZXhpc3RpbmdDb21tZW50MikgPT4gZXhpc3RpbmdDb21tZW50Mi5pZCA9PT0gY29tbWVudC5pZFxuICApO1xuICBpZiAoZXhpc3RpbmdDb21tZW50ID09PSB2b2lkIDApIHtcbiAgICBjb25zdCB1cGRhdGVkQXQgPSBuZXcgRGF0ZShcbiAgICAgIE1hdGgubWF4KHRocmVhZC51cGRhdGVkQXQuZ2V0VGltZSgpLCBjb21tZW50LmNyZWF0ZWRBdC5nZXRUaW1lKCkpXG4gICAgKTtcbiAgICBjb25zdCB1cGRhdGVkVGhyZWFkID0ge1xuICAgICAgLi4udGhyZWFkLFxuICAgICAgdXBkYXRlZEF0LFxuICAgICAgY29tbWVudHM6IFsuLi50aHJlYWQuY29tbWVudHMsIGNvbW1lbnRdXG4gICAgfTtcbiAgICByZXR1cm4gdXBkYXRlZFRocmVhZDtcbiAgfVxuICBpZiAoZXhpc3RpbmdDb21tZW50LmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBpZiAoZXhpc3RpbmdDb21tZW50LmVkaXRlZEF0ID09PSB2b2lkIDAgfHwgY29tbWVudC5lZGl0ZWRBdCA9PT0gdm9pZCAwIHx8IGV4aXN0aW5nQ29tbWVudC5lZGl0ZWRBdCA8PSBjb21tZW50LmVkaXRlZEF0KSB7XG4gICAgY29uc3QgdXBkYXRlZENvbW1lbnRzID0gdGhyZWFkLmNvbW1lbnRzLm1hcChcbiAgICAgIChleGlzdGluZ0NvbW1lbnQyKSA9PiBleGlzdGluZ0NvbW1lbnQyLmlkID09PSBjb21tZW50LmlkID8gY29tbWVudCA6IGV4aXN0aW5nQ29tbWVudDJcbiAgICApO1xuICAgIGNvbnN0IHVwZGF0ZWRUaHJlYWQgPSB7XG4gICAgICAuLi50aHJlYWQsXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKFxuICAgICAgICBNYXRoLm1heChcbiAgICAgICAgICB0aHJlYWQudXBkYXRlZEF0LmdldFRpbWUoKSxcbiAgICAgICAgICBjb21tZW50LmVkaXRlZEF0Py5nZXRUaW1lKCkgfHwgY29tbWVudC5jcmVhdGVkQXQuZ2V0VGltZSgpXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICBjb21tZW50czogdXBkYXRlZENvbW1lbnRzXG4gICAgfTtcbiAgICByZXR1cm4gdXBkYXRlZFRocmVhZDtcbiAgfVxuICByZXR1cm4gdGhyZWFkO1xufVxuZnVuY3Rpb24gYXBwbHlEZWxldGVDb21tZW50KHRocmVhZCwgY29tbWVudElkLCBkZWxldGVkQXQpIHtcbiAgaWYgKHRocmVhZC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgZXhpc3RpbmdDb21tZW50ID0gdGhyZWFkLmNvbW1lbnRzLmZpbmQoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZFxuICApO1xuICBpZiAoZXhpc3RpbmdDb21tZW50ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGlmIChleGlzdGluZ0NvbW1lbnQuZGVsZXRlZEF0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdGhyZWFkO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWRDb21tZW50cyA9IHRocmVhZC5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbW1lbnQuaWQgPT09IGNvbW1lbnRJZCA/IHtcbiAgICAgIC4uLmNvbW1lbnQsXG4gICAgICBkZWxldGVkQXQsXG4gICAgICAvLyBXZSBvcHRpbWlzdGljYWxseSByZW1vdmUgdGhlIGNvbW1lbnQgYm9keSBhbmQgYXR0YWNobWVudHMgd2hlbiBtYXJraW5nIGl0IGFzIGRlbGV0ZWRcbiAgICAgIGJvZHk6IHZvaWQgMCxcbiAgICAgIGF0dGFjaG1lbnRzOiBbXVxuICAgIH0gOiBjb21tZW50XG4gICk7XG4gIGlmICh1cGRhdGVkQ29tbWVudHMuZXZlcnkoKGNvbW1lbnQpID0+IGNvbW1lbnQuZGVsZXRlZEF0ICE9PSB2b2lkIDApKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRocmVhZCxcbiAgICAgIGRlbGV0ZWRBdCxcbiAgICAgIHVwZGF0ZWRBdDogZGVsZXRlZEF0XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnRocmVhZCxcbiAgICB1cGRhdGVkQXQ6IGRlbGV0ZWRBdCxcbiAgICBjb21tZW50czogdXBkYXRlZENvbW1lbnRzXG4gIH07XG59XG5mdW5jdGlvbiBhcHBseUFkZFJlYWN0aW9uKHRocmVhZCwgY29tbWVudElkLCByZWFjdGlvbikge1xuICBpZiAodGhyZWFkLmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCBleGlzdGluZ0NvbW1lbnQgPSB0aHJlYWQuY29tbWVudHMuZmluZChcbiAgICAoY29tbWVudCkgPT4gY29tbWVudC5pZCA9PT0gY29tbWVudElkXG4gICk7XG4gIGlmIChleGlzdGluZ0NvbW1lbnQgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgaWYgKGV4aXN0aW5nQ29tbWVudC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgdXBkYXRlZENvbW1lbnRzID0gdGhyZWFkLmNvbW1lbnRzLm1hcChcbiAgICAoY29tbWVudCkgPT4gY29tbWVudC5pZCA9PT0gY29tbWVudElkID8ge1xuICAgICAgLi4uY29tbWVudCxcbiAgICAgIHJlYWN0aW9uczogdXBzZXJ0UmVhY3Rpb24oY29tbWVudC5yZWFjdGlvbnMsIHJlYWN0aW9uKVxuICAgIH0gOiBjb21tZW50XG4gICk7XG4gIHJldHVybiB7XG4gICAgLi4udGhyZWFkLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoXG4gICAgICBNYXRoLm1heChyZWFjdGlvbi5jcmVhdGVkQXQuZ2V0VGltZSgpLCB0aHJlYWQudXBkYXRlZEF0LmdldFRpbWUoKSlcbiAgICApLFxuICAgIGNvbW1lbnRzOiB1cGRhdGVkQ29tbWVudHNcbiAgfTtcbn1cbmZ1bmN0aW9uIGFwcGx5UmVtb3ZlUmVhY3Rpb24odGhyZWFkLCBjb21tZW50SWQsIGVtb2ppLCB1c2VySWQsIHJlbW92ZWRBdCkge1xuICBpZiAodGhyZWFkLmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRocmVhZDtcbiAgfVxuICBjb25zdCBleGlzdGluZ0NvbW1lbnQgPSB0aHJlYWQuY29tbWVudHMuZmluZChcbiAgICAoY29tbWVudCkgPT4gY29tbWVudC5pZCA9PT0gY29tbWVudElkXG4gICk7XG4gIGlmIChleGlzdGluZ0NvbW1lbnQgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgaWYgKGV4aXN0aW5nQ29tbWVudC5kZWxldGVkQXQgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB0aHJlYWQ7XG4gIH1cbiAgY29uc3QgdXBkYXRlZENvbW1lbnRzID0gdGhyZWFkLmNvbW1lbnRzLm1hcChcbiAgICAoY29tbWVudCkgPT4gY29tbWVudC5pZCA9PT0gY29tbWVudElkID8ge1xuICAgICAgLi4uY29tbWVudCxcbiAgICAgIHJlYWN0aW9uczogY29tbWVudC5yZWFjdGlvbnMubWFwKFxuICAgICAgICAocmVhY3Rpb24pID0+IHJlYWN0aW9uLmVtb2ppID09PSBlbW9qaSA/IHtcbiAgICAgICAgICAuLi5yZWFjdGlvbixcbiAgICAgICAgICB1c2VyczogcmVhY3Rpb24udXNlcnMuZmlsdGVyKCh1c2VyKSA9PiB1c2VyLmlkICE9PSB1c2VySWQpXG4gICAgICAgIH0gOiByZWFjdGlvblxuICAgICAgKS5maWx0ZXIoKHJlYWN0aW9uKSA9PiByZWFjdGlvbi51c2Vycy5sZW5ndGggPiAwKVxuICAgICAgLy8gUmVtb3ZlIHJlYWN0aW9ucyB3aXRoIG5vIHVzZXJzIGxlZnRcbiAgICB9IDogY29tbWVudFxuICApO1xuICByZXR1cm4ge1xuICAgIC4uLnRocmVhZCxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKFxuICAgICAgTWF0aC5tYXgocmVtb3ZlZEF0LmdldFRpbWUoKSwgdGhyZWFkLnVwZGF0ZWRBdC5nZXRUaW1lKCkpXG4gICAgKSxcbiAgICBjb21tZW50czogdXBkYXRlZENvbW1lbnRzXG4gIH07XG59XG5mdW5jdGlvbiB1cHNlcnRSZWFjdGlvbihyZWFjdGlvbnMsIHJlYWN0aW9uKSB7XG4gIGNvbnN0IGV4aXN0aW5nUmVhY3Rpb24gPSByZWFjdGlvbnMuZmluZChcbiAgICAoZXhpc3RpbmdSZWFjdGlvbjIpID0+IGV4aXN0aW5nUmVhY3Rpb24yLmVtb2ppID09PSByZWFjdGlvbi5lbW9qaVxuICApO1xuICBpZiAoZXhpc3RpbmdSZWFjdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC4uLnJlYWN0aW9ucyxcbiAgICAgIHtcbiAgICAgICAgZW1vamk6IHJlYWN0aW9uLmVtb2ppLFxuICAgICAgICBjcmVhdGVkQXQ6IHJlYWN0aW9uLmNyZWF0ZWRBdCxcbiAgICAgICAgdXNlcnM6IFt7IGlkOiByZWFjdGlvbi51c2VySWQgfV1cbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIGlmIChleGlzdGluZ1JlYWN0aW9uLnVzZXJzLnNvbWUoKHVzZXIpID0+IHVzZXIuaWQgPT09IHJlYWN0aW9uLnVzZXJJZCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHJlYWN0aW9ucy5tYXAoXG4gICAgICAoZXhpc3RpbmdSZWFjdGlvbjIpID0+IGV4aXN0aW5nUmVhY3Rpb24yLmVtb2ppID09PSByZWFjdGlvbi5lbW9qaSA/IHtcbiAgICAgICAgLi4uZXhpc3RpbmdSZWFjdGlvbjIsXG4gICAgICAgIHVzZXJzOiBbLi4uZXhpc3RpbmdSZWFjdGlvbjIudXNlcnMsIHsgaWQ6IHJlYWN0aW9uLnVzZXJJZCB9XVxuICAgICAgfSA6IGV4aXN0aW5nUmVhY3Rpb24yXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVhY3Rpb25zO1xufVxuXG4vLyBzcmMvbGl2ZWJsb2Nrcy50c3hcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIENsaWVudENvbnRleHQgPSBjcmVhdGVDb250ZXh0MihudWxsKTtcbmZ1bmN0aW9uIG1pc3NpbmdVc2VyRXJyb3IodXNlcklkKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoYHJlc29sdmVVc2VycyBkaWRuJ3QgcmV0dXJuIGFueXRoaW5nIGZvciB1c2VyICcke3VzZXJJZH0nYCk7XG59XG5mdW5jdGlvbiBtaXNzaW5nUm9vbUluZm9FcnJvcihyb29tSWQpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICBgcmVzb2x2ZVJvb21zSW5mbyBkaWRuJ3QgcmV0dXJuIGFueXRoaW5nIGZvciByb29tICcke3Jvb21JZH0nYFxuICApO1xufVxuZnVuY3Rpb24gaWRlbnRpdHkyKHgpIHtcbiAgcmV0dXJuIHg7XG59XG52YXIgX3VtYnJlbGxhU3RvcmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgX2V4dHJhcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIF9idW5kbGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBzZWxlY3RvckZvcl91c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudChyZXN1bHQpIHtcbiAgaWYgKCFyZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXR1cm4gQVNZTkNfT0soXG4gICAgXCJjb3VudFwiLFxuICAgIGNvdW50KFxuICAgICAgcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucyxcbiAgICAgIChuKSA9PiBuLnJlYWRBdCA9PT0gbnVsbCB8fCBuLnJlYWRBdCA8IG4ubm90aWZpZWRBdFxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdG9yRm9yX3VzZVVzZXIoc3RhdGUsIHVzZXJJZCkge1xuICBpZiAoc3RhdGUgPT09IHZvaWQgMCB8fCBzdGF0ZT8uaXNMb2FkaW5nKSB7XG4gICAgcmV0dXJuIHN0YXRlID8/IHsgaXNMb2FkaW5nOiB0cnVlIH07XG4gIH1cbiAgaWYgKHN0YXRlLmVycm9yKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG4gIGlmICghc3RhdGUuZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgZXJyb3I6IG1pc3NpbmdVc2VyRXJyb3IodXNlcklkKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgIHVzZXI6IHN0YXRlLmRhdGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHNlbGVjdG9yRm9yX3VzZVJvb21JbmZvKHN0YXRlLCByb29tSWQpIHtcbiAgaWYgKHN0YXRlID09PSB2b2lkIDAgfHwgc3RhdGU/LmlzTG9hZGluZykge1xuICAgIHJldHVybiBzdGF0ZSA/PyB7IGlzTG9hZGluZzogdHJ1ZSB9O1xuICB9XG4gIGlmIChzdGF0ZS5lcnJvcikge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBpZiAoIXN0YXRlLmRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgIGVycm9yOiBtaXNzaW5nUm9vbUluZm9FcnJvcihyb29tSWQpXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgaW5mbzogc3RhdGUuZGF0YVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVDb250ZXh0QnVuZGxlKGNsaWVudCkge1xuICBsZXQgYnVuZGxlID0gX2J1bmRsZXMuZ2V0KGNsaWVudCk7XG4gIGlmICghYnVuZGxlKSB7XG4gICAgYnVuZGxlID0gbWFrZUxpdmVibG9ja3NDb250ZXh0QnVuZGxlKGNsaWVudCk7XG4gICAgX2J1bmRsZXMuc2V0KGNsaWVudCwgYnVuZGxlKTtcbiAgfVxuICByZXR1cm4gYnVuZGxlO1xufVxuZnVuY3Rpb24gZ2V0VW1icmVsbGFTdG9yZUZvckNsaWVudChjbGllbnQpIHtcbiAgbGV0IHN0b3JlID0gX3VtYnJlbGxhU3RvcmVzLmdldChjbGllbnQpO1xuICBpZiAoIXN0b3JlKSB7XG4gICAgc3RvcmUgPSBuZXcgVW1icmVsbGFTdG9yZShjbGllbnQpO1xuICAgIF91bWJyZWxsYVN0b3Jlcy5zZXQoY2xpZW50LCBzdG9yZSk7XG4gIH1cbiAgcmV0dXJuIHN0b3JlO1xufVxuZnVuY3Rpb24gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpIHtcbiAgbGV0IGV4dHJhcyA9IF9leHRyYXMuZ2V0KGNsaWVudCk7XG4gIGlmICghZXh0cmFzKSB7XG4gICAgZXh0cmFzID0gbWFrZUxpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICBfZXh0cmFzLnNldChjbGllbnQsIGV4dHJhcyk7XG4gIH1cbiAgcmV0dXJuIGV4dHJhcztcbn1cbmZ1bmN0aW9uIG1ha2VMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCkge1xuICBjb25zdCBzdG9yZSA9IGdldFVtYnJlbGxhU3RvcmVGb3JDbGllbnQoY2xpZW50KTtcbiAgY29uc3Qgbm90aWZpY2F0aW9uc1BvbGxlciA9IG1ha2VQb2xsZXIoXG4gICAgYXN5bmMgKHNpZ25hbCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHN0b3JlLmZldGNoTm90aWZpY2F0aW9uc0RlbHRhVXBkYXRlKHNpZ25hbCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBQb2xsaW5nIG5ldyBpbmJveCBub3RpZmljYXRpb25zIGZhaWxlZDogJHtTdHJpbmcoZXJyKX1gKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29uZmlnLk5PVElGSUNBVElPTlNfUE9MTF9JTlRFUlZBTCxcbiAgICB7IG1heFN0YWxlVGltZU1zOiBjb25maWcuTk9USUZJQ0FUSU9OU19NQVhfU1RBTEVfVElNRSB9XG4gICk7XG4gIGNvbnN0IHVzZXJUaHJlYWRzUG9sbGVyID0gbWFrZVBvbGxlcihcbiAgICBhc3luYyAoc2lnbmFsKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgc3RvcmUuZmV0Y2hVc2VyVGhyZWFkc0RlbHRhVXBkYXRlKHNpZ25hbCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBQb2xsaW5nIG5ldyB1c2VyIHRocmVhZHMgZmFpbGVkOiAke1N0cmluZyhlcnIpfWApO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb25maWcuVVNFUl9USFJFQURTX1BPTExfSU5URVJWQUwsXG4gICAgeyBtYXhTdGFsZVRpbWVNczogY29uZmlnLlVTRVJfVEhSRUFEU19NQVhfU1RBTEVfVElNRSB9XG4gICk7XG4gIGNvbnN0IHVzZXJOb3RpZmljYXRpb25TZXR0aW5nc1BvbGxlciA9IG1ha2VQb2xsZXIoXG4gICAgYXN5bmMgKHNpZ25hbCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHN0b3JlLnJlZnJlc2hVc2VyTm90aWZpY2F0aW9uU2V0dGluZ3Moc2lnbmFsKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYFBvbGxpbmcgbmV3IHVzZXIgbm90aWZpY2F0aW9uIHNldHRpbmdzIGZhaWxlZDogJHtTdHJpbmcoZXJyKX1gXG4gICAgICAgICk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbmZpZy5VU0VSX05PVElGSUNBVElPTl9TRVRUSU5HU19JTlRFUlZBTCxcbiAgICB7IG1heFN0YWxlVGltZU1zOiBjb25maWcuVVNFUl9OT1RJRklDQVRJT05fU0VUVElOR1NfTUFYX1NUQUxFX1RJTUUgfVxuICApO1xuICByZXR1cm4ge1xuICAgIHN0b3JlLFxuICAgIG5vdGlmaWNhdGlvbnNQb2xsZXIsXG4gICAgdXNlclRocmVhZHNQb2xsZXIsXG4gICAgdXNlck5vdGlmaWNhdGlvblNldHRpbmdzUG9sbGVyXG4gIH07XG59XG5mdW5jdGlvbiBtYWtlTGl2ZWJsb2Nrc0NvbnRleHRCdW5kbGUoY2xpZW50KSB7XG4gIGNvbnN0IHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkMiA9IChpbmJveE5vdGlmaWNhdGlvbklkKSA9PiB1c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZF93aXRoQ2xpZW50KGNsaWVudCwgaW5ib3hOb3RpZmljYXRpb25JZCk7XG4gIGNvbnN0IHVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZDIgPSAoKSA9PiB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRfd2l0aENsaWVudChjbGllbnQpO1xuICBjb25zdCB1c2VNYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkMiA9ICgpID0+IHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWRfd2l0aENsaWVudChjbGllbnQpO1xuICBjb25zdCB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbjIgPSAoKSA9PiB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbl93aXRoQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9uczIgPSAoKSA9PiB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnNfd2l0aENsaWVudChjbGllbnQpO1xuICBjb25zdCB1c2VVcGRhdGVOb3RpZmljYXRpb25TZXR0aW5nczIgPSAoKSA9PiB1c2VVcGRhdGVOb3RpZmljYXRpb25TZXR0aW5nc193aXRoQ2xpZW50KGNsaWVudCk7XG4gIGZ1bmN0aW9uIExpdmVibG9ja3NQcm92aWRlcjIocHJvcHMpIHtcbiAgICB1c2VFbnN1cmVOb0xpdmVibG9ja3NQcm92aWRlcigpO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KENsaWVudENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNsaWVudCwgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuIH0pO1xuICB9XG4gIGNvbnN0IHNoYXJlZCA9IGNyZWF0ZVNoYXJlZENvbnRleHQoY2xpZW50KTtcbiAgY29uc3QgYnVuZGxlID0ge1xuICAgIExpdmVibG9ja3NQcm92aWRlcjogTGl2ZWJsb2Nrc1Byb3ZpZGVyMixcbiAgICB1c2VJbmJveE5vdGlmaWNhdGlvbnM6ICgpID0+IHVzZUluYm94Tm90aWZpY2F0aW9uc193aXRoQ2xpZW50KGNsaWVudCwgaWRlbnRpdHkyLCBzaGFsbG93NCksXG4gICAgdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnQ6ICgpID0+IHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50X3dpdGhDbGllbnQoY2xpZW50KSxcbiAgICB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQ6IHVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZDIsXG4gICAgdXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZDogdXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZDIsXG4gICAgdXNlRGVsZXRlSW5ib3hOb3RpZmljYXRpb246IHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uMixcbiAgICB1c2VEZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnM6IHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9uczIsXG4gICAgdXNlTm90aWZpY2F0aW9uU2V0dGluZ3M6ICgpID0+IHVzZU5vdGlmaWNhdGlvblNldHRpbmdzX3dpdGhDbGllbnQoY2xpZW50KSxcbiAgICB1c2VVcGRhdGVOb3RpZmljYXRpb25TZXR0aW5nczogdXNlVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3MyLFxuICAgIHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkOiB1c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZDIsXG4gICAgdXNlVXNlclRocmVhZHNfZXhwZXJpbWVudGFsLFxuICAgIC4uLnNoYXJlZC5jbGFzc2ljLFxuICAgIHN1c3BlbnNlOiB7XG4gICAgICBMaXZlYmxvY2tzUHJvdmlkZXI6IExpdmVibG9ja3NQcm92aWRlcjIsXG4gICAgICB1c2VJbmJveE5vdGlmaWNhdGlvbnM6ICgpID0+IHVzZUluYm94Tm90aWZpY2F0aW9uc1N1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50KSxcbiAgICAgIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50OiAoKSA9PiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudFN1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50KSxcbiAgICAgIHVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZDogdXNlTWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkMixcbiAgICAgIHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQ6IHVzZU1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQyLFxuICAgICAgdXNlRGVsZXRlSW5ib3hOb3RpZmljYXRpb246IHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uMixcbiAgICAgIHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9uczogdXNlRGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zMixcbiAgICAgIHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkOiB1c2VJbmJveE5vdGlmaWNhdGlvblRocmVhZDIsXG4gICAgICB1c2VOb3RpZmljYXRpb25TZXR0aW5nczogKCkgPT4gdXNlTm90aWZpY2F0aW9uU2V0dGluZ3NTdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCksXG4gICAgICB1c2VVcGRhdGVOb3RpZmljYXRpb25TZXR0aW5nczogdXNlVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3MyLFxuICAgICAgdXNlVXNlclRocmVhZHNfZXhwZXJpbWVudGFsOiB1c2VVc2VyVGhyZWFkc1N1c3BlbnNlX2V4cGVyaW1lbnRhbCxcbiAgICAgIC4uLnNoYXJlZC5zdXNwZW5zZVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGJ1bmRsZTtcbn1cbmZ1bmN0aW9uIHVzZUluYm94Tm90aWZpY2F0aW9uc193aXRoQ2xpZW50KGNsaWVudCwgc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgY29uc3QgeyBzdG9yZSwgbm90aWZpY2F0aW9uc1BvbGxlcjogcG9sbGVyIH0gPSBnZXRMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gIHVzZUVmZmVjdDMoXG4gICAgKCkgPT4gdm9pZCBzdG9yZS5vdXRwdXRzLmxvYWRpbmdOb3RpZmljYXRpb25zLndhaXRVbnRpbExvYWRlZCgpXG4gICAgLy8gTk9URTogRGVsaWJlcmF0ZWx5ICpub3QqIHVzaW5nIGEgZGVwZW5kZW5jeSBhcnJheSBoZXJlIVxuICAgIC8vXG4gICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIGNhbGwgd2FpdFVudGlsIG9uICpldmVyeSogcmVuZGVyLlxuICAgIC8vIFRoaXMgaXMgaGFybWxlc3MgdGhvdWdoLCBvbiBtb3N0IHJlbmRlcnMsIGV4Y2VwdDpcbiAgICAvLyAxLiBUaGUgdmVyeSBmaXJzdCByZW5kZXIsIGluIHdoaWNoIGNhc2Ugd2UnbGwgd2FudCB0byB0cmlnZ2VyIHRoZSBpbml0aWFsIHBhZ2UgZmV0Y2guXG4gICAgLy8gMi4gQWxsIG90aGVyIHN1YnNlcXVlbnQgcmVuZGVycyBub3cgXCJqdXN0XCIgcmV0dXJuIHRoZSBzYW1lIHByb21pc2UgKGEgcXVpY2sgb3BlcmF0aW9uKS5cbiAgICAvLyAzLiBJZiBldmVyIHRoZSBwcm9taXNlIHdvdWxkIGZhaWwsIHRoZW4gYWZ0ZXIgNSBzZWNvbmRzIGl0IHdvdWxkIHJlc2V0LCBhbmQgb24gdGhlIHZlcnlcbiAgICAvLyAgICAqbmV4dCogcmVuZGVyIGFmdGVyIHRoYXQsIGEgKm5ldyogZmV0Y2gvcHJvbWlzZSB3aWxsIGdldCBjcmVhdGVkLlxuICApO1xuICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICBwb2xsZXIuaW5jKCk7XG4gICAgcG9sbGVyLnBvbGxOb3dJZlN0YWxlKCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBvbGxlci5kZWMoKTtcbiAgICB9O1xuICB9LCBbcG9sbGVyXSk7XG4gIHJldHVybiB1c2VTaWduYWwoXG4gICAgc3RvcmUub3V0cHV0cy5sb2FkaW5nTm90aWZpY2F0aW9ucy5zaWduYWwsXG4gICAgc2VsZWN0b3IsXG4gICAgaXNFcXVhbFxuICApO1xufVxuZnVuY3Rpb24gdXNlSW5ib3hOb3RpZmljYXRpb25zU3VzcGVuc2Vfd2l0aENsaWVudChjbGllbnQpIHtcbiAgZW5zdXJlTm90U2VydmVyU2lkZSgpO1xuICBjb25zdCBzdG9yZSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KS5zdG9yZTtcbiAgdXNlKHN0b3JlLm91dHB1dHMubG9hZGluZ05vdGlmaWNhdGlvbnMud2FpdFVudGlsTG9hZGVkKCkpO1xuICBjb25zdCByZXN1bHQgPSB1c2VJbmJveE5vdGlmaWNhdGlvbnNfd2l0aENsaWVudChjbGllbnQsIGlkZW50aXR5Miwgc2hhbGxvdzQpO1xuICBhc3NlcnQoIXJlc3VsdC5lcnJvciwgXCJEaWQgbm90IGV4cGVjdCBlcnJvclwiKTtcbiAgYXNzZXJ0KCFyZXN1bHQuaXNMb2FkaW5nLCBcIkRpZCBub3QgZXhwZWN0IGxvYWRpbmdcIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudF93aXRoQ2xpZW50KGNsaWVudCkge1xuICByZXR1cm4gdXNlSW5ib3hOb3RpZmljYXRpb25zX3dpdGhDbGllbnQoXG4gICAgY2xpZW50LFxuICAgIHNlbGVjdG9yRm9yX3VzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50LFxuICAgIHNoYWxsb3c0XG4gICk7XG59XG5mdW5jdGlvbiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudFN1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIGVuc3VyZU5vdFNlcnZlclNpZGUoKTtcbiAgY29uc3Qgc3RvcmUgPSBnZXRMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCkuc3RvcmU7XG4gIHVzZShzdG9yZS5vdXRwdXRzLmxvYWRpbmdOb3RpZmljYXRpb25zLndhaXRVbnRpbExvYWRlZCgpKTtcbiAgY29uc3QgcmVzdWx0ID0gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRfd2l0aENsaWVudChjbGllbnQpO1xuICBhc3NlcnQoIXJlc3VsdC5pc0xvYWRpbmcsIFwiRGlkIG5vdCBleHBlY3QgbG9hZGluZ1wiKTtcbiAgYXNzZXJ0KCFyZXN1bHQuZXJyb3IsIFwiRGlkIG5vdCBleHBlY3QgZXJyb3JcIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRfd2l0aENsaWVudChjbGllbnQpIHtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMihcbiAgICAoaW5ib3hOb3RpZmljYXRpb25JZCkgPT4ge1xuICAgICAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3QgcmVhZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljSWQgPSBzdG9yZS5vcHRpbWlzdGljVXBkYXRlcy5hZGQoe1xuICAgICAgICB0eXBlOiBcIm1hcmstaW5ib3gtbm90aWZpY2F0aW9uLWFzLXJlYWRcIixcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb25JZCxcbiAgICAgICAgcmVhZEF0XG4gICAgICB9KTtcbiAgICAgIGNsaWVudC5tYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQoaW5ib3hOb3RpZmljYXRpb25JZCkudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLm1hcmtJbmJveE5vdGlmaWNhdGlvblJlYWQoXG4gICAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbklkLFxuICAgICAgICAgICAgcmVhZEF0LFxuICAgICAgICAgICAgb3B0aW1pc3RpY0lkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgIHN0b3JlLm9wdGltaXN0aWNVcGRhdGVzLnJlbW92ZShvcHRpbWlzdGljSWQpO1xuICAgICAgICAgIGNsaWVudFtrSW50ZXJuYWwyXS5lbWl0RXJyb3IoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiTUFSS19JTkJPWF9OT1RJRklDQVRJT05fQVNfUkVBRF9FUlJPUlwiLFxuICAgICAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbklkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnRdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VNYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkX3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIHJldHVybiB1c2VDYWxsYmFjazIoKCkgPT4ge1xuICAgIGNvbnN0IHsgc3RvcmUgfSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICBjb25zdCByZWFkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICBjb25zdCBvcHRpbWlzdGljSWQgPSBzdG9yZS5vcHRpbWlzdGljVXBkYXRlcy5hZGQoe1xuICAgICAgdHlwZTogXCJtYXJrLWFsbC1pbmJveC1ub3RpZmljYXRpb25zLWFzLXJlYWRcIixcbiAgICAgIHJlYWRBdFxuICAgIH0pO1xuICAgIGNsaWVudC5tYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKCkudGhlbihcbiAgICAgICgpID0+IHtcbiAgICAgICAgc3RvcmUubWFya0FsbEluYm94Tm90aWZpY2F0aW9uc1JlYWQob3B0aW1pc3RpY0lkLCByZWFkQXQpO1xuICAgICAgfSxcbiAgICAgIChlcnIpID0+IHtcbiAgICAgICAgc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMucmVtb3ZlKG9wdGltaXN0aWNJZCk7XG4gICAgICAgIGNsaWVudFtrSW50ZXJuYWwyXS5lbWl0RXJyb3IoXG4gICAgICAgICAgLy8gTm8gcm9vbUlkLCB0aHJlYWRJZCwgY29tbWVudElkIHRvIGluY2x1ZGUgZm9yIHRoaXMgZXJyb3JcbiAgICAgICAgICB7IHR5cGU6IFwiTUFSS19BTExfSU5CT1hfTk9USUZJQ0FUSU9OU19BU19SRUFEX0VSUk9SXCIgfSxcbiAgICAgICAgICBlcnJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApO1xuICB9LCBbY2xpZW50XSk7XG59XG5mdW5jdGlvbiB1c2VEZWxldGVJbmJveE5vdGlmaWNhdGlvbl93aXRoQ2xpZW50KGNsaWVudCkge1xuICByZXR1cm4gdXNlQ2FsbGJhY2syKFxuICAgIChpbmJveE5vdGlmaWNhdGlvbklkKSA9PiB7XG4gICAgICBjb25zdCB7IHN0b3JlIH0gPSBnZXRMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBkZWxldGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNJZCA9IHN0b3JlLm9wdGltaXN0aWNVcGRhdGVzLmFkZCh7XG4gICAgICAgIHR5cGU6IFwiZGVsZXRlLWluYm94LW5vdGlmaWNhdGlvblwiLFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbklkLFxuICAgICAgICBkZWxldGVkQXRcbiAgICAgIH0pO1xuICAgICAgY2xpZW50LmRlbGV0ZUluYm94Tm90aWZpY2F0aW9uKGluYm94Tm90aWZpY2F0aW9uSWQpLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5kZWxldGVJbmJveE5vdGlmaWNhdGlvbihpbmJveE5vdGlmaWNhdGlvbklkLCBvcHRpbWlzdGljSWQpO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMucmVtb3ZlKG9wdGltaXN0aWNJZCk7XG4gICAgICAgICAgY2xpZW50W2tJbnRlcm5hbDJdLmVtaXRFcnJvcihcbiAgICAgICAgICAgIHsgdHlwZTogXCJERUxFVEVfSU5CT1hfTk9USUZJQ0FUSU9OX0VSUk9SXCIsIGluYm94Tm90aWZpY2F0aW9uSWQgfSxcbiAgICAgICAgICAgIGVyclxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50XVxuICApO1xufVxuZnVuY3Rpb24gdXNlRGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zX3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIHJldHVybiB1c2VDYWxsYmFjazIoKCkgPT4ge1xuICAgIGNvbnN0IHsgc3RvcmUgfSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICBjb25zdCBkZWxldGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICBjb25zdCBvcHRpbWlzdGljSWQgPSBzdG9yZS5vcHRpbWlzdGljVXBkYXRlcy5hZGQoe1xuICAgICAgdHlwZTogXCJkZWxldGUtYWxsLWluYm94LW5vdGlmaWNhdGlvbnNcIixcbiAgICAgIGRlbGV0ZWRBdFxuICAgIH0pO1xuICAgIGNsaWVudC5kZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMoKS50aGVuKFxuICAgICAgKCkgPT4ge1xuICAgICAgICBzdG9yZS5kZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMob3B0aW1pc3RpY0lkKTtcbiAgICAgIH0sXG4gICAgICAoZXJyKSA9PiB7XG4gICAgICAgIHN0b3JlLm9wdGltaXN0aWNVcGRhdGVzLnJlbW92ZShvcHRpbWlzdGljSWQpO1xuICAgICAgICBjbGllbnRba0ludGVybmFsMl0uZW1pdEVycm9yKFxuICAgICAgICAgIHsgdHlwZTogXCJERUxFVEVfQUxMX0lOQk9YX05PVElGSUNBVElPTlNfRVJST1JcIiB9LFxuICAgICAgICAgIGVyclxuICAgICAgICApO1xuICAgICAgfVxuICAgICk7XG4gIH0sIFtjbGllbnRdKTtcbn1cbmZ1bmN0aW9uIHVzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkX3dpdGhDbGllbnQoY2xpZW50LCBpbmJveE5vdGlmaWNhdGlvbklkKSB7XG4gIGNvbnN0IHsgc3RvcmUgfSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgcmV0dXJuIHVzZVNpZ25hbChcbiAgICBzdG9yZS5vdXRwdXRzLnRocmVhZGlmaWNhdGlvbnMsXG4gICAgdXNlQ2FsbGJhY2syKFxuICAgICAgKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IGluYm94Tm90aWZpY2F0aW9uID0gc3RhdGUubm90aWZpY2F0aW9uc0J5SWRbaW5ib3hOb3RpZmljYXRpb25JZF0gPz8gcmFpc2UoXG4gICAgICAgICAgYEluYm94IG5vdGlmaWNhdGlvbiB3aXRoIElEIFwiJHtpbmJveE5vdGlmaWNhdGlvbklkfVwiIG5vdCBmb3VuZGBcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGluYm94Tm90aWZpY2F0aW9uLmtpbmQgIT09IFwidGhyZWFkXCIpIHtcbiAgICAgICAgICByYWlzZShcbiAgICAgICAgICAgIGBJbmJveCBub3RpZmljYXRpb24gd2l0aCBJRCBcIiR7aW5ib3hOb3RpZmljYXRpb25JZH1cIiBpcyBub3Qgb2Yga2luZCBcInRocmVhZFwiYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhyZWFkID0gc3RhdGUudGhyZWFkc0RCLmdldChpbmJveE5vdGlmaWNhdGlvbi50aHJlYWRJZCkgPz8gcmFpc2UoXG4gICAgICAgICAgYFRocmVhZCB3aXRoIElEIFwiJHtpbmJveE5vdGlmaWNhdGlvbi50aHJlYWRJZH1cIiBub3QgZm91bmQsIHRoaXMgaW5ib3ggbm90aWZpY2F0aW9uIG1pZ2h0IG5vdCBiZSBvZiBraW5kIFwidGhyZWFkXCJgXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aHJlYWQ7XG4gICAgICB9LFxuICAgICAgW2luYm94Tm90aWZpY2F0aW9uSWRdXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gdXNlVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3Nfd2l0aENsaWVudChjbGllbnQpIHtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMihcbiAgICAoc2V0dGluZ3MpID0+IHtcbiAgICAgIGNvbnN0IHsgc3RvcmUgfSA9IGdldExpdmVibG9ja3NFeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IG9wdGltaXN0aWNVcGRhdGVJZCA9IHN0b3JlLm9wdGltaXN0aWNVcGRhdGVzLmFkZCh7XG4gICAgICAgIHR5cGU6IFwidXBkYXRlLXVzZXItbm90aWZpY2F0aW9uLXNldHRpbmdzXCIsXG4gICAgICAgIHNldHRpbmdzXG4gICAgICB9KTtcbiAgICAgIGNsaWVudC51cGRhdGVOb3RpZmljYXRpb25TZXR0aW5ncyhzZXR0aW5ncykudGhlbihcbiAgICAgICAgKHNldHRpbmdzMikgPT4ge1xuICAgICAgICAgIHN0b3JlLnVwZGF0ZVVzZXJOb3RpZmljYXRpb25TZXR0aW5nc19jb25maXJtT3B0aW1pc3RpY1VwZGF0ZShcbiAgICAgICAgICAgIHNldHRpbmdzMixcbiAgICAgICAgICAgIG9wdGltaXN0aWNVcGRhdGVJZFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICBzdG9yZS5vcHRpbWlzdGljVXBkYXRlcy5yZW1vdmUob3B0aW1pc3RpY1VwZGF0ZUlkKTtcbiAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgSHR0cEVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyLnN0YXR1cyA9PT0gNDIyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1zZyA9IFtlcnIuZGV0YWlscz8uZXJyb3IsIGVyci5kZXRhaWxzPy5yZWFzb25dLmZpbHRlcihCb29sZWFuKS5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGllbnRba0ludGVybmFsMl0uZW1pdEVycm9yKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJVUERBVEVfVVNFUl9OT1RJRklDQVRJT05fU0VUVElOR1NfRVJST1JcIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBlcnJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50XVxuICApO1xufVxuZnVuY3Rpb24gdXNlTm90aWZpY2F0aW9uU2V0dGluZ3Nfd2l0aENsaWVudChjbGllbnQpIHtcbiAgY29uc3QgdXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3MgPSB1c2VVcGRhdGVOb3RpZmljYXRpb25TZXR0aW5nc193aXRoQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IHsgc3RvcmUsIHVzZXJOb3RpZmljYXRpb25TZXR0aW5nc1BvbGxlcjogcG9sbGVyIH0gPSBnZXRMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIHZvaWQgc3RvcmUub3V0cHV0cy51c2VyTm90aWZpY2F0aW9uU2V0dGluZ3Mud2FpdFVudGlsTG9hZGVkKCk7XG4gIH0pO1xuICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICBwb2xsZXIuaW5jKCk7XG4gICAgcG9sbGVyLnBvbGxOb3dJZlN0YWxlKCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBvbGxlci5kZWMoKTtcbiAgICB9O1xuICB9LCBbcG9sbGVyXSk7XG4gIGNvbnN0IHJlc3VsdCA9IHVzZVNpZ25hbChzdG9yZS5vdXRwdXRzLnVzZXJOb3RpZmljYXRpb25TZXR0aW5ncy5zaWduYWwpO1xuICByZXR1cm4gdXNlTWVtbzIoKCkgPT4ge1xuICAgIHJldHVybiBbcmVzdWx0LCB1cGRhdGVOb3RpZmljYXRpb25TZXR0aW5nc107XG4gIH0sIFtyZXN1bHQsIHVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzXSk7XG59XG5mdW5jdGlvbiB1c2VOb3RpZmljYXRpb25TZXR0aW5nc1N1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50KSB7XG4gIGVuc3VyZU5vdFNlcnZlclNpZGUoKTtcbiAgY29uc3Qgc3RvcmUgPSBnZXRMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCkuc3RvcmU7XG4gIHVzZShzdG9yZS5vdXRwdXRzLnVzZXJOb3RpZmljYXRpb25TZXR0aW5ncy53YWl0VW50aWxMb2FkZWQoKSk7XG4gIGNvbnN0IFtyZXN1bHQsIHVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzXSA9IHVzZU5vdGlmaWNhdGlvblNldHRpbmdzX3dpdGhDbGllbnQoY2xpZW50KTtcbiAgYXNzZXJ0KCFyZXN1bHQuZXJyb3IsIFwiRGlkIG5vdCBleHBlY3QgZXJyb3JcIik7XG4gIGFzc2VydCghcmVzdWx0LmlzTG9hZGluZywgXCJEaWQgbm90IGV4cGVjdCBsb2FkaW5nXCIpO1xuICByZXR1cm4gdXNlTWVtbzIoKCkgPT4ge1xuICAgIHJldHVybiBbcmVzdWx0LCB1cGRhdGVOb3RpZmljYXRpb25TZXR0aW5nc107XG4gIH0sIFtyZXN1bHQsIHVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzXSk7XG59XG5mdW5jdGlvbiB1c2VVc2VyX3dpdGhDbGllbnQoY2xpZW50LCB1c2VySWQpIHtcbiAgY29uc3QgdXNlcnNTdG9yZSA9IGNsaWVudFtrSW50ZXJuYWwyXS51c2Vyc1N0b3JlO1xuICBjb25zdCBnZXRVc2VyU3RhdGUgPSB1c2VDYWxsYmFjazIoXG4gICAgKCkgPT4gdXNlcnNTdG9yZS5nZXRJdGVtU3RhdGUodXNlcklkKSxcbiAgICBbdXNlcnNTdG9yZSwgdXNlcklkXVxuICApO1xuICBjb25zdCBzZWxlY3RvciA9IHVzZUNhbGxiYWNrMihcbiAgICAoc3RhdGUpID0+IHNlbGVjdG9yRm9yX3VzZVVzZXIoc3RhdGUsIHVzZXJJZCksXG4gICAgW3VzZXJJZF1cbiAgKTtcbiAgY29uc3QgcmVzdWx0ID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgdXNlcnNTdG9yZS5zdWJzY3JpYmUsXG4gICAgZ2V0VXNlclN0YXRlLFxuICAgIGdldFVzZXJTdGF0ZSxcbiAgICBzZWxlY3RvcixcbiAgICBzaGFsbG93NFxuICApO1xuICB1c2VFZmZlY3QzKFxuICAgICgpID0+IHZvaWQgdXNlcnNTdG9yZS5lbnF1ZXVlKHVzZXJJZClcbiAgICAvLyBOT1RFOiBEZWxpYmVyYXRlbHkgKm5vdCogdXNpbmcgYSBkZXBlbmRlbmN5IGFycmF5IGhlcmUhXG4gICAgLy9cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gY2FsbCB1c2Vyc1N0b3JlLmVucXVldWUgb24gKmV2ZXJ5KiByZW5kZXIuXG4gICAgLy8gVGhpcyBpcyBoYXJtbGVzcyB0aG91Z2gsIG9uIG1vc3QgcmVuZGVycywgZXhjZXB0OlxuICAgIC8vIDEuIFRoZSB2ZXJ5IGZpcnN0IHJlbmRlciwgaW4gd2hpY2ggY2FzZSB3ZSdsbCB3YW50IHRvIHRyaWdnZXIgZXZhbHVhdGlvblxuICAgIC8vICAgIG9mIHRoZSB1c2VySWQuXG4gICAgLy8gMi4gQWxsIG90aGVyIHN1YnNlcXVlbnQgcmVuZGVycyBub3cgYXJlIGEgbm8tb3AgKGZyb20gdGhlIGltcGxlbWVudGF0aW9uXG4gICAgLy8gICAgb2YgLmVucXVldWUpXG4gICAgLy8gMy4gSWYgZXZlciB0aGUgdXNlcklkIGdldHMgaW52YWxpZGF0ZWQsIHRoZSB1c2VyIHdvdWxkIGJlIGZldGNoZWQgYWdhaW4uXG4gICk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1c2VVc2VyU3VzcGVuc2Vfd2l0aENsaWVudChjbGllbnQsIHVzZXJJZCkge1xuICBjb25zdCB1c2Vyc1N0b3JlID0gY2xpZW50W2tJbnRlcm5hbDJdLnVzZXJzU3RvcmU7XG4gIGNvbnN0IGdldFVzZXJTdGF0ZSA9IHVzZUNhbGxiYWNrMihcbiAgICAoKSA9PiB1c2Vyc1N0b3JlLmdldEl0ZW1TdGF0ZSh1c2VySWQpLFxuICAgIFt1c2Vyc1N0b3JlLCB1c2VySWRdXG4gICk7XG4gIGNvbnN0IHVzZXJTdGF0ZSA9IGdldFVzZXJTdGF0ZSgpO1xuICBpZiAoIXVzZXJTdGF0ZSB8fCB1c2VyU3RhdGUuaXNMb2FkaW5nKSB7XG4gICAgdGhyb3cgdXNlcnNTdG9yZS5lbnF1ZXVlKHVzZXJJZCk7XG4gIH1cbiAgaWYgKHVzZXJTdGF0ZS5lcnJvcikge1xuICAgIHRocm93IHVzZXJTdGF0ZS5lcnJvcjtcbiAgfVxuICBpZiAoIXVzZXJTdGF0ZS5kYXRhKSB7XG4gICAgdGhyb3cgbWlzc2luZ1VzZXJFcnJvcih1c2VySWQpO1xuICB9XG4gIGNvbnN0IHN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmUyKFxuICAgIHVzZXJzU3RvcmUuc3Vic2NyaWJlLFxuICAgIGdldFVzZXJTdGF0ZSxcbiAgICBnZXRVc2VyU3RhdGVcbiAgKTtcbiAgYXNzZXJ0KHN0YXRlICE9PSB2b2lkIDAsIFwiVW5leHBlY3RlZCBtaXNzaW5nIHN0YXRlXCIpO1xuICBhc3NlcnQoIXN0YXRlLmlzTG9hZGluZywgXCJVbmV4cGVjdGVkIGxvYWRpbmcgc3RhdGVcIik7XG4gIGFzc2VydCghc3RhdGUuZXJyb3IsIFwiVW5leHBlY3RlZCBlcnJvciBzdGF0ZVwiKTtcbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgIHVzZXI6IHN0YXRlLmRhdGEsXG4gICAgZXJyb3I6IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gdXNlUm9vbUluZm9fd2l0aENsaWVudChjbGllbnQsIHJvb21JZCkge1xuICBjb25zdCByb29tc0luZm9TdG9yZSA9IGNsaWVudFtrSW50ZXJuYWwyXS5yb29tc0luZm9TdG9yZTtcbiAgY29uc3QgZ2V0Um9vbUluZm9TdGF0ZSA9IHVzZUNhbGxiYWNrMihcbiAgICAoKSA9PiByb29tc0luZm9TdG9yZS5nZXRJdGVtU3RhdGUocm9vbUlkKSxcbiAgICBbcm9vbXNJbmZvU3RvcmUsIHJvb21JZF1cbiAgKTtcbiAgY29uc3Qgc2VsZWN0b3IgPSB1c2VDYWxsYmFjazIoXG4gICAgKHN0YXRlKSA9PiBzZWxlY3RvckZvcl91c2VSb29tSW5mbyhzdGF0ZSwgcm9vbUlkKSxcbiAgICBbcm9vbUlkXVxuICApO1xuICBjb25zdCByZXN1bHQgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICByb29tc0luZm9TdG9yZS5zdWJzY3JpYmUsXG4gICAgZ2V0Um9vbUluZm9TdGF0ZSxcbiAgICBnZXRSb29tSW5mb1N0YXRlLFxuICAgIHNlbGVjdG9yLFxuICAgIHNoYWxsb3c0XG4gICk7XG4gIHVzZUVmZmVjdDMoXG4gICAgKCkgPT4gdm9pZCByb29tc0luZm9TdG9yZS5lbnF1ZXVlKHJvb21JZClcbiAgICAvLyBOT1RFOiBEZWxpYmVyYXRlbHkgKm5vdCogdXNpbmcgYSBkZXBlbmRlbmN5IGFycmF5IGhlcmUhXG4gICAgLy9cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gY2FsbCByb29tc0luZm9TdG9yZS5lbnF1ZXVlIG9uICpldmVyeSogcmVuZGVyLlxuICAgIC8vIFRoaXMgaXMgaGFybWxlc3MgdGhvdWdoLCBvbiBtb3N0IHJlbmRlcnMsIGV4Y2VwdDpcbiAgICAvLyAxLiBUaGUgdmVyeSBmaXJzdCByZW5kZXIsIGluIHdoaWNoIGNhc2Ugd2UnbGwgd2FudCB0byB0cmlnZ2VyIGV2YWx1YXRpb25cbiAgICAvLyAgICBvZiB0aGUgcm9vbUlkLlxuICAgIC8vIDIuIEFsbCBvdGhlciBzdWJzZXF1ZW50IHJlbmRlcnMgbm93IGFyZSBhIG5vLW9wIChmcm9tIHRoZSBpbXBsZW1lbnRhdGlvblxuICAgIC8vICAgIG9mIC5lbnF1ZXVlKVxuICAgIC8vIDMuIElmIGV2ZXIgdGhlIHJvb21JZCBnZXRzIGludmFsaWRhdGVkLCB0aGUgcm9vbSBpbmZvIHdvdWxkIGJlIGZldGNoZWQgYWdhaW4uXG4gICk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1c2VSb29tSW5mb1N1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50LCByb29tSWQpIHtcbiAgY29uc3Qgcm9vbXNJbmZvU3RvcmUgPSBjbGllbnRba0ludGVybmFsMl0ucm9vbXNJbmZvU3RvcmU7XG4gIGNvbnN0IGdldFJvb21JbmZvU3RhdGUgPSB1c2VDYWxsYmFjazIoXG4gICAgKCkgPT4gcm9vbXNJbmZvU3RvcmUuZ2V0SXRlbVN0YXRlKHJvb21JZCksXG4gICAgW3Jvb21zSW5mb1N0b3JlLCByb29tSWRdXG4gICk7XG4gIGNvbnN0IHJvb21JbmZvU3RhdGUgPSBnZXRSb29tSW5mb1N0YXRlKCk7XG4gIGlmICghcm9vbUluZm9TdGF0ZSB8fCByb29tSW5mb1N0YXRlLmlzTG9hZGluZykge1xuICAgIHRocm93IHJvb21zSW5mb1N0b3JlLmVucXVldWUocm9vbUlkKTtcbiAgfVxuICBpZiAocm9vbUluZm9TdGF0ZS5lcnJvcikge1xuICAgIHRocm93IHJvb21JbmZvU3RhdGUuZXJyb3I7XG4gIH1cbiAgaWYgKCFyb29tSW5mb1N0YXRlLmRhdGEpIHtcbiAgICB0aHJvdyBtaXNzaW5nUm9vbUluZm9FcnJvcihyb29tSWQpO1xuICB9XG4gIGNvbnN0IHN0YXRlID0gdXNlU3luY0V4dGVybmFsU3RvcmUyKFxuICAgIHJvb21zSW5mb1N0b3JlLnN1YnNjcmliZSxcbiAgICBnZXRSb29tSW5mb1N0YXRlLFxuICAgIGdldFJvb21JbmZvU3RhdGVcbiAgKTtcbiAgYXNzZXJ0KHN0YXRlICE9PSB2b2lkIDAsIFwiVW5leHBlY3RlZCBtaXNzaW5nIHN0YXRlXCIpO1xuICBhc3NlcnQoIXN0YXRlLmlzTG9hZGluZywgXCJVbmV4cGVjdGVkIGxvYWRpbmcgc3RhdGVcIik7XG4gIGFzc2VydCghc3RhdGUuZXJyb3IsIFwiVW5leHBlY3RlZCBlcnJvciBzdGF0ZVwiKTtcbiAgYXNzZXJ0KHN0YXRlLmRhdGEgIT09IHZvaWQgMCwgXCJVbmV4cGVjdGVkIG1pc3Npbmcgcm9vbSBpbmZvIGRhdGFcIik7XG4gIHJldHVybiB7XG4gICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICBpbmZvOiBzdGF0ZS5kYXRhLFxuICAgIGVycm9yOiB2b2lkIDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNoYXJlZENvbnRleHQoY2xpZW50KSB7XG4gIGNvbnN0IHVzZUNsaWVudDIgPSAoKSA9PiBjbGllbnQ7XG4gIGZ1bmN0aW9uIHVzZVN5bmNTdGF0dXMyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdXNlU3luY1N0YXR1c193aXRoQ2xpZW50KGNsaWVudCwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjbGFzc2ljOiB7XG4gICAgICB1c2VDbGllbnQ6IHVzZUNsaWVudDIsXG4gICAgICB1c2VVc2VyOiAodXNlcklkKSA9PiB1c2VVc2VyX3dpdGhDbGllbnQoY2xpZW50LCB1c2VySWQpLFxuICAgICAgdXNlUm9vbUluZm86IChyb29tSWQpID0+IHVzZVJvb21JbmZvX3dpdGhDbGllbnQoY2xpZW50LCByb29tSWQpLFxuICAgICAgdXNlSXNJbnNpZGVSb29tLFxuICAgICAgdXNlRXJyb3JMaXN0ZW5lcixcbiAgICAgIHVzZVN5bmNTdGF0dXM6IHVzZVN5bmNTdGF0dXMyXG4gICAgfSxcbiAgICBzdXNwZW5zZToge1xuICAgICAgdXNlQ2xpZW50OiB1c2VDbGllbnQyLFxuICAgICAgdXNlVXNlcjogKHVzZXJJZCkgPT4gdXNlVXNlclN1c3BlbnNlX3dpdGhDbGllbnQoY2xpZW50LCB1c2VySWQpLFxuICAgICAgdXNlUm9vbUluZm86IChyb29tSWQpID0+IHVzZVJvb21JbmZvU3VzcGVuc2Vfd2l0aENsaWVudChjbGllbnQsIHJvb21JZCksXG4gICAgICB1c2VJc0luc2lkZVJvb20sXG4gICAgICB1c2VFcnJvckxpc3RlbmVyLFxuICAgICAgdXNlU3luY1N0YXR1czogdXNlU3luY1N0YXR1czJcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB1c2VFbnN1cmVOb0xpdmVibG9ja3NQcm92aWRlcihvcHRpb25zKSB7XG4gIGNvbnN0IGV4aXN0aW5nID0gdXNlQ2xpZW50T3JOdWxsKCk7XG4gIGlmICghb3B0aW9ucz8uYWxsb3dOZXN0aW5nICYmIGV4aXN0aW5nICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJZb3UgY2Fubm90IG5lc3QgbXVsdGlwbGUgTGl2ZWJsb2Nrc1Byb3ZpZGVyIGluc3RhbmNlcyBpbiB0aGUgc2FtZSBSZWFjdCB0cmVlLlwiXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gdXNlQ2xpZW50T3JOdWxsKCkge1xuICByZXR1cm4gdXNlQ29udGV4dDIoQ2xpZW50Q29udGV4dCk7XG59XG5mdW5jdGlvbiB1c2VDbGllbnQoKSB7XG4gIHJldHVybiB1c2VDbGllbnRPck51bGwoKSA/PyByYWlzZShcIkxpdmVibG9ja3NQcm92aWRlciBpcyBtaXNzaW5nIGZyb20gdGhlIFJlYWN0IHRyZWUuXCIpO1xufVxuZnVuY3Rpb24gTGl2ZWJsb2Nrc1Byb3ZpZGVyV2l0aENsaWVudChwcm9wcykge1xuICB1c2VFbnN1cmVOb0xpdmVibG9ja3NQcm92aWRlcihwcm9wcyk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KENsaWVudENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHByb3BzLmNsaWVudCwgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuIH0pO1xufVxuZnVuY3Rpb24gTGl2ZWJsb2Nrc1Byb3ZpZGVyKHByb3BzKSB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIC4uLm8gfSA9IHByb3BzO1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIHB1YmxpY0FwaUtleTogdXNlSW5pdGlhbChvLnB1YmxpY0FwaUtleSksXG4gICAgdGhyb3R0bGU6IHVzZUluaXRpYWwoby50aHJvdHRsZSksXG4gICAgbG9zdENvbm5lY3Rpb25UaW1lb3V0OiB1c2VJbml0aWFsKG8ubG9zdENvbm5lY3Rpb25UaW1lb3V0KSxcbiAgICBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dDogdXNlSW5pdGlhbChvLmJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0KSxcbiAgICBwb2x5ZmlsbHM6IHVzZUluaXRpYWwoby5wb2x5ZmlsbHMpLFxuICAgIGxhcmdlTWVzc2FnZVN0cmF0ZWd5OiB1c2VJbml0aWFsKG8ubGFyZ2VNZXNzYWdlU3RyYXRlZ3kpLFxuICAgIHVuc3RhYmxlX2ZhbGxiYWNrVG9IVFRQOiB1c2VJbml0aWFsKG8udW5zdGFibGVfZmFsbGJhY2tUb0hUVFApLFxuICAgIHVuc3RhYmxlX3N0cmVhbURhdGE6IHVzZUluaXRpYWwoby51bnN0YWJsZV9zdHJlYW1EYXRhKSxcbiAgICBwcmV2ZW50VW5zYXZlZENoYW5nZXM6IHVzZUluaXRpYWwoby5wcmV2ZW50VW5zYXZlZENoYW5nZXMpLFxuICAgIGF1dGhFbmRwb2ludDogdXNlSW5pdGlhbFVubGVzc0Z1bmN0aW9uKG8uYXV0aEVuZHBvaW50KSxcbiAgICByZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zOiB1c2VJbml0aWFsVW5sZXNzRnVuY3Rpb24oXG4gICAgICBvLnJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnNcbiAgICApLFxuICAgIHJlc29sdmVVc2VyczogdXNlSW5pdGlhbFVubGVzc0Z1bmN0aW9uKG8ucmVzb2x2ZVVzZXJzKSxcbiAgICByZXNvbHZlUm9vbXNJbmZvOiB1c2VJbml0aWFsVW5sZXNzRnVuY3Rpb24oby5yZXNvbHZlUm9vbXNJbmZvKSxcbiAgICBiYXNlVXJsOiB1c2VJbml0aWFsKFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIEhpZGRlbiBjb25maWcgb3B0aW9uc1xuICAgICAgby5iYXNlVXJsXG4gICAgKSxcbiAgICBlbmFibGVEZWJ1Z0xvZ2dpbmc6IHVzZUluaXRpYWwoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gSGlkZGVuIGNvbmZpZyBvcHRpb25zXG4gICAgICBvLmVuYWJsZURlYnVnTG9nZ2luZ1xuICAgIClcbiAgfTtcbiAgY29uc3QgY2xpZW50ID0gdXNlTWVtbzIoKCkgPT4gY3JlYXRlQ2xpZW50KG9wdGlvbnMpLCBbXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KExpdmVibG9ja3NQcm92aWRlcldpdGhDbGllbnQsIHsgY2xpZW50LCBjaGlsZHJlbiB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxpdmVibG9ja3NDb250ZXh0KGNsaWVudCkge1xuICByZXR1cm4gZ2V0T3JDcmVhdGVDb250ZXh0QnVuZGxlKGNsaWVudCk7XG59XG5mdW5jdGlvbiB1c2VVc2VyVGhyZWFkc19leHBlcmltZW50YWwob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCB7IHN0b3JlLCB1c2VyVGhyZWFkc1BvbGxlcjogcG9sbGVyIH0gPSBnZXRMaXZlYmxvY2tzRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IHF1ZXJ5S2V5ID0gbWFrZVVzZXJUaHJlYWRzUXVlcnlLZXkob3B0aW9ucy5xdWVyeSk7XG4gIHVzZUVmZmVjdDMoXG4gICAgKCkgPT4gdm9pZCBzdG9yZS5vdXRwdXRzLmxvYWRpbmdVc2VyVGhyZWFkcy5nZXRPckNyZWF0ZShxdWVyeUtleSkud2FpdFVudGlsTG9hZGVkKClcbiAgICAvLyBOT1RFOiBEZWxpYmVyYXRlbHkgKm5vdCogdXNpbmcgYSBkZXBlbmRlbmN5IGFycmF5IGhlcmUhXG4gICAgLy9cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gY2FsbCB3YWl0VW50aWwgb24gKmV2ZXJ5KiByZW5kZXIuXG4gICAgLy8gVGhpcyBpcyBoYXJtbGVzcyB0aG91Z2gsIG9uIG1vc3QgcmVuZGVycywgZXhjZXB0OlxuICAgIC8vIDEuIFRoZSB2ZXJ5IGZpcnN0IHJlbmRlciwgaW4gd2hpY2ggY2FzZSB3ZSdsbCB3YW50IHRvIHRyaWdnZXIgdGhlIGluaXRpYWwgcGFnZSBmZXRjaC5cbiAgICAvLyAyLiBBbGwgb3RoZXIgc3Vic2VxdWVudCByZW5kZXJzIG5vdyBcImp1c3RcIiByZXR1cm4gdGhlIHNhbWUgcHJvbWlzZSAoYSBxdWljayBvcGVyYXRpb24pLlxuICAgIC8vIDMuIElmIGV2ZXIgdGhlIHByb21pc2Ugd291bGQgZmFpbCwgdGhlbiBhZnRlciA1IHNlY29uZHMgaXQgd291bGQgcmVzZXQsIGFuZCBvbiB0aGUgdmVyeVxuICAgIC8vICAgICpuZXh0KiByZW5kZXIgYWZ0ZXIgdGhhdCwgYSAqbmV3KiBmZXRjaC9wcm9taXNlIHdpbGwgZ2V0IGNyZWF0ZWQuXG4gICk7XG4gIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgIHBvbGxlci5pbmMoKTtcbiAgICBwb2xsZXIucG9sbE5vd0lmU3RhbGUoKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcG9sbGVyLmRlYygpO1xuICAgIH07XG4gIH0sIFtwb2xsZXJdKTtcbiAgcmV0dXJuIHVzZVNpZ25hbChcbiAgICBzdG9yZS5vdXRwdXRzLmxvYWRpbmdVc2VyVGhyZWFkcy5nZXRPckNyZWF0ZShxdWVyeUtleSkuc2lnbmFsXG4gICk7XG59XG5mdW5jdGlvbiB1c2VVc2VyVGhyZWFkc1N1c3BlbnNlX2V4cGVyaW1lbnRhbChvcHRpb25zID0ge30pIHtcbiAgZW5zdXJlTm90U2VydmVyU2lkZSgpO1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0TGl2ZWJsb2Nrc0V4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICBjb25zdCBxdWVyeUtleSA9IG1ha2VVc2VyVGhyZWFkc1F1ZXJ5S2V5KG9wdGlvbnMucXVlcnkpO1xuICB1c2Uoc3RvcmUub3V0cHV0cy5sb2FkaW5nVXNlclRocmVhZHMuZ2V0T3JDcmVhdGUocXVlcnlLZXkpLndhaXRVbnRpbExvYWRlZCgpKTtcbiAgY29uc3QgcmVzdWx0ID0gdXNlVXNlclRocmVhZHNfZXhwZXJpbWVudGFsKG9wdGlvbnMpO1xuICBhc3NlcnQoIXJlc3VsdC5lcnJvciwgXCJEaWQgbm90IGV4cGVjdCBlcnJvclwiKTtcbiAgYXNzZXJ0KCFyZXN1bHQuaXNMb2FkaW5nLCBcIkRpZCBub3QgZXhwZWN0IGxvYWRpbmdcIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1c2VJbmJveE5vdGlmaWNhdGlvbnMoKSB7XG4gIHJldHVybiB1c2VJbmJveE5vdGlmaWNhdGlvbnNfd2l0aENsaWVudCh1c2VDbGllbnQoKSwgaWRlbnRpdHkyLCBzaGFsbG93NCk7XG59XG5mdW5jdGlvbiB1c2VJbmJveE5vdGlmaWNhdGlvbnNTdXNwZW5zZSgpIHtcbiAgcmV0dXJuIHVzZUluYm94Tm90aWZpY2F0aW9uc1N1c3BlbnNlX3dpdGhDbGllbnQodXNlQ2xpZW50KCkpO1xufVxuZnVuY3Rpb24gdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWQoaW5ib3hOb3RpZmljYXRpb25JZCkge1xuICByZXR1cm4gdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWRfd2l0aENsaWVudChcbiAgICB1c2VDbGllbnQoKSxcbiAgICBpbmJveE5vdGlmaWNhdGlvbklkXG4gICk7XG59XG5mdW5jdGlvbiB1c2VNYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKCkge1xuICByZXR1cm4gdXNlTWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZF93aXRoQ2xpZW50KHVzZUNsaWVudCgpKTtcbn1cbmZ1bmN0aW9uIHVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCgpIHtcbiAgcmV0dXJuIHVzZU1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZF93aXRoQ2xpZW50KHVzZUNsaWVudCgpKTtcbn1cbmZ1bmN0aW9uIHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9ucygpIHtcbiAgcmV0dXJuIHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9uc193aXRoQ2xpZW50KHVzZUNsaWVudCgpKTtcbn1cbmZ1bmN0aW9uIHVzZURlbGV0ZUluYm94Tm90aWZpY2F0aW9uKCkge1xuICByZXR1cm4gdXNlRGVsZXRlSW5ib3hOb3RpZmljYXRpb25fd2l0aENsaWVudCh1c2VDbGllbnQoKSk7XG59XG5mdW5jdGlvbiB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCgpIHtcbiAgcmV0dXJuIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50X3dpdGhDbGllbnQodXNlQ2xpZW50KCkpO1xufVxuZnVuY3Rpb24gdXNlVW5yZWFkSW5ib3hOb3RpZmljYXRpb25zQ291bnRTdXNwZW5zZSgpIHtcbiAgcmV0dXJuIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50U3VzcGVuc2Vfd2l0aENsaWVudCh1c2VDbGllbnQoKSk7XG59XG5mdW5jdGlvbiB1c2VOb3RpZmljYXRpb25TZXR0aW5ncygpIHtcbiAgcmV0dXJuIHVzZU5vdGlmaWNhdGlvblNldHRpbmdzX3dpdGhDbGllbnQodXNlQ2xpZW50KCkpO1xufVxuZnVuY3Rpb24gdXNlTm90aWZpY2F0aW9uU2V0dGluZ3NTdXNwZW5zZSgpIHtcbiAgcmV0dXJuIHVzZU5vdGlmaWNhdGlvblNldHRpbmdzU3VzcGVuc2Vfd2l0aENsaWVudCh1c2VDbGllbnQoKSk7XG59XG5mdW5jdGlvbiB1c2VVcGRhdGVOb3RpZmljYXRpb25TZXR0aW5ncygpIHtcbiAgcmV0dXJuIHVzZVVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzX3dpdGhDbGllbnQodXNlQ2xpZW50KCkpO1xufVxuZnVuY3Rpb24gdXNlVXNlcih1c2VySWQpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIHJldHVybiB1c2VVc2VyX3dpdGhDbGllbnQoY2xpZW50LCB1c2VySWQpO1xufVxuZnVuY3Rpb24gdXNlVXNlclN1c3BlbnNlKHVzZXJJZCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgcmV0dXJuIHVzZVVzZXJTdXNwZW5zZV93aXRoQ2xpZW50KGNsaWVudCwgdXNlcklkKTtcbn1cbmZ1bmN0aW9uIHVzZVJvb21JbmZvKHJvb21JZCkge1xuICByZXR1cm4gdXNlUm9vbUluZm9fd2l0aENsaWVudCh1c2VDbGllbnQoKSwgcm9vbUlkKTtcbn1cbmZ1bmN0aW9uIHVzZVJvb21JbmZvU3VzcGVuc2Uocm9vbUlkKSB7XG4gIHJldHVybiB1c2VSb29tSW5mb1N1c3BlbnNlX3dpdGhDbGllbnQodXNlQ2xpZW50KCksIHJvb21JZCk7XG59XG52YXIgX3VzZUluYm94Tm90aWZpY2F0aW9uVGhyZWFkID0gdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWQ7XG52YXIgX3VzZVVzZXIgPSB1c2VVc2VyO1xudmFyIF91c2VVc2VyU3VzcGVuc2UgPSB1c2VVc2VyU3VzcGVuc2U7XG52YXIgX3VzZVVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbCA9IHVzZVVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbDtcbnZhciBfdXNlVXNlclRocmVhZHNTdXNwZW5zZV9leHBlcmltZW50YWwgPSB1c2VVc2VyVGhyZWFkc1N1c3BlbnNlX2V4cGVyaW1lbnRhbDtcbmZ1bmN0aW9uIHVzZVN5bmNTdGF0dXNfd2l0aENsaWVudChjbGllbnQsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc21vb3RoID0gdXNlSW5pdGlhbChvcHRpb25zPy5zbW9vdGggPz8gZmFsc2UpO1xuICBpZiAoc21vb3RoKSB7XG4gICAgcmV0dXJuIHVzZVN5bmNTdGF0dXNTbW9vdGhfd2l0aENsaWVudChjbGllbnQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1c2VTeW5jU3RhdHVzSW1tZWRpYXRlX3dpdGhDbGllbnQoY2xpZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gdXNlU3luY1N0YXR1c0ltbWVkaWF0ZV93aXRoQ2xpZW50KGNsaWVudCkge1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUyKFxuICAgIGNsaWVudC5ldmVudHMuc3luY1N0YXR1cy5zdWJzY3JpYmUsXG4gICAgY2xpZW50LmdldFN5bmNTdGF0dXMsXG4gICAgY2xpZW50LmdldFN5bmNTdGF0dXNcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVN5bmNTdGF0dXNTbW9vdGhfd2l0aENsaWVudChjbGllbnQpIHtcbiAgY29uc3QgZ2V0dGVyID0gY2xpZW50LmdldFN5bmNTdGF0dXM7XG4gIGNvbnN0IFtzdGF0dXMsIHNldFN0YXR1c10gPSB1c2VTdGF0ZShnZXR0ZXIpO1xuICBjb25zdCBvbGRTdGF0dXMgPSB1c2VMYXRlc3QoZ2V0dGVyKCkpO1xuICB1c2VFZmZlY3QzKCgpID0+IHtcbiAgICBsZXQgdGltZW91dElkO1xuICAgIGNvbnN0IHVuc3ViID0gY2xpZW50LmV2ZW50cy5zeW5jU3RhdHVzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICBjb25zdCBuZXdTdGF0dXMgPSBnZXR0ZXIoKTtcbiAgICAgIGlmIChvbGRTdGF0dXMuY3VycmVudCA9PT0gXCJzeW5jaHJvbml6aW5nXCIgJiYgbmV3U3RhdHVzID09PSBcInN5bmNocm9uaXplZFwiKSB7XG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gc2V0U3RhdHVzKG5ld1N0YXR1cyksIGNvbmZpZy5TTU9PVEhfREVMQVkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIHNldFN0YXR1cyhuZXdTdGF0dXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIHVuc3ViKCk7XG4gICAgfTtcbiAgfSwgW2NsaWVudCwgZ2V0dGVyLCBvbGRTdGF0dXNdKTtcbiAgcmV0dXJuIHN0YXR1cztcbn1cbmZ1bmN0aW9uIHVzZVN5bmNTdGF0dXMob3B0aW9ucykge1xuICByZXR1cm4gdXNlU3luY1N0YXR1c193aXRoQ2xpZW50KHVzZUNsaWVudCgpLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHVzZUVycm9yTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSB1c2VMYXRlc3QoY2FsbGJhY2spO1xuICB1c2VFZmZlY3QzKFxuICAgICgpID0+IGNsaWVudC5ldmVudHMuZXJyb3Iuc3Vic2NyaWJlKChlKSA9PiBzYXZlZENhbGxiYWNrLmN1cnJlbnQoZSkpLFxuICAgIFtjbGllbnQsIHNhdmVkQ2FsbGJhY2tdXG4gICk7XG59XG5cbi8vIHNyYy9yb29tLnRzeFxuaW1wb3J0IHsgc2hhbGxvdyBhcyBzaGFsbG93NSB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jbGllbnRcIjtcbmltcG9ydCB7XG4gIGFzc2VydCBhcyBhc3NlcnQyLFxuICBjb25zb2xlIGFzIGNvbnNvbGUzLFxuICBjcmVhdGVDb21tZW50SWQsXG4gIGNyZWF0ZVRocmVhZElkLFxuICBEZWZhdWx0TWFwIGFzIERlZmF1bHRNYXAyLFxuICBlcnJvcklmLFxuICBIdHRwRXJyb3IgYXMgSHR0cEVycm9yMixcbiAga0ludGVybmFsIGFzIGtJbnRlcm5hbDMsXG4gIG1ha2VQb2xsZXIgYXMgbWFrZVBvbGxlcjIsXG4gIFNlcnZlck1zZ0NvZGVcbn0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmltcG9ydCB7XG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMyxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDUsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzMsXG4gIHVzZVJlZiBhcyB1c2VSZWYzLFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTIsXG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlIGFzIHVzZVN5bmNFeHRlcm5hbFN0b3JlMyxcbiAgdmVyc2lvbiBhcyByZWFjdFZlcnNpb25cbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy91c2Utc2Nyb2xsLXRvLWNvbW1lbnQtb24tbG9hZC1lZmZlY3QudHNcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q0IH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBoYW5kbGVTY3JvbGxUb0NvbW1lbnRPbkxvYWQoc2hvdWxkU2Nyb2xsT25Mb2FkLCBzdGF0ZSkge1xuICBpZiAoc2hvdWxkU2Nyb2xsT25Mb2FkID09PSBmYWxzZSkgcmV0dXJuO1xuICBpZiAoIXN0YXRlLnRocmVhZHMpIHJldHVybjtcbiAgY29uc3QgaXNXaW5kb3dEZWZpbmVkID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgaWYgKCFpc1dpbmRvd0RlZmluZWQpIHJldHVybjtcbiAgY29uc3QgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuICBjb25zdCBjb21tZW50SWQgPSBoYXNoLnNsaWNlKDEpO1xuICBpZiAoIWNvbW1lbnRJZC5zdGFydHNXaXRoKFwiY21fXCIpKSByZXR1cm47XG4gIGNvbnN0IGNvbW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb21tZW50SWQpO1xuICBpZiAoY29tbWVudCA9PT0gbnVsbCkgcmV0dXJuO1xuICBjb25zdCBjb21tZW50cyA9IHN0YXRlLnRocmVhZHMuZmxhdE1hcCgodGhyZWFkKSA9PiB0aHJlYWQuY29tbWVudHMpO1xuICBjb25zdCBpc0NvbW1lbnRJblRocmVhZHMgPSBjb21tZW50cy5zb21lKFxuICAgIChjb21tZW50MikgPT4gY29tbWVudDIuaWQgPT09IGNvbW1lbnRJZFxuICApO1xuICBpZiAoIWlzQ29tbWVudEluVGhyZWFkcykgcmV0dXJuO1xuICBjb21tZW50LnNjcm9sbEludG9WaWV3KCk7XG59XG5mdW5jdGlvbiB1c2VTY3JvbGxUb0NvbW1lbnRPbkxvYWRFZmZlY3Qoc2hvdWxkU2Nyb2xsT25Mb2FkLCBzdGF0ZSkge1xuICB1c2VFZmZlY3Q0KFxuICAgICgpID0+IHtcbiAgICAgIGhhbmRsZVNjcm9sbFRvQ29tbWVudE9uTG9hZChzaG91bGRTY3JvbGxPbkxvYWQsIHN0YXRlKTtcbiAgICB9LFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHMgLS0gV2Ugb25seSB3YW50IHRvIHJ1biB0aGlzIGVmZmVjdCBvbmNlXG4gICAgW3N0YXRlLmlzTG9hZGluZ11cbiAgKTtcbn1cblxuLy8gc3JjL3Jvb20udHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIG5vb3AzID0gKCkgPT4ge1xufTtcbnZhciBpZGVudGl0eTMgPSAoeCkgPT4geDtcbnZhciBTVEFCTEVfRU1QVFlfTElTVCA9IE9iamVjdC5mcmVlemUoW10pO1xuZnVuY3Rpb24gYWx3YXlzRW1wdHlMaXN0KCkge1xuICByZXR1cm4gU1RBQkxFX0VNUFRZX0xJU1Q7XG59XG5mdW5jdGlvbiBhbHdheXNOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNlbGVjdG9yRm9yX3VzZU90aGVyc0Nvbm5lY3Rpb25JZHMob3RoZXJzKSB7XG4gIHJldHVybiBvdGhlcnMubWFwKCh1c2VyKSA9PiB1c2VyLmNvbm5lY3Rpb25JZCk7XG59XG5mdW5jdGlvbiBtYWtlTXV0YXRpb25Db250ZXh0KHJvb20pIHtcbiAgY29uc3QgY2Fubm90VXNlVW50aWwgPSBcIlRoaXMgbXV0YXRpb24gY2Fubm90IGJlIHVzZWQgdW50aWxcIjtcbiAgY29uc3QgbmVlZHNQcmVzZW5jZSA9IGAke2Nhbm5vdFVzZVVudGlsfSBjb25uZWN0ZWQgdG8gdGhlIExpdmVibG9ja3Mgcm9vbWA7XG4gIGNvbnN0IG5lZWRzU3RvcmFnZSA9IGAke2Nhbm5vdFVzZVVudGlsfSBzdG9yYWdlIGhhcyBiZWVuIGxvYWRlZGA7XG4gIHJldHVybiB7XG4gICAgZ2V0IHN0b3JhZ2UoKSB7XG4gICAgICBjb25zdCBtdXRhYmxlUm9vdCA9IHJvb20uZ2V0U3RvcmFnZVNuYXBzaG90KCk7XG4gICAgICBpZiAobXV0YWJsZVJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG5lZWRzU3RvcmFnZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbXV0YWJsZVJvb3Q7XG4gICAgfSxcbiAgICBnZXQgc2VsZigpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSByb29tLmdldFNlbGYoKTtcbiAgICAgIGlmIChzZWxmID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihuZWVkc1ByZXNlbmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG4gICAgZ2V0IG90aGVycygpIHtcbiAgICAgIGNvbnN0IG90aGVycyA9IHJvb20uZ2V0T3RoZXJzKCk7XG4gICAgICBpZiAocm9vbS5nZXRTZWxmKCkgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG5lZWRzUHJlc2VuY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG90aGVycztcbiAgICB9LFxuICAgIHNldE15UHJlc2VuY2U6IHJvb20udXBkYXRlUHJlc2VuY2VcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRVc2VySWQoY2xpZW50KSB7XG4gIGNvbnN0IHVzZXJJZCA9IGNsaWVudFtrSW50ZXJuYWwzXS5jdXJyZW50VXNlcklkLmdldCgpO1xuICBpZiAodXNlcklkID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gXCJhbm9ueW1vdXNcIjtcbiAgfVxuICByZXR1cm4gdXNlcklkO1xufVxudmFyIF9leHRyYXMyID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgX2J1bmRsZXMyID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBnZXRPckNyZWF0ZVJvb21Db250ZXh0QnVuZGxlKGNsaWVudCkge1xuICBsZXQgYnVuZGxlID0gX2J1bmRsZXMyLmdldChjbGllbnQpO1xuICBpZiAoIWJ1bmRsZSkge1xuICAgIGJ1bmRsZSA9IG1ha2VSb29tQ29udGV4dEJ1bmRsZShjbGllbnQpO1xuICAgIF9idW5kbGVzMi5zZXQoY2xpZW50LCBidW5kbGUpO1xuICB9XG4gIHJldHVybiBidW5kbGU7XG59XG5mdW5jdGlvbiBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCkge1xuICBsZXQgZXh0cmFzID0gX2V4dHJhczIuZ2V0KGNsaWVudCk7XG4gIGlmICghZXh0cmFzKSB7XG4gICAgZXh0cmFzID0gbWFrZVJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICBfZXh0cmFzMi5zZXQoY2xpZW50LCBleHRyYXMpO1xuICB9XG4gIHJldHVybiBleHRyYXM7XG59XG5mdW5jdGlvbiBtYWtlUm9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpIHtcbiAgY29uc3Qgc3RvcmUgPSBnZXRVbWJyZWxsYVN0b3JlRm9yQ2xpZW50KGNsaWVudCk7XG4gIGZ1bmN0aW9uIG9uTXV0YXRpb25GYWlsdXJlKG9wdGltaXN0aWNJZCwgY29udGV4dCwgaW5uZXJFcnJvcikge1xuICAgIHN0b3JlLm9wdGltaXN0aWNVcGRhdGVzLnJlbW92ZShvcHRpbWlzdGljSWQpO1xuICAgIGlmIChpbm5lckVycm9yIGluc3RhbmNlb2YgSHR0cEVycm9yMikge1xuICAgICAgaWYgKGlubmVyRXJyb3Iuc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgY29uc3QgZGV0YWlsZWRNZXNzYWdlID0gW1xuICAgICAgICAgIGlubmVyRXJyb3IubWVzc2FnZSxcbiAgICAgICAgICBpbm5lckVycm9yLmRldGFpbHM/LnN1Z2dlc3Rpb24sXG4gICAgICAgICAgaW5uZXJFcnJvci5kZXRhaWxzPy5kb2NzXG4gICAgICAgIF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIGNvbnNvbGUzLmVycm9yKGRldGFpbGVkTWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBjbGllbnRba0ludGVybmFsM10uZW1pdEVycm9yKGNvbnRleHQsIGlubmVyRXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBpbm5lckVycm9yO1xuICAgIH1cbiAgfVxuICBjb25zdCB0aHJlYWRzUG9sbGVyc0J5Um9vbUlkID0gbmV3IERlZmF1bHRNYXAyKFxuICAgIChyb29tSWQpID0+IG1ha2VQb2xsZXIyKFxuICAgICAgYXN5bmMgKHNpZ25hbCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBhd2FpdCBzdG9yZS5mZXRjaFJvb21UaHJlYWRzRGVsdGFVcGRhdGUocm9vbUlkLCBzaWduYWwpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlMy53YXJuKGBQb2xsaW5nIG5ldyB0aHJlYWRzIGZvciAnJHtyb29tSWR9JyBmYWlsZWQ6ICR7U3RyaW5nKGVycil9YCk7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY29uZmlnLlJPT01fVEhSRUFEU19QT0xMX0lOVEVSVkFMLFxuICAgICAgeyBtYXhTdGFsZVRpbWVNczogY29uZmlnLlJPT01fVEhSRUFEU19NQVhfU1RBTEVfVElNRSB9XG4gICAgKVxuICApO1xuICBjb25zdCB2ZXJzaW9uc1BvbGxlcnNCeVJvb21JZCA9IG5ldyBEZWZhdWx0TWFwMihcbiAgICAocm9vbUlkKSA9PiBtYWtlUG9sbGVyMihcbiAgICAgIGFzeW5jIChzaWduYWwpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgc3RvcmUuZmV0Y2hSb29tVmVyc2lvbnNEZWx0YVVwZGF0ZShyb29tSWQsIHNpZ25hbCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUzLndhcm4oYFBvbGxpbmcgbmV3IGhpc3RvcnkgdmVyc2lvbnMgZm9yICcke3Jvb21JZH0nIGZhaWxlZDogJHtTdHJpbmcoZXJyKX1gKTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjb25maWcuSElTVE9SWV9WRVJTSU9OU19QT0xMX0lOVEVSVkFMLFxuICAgICAgeyBtYXhTdGFsZVRpbWVNczogY29uZmlnLkhJU1RPUllfVkVSU0lPTlNfTUFYX1NUQUxFX1RJTUUgfVxuICAgIClcbiAgKTtcbiAgY29uc3Qgcm9vbU5vdGlmaWNhdGlvblNldHRpbmdzUG9sbGVyc0J5Um9vbUlkID0gbmV3IERlZmF1bHRNYXAyKFxuICAgIChyb29tSWQpID0+IG1ha2VQb2xsZXIyKFxuICAgICAgYXN5bmMgKHNpZ25hbCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBhd2FpdCBzdG9yZS5yZWZyZXNoUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKHJvb21JZCwgc2lnbmFsKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZTMud2FybihgUG9sbGluZyBub3RpZmljYXRpb24gc2V0dGluZ3MgZm9yICcke3Jvb21JZH0nIGZhaWxlZDogJHtTdHJpbmcoZXJyKX1gKTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjb25maWcuTk9USUZJQ0FUSU9OX1NFVFRJTkdTX1BPTExfSU5URVJWQUwsXG4gICAgICB7IG1heFN0YWxlVGltZU1zOiBjb25maWcuTk9USUZJQ0FUSU9OX1NFVFRJTkdTX01BWF9TVEFMRV9USU1FIH1cbiAgICApXG4gICk7XG4gIHJldHVybiB7XG4gICAgc3RvcmUsXG4gICAgb25NdXRhdGlvbkZhaWx1cmUsXG4gICAgZ2V0T3JDcmVhdGVUaHJlYWRzUG9sbGVyRm9yUm9vbUlkOiB0aHJlYWRzUG9sbGVyc0J5Um9vbUlkLmdldE9yQ3JlYXRlLmJpbmQoXG4gICAgICB0aHJlYWRzUG9sbGVyc0J5Um9vbUlkXG4gICAgKSxcbiAgICBnZXRPckNyZWF0ZVZlcnNpb25zUG9sbGVyRm9yUm9vbUlkOiB2ZXJzaW9uc1BvbGxlcnNCeVJvb21JZC5nZXRPckNyZWF0ZS5iaW5kKHZlcnNpb25zUG9sbGVyc0J5Um9vbUlkKSxcbiAgICBnZXRPckNyZWF0ZU5vdGlmaWNhdGlvbnNTZXR0aW5nc1BvbGxlckZvclJvb21JZDogcm9vbU5vdGlmaWNhdGlvblNldHRpbmdzUG9sbGVyc0J5Um9vbUlkLmdldE9yQ3JlYXRlLmJpbmQoXG4gICAgICByb29tTm90aWZpY2F0aW9uU2V0dGluZ3NQb2xsZXJzQnlSb29tSWRcbiAgICApXG4gIH07XG59XG5mdW5jdGlvbiBtYWtlUm9vbUNvbnRleHRCdW5kbGUoY2xpZW50KSB7XG4gIGZ1bmN0aW9uIFJvb21Qcm92aWRlcl93aXRoSW1wbGljaXRMaXZlYmxvY2tzUHJvdmlkZXIocHJvcHMpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDIoTGl2ZWJsb2Nrc1Byb3ZpZGVyV2l0aENsaWVudCwgeyBjbGllbnQsIGFsbG93TmVzdGluZzogdHJ1ZSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyKFJvb21Qcm92aWRlciwgeyAuLi5wcm9wcyB9KSB9KTtcbiAgfVxuICBjb25zdCBzaGFyZWQgPSBjcmVhdGVTaGFyZWRDb250ZXh0KGNsaWVudCk7XG4gIGNvbnN0IGJ1bmRsZSA9IHtcbiAgICBSb29tQ29udGV4dCxcbiAgICBSb29tUHJvdmlkZXI6IFJvb21Qcm92aWRlcl93aXRoSW1wbGljaXRMaXZlYmxvY2tzUHJvdmlkZXIsXG4gICAgdXNlUm9vbSxcbiAgICB1c2VTdGF0dXMsXG4gICAgdXNlU3RvcmFnZVN0YXR1cyxcbiAgICB1c2VCYXRjaCxcbiAgICB1c2VCcm9hZGNhc3RFdmVudCxcbiAgICB1c2VPdGhlcnNMaXN0ZW5lcixcbiAgICB1c2VMb3N0Q29ubmVjdGlvbkxpc3RlbmVyLFxuICAgIHVzZUV2ZW50TGlzdGVuZXIsXG4gICAgdXNlSGlzdG9yeSxcbiAgICB1c2VVbmRvLFxuICAgIHVzZVJlZG8sXG4gICAgdXNlQ2FuUmVkbyxcbiAgICB1c2VDYW5VbmRvLFxuICAgIHVzZVN0b3JhZ2VSb290LFxuICAgIHVzZVN0b3JhZ2UsXG4gICAgdXNlU2VsZixcbiAgICB1c2VNeVByZXNlbmNlLFxuICAgIHVzZVVwZGF0ZU15UHJlc2VuY2UsXG4gICAgdXNlT3RoZXJzLFxuICAgIHVzZU90aGVyc01hcHBlZCxcbiAgICB1c2VPdGhlcnNDb25uZWN0aW9uSWRzLFxuICAgIHVzZU90aGVyLFxuICAgIHVzZU11dGF0aW9uLFxuICAgIHVzZVRocmVhZHMsXG4gICAgdXNlQ3JlYXRlVGhyZWFkLFxuICAgIHVzZURlbGV0ZVRocmVhZCxcbiAgICB1c2VFZGl0VGhyZWFkTWV0YWRhdGEsXG4gICAgdXNlTWFya1RocmVhZEFzUmVzb2x2ZWQsXG4gICAgdXNlTWFya1RocmVhZEFzVW5yZXNvbHZlZCxcbiAgICB1c2VDcmVhdGVDb21tZW50LFxuICAgIHVzZUVkaXRDb21tZW50LFxuICAgIHVzZURlbGV0ZUNvbW1lbnQsXG4gICAgdXNlQWRkUmVhY3Rpb24sXG4gICAgdXNlUmVtb3ZlUmVhY3Rpb24sXG4gICAgdXNlTWFya1RocmVhZEFzUmVhZCxcbiAgICB1c2VUaHJlYWRTdWJzY3JpcHRpb24sXG4gICAgdXNlQXR0YWNobWVudFVybCxcbiAgICB1c2VIaXN0b3J5VmVyc2lvbnMsXG4gICAgdXNlSGlzdG9yeVZlcnNpb25EYXRhLFxuICAgIHVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyxcbiAgICB1c2VVcGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgLi4uc2hhcmVkLmNsYXNzaWMsXG4gICAgc3VzcGVuc2U6IHtcbiAgICAgIFJvb21Db250ZXh0LFxuICAgICAgUm9vbVByb3ZpZGVyOiBSb29tUHJvdmlkZXJfd2l0aEltcGxpY2l0TGl2ZWJsb2Nrc1Byb3ZpZGVyLFxuICAgICAgdXNlUm9vbSxcbiAgICAgIHVzZVN0YXR1cyxcbiAgICAgIHVzZVN0b3JhZ2VTdGF0dXM6IHVzZVN0b3JhZ2VTdGF0dXNTdXNwZW5zZSxcbiAgICAgIHVzZUJhdGNoLFxuICAgICAgdXNlQnJvYWRjYXN0RXZlbnQsXG4gICAgICB1c2VPdGhlcnNMaXN0ZW5lcixcbiAgICAgIHVzZUxvc3RDb25uZWN0aW9uTGlzdGVuZXIsXG4gICAgICB1c2VFdmVudExpc3RlbmVyLFxuICAgICAgdXNlSGlzdG9yeSxcbiAgICAgIHVzZVVuZG8sXG4gICAgICB1c2VSZWRvLFxuICAgICAgdXNlQ2FuUmVkbyxcbiAgICAgIHVzZUNhblVuZG8sXG4gICAgICB1c2VTdG9yYWdlUm9vdCxcbiAgICAgIHVzZVN0b3JhZ2U6IHVzZVN0b3JhZ2VTdXNwZW5zZSxcbiAgICAgIHVzZVNlbGY6IHVzZVNlbGZTdXNwZW5zZSxcbiAgICAgIHVzZU15UHJlc2VuY2UsXG4gICAgICB1c2VVcGRhdGVNeVByZXNlbmNlLFxuICAgICAgdXNlT3RoZXJzOiB1c2VPdGhlcnNTdXNwZW5zZSxcbiAgICAgIHVzZU90aGVyc01hcHBlZDogdXNlT3RoZXJzTWFwcGVkU3VzcGVuc2UsXG4gICAgICB1c2VPdGhlcnNDb25uZWN0aW9uSWRzOiB1c2VPdGhlcnNDb25uZWN0aW9uSWRzU3VzcGVuc2UsXG4gICAgICB1c2VPdGhlcjogdXNlT3RoZXJTdXNwZW5zZSxcbiAgICAgIHVzZU11dGF0aW9uLFxuICAgICAgdXNlVGhyZWFkczogdXNlVGhyZWFkc1N1c3BlbnNlLFxuICAgICAgdXNlQ3JlYXRlVGhyZWFkLFxuICAgICAgdXNlRGVsZXRlVGhyZWFkLFxuICAgICAgdXNlRWRpdFRocmVhZE1ldGFkYXRhLFxuICAgICAgdXNlTWFya1RocmVhZEFzUmVzb2x2ZWQsXG4gICAgICB1c2VNYXJrVGhyZWFkQXNVbnJlc29sdmVkLFxuICAgICAgdXNlQ3JlYXRlQ29tbWVudCxcbiAgICAgIHVzZUVkaXRDb21tZW50LFxuICAgICAgdXNlRGVsZXRlQ29tbWVudCxcbiAgICAgIHVzZUFkZFJlYWN0aW9uLFxuICAgICAgdXNlUmVtb3ZlUmVhY3Rpb24sXG4gICAgICB1c2VNYXJrVGhyZWFkQXNSZWFkLFxuICAgICAgdXNlVGhyZWFkU3Vic2NyaXB0aW9uLFxuICAgICAgdXNlQXR0YWNobWVudFVybDogdXNlQXR0YWNobWVudFVybFN1c3BlbnNlLFxuICAgICAgLy8gVE9ETzogdXNlSGlzdG9yeVZlcnNpb25EYXRhOiB1c2VIaXN0b3J5VmVyc2lvbkRhdGFTdXNwZW5zZSxcbiAgICAgIHVzZUhpc3RvcnlWZXJzaW9uczogdXNlSGlzdG9yeVZlcnNpb25zU3VzcGVuc2UsXG4gICAgICB1c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3M6IHVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nc1N1c3BlbnNlLFxuICAgICAgdXNlVXBkYXRlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgICAgLi4uc2hhcmVkLnN1c3BlbnNlXG4gICAgfVxuICB9O1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGJ1bmRsZSwga0ludGVybmFsMywge1xuICAgIGVudW1lcmFibGU6IGZhbHNlXG4gIH0pO1xufVxuZnVuY3Rpb24gUm9vbVByb3ZpZGVyKHByb3BzKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCBbY2FjaGVdID0gdXNlU3RhdGUyKFxuICAgICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgKTtcbiAgY29uc3Qgc3RhYmxlRW50ZXJSb29tID0gdXNlQ2FsbGJhY2szKFxuICAgIChyb29tSWQsIG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChyb29tSWQpO1xuICAgICAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZDtcbiAgICAgIGNvbnN0IHJ2ID0gY2xpZW50LmVudGVyUm9vbShyb29tSWQsIG9wdGlvbnMpO1xuICAgICAgY29uc3Qgb3JpZ0xlYXZlID0gcnYubGVhdmU7XG4gICAgICBydi5sZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgb3JpZ0xlYXZlKCk7XG4gICAgICAgIGNhY2hlLmRlbGV0ZShyb29tSWQpO1xuICAgICAgfTtcbiAgICAgIGNhY2hlLnNldChyb29tSWQsIHJ2KTtcbiAgICAgIHJldHVybiBydjtcbiAgICB9LFxuICAgIFtjbGllbnQsIGNhY2hlXVxuICApO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDIoXG4gICAgUm9vbVByb3ZpZGVySW5uZXIsXG4gICAge1xuICAgICAgLi4ucHJvcHMsXG4gICAgICBzdGFibGVFbnRlclJvb21cbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBSb29tUHJvdmlkZXJJbm5lcihwcm9wcykge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3QgeyBpZDogcm9vbUlkLCBzdGFibGVFbnRlclJvb20gfSA9IHByb3BzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFyb29tSWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJSb29tUHJvdmlkZXIgaWQgcHJvcGVydHkgaXMgcmVxdWlyZWQuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9lcnJvcnMvbGl2ZWJsb2Nrcy1yZWFjdC9Sb29tUHJvdmlkZXItaWQtcHJvcGVydHktaXMtcmVxdWlyZWRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByb29tSWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvb21Qcm92aWRlciBpZCBwcm9wZXJ0eSBzaG91bGQgYmUgYSBzdHJpbmcuXCIpO1xuICAgIH1cbiAgICBjb25zdCBtYWpvclJlYWN0VmVyc2lvbiA9IHBhcnNlSW50KHJlYWN0VmVyc2lvbikgfHwgMTtcbiAgICBjb25zdCByZXF1aXJlZFZlcnNpb24gPSAxODtcbiAgICBlcnJvcklmKFxuICAgICAgbWFqb3JSZWFjdFZlcnNpb24gPCByZXF1aXJlZFZlcnNpb24sXG4gICAgICBgUmVhY3QgJHtyZXF1aXJlZFZlcnNpb259IG9yIGhpZ2hlciBpcyByZXF1aXJlZCAoeW91XFx1MjAxOXJlIG9uICR7cmVhY3RWZXJzaW9ufSlgXG4gICAgKTtcbiAgfVxuICBjb25zdCBmcm96ZW5Qcm9wcyA9IHVzZUluaXRpYWwoe1xuICAgIGluaXRpYWxQcmVzZW5jZTogcHJvcHMuaW5pdGlhbFByZXNlbmNlLFxuICAgIGluaXRpYWxTdG9yYWdlOiBwcm9wcy5pbml0aWFsU3RvcmFnZSxcbiAgICBhdXRvQ29ubmVjdDogcHJvcHMuYXV0b0Nvbm5lY3QgPz8gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIlxuICB9KTtcbiAgY29uc3QgW3sgcm9vbSB9LCBzZXRSb29tTGVhdmVQYWlyXSA9IHVzZVN0YXRlMihcbiAgICAoKSA9PiBzdGFibGVFbnRlclJvb20ocm9vbUlkLCB7XG4gICAgICAuLi5mcm96ZW5Qcm9wcyxcbiAgICAgIGF1dG9Db25uZWN0OiBmYWxzZVxuICAgICAgLy8gRGVsaWJlcmF0ZWx5IHVzaW5nIGZhbHNlIGhlcmUgb24gdGhlIGZpcnN0IHJlbmRlciwgc2VlIGJlbG93XG4gICAgfSlcbiAgKTtcbiAgdXNlRWZmZWN0NSgoKSA9PiB7XG4gICAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUNvbW1lbnRFdmVudChtZXNzYWdlKSB7XG4gICAgICBpZiAobWVzc2FnZS50eXBlID09PSBTZXJ2ZXJNc2dDb2RlLlRIUkVBRF9ERUxFVEVEKSB7XG4gICAgICAgIHN0b3JlLmRlbGV0ZVRocmVhZChtZXNzYWdlLnRocmVhZElkLCBudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5mbyA9IGF3YWl0IHJvb20uZ2V0VGhyZWFkKG1lc3NhZ2UudGhyZWFkSWQpO1xuICAgICAgaWYgKCFpbmZvLnRocmVhZCkge1xuICAgICAgICBzdG9yZS5kZWxldGVUaHJlYWQobWVzc2FnZS50aHJlYWRJZCwgbnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgdGhyZWFkLCBpbmJveE5vdGlmaWNhdGlvbjogbWF5YmVOb3RpZmljYXRpb24gfSA9IGluZm87XG4gICAgICBjb25zdCBleGlzdGluZ1RocmVhZCA9IHN0b3JlLm91dHB1dHMudGhyZWFkcy5nZXQoKS5nZXRFdmVuSWZEZWxldGVkKG1lc3NhZ2UudGhyZWFkSWQpO1xuICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBTZXJ2ZXJNc2dDb2RlLkNPTU1FTlRfRURJVEVEOlxuICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuVEhSRUFEX01FVEFEQVRBX1VQREFURUQ6XG4gICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5USFJFQURfVVBEQVRFRDpcbiAgICAgICAgY2FzZSBTZXJ2ZXJNc2dDb2RlLkNPTU1FTlRfUkVBQ1RJT05fQURERUQ6XG4gICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5DT01NRU5UX1JFQUNUSU9OX1JFTU9WRUQ6XG4gICAgICAgIGNhc2UgU2VydmVyTXNnQ29kZS5DT01NRU5UX0RFTEVURUQ6XG4gICAgICAgICAgaWYgKCFleGlzdGluZ1RocmVhZCkgYnJlYWs7XG4gICAgICAgICAgc3RvcmUudXBkYXRlVGhyZWFkaWZpY2F0aW9ucyhcbiAgICAgICAgICAgIFt0aHJlYWRdLFxuICAgICAgICAgICAgbWF5YmVOb3RpZmljYXRpb24gPyBbbWF5YmVOb3RpZmljYXRpb25dIDogW11cbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNlcnZlck1zZ0NvZGUuQ09NTUVOVF9DUkVBVEVEOlxuICAgICAgICAgIHN0b3JlLnVwZGF0ZVRocmVhZGlmaWNhdGlvbnMoXG4gICAgICAgICAgICBbdGhyZWFkXSxcbiAgICAgICAgICAgIG1heWJlTm90aWZpY2F0aW9uID8gW21heWJlTm90aWZpY2F0aW9uXSA6IFtdXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvb20uZXZlbnRzLmNvbW1lbnRzLnN1YnNjcmliZShcbiAgICAgIChtZXNzYWdlKSA9PiB2b2lkIGhhbmRsZUNvbW1lbnRFdmVudChtZXNzYWdlKVxuICAgICk7XG4gIH0sIFtjbGllbnQsIHJvb21dKTtcbiAgdXNlRWZmZWN0NSgoKSA9PiB7XG4gICAgY29uc3QgcGFpciA9IHN0YWJsZUVudGVyUm9vbShyb29tSWQsIGZyb3plblByb3BzKTtcbiAgICBzZXRSb29tTGVhdmVQYWlyKHBhaXIpO1xuICAgIGNvbnN0IHsgcm9vbTogcm9vbTIsIGxlYXZlIH0gPSBwYWlyO1xuICAgIGlmIChmcm96ZW5Qcm9wcy5hdXRvQ29ubmVjdCkge1xuICAgICAgcm9vbTIuY29ubmVjdCgpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbGVhdmUoKTtcbiAgICB9O1xuICB9LCBbcm9vbUlkLCBmcm96ZW5Qcm9wcywgc3RhYmxlRW50ZXJSb29tXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MihSb29tQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcm9vbSwgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuIH0pO1xufVxuZnVuY3Rpb24gdXNlUm9vbShvcHRpb25zKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tT3JOdWxsKCk7XG4gIGlmIChyb29tID09PSBudWxsICYmICFvcHRpb25zPy5hbGxvd091dHNpZGVSb29tKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vbVByb3ZpZGVyIGlzIG1pc3NpbmcgZnJvbSB0aGUgUmVhY3QgdHJlZS5cIik7XG4gIH1cbiAgcmV0dXJuIHJvb207XG59XG5mdW5jdGlvbiB1c2VTdGF0dXMoKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmU7XG4gIGNvbnN0IGdldFNuYXBzaG90ID0gcm9vbS5nZXRTdGF0dXM7XG4gIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gcm9vbS5nZXRTdGF0dXM7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTMoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xufVxuZnVuY3Rpb24gdXNlUmVwb3J0VGV4dEVkaXRvcihlZGl0b3IsIHJvb3RLZXkpIHtcbiAgY29uc3QgaXNSZXBvcnRlZCA9IHVzZVJlZjMoZmFsc2UpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICB1c2VFZmZlY3Q1KCgpID0+IHtcbiAgICBpZiAoaXNSZXBvcnRlZC5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gcm9vbS5ldmVudHMuc3RhdHVzLnN1YnNjcmliZSgoc3RhdHVzKSA9PiB7XG4gICAgICBpZiAoc3RhdHVzID09PSBcImNvbm5lY3RlZFwiICYmICFpc1JlcG9ydGVkLmN1cnJlbnQpIHtcbiAgICAgICAgaXNSZXBvcnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgdm9pZCByb29tW2tJbnRlcm5hbDNdLnJlcG9ydFRleHRFZGl0b3IoZWRpdG9yLCByb290S2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gIH0sIFtyb29tLCBlZGl0b3IsIHJvb3RLZXldKTtcbn1cbmZ1bmN0aW9uIHVzZVlqc1Byb3ZpZGVyKCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSB1c2VDYWxsYmFjazMoXG4gICAgKG9uU3RvcmVDaGFuZ2UpID0+IHtcbiAgICAgIHJldHVybiByb29tW2tJbnRlcm5hbDNdLnlqc1Byb3ZpZGVyRGlkQ2hhbmdlLnN1YnNjcmliZShvblN0b3JlQ2hhbmdlKTtcbiAgICB9LFxuICAgIFtyb29tXVxuICApO1xuICBjb25zdCBnZXRTbmFwc2hvdCA9IHVzZUNhbGxiYWNrMygoKSA9PiB7XG4gICAgcmV0dXJuIHJvb21ba0ludGVybmFsM10uZ2V0WWpzUHJvdmlkZXIoKTtcbiAgfSwgW3Jvb21dKTtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlMyhzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTbmFwc2hvdCk7XG59XG5mdW5jdGlvbiB1c2VDcmVhdGVUZXh0TWVudGlvbigpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMyhcbiAgICAodXNlcklkLCBtZW50aW9uSWQpID0+IHtcbiAgICAgIHJvb21ba0ludGVybmFsM10uY3JlYXRlVGV4dE1lbnRpb24odXNlcklkLCBtZW50aW9uSWQpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgY29uc29sZTMuZXJyb3IoXG4gICAgICAgICAgYENhbm5vdCBjcmVhdGUgdGV4dCBtZW50aW9uIGZvciB1c2VyICcke3VzZXJJZH0nIGFuZCBtZW50aW9uICcke21lbnRpb25JZH0nYCxcbiAgICAgICAgICBlcnJcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgW3Jvb21dXG4gICk7XG59XG5mdW5jdGlvbiB1c2VEZWxldGVUZXh0TWVudGlvbigpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMyhcbiAgICAobWVudGlvbklkKSA9PiB7XG4gICAgICByb29tW2tJbnRlcm5hbDNdLmRlbGV0ZVRleHRNZW50aW9uKG1lbnRpb25JZCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBjb25zb2xlMy5lcnJvcihgQ2Fubm90IGRlbGV0ZSB0ZXh0IG1lbnRpb24gJyR7bWVudGlvbklkfSdgLCBlcnIpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBbcm9vbV1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMoKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICByZXR1cm4gY2xpZW50W2tJbnRlcm5hbDNdLnJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnM7XG59XG5mdW5jdGlvbiB1c2VNZW50aW9uU3VnZ2VzdGlvbnNDYWNoZSgpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIHJldHVybiBjbGllbnRba0ludGVybmFsM10ubWVudGlvblN1Z2dlc3Rpb25zQ2FjaGU7XG59XG5mdW5jdGlvbiB1c2VTdG9yYWdlU3RhdHVzKG9wdGlvbnMpIHtcbiAgY29uc3Qgc21vb3RoID0gdXNlSW5pdGlhbChvcHRpb25zPy5zbW9vdGggPz8gZmFsc2UpO1xuICBpZiAoc21vb3RoKSB7XG4gICAgcmV0dXJuIHVzZVN0b3JhZ2VTdGF0dXNTbW9vdGgoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdXNlU3RvcmFnZVN0YXR1c0ltbWVkaWF0ZSgpO1xuICB9XG59XG5mdW5jdGlvbiB1c2VTdG9yYWdlU3RhdHVzSW1tZWRpYXRlKCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSByb29tLmV2ZW50cy5zdG9yYWdlU3RhdHVzLnN1YnNjcmliZTtcbiAgY29uc3QgZ2V0U25hcHNob3QgPSByb29tLmdldFN0b3JhZ2VTdGF0dXM7XG4gIGNvbnN0IGdldFNlcnZlclNuYXBzaG90ID0gcm9vbS5nZXRTdG9yYWdlU3RhdHVzO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUzKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbn1cbmZ1bmN0aW9uIHVzZVN0b3JhZ2VTdGF0dXNTbW9vdGgoKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IFtzdGF0dXMsIHNldFN0YXR1c10gPSB1c2VTdGF0ZTIocm9vbS5nZXRTdG9yYWdlU3RhdHVzKTtcbiAgY29uc3Qgb2xkU3RhdHVzID0gdXNlTGF0ZXN0KHJvb20uZ2V0U3RvcmFnZVN0YXR1cygpKTtcbiAgdXNlRWZmZWN0NSgoKSA9PiB7XG4gICAgbGV0IHRpbWVvdXRJZDtcbiAgICBjb25zdCB1bnN1YiA9IHJvb20uZXZlbnRzLnN0b3JhZ2VTdGF0dXMuc3Vic2NyaWJlKChuZXdTdGF0dXMpID0+IHtcbiAgICAgIGlmIChvbGRTdGF0dXMuY3VycmVudCA9PT0gXCJzeW5jaHJvbml6aW5nXCIgJiYgbmV3U3RhdHVzID09PSBcInN5bmNocm9uaXplZFwiKSB7XG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gc2V0U3RhdHVzKG5ld1N0YXR1cyksIGNvbmZpZy5TTU9PVEhfREVMQVkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIHNldFN0YXR1cyhuZXdTdGF0dXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIHVuc3ViKCk7XG4gICAgfTtcbiAgfSwgW3Jvb20sIG9sZFN0YXR1c10pO1xuICByZXR1cm4gc3RhdHVzO1xufVxuZnVuY3Rpb24gdXNlQmF0Y2goKSB7XG4gIHJldHVybiB1c2VSb29tKCkuYmF0Y2g7XG59XG5mdW5jdGlvbiB1c2VCcm9hZGNhc3RFdmVudCgpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMyhcbiAgICAoZXZlbnQsIG9wdGlvbnMgPSB7IHNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5OiBmYWxzZSB9KSA9PiB7XG4gICAgICByb29tLmJyb2FkY2FzdEV2ZW50KGV2ZW50LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIFtyb29tXVxuICApO1xufVxuZnVuY3Rpb24gdXNlT3RoZXJzTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc2F2ZWRDYWxsYmFjayA9IHVzZUxhdGVzdChjYWxsYmFjayk7XG4gIHVzZUVmZmVjdDUoXG4gICAgKCkgPT4gcm9vbS5ldmVudHMub3RoZXJzLnN1YnNjcmliZSgoZXZlbnQpID0+IHNhdmVkQ2FsbGJhY2suY3VycmVudChldmVudCkpLFxuICAgIFtyb29tLCBzYXZlZENhbGxiYWNrXVxuICApO1xufVxuZnVuY3Rpb24gdXNlTG9zdENvbm5lY3Rpb25MaXN0ZW5lcihjYWxsYmFjaykge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzYXZlZENhbGxiYWNrID0gdXNlTGF0ZXN0KGNhbGxiYWNrKTtcbiAgdXNlRWZmZWN0NShcbiAgICAoKSA9PiByb29tLmV2ZW50cy5sb3N0Q29ubmVjdGlvbi5zdWJzY3JpYmUoXG4gICAgICAoZXZlbnQpID0+IHNhdmVkQ2FsbGJhY2suY3VycmVudChldmVudClcbiAgICApLFxuICAgIFtyb29tLCBzYXZlZENhbGxiYWNrXVxuICApO1xufVxuZnVuY3Rpb24gdXNlRXZlbnRMaXN0ZW5lcihjYWxsYmFjaykge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzYXZlZENhbGxiYWNrID0gdXNlTGF0ZXN0KGNhbGxiYWNrKTtcbiAgdXNlRWZmZWN0NSgoKSA9PiB7XG4gICAgY29uc3QgbGlzdGVuZXIgPSAoZXZlbnREYXRhKSA9PiB7XG4gICAgICBzYXZlZENhbGxiYWNrLmN1cnJlbnQoZXZlbnREYXRhKTtcbiAgICB9O1xuICAgIHJldHVybiByb29tLmV2ZW50cy5jdXN0b21FdmVudC5zdWJzY3JpYmUobGlzdGVuZXIpO1xuICB9LCBbcm9vbSwgc2F2ZWRDYWxsYmFja10pO1xufVxuZnVuY3Rpb24gdXNlSGlzdG9yeSgpIHtcbiAgcmV0dXJuIHVzZVJvb20oKS5oaXN0b3J5O1xufVxuZnVuY3Rpb24gdXNlVW5kbygpIHtcbiAgcmV0dXJuIHVzZUhpc3RvcnkoKS51bmRvO1xufVxuZnVuY3Rpb24gdXNlUmVkbygpIHtcbiAgcmV0dXJuIHVzZUhpc3RvcnkoKS5yZWRvO1xufVxuZnVuY3Rpb24gdXNlQ2FuVW5kbygpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMuaGlzdG9yeS5zdWJzY3JpYmU7XG4gIGNvbnN0IGNhblVuZG8gPSByb29tLmhpc3RvcnkuY2FuVW5kbztcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlMyhzdWJzY3JpYmUsIGNhblVuZG8sIGNhblVuZG8pO1xufVxuZnVuY3Rpb24gdXNlQ2FuUmVkbygpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMuaGlzdG9yeS5zdWJzY3JpYmU7XG4gIGNvbnN0IGNhblJlZG8gPSByb29tLmhpc3RvcnkuY2FuUmVkbztcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlMyhzdWJzY3JpYmUsIGNhblJlZG8sIGNhblJlZG8pO1xufVxuZnVuY3Rpb24gdXNlU2VsZihtYXliZVNlbGVjdG9yLCBpc0VxdWFsKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHJvb20uZXZlbnRzLnNlbGYuc3Vic2NyaWJlO1xuICBjb25zdCBnZXRTbmFwc2hvdCA9IHJvb20uZ2V0U2VsZjtcbiAgY29uc3Qgc2VsZWN0b3IgPSBtYXliZVNlbGVjdG9yID8/IGlkZW50aXR5MztcbiAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gdXNlQ2FsbGJhY2szKFxuICAgIChtZSkgPT4gbWUgIT09IG51bGwgPyBzZWxlY3RvcihtZSkgOiBudWxsLFxuICAgIFtzZWxlY3Rvcl1cbiAgKTtcbiAgY29uc3QgZ2V0U2VydmVyU25hcHNob3QgPSBhbHdheXNOdWxsO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgc3Vic2NyaWJlLFxuICAgIGdldFNuYXBzaG90LFxuICAgIGdldFNlcnZlclNuYXBzaG90LFxuICAgIHdyYXBwZWRTZWxlY3RvcixcbiAgICBpc0VxdWFsXG4gICk7XG59XG5mdW5jdGlvbiB1c2VNeVByZXNlbmNlKCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSByb29tLmV2ZW50cy5teVByZXNlbmNlLnN1YnNjcmliZTtcbiAgY29uc3QgZ2V0U25hcHNob3QgPSByb29tLmdldFByZXNlbmNlO1xuICBjb25zdCBwcmVzZW5jZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlMyhzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTbmFwc2hvdCk7XG4gIGNvbnN0IHNldFByZXNlbmNlID0gcm9vbS51cGRhdGVQcmVzZW5jZTtcbiAgcmV0dXJuIFtwcmVzZW5jZSwgc2V0UHJlc2VuY2VdO1xufVxuZnVuY3Rpb24gdXNlVXBkYXRlTXlQcmVzZW5jZSgpIHtcbiAgcmV0dXJuIHVzZVJvb20oKS51cGRhdGVQcmVzZW5jZTtcbn1cbmZ1bmN0aW9uIHVzZU90aGVycyhzZWxlY3RvciwgaXNFcXVhbCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSByb29tLmV2ZW50cy5vdGhlcnMuc3Vic2NyaWJlO1xuICBjb25zdCBnZXRTbmFwc2hvdCA9IHJvb20uZ2V0T3RoZXJzO1xuICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGFsd2F5c0VtcHR5TGlzdDtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yKFxuICAgIHN1YnNjcmliZSxcbiAgICBnZXRTbmFwc2hvdCxcbiAgICBnZXRTZXJ2ZXJTbmFwc2hvdCxcbiAgICBzZWxlY3RvciA/PyBpZGVudGl0eTMsXG4gICAgaXNFcXVhbFxuICApO1xufVxuZnVuY3Rpb24gdXNlT3RoZXJzTWFwcGVkKGl0ZW1TZWxlY3RvciwgaXRlbUlzRXF1YWwpIHtcbiAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gdXNlQ2FsbGJhY2szKFxuICAgIChvdGhlcnMpID0+IG90aGVycy5tYXAoKG90aGVyKSA9PiBbb3RoZXIuY29ubmVjdGlvbklkLCBpdGVtU2VsZWN0b3Iob3RoZXIpXSksXG4gICAgW2l0ZW1TZWxlY3Rvcl1cbiAgKTtcbiAgY29uc3Qgd3JhcHBlZElzRXF1YWwgPSB1c2VDYWxsYmFjazMoXG4gICAgKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGVxID0gaXRlbUlzRXF1YWwgPz8gT2JqZWN0LmlzO1xuICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KChhdHVwbGUsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGJ0dXBsZSA9IGJbaW5kZXhdO1xuICAgICAgICByZXR1cm4gYXR1cGxlWzBdID09PSBidHVwbGVbMF0gJiYgZXEoYXR1cGxlWzFdLCBidHVwbGVbMV0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBbaXRlbUlzRXF1YWxdXG4gICk7XG4gIHJldHVybiB1c2VPdGhlcnMod3JhcHBlZFNlbGVjdG9yLCB3cmFwcGVkSXNFcXVhbCk7XG59XG5mdW5jdGlvbiB1c2VPdGhlcnNDb25uZWN0aW9uSWRzKCkge1xuICByZXR1cm4gdXNlT3RoZXJzKHNlbGVjdG9yRm9yX3VzZU90aGVyc0Nvbm5lY3Rpb25JZHMsIHNoYWxsb3c1KTtcbn1cbnZhciBOT1RfRk9VTkQgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIHVzZU90aGVyKGNvbm5lY3Rpb25JZCwgc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gdXNlQ2FsbGJhY2szKFxuICAgIChvdGhlcnMpID0+IHtcbiAgICAgIGNvbnN0IG90aGVyMiA9IG90aGVycy5maW5kKChvdGhlcjMpID0+IG90aGVyMy5jb25uZWN0aW9uSWQgPT09IGNvbm5lY3Rpb25JZCk7XG4gICAgICByZXR1cm4gb3RoZXIyICE9PSB2b2lkIDAgPyBzZWxlY3RvcihvdGhlcjIpIDogTk9UX0ZPVU5EO1xuICAgIH0sXG4gICAgW2Nvbm5lY3Rpb25JZCwgc2VsZWN0b3JdXG4gICk7XG4gIGNvbnN0IHdyYXBwZWRJc0VxdWFsID0gdXNlQ2FsbGJhY2szKFxuICAgIChwcmV2LCBjdXJyKSA9PiB7XG4gICAgICBpZiAocHJldiA9PT0gTk9UX0ZPVU5EIHx8IGN1cnIgPT09IE5PVF9GT1VORCkge1xuICAgICAgICByZXR1cm4gcHJldiA9PT0gY3VycjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVxID0gaXNFcXVhbCA/PyBPYmplY3QuaXM7XG4gICAgICByZXR1cm4gZXEocHJldiwgY3Vycik7XG4gICAgfSxcbiAgICBbaXNFcXVhbF1cbiAgKTtcbiAgY29uc3Qgb3RoZXIgPSB1c2VPdGhlcnMod3JhcHBlZFNlbGVjdG9yLCB3cmFwcGVkSXNFcXVhbCk7XG4gIGlmIChvdGhlciA9PT0gTk9UX0ZPVU5EKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYE5vIHN1Y2ggb3RoZXIgdXNlciB3aXRoIGNvbm5lY3Rpb24gaWQgJHtjb25uZWN0aW9uSWR9IGV4aXN0c2BcbiAgICApO1xuICB9XG4gIHJldHVybiBvdGhlcjtcbn1cbmZ1bmN0aW9uIHVzZU11dGFibGVTdG9yYWdlUm9vdCgpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gcm9vbS5ldmVudHMuc3RvcmFnZURpZExvYWQuc3Vic2NyaWJlT25jZTtcbiAgY29uc3QgZ2V0U25hcHNob3QgPSByb29tLmdldFN0b3JhZ2VTbmFwc2hvdDtcbiAgY29uc3QgZ2V0U2VydmVyU25hcHNob3QgPSBhbHdheXNOdWxsO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUzKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbn1cbmZ1bmN0aW9uIHVzZVN0b3JhZ2VSb290KCkge1xuICByZXR1cm4gW3VzZU11dGFibGVTdG9yYWdlUm9vdCgpXTtcbn1cbmZ1bmN0aW9uIHVzZVN0b3JhZ2Uoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3Qgcm9vdE9yTnVsbCA9IHVzZU11dGFibGVTdG9yYWdlUm9vdCgpO1xuICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSB1c2VDYWxsYmFjazMoXG4gICAgKHJvb3RPck51bGwyKSA9PiByb290T3JOdWxsMiAhPT0gbnVsbCA/IHNlbGVjdG9yKHJvb3RPck51bGwyKSA6IG51bGwsXG4gICAgW3NlbGVjdG9yXVxuICApO1xuICBjb25zdCBzdWJzY3JpYmUgPSB1c2VDYWxsYmFjazMoXG4gICAgKG9uU3RvcmVDaGFuZ2UpID0+IHJvb3RPck51bGwgIT09IG51bGwgPyByb29tLnN1YnNjcmliZShyb290T3JOdWxsLCBvblN0b3JlQ2hhbmdlLCB7IGlzRGVlcDogdHJ1ZSB9KSA6IG5vb3AzLFxuICAgIFtyb29tLCByb290T3JOdWxsXVxuICApO1xuICBjb25zdCBnZXRTbmFwc2hvdCA9IHVzZUNhbGxiYWNrMygoKSA9PiB7XG4gICAgaWYgKHJvb3RPck51bGwgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByb290ID0gcm9vdE9yTnVsbDtcbiAgICAgIGNvbnN0IGltbSA9IHJvb3QudG9JbW11dGFibGUoKTtcbiAgICAgIHJldHVybiBpbW07XG4gICAgfVxuICB9LCBbcm9vdE9yTnVsbF0pO1xuICBjb25zdCBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGFsd2F5c051bGw7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICBzdWJzY3JpYmUsXG4gICAgZ2V0U25hcHNob3QsXG4gICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgd3JhcHBlZFNlbGVjdG9yLFxuICAgIGlzRXF1YWxcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU11dGF0aW9uKGNhbGxiYWNrLCBkZXBzKSB7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHJldHVybiB1c2VNZW1vMyhcbiAgICAoKSA9PiB7XG4gICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IChcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgIHJvb20uYmF0Y2goXG4gICAgICAgICAgKCkgPT4gKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICAgICAgbWFrZU11dGF0aW9uQ29udGV4dChyb29tKSxcbiAgICAgICAgICAgICAgLi4uYXJnc1xuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbcm9vbSwgLi4uZGVwc11cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVRocmVhZHMob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHsgc2Nyb2xsT25Mb2FkID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHsgc3RvcmUsIGdldE9yQ3JlYXRlVGhyZWFkc1BvbGxlckZvclJvb21JZCB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICBjb25zdCBxdWVyeUtleSA9IG1ha2VSb29tVGhyZWFkc1F1ZXJ5S2V5KHJvb20uaWQsIG9wdGlvbnMucXVlcnkpO1xuICBjb25zdCBwb2xsZXIgPSBnZXRPckNyZWF0ZVRocmVhZHNQb2xsZXJGb3JSb29tSWQocm9vbS5pZCk7XG4gIHVzZUVmZmVjdDUoXG4gICAgKCkgPT4gdm9pZCBzdG9yZS5vdXRwdXRzLmxvYWRpbmdSb29tVGhyZWFkcy5nZXRPckNyZWF0ZShxdWVyeUtleSkud2FpdFVudGlsTG9hZGVkKClcbiAgICAvLyBOT1RFOiBEZWxpYmVyYXRlbHkgKm5vdCogdXNpbmcgYSBkZXBlbmRlbmN5IGFycmF5IGhlcmUhXG4gICAgLy9cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gY2FsbCB3YWl0VW50aWwgb24gKmV2ZXJ5KiByZW5kZXIuXG4gICAgLy8gVGhpcyBpcyBoYXJtbGVzcyB0aG91Z2gsIG9uIG1vc3QgcmVuZGVycywgZXhjZXB0OlxuICAgIC8vIDEuIFRoZSB2ZXJ5IGZpcnN0IHJlbmRlciwgaW4gd2hpY2ggY2FzZSB3ZSdsbCB3YW50IHRvIHRyaWdnZXIgdGhlIGluaXRpYWwgcGFnZSBmZXRjaC5cbiAgICAvLyAyLiBBbGwgb3RoZXIgc3Vic2VxdWVudCByZW5kZXJzIG5vdyBcImp1c3RcIiByZXR1cm4gdGhlIHNhbWUgcHJvbWlzZSAoYSBxdWljayBvcGVyYXRpb24pLlxuICAgIC8vIDMuIElmIGV2ZXIgdGhlIHByb21pc2Ugd291bGQgZmFpbCwgdGhlbiBhZnRlciA1IHNlY29uZHMgaXQgd291bGQgcmVzZXQsIGFuZCBvbiB0aGUgdmVyeVxuICAgIC8vICAgICpuZXh0KiByZW5kZXIgYWZ0ZXIgdGhhdCwgYSAqbmV3KiBmZXRjaC9wcm9taXNlIHdpbGwgZ2V0IGNyZWF0ZWQuXG4gICk7XG4gIHVzZUVmZmVjdDUoKCkgPT4ge1xuICAgIHBvbGxlci5pbmMoKTtcbiAgICBwb2xsZXIucG9sbE5vd0lmU3RhbGUoKTtcbiAgICByZXR1cm4gKCkgPT4gcG9sbGVyLmRlYygpO1xuICB9LCBbcG9sbGVyXSk7XG4gIGNvbnN0IHJlc3VsdCA9IHVzZVNpZ25hbChcbiAgICBzdG9yZS5vdXRwdXRzLmxvYWRpbmdSb29tVGhyZWFkcy5nZXRPckNyZWF0ZShxdWVyeUtleSkuc2lnbmFsXG4gICk7XG4gIHVzZVNjcm9sbFRvQ29tbWVudE9uTG9hZEVmZmVjdChzY3JvbGxPbkxvYWQsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1c2VDcmVhdGVUaHJlYWQoKSB7XG4gIHJldHVybiB1c2VDcmVhdGVSb29tVGhyZWFkKHVzZVJvb20oKS5pZCk7XG59XG5mdW5jdGlvbiB1c2VDcmVhdGVSb29tVGhyZWFkKHJvb21JZCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMyhcbiAgICAob3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgYm9keSA9IG9wdGlvbnMuYm9keTtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gb3B0aW9ucy5tZXRhZGF0YSA/PyB7fTtcbiAgICAgIGNvbnN0IGF0dGFjaG1lbnRzID0gb3B0aW9ucy5hdHRhY2htZW50cztcbiAgICAgIGNvbnN0IHRocmVhZElkID0gY3JlYXRlVGhyZWFkSWQoKTtcbiAgICAgIGNvbnN0IGNvbW1lbnRJZCA9IGNyZWF0ZUNvbW1lbnRJZCgpO1xuICAgICAgY29uc3QgY3JlYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCBuZXdDb21tZW50ID0ge1xuICAgICAgICBpZDogY29tbWVudElkLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgcm9vbUlkLFxuICAgICAgICBjcmVhdGVkQXQsXG4gICAgICAgIHR5cGU6IFwiY29tbWVudFwiLFxuICAgICAgICB1c2VySWQ6IGdldEN1cnJlbnRVc2VySWQoY2xpZW50KSxcbiAgICAgICAgYm9keSxcbiAgICAgICAgcmVhY3Rpb25zOiBbXSxcbiAgICAgICAgYXR0YWNobWVudHM6IGF0dGFjaG1lbnRzID8/IFtdXG4gICAgICB9O1xuICAgICAgY29uc3QgbmV3VGhyZWFkID0ge1xuICAgICAgICBpZDogdGhyZWFkSWQsXG4gICAgICAgIHR5cGU6IFwidGhyZWFkXCIsXG4gICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgICAgdXBkYXRlZEF0OiBjcmVhdGVkQXQsXG4gICAgICAgIHJvb21JZCxcbiAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgIGNvbW1lbnRzOiBbbmV3Q29tbWVudF0sXG4gICAgICAgIHJlc29sdmVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljSWQgPSBzdG9yZS5vcHRpbWlzdGljVXBkYXRlcy5hZGQoe1xuICAgICAgICB0eXBlOiBcImNyZWF0ZS10aHJlYWRcIixcbiAgICAgICAgdGhyZWFkOiBuZXdUaHJlYWQsXG4gICAgICAgIHJvb21JZFxuICAgICAgfSk7XG4gICAgICBjb25zdCBhdHRhY2htZW50SWRzID0gYXR0YWNobWVudHM/Lm1hcCgoYXR0YWNobWVudCkgPT4gYXR0YWNobWVudC5pZCk7XG4gICAgICBjbGllbnRba0ludGVybmFsM10uaHR0cENsaWVudC5jcmVhdGVUaHJlYWQoe1xuICAgICAgICByb29tSWQsXG4gICAgICAgIHRocmVhZElkLFxuICAgICAgICBjb21tZW50SWQsXG4gICAgICAgIGJvZHksXG4gICAgICAgIG1ldGFkYXRhLFxuICAgICAgICBhdHRhY2htZW50SWRzXG4gICAgICB9KS50aGVuKFxuICAgICAgICAodGhyZWFkKSA9PiB7XG4gICAgICAgICAgc3RvcmUuY3JlYXRlVGhyZWFkKG9wdGltaXN0aWNJZCwgdGhyZWFkKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwiQ1JFQVRFX1RIUkVBRF9FUlJPUlwiLFxuICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBjb21tZW50SWQsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgbWV0YWRhdGFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVyclxuICAgICAgICApXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ld1RocmVhZDtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21JZF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZURlbGV0ZVRocmVhZCgpIHtcbiAgcmV0dXJuIHVzZURlbGV0ZVJvb21UaHJlYWQodXNlUm9vbSgpLmlkKTtcbn1cbmZ1bmN0aW9uIHVzZURlbGV0ZVJvb21UaHJlYWQocm9vbUlkKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2szKFxuICAgICh0aHJlYWRJZCkgPT4ge1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IGdldEN1cnJlbnRVc2VySWQoY2xpZW50KTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gc3RvcmUub3V0cHV0cy50aHJlYWRzLmdldCgpLmdldCh0aHJlYWRJZCk7XG4gICAgICBpZiAoZXhpc3Rpbmc/LmNvbW1lbnRzPy5bMF0/LnVzZXJJZCAhPT0gdXNlcklkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgdGhlIHRocmVhZCBjcmVhdG9yIGNhbiBkZWxldGUgdGhlIHRocmVhZFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGltaXN0aWNJZCA9IHN0b3JlLm9wdGltaXN0aWNVcGRhdGVzLmFkZCh7XG4gICAgICAgIHR5cGU6IFwiZGVsZXRlLXRocmVhZFwiLFxuICAgICAgICByb29tSWQsXG4gICAgICAgIHRocmVhZElkLFxuICAgICAgICBkZWxldGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICB9KTtcbiAgICAgIGNsaWVudFtrSW50ZXJuYWwzXS5odHRwQ2xpZW50LmRlbGV0ZVRocmVhZCh7IHJvb21JZCwgdGhyZWFkSWQgfSkudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLmRlbGV0ZVRocmVhZCh0aHJlYWRJZCwgb3B0aW1pc3RpY0lkKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgICAgIHsgdHlwZTogXCJERUxFVEVfVEhSRUFEX0VSUk9SXCIsIHJvb21JZCwgdGhyZWFkSWQgfSxcbiAgICAgICAgICBlcnJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21JZF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUVkaXRUaHJlYWRNZXRhZGF0YSgpIHtcbiAgcmV0dXJuIHVzZUVkaXRSb29tVGhyZWFkTWV0YWRhdGEodXNlUm9vbSgpLmlkKTtcbn1cbmZ1bmN0aW9uIHVzZUVkaXRSb29tVGhyZWFkTWV0YWRhdGEocm9vbUlkKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2szKFxuICAgIChvcHRpb25zKSA9PiB7XG4gICAgICBpZiAoIW9wdGlvbnMubWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdGhyZWFkSWQgPSBvcHRpb25zLnRocmVhZElkO1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSBvcHRpb25zLm1ldGFkYXRhO1xuICAgICAgY29uc3QgdXBkYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgICAgdHlwZTogXCJlZGl0LXRocmVhZC1tZXRhZGF0YVwiLFxuICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgIHVwZGF0ZWRBdFxuICAgICAgfSk7XG4gICAgICBjbGllbnRba0ludGVybmFsM10uaHR0cENsaWVudC5lZGl0VGhyZWFkTWV0YWRhdGEoeyByb29tSWQsIHRocmVhZElkLCBtZXRhZGF0YSB9KS50aGVuKFxuICAgICAgICAobWV0YWRhdGEyKSA9PiAoXG4gICAgICAgICAgLy8gUmVwbGFjZSB0aGUgb3B0aW1pc3RpYyB1cGRhdGUgYnkgdGhlIHJlYWwgdGhpbmdcbiAgICAgICAgICBzdG9yZS5wYXRjaFRocmVhZCh0aHJlYWRJZCwgb3B0aW1pc3RpY0lkLCB7IG1ldGFkYXRhOiBtZXRhZGF0YTIgfSwgdXBkYXRlZEF0KVxuICAgICAgICApLFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBvcHRpbWlzdGljSWQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJFRElUX1RIUkVBRF9NRVRBREFUQV9FUlJPUlwiLFxuICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgICBtZXRhZGF0YVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tSWRdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VDcmVhdGVDb21tZW50KCkge1xuICByZXR1cm4gdXNlQ3JlYXRlUm9vbUNvbW1lbnQodXNlUm9vbSgpLmlkKTtcbn1cbmZ1bmN0aW9uIHVzZUNyZWF0ZVJvb21Db21tZW50KHJvb21JZCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMyhcbiAgICAoeyB0aHJlYWRJZCwgYm9keSwgYXR0YWNobWVudHMgfSkgPT4ge1xuICAgICAgY29uc3QgY29tbWVudElkID0gY3JlYXRlQ29tbWVudElkKCk7XG4gICAgICBjb25zdCBjcmVhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IGNvbW1lbnQgPSB7XG4gICAgICAgIGlkOiBjb21tZW50SWQsXG4gICAgICAgIHRocmVhZElkLFxuICAgICAgICByb29tSWQsXG4gICAgICAgIHR5cGU6IFwiY29tbWVudFwiLFxuICAgICAgICBjcmVhdGVkQXQsXG4gICAgICAgIHVzZXJJZDogZ2V0Q3VycmVudFVzZXJJZChjbGllbnQpLFxuICAgICAgICBib2R5LFxuICAgICAgICByZWFjdGlvbnM6IFtdLFxuICAgICAgICBhdHRhY2htZW50czogYXR0YWNobWVudHMgPz8gW11cbiAgICAgIH07XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgICAgdHlwZTogXCJjcmVhdGUtY29tbWVudFwiLFxuICAgICAgICBjb21tZW50XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGF0dGFjaG1lbnRJZHMgPSBhdHRhY2htZW50cz8ubWFwKChhdHRhY2htZW50KSA9PiBhdHRhY2htZW50LmlkKTtcbiAgICAgIGNsaWVudFtrSW50ZXJuYWwzXS5odHRwQ2xpZW50LmNyZWF0ZUNvbW1lbnQoeyByb29tSWQsIHRocmVhZElkLCBjb21tZW50SWQsIGJvZHksIGF0dGFjaG1lbnRJZHMgfSkudGhlbihcbiAgICAgICAgKG5ld0NvbW1lbnQpID0+IHtcbiAgICAgICAgICBzdG9yZS5jcmVhdGVDb21tZW50KG5ld0NvbW1lbnQsIG9wdGltaXN0aWNJZCk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcIkNSRUFURV9DT01NRU5UX0VSUk9SXCIsXG4gICAgICAgICAgICByb29tSWQsXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgIGJvZHlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVyclxuICAgICAgICApXG4gICAgICApO1xuICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgfSxcbiAgICBbY2xpZW50LCByb29tSWRdXG4gICk7XG59XG5mdW5jdGlvbiB1c2VFZGl0Q29tbWVudCgpIHtcbiAgcmV0dXJuIHVzZUVkaXRSb29tQ29tbWVudCh1c2VSb29tKCkuaWQpO1xufVxuZnVuY3Rpb24gdXNlRWRpdFJvb21Db21tZW50KHJvb21JZCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMyhcbiAgICAoeyB0aHJlYWRJZCwgY29tbWVudElkLCBib2R5LCBhdHRhY2htZW50cyB9KSA9PiB7XG4gICAgICBjb25zdCBlZGl0ZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3QgeyBzdG9yZSwgb25NdXRhdGlvbkZhaWx1cmUgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gc3RvcmUub3V0cHV0cy50aHJlYWRzLmdldCgpLmdldEV2ZW5JZkRlbGV0ZWQodGhyZWFkSWQpO1xuICAgICAgaWYgKGV4aXN0aW5nID09PSB2b2lkIDApIHtcbiAgICAgICAgY29uc29sZTMud2FybihcbiAgICAgICAgICBgSW50ZXJuYWwgdW5leHBlY3RlZCBiZWhhdmlvci4gQ2Fubm90IGVkaXQgY29tbWVudCBpbiB0aHJlYWQgXCIke3RocmVhZElkfVwiIGJlY2F1c2UgdGhlIHRocmVhZCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgY2FjaGUuYFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjb21tZW50ID0gZXhpc3RpbmcuY29tbWVudHMuZmluZChcbiAgICAgICAgKGNvbW1lbnQyKSA9PiBjb21tZW50Mi5pZCA9PT0gY29tbWVudElkXG4gICAgICApO1xuICAgICAgaWYgKGNvbW1lbnQgPT09IHZvaWQgMCB8fCBjb21tZW50LmRlbGV0ZWRBdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnNvbGUzLndhcm4oXG4gICAgICAgICAgYEludGVybmFsIHVuZXhwZWN0ZWQgYmVoYXZpb3IuIENhbm5vdCBlZGl0IGNvbW1lbnQgXCIke2NvbW1lbnRJZH1cIiBpbiB0aHJlYWQgXCIke3RocmVhZElkfVwiIGJlY2F1c2UgdGhlIGNvbW1lbnQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGNhY2hlLmBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgICAgdHlwZTogXCJlZGl0LWNvbW1lbnRcIixcbiAgICAgICAgY29tbWVudDoge1xuICAgICAgICAgIC4uLmNvbW1lbnQsXG4gICAgICAgICAgZWRpdGVkQXQsXG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICBhdHRhY2htZW50czogYXR0YWNobWVudHMgPz8gW11cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBhdHRhY2htZW50SWRzID0gYXR0YWNobWVudHM/Lm1hcCgoYXR0YWNobWVudCkgPT4gYXR0YWNobWVudC5pZCk7XG4gICAgICBjbGllbnRba0ludGVybmFsM10uaHR0cENsaWVudC5lZGl0Q29tbWVudCh7IHJvb21JZCwgdGhyZWFkSWQsIGNvbW1lbnRJZCwgYm9keSwgYXR0YWNobWVudElkcyB9KS50aGVuKFxuICAgICAgICAoZWRpdGVkQ29tbWVudCkgPT4ge1xuICAgICAgICAgIHN0b3JlLmVkaXRDb21tZW50KHRocmVhZElkLCBvcHRpbWlzdGljSWQsIGVkaXRlZENvbW1lbnQpO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBvcHRpbWlzdGljSWQsXG4gICAgICAgICAgeyB0eXBlOiBcIkVESVRfQ09NTUVOVF9FUlJPUlwiLCByb29tSWQsIHRocmVhZElkLCBjb21tZW50SWQsIGJvZHkgfSxcbiAgICAgICAgICBlcnJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21JZF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZURlbGV0ZUNvbW1lbnQoKSB7XG4gIHJldHVybiB1c2VEZWxldGVSb29tQ29tbWVudCh1c2VSb29tKCkuaWQpO1xufVxuZnVuY3Rpb24gdXNlRGVsZXRlUm9vbUNvbW1lbnQocm9vbUlkKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2szKFxuICAgICh7IHRocmVhZElkLCBjb21tZW50SWQgfSkgPT4ge1xuICAgICAgY29uc3QgZGVsZXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgICAgdHlwZTogXCJkZWxldGUtY29tbWVudFwiLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgY29tbWVudElkLFxuICAgICAgICBkZWxldGVkQXQsXG4gICAgICAgIHJvb21JZFxuICAgICAgfSk7XG4gICAgICBjbGllbnRba0ludGVybmFsM10uaHR0cENsaWVudC5kZWxldGVDb21tZW50KHsgcm9vbUlkLCB0aHJlYWRJZCwgY29tbWVudElkIH0pLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5kZWxldGVDb21tZW50KHRocmVhZElkLCBvcHRpbWlzdGljSWQsIGNvbW1lbnRJZCwgZGVsZXRlZEF0KTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4gb25NdXRhdGlvbkZhaWx1cmUoXG4gICAgICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgICAgIHsgdHlwZTogXCJERUxFVEVfQ09NTUVOVF9FUlJPUlwiLCByb29tSWQsIHRocmVhZElkLCBjb21tZW50SWQgfSxcbiAgICAgICAgICBlcnJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21JZF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUFkZFJlYWN0aW9uKCkge1xuICByZXR1cm4gdXNlQWRkUm9vbUNvbW1lbnRSZWFjdGlvbih1c2VSb29tKCkuaWQpO1xufVxuZnVuY3Rpb24gdXNlQWRkUm9vbUNvbW1lbnRSZWFjdGlvbihyb29tSWQpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIHJldHVybiB1c2VDYWxsYmFjazMoXG4gICAgKHsgdGhyZWFkSWQsIGNvbW1lbnRJZCwgZW1vamkgfSkgPT4ge1xuICAgICAgY29uc3QgY3JlYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB1c2VySWQgPSBnZXRDdXJyZW50VXNlcklkKGNsaWVudCk7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgICAgdHlwZTogXCJhZGQtcmVhY3Rpb25cIixcbiAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgcmVhY3Rpb246IHtcbiAgICAgICAgICBlbW9qaSxcbiAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgY3JlYXRlZEF0XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY2xpZW50W2tJbnRlcm5hbDNdLmh0dHBDbGllbnQuYWRkUmVhY3Rpb24oeyByb29tSWQsIHRocmVhZElkLCBjb21tZW50SWQsIGVtb2ppIH0pLnRoZW4oXG4gICAgICAgIChhZGRlZFJlYWN0aW9uKSA9PiB7XG4gICAgICAgICAgc3RvcmUuYWRkUmVhY3Rpb24oXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICAgICAgIGNvbW1lbnRJZCxcbiAgICAgICAgICAgIGFkZGVkUmVhY3Rpb24sXG4gICAgICAgICAgICBjcmVhdGVkQXRcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBvcHRpbWlzdGljSWQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJBRERfUkVBQ1RJT05fRVJST1JcIixcbiAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgZW1vamlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVyclxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbUlkXVxuICApO1xufVxuZnVuY3Rpb24gdXNlUmVtb3ZlUmVhY3Rpb24oKSB7XG4gIHJldHVybiB1c2VSZW1vdmVSb29tQ29tbWVudFJlYWN0aW9uKHVzZVJvb20oKS5pZCk7XG59XG5mdW5jdGlvbiB1c2VSZW1vdmVSb29tQ29tbWVudFJlYWN0aW9uKHJvb21JZCkge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrMyhcbiAgICAoeyB0aHJlYWRJZCwgY29tbWVudElkLCBlbW9qaSB9KSA9PiB7XG4gICAgICBjb25zdCB1c2VySWQgPSBnZXRDdXJyZW50VXNlcklkKGNsaWVudCk7XG4gICAgICBjb25zdCByZW1vdmVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljSWQgPSBzdG9yZS5vcHRpbWlzdGljVXBkYXRlcy5hZGQoe1xuICAgICAgICB0eXBlOiBcInJlbW92ZS1yZWFjdGlvblwiLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgY29tbWVudElkLFxuICAgICAgICBlbW9qaSxcbiAgICAgICAgdXNlcklkLFxuICAgICAgICByZW1vdmVkQXRcbiAgICAgIH0pO1xuICAgICAgY2xpZW50W2tJbnRlcm5hbDNdLmh0dHBDbGllbnQucmVtb3ZlUmVhY3Rpb24oeyByb29tSWQsIHRocmVhZElkLCBjb21tZW50SWQsIGVtb2ppIH0pLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBzdG9yZS5yZW1vdmVSZWFjdGlvbihcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgb3B0aW1pc3RpY0lkLFxuICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgZW1vamksXG4gICAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgICByZW1vdmVkQXRcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBvcHRpbWlzdGljSWQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJSRU1PVkVfUkVBQ1RJT05fRVJST1JcIixcbiAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgY29tbWVudElkLFxuICAgICAgICAgICAgZW1vamlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVyclxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbUlkXVxuICApO1xufVxuZnVuY3Rpb24gdXNlTWFya1RocmVhZEFzUmVhZCgpIHtcbiAgcmV0dXJuIHVzZU1hcmtSb29tVGhyZWFkQXNSZWFkKHVzZVJvb20oKS5pZCk7XG59XG5mdW5jdGlvbiB1c2VNYXJrUm9vbVRocmVhZEFzUmVhZChyb29tSWQpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIHJldHVybiB1c2VDYWxsYmFjazMoXG4gICAgKHRocmVhZElkKSA9PiB7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3QgaW5ib3hOb3RpZmljYXRpb24gPSBPYmplY3QudmFsdWVzKFxuICAgICAgICBzdG9yZS5vdXRwdXRzLm5vdGlmaWNhdGlvbnMuZ2V0KCkubm90aWZpY2F0aW9uc0J5SWRcbiAgICAgICkuZmluZChcbiAgICAgICAgKGluYm94Tm90aWZpY2F0aW9uMikgPT4gaW5ib3hOb3RpZmljYXRpb24yLmtpbmQgPT09IFwidGhyZWFkXCIgJiYgaW5ib3hOb3RpZmljYXRpb24yLnRocmVhZElkID09PSB0aHJlYWRJZFxuICAgICAgKTtcbiAgICAgIGlmICghaW5ib3hOb3RpZmljYXRpb24pIHJldHVybjtcbiAgICAgIGNvbnN0IG5vdyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgICAgdHlwZTogXCJtYXJrLWluYm94LW5vdGlmaWNhdGlvbi1hcy1yZWFkXCIsXG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uSWQ6IGluYm94Tm90aWZpY2F0aW9uLmlkLFxuICAgICAgICByZWFkQXQ6IG5vd1xuICAgICAgfSk7XG4gICAgICBjbGllbnRba0ludGVybmFsM10uaHR0cENsaWVudC5tYXJrUm9vbUluYm94Tm90aWZpY2F0aW9uQXNSZWFkKHtcbiAgICAgICAgcm9vbUlkLFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbklkOiBpbmJveE5vdGlmaWNhdGlvbi5pZFxuICAgICAgfSkudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHN0b3JlLm1hcmtJbmJveE5vdGlmaWNhdGlvblJlYWQoXG4gICAgICAgICAgICBpbmJveE5vdGlmaWNhdGlvbi5pZCxcbiAgICAgICAgICAgIG5vdyxcbiAgICAgICAgICAgIG9wdGltaXN0aWNJZFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJNQVJLX0lOQk9YX05PVElGSUNBVElPTl9BU19SRUFEX0VSUk9SXCIsXG4gICAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgICAgaW5ib3hOb3RpZmljYXRpb25JZDogaW5ib3hOb3RpZmljYXRpb24uaWRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21JZF1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZU1hcmtUaHJlYWRBc1Jlc29sdmVkKCkge1xuICByZXR1cm4gdXNlTWFya1Jvb21UaHJlYWRBc1Jlc29sdmVkKHVzZVJvb20oKS5pZCk7XG59XG5mdW5jdGlvbiB1c2VNYXJrUm9vbVRocmVhZEFzUmVzb2x2ZWQocm9vbUlkKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2szKFxuICAgICh0aHJlYWRJZCkgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgICAgdHlwZTogXCJtYXJrLXRocmVhZC1hcy1yZXNvbHZlZFwiLFxuICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgdXBkYXRlZEF0XG4gICAgICB9KTtcbiAgICAgIGNsaWVudFtrSW50ZXJuYWwzXS5odHRwQ2xpZW50Lm1hcmtUaHJlYWRBc1Jlc29sdmVkKHsgcm9vbUlkLCB0aHJlYWRJZCB9KS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUucGF0Y2hUaHJlYWQoXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICAgICAgIHsgcmVzb2x2ZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIHVwZGF0ZWRBdFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICAgICB7IHR5cGU6IFwiTUFSS19USFJFQURfQVNfUkVTT0xWRURfRVJST1JcIiwgcm9vbUlkLCB0aHJlYWRJZCB9LFxuICAgICAgICAgIGVyclxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbUlkXVxuICApO1xufVxuZnVuY3Rpb24gdXNlTWFya1RocmVhZEFzVW5yZXNvbHZlZCgpIHtcbiAgcmV0dXJuIHVzZU1hcmtSb29tVGhyZWFkQXNVbnJlc29sdmVkKHVzZVJvb20oKS5pZCk7XG59XG5mdW5jdGlvbiB1c2VNYXJrUm9vbVRocmVhZEFzVW5yZXNvbHZlZChyb29tSWQpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIHJldHVybiB1c2VDYWxsYmFjazMoXG4gICAgKHRocmVhZElkKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IHsgc3RvcmUsIG9uTXV0YXRpb25GYWlsdXJlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gICAgICBjb25zdCBvcHRpbWlzdGljSWQgPSBzdG9yZS5vcHRpbWlzdGljVXBkYXRlcy5hZGQoe1xuICAgICAgICB0eXBlOiBcIm1hcmstdGhyZWFkLWFzLXVucmVzb2x2ZWRcIixcbiAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgIHVwZGF0ZWRBdFxuICAgICAgfSk7XG4gICAgICBjbGllbnRba0ludGVybmFsM10uaHR0cENsaWVudC5tYXJrVGhyZWFkQXNVbnJlc29sdmVkKHsgcm9vbUlkLCB0aHJlYWRJZCB9KS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc3RvcmUucGF0Y2hUaHJlYWQoXG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICAgICAgIHsgcmVzb2x2ZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICB1cGRhdGVkQXRcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiBvbk11dGF0aW9uRmFpbHVyZShcbiAgICAgICAgICBvcHRpbWlzdGljSWQsXG4gICAgICAgICAgeyB0eXBlOiBcIk1BUktfVEhSRUFEX0FTX1VOUkVTT0xWRURfRVJST1JcIiwgcm9vbUlkLCB0aHJlYWRJZCB9LFxuICAgICAgICAgIGVyclxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG4gICAgW2NsaWVudCwgcm9vbUlkXVxuICApO1xufVxuZnVuY3Rpb24gdXNlVGhyZWFkU3Vic2NyaXB0aW9uKHRocmVhZElkKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCB7IHN0b3JlIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IHNpZ25hbCA9IHN0b3JlLm91dHB1dHMudGhyZWFkaWZpY2F0aW9ucztcbiAgY29uc3Qgc2VsZWN0b3IgPSB1c2VDYWxsYmFjazMoXG4gICAgKHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBub3RpZmljYXRpb24gPSBzdGF0ZS5zb3J0ZWROb3RpZmljYXRpb25zLmZpbmQoXG4gICAgICAgIChpbmJveE5vdGlmaWNhdGlvbikgPT4gaW5ib3hOb3RpZmljYXRpb24ua2luZCA9PT0gXCJ0aHJlYWRcIiAmJiBpbmJveE5vdGlmaWNhdGlvbi50aHJlYWRJZCA9PT0gdGhyZWFkSWRcbiAgICAgICk7XG4gICAgICBjb25zdCB0aHJlYWQgPSBzdGF0ZS50aHJlYWRzREIuZ2V0KHRocmVhZElkKTtcbiAgICAgIGlmIChub3RpZmljYXRpb24gPT09IHZvaWQgMCB8fCB0aHJlYWQgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwibm90LXN1YnNjcmliZWRcIiB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiBcInN1YnNjcmliZWRcIixcbiAgICAgICAgdW5yZWFkU2luY2U6IG5vdGlmaWNhdGlvbi5yZWFkQXRcbiAgICAgIH07XG4gICAgfSxcbiAgICBbdGhyZWFkSWRdXG4gICk7XG4gIHJldHVybiB1c2VTaWduYWwoc2lnbmFsLCBzZWxlY3Rvciwgc2hhbGxvdzUpO1xufVxuZnVuY3Rpb24gdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKCkge1xuICBjb25zdCB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MgPSB1c2VVcGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MoKTtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHsgc3RvcmUsIGdldE9yQ3JlYXRlTm90aWZpY2F0aW9uc1NldHRpbmdzUG9sbGVyRm9yUm9vbUlkIH0gPSBnZXRSb29tRXh0cmFzRm9yQ2xpZW50KGNsaWVudCk7XG4gIGNvbnN0IHBvbGxlciA9IGdldE9yQ3JlYXRlTm90aWZpY2F0aW9uc1NldHRpbmdzUG9sbGVyRm9yUm9vbUlkKHJvb20uaWQpO1xuICB1c2VFZmZlY3Q1KFxuICAgICgpID0+IHZvaWQgc3RvcmUub3V0cHV0cy5zZXR0aW5nc0J5Um9vbUlkLmdldE9yQ3JlYXRlKHJvb20uaWQpLndhaXRVbnRpbExvYWRlZCgpXG4gICAgLy8gTk9URTogRGVsaWJlcmF0ZWx5ICpub3QqIHVzaW5nIGEgZGVwZW5kZW5jeSBhcnJheSBoZXJlIVxuICAgIC8vXG4gICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIGNhbGwgd2FpdFVudGlsIG9uICpldmVyeSogcmVuZGVyLlxuICAgIC8vIFRoaXMgaXMgaGFybWxlc3MgdGhvdWdoLCBvbiBtb3N0IHJlbmRlcnMsIGV4Y2VwdDpcbiAgICAvLyAxLiBUaGUgdmVyeSBmaXJzdCByZW5kZXIsIGluIHdoaWNoIGNhc2Ugd2UnbGwgd2FudCB0byB0cmlnZ2VyIHRoZSBpbml0aWFsIHBhZ2UgZmV0Y2guXG4gICAgLy8gMi4gQWxsIG90aGVyIHN1YnNlcXVlbnQgcmVuZGVycyBub3cgXCJqdXN0XCIgcmV0dXJuIHRoZSBzYW1lIHByb21pc2UgKGEgcXVpY2sgb3BlcmF0aW9uKS5cbiAgICAvLyAzLiBJZiBldmVyIHRoZSBwcm9taXNlIHdvdWxkIGZhaWwsIHRoZW4gYWZ0ZXIgNSBzZWNvbmRzIGl0IHdvdWxkIHJlc2V0LCBhbmQgb24gdGhlIHZlcnlcbiAgICAvLyAgICAqbmV4dCogcmVuZGVyIGFmdGVyIHRoYXQsIGEgKm5ldyogZmV0Y2gvcHJvbWlzZSB3aWxsIGdldCBjcmVhdGVkLlxuICApO1xuICB1c2VFZmZlY3Q1KCgpID0+IHtcbiAgICBwb2xsZXIuaW5jKCk7XG4gICAgcG9sbGVyLnBvbGxOb3dJZlN0YWxlKCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBvbGxlci5kZWMoKTtcbiAgICB9O1xuICB9LCBbcG9sbGVyXSk7XG4gIGNvbnN0IHNldHRpbmdzID0gdXNlU2lnbmFsKFxuICAgIHN0b3JlLm91dHB1dHMuc2V0dGluZ3NCeVJvb21JZC5nZXRPckNyZWF0ZShyb29tLmlkKS5zaWduYWxcbiAgKTtcbiAgcmV0dXJuIHVzZU1lbW8zKCgpID0+IHtcbiAgICByZXR1cm4gW3NldHRpbmdzLCB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NdO1xuICB9LCBbc2V0dGluZ3MsIHVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nc10pO1xufVxuZnVuY3Rpb24gdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzU3VzcGVuc2UoKSB7XG4gIGVuc3VyZU5vdFNlcnZlclNpZGUoKTtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHN0b3JlID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpLnN0b3JlO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICB1c2Uoc3RvcmUub3V0cHV0cy5zZXR0aW5nc0J5Um9vbUlkLmdldE9yQ3JlYXRlKHJvb20uaWQpLndhaXRVbnRpbExvYWRlZCgpKTtcbiAgY29uc3QgW3NldHRpbmdzLCB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NdID0gdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzKCk7XG4gIGFzc2VydDIoIXNldHRpbmdzLmVycm9yLCBcIkRpZCBub3QgZXhwZWN0IGVycm9yXCIpO1xuICBhc3NlcnQyKCFzZXR0aW5ncy5pc0xvYWRpbmcsIFwiRGlkIG5vdCBleHBlY3QgbG9hZGluZ1wiKTtcbiAgcmV0dXJuIHVzZU1lbW8zKCgpID0+IHtcbiAgICByZXR1cm4gW3NldHRpbmdzLCB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NdO1xuICB9LCBbc2V0dGluZ3MsIHVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5nc10pO1xufVxuZnVuY3Rpb24gdXNlSGlzdG9yeVZlcnNpb25EYXRhKHZlcnNpb25JZCkge1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlMih7XG4gICAgaXNMb2FkaW5nOiB0cnVlXG4gIH0pO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICB1c2VFZmZlY3Q1KCgpID0+IHtcbiAgICBzZXRTdGF0ZSh7IGlzTG9hZGluZzogdHJ1ZSB9KTtcbiAgICBjb25zdCBsb2FkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByb29tW2tJbnRlcm5hbDNdLmdldFRleHRWZXJzaW9uKHZlcnNpb25JZCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICBkYXRhXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCB3aGlsZSBsb2FkaW5nIHRoaXMgdmVyc2lvblwiXG4gICAgICAgICAgKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZvaWQgbG9hZCgpO1xuICB9LCBbcm9vbSwgdmVyc2lvbklkXSk7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIHVzZUhpc3RvcnlWZXJzaW9ucygpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIGNvbnN0IHsgc3RvcmUsIGdldE9yQ3JlYXRlVmVyc2lvbnNQb2xsZXJGb3JSb29tSWQgfSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KTtcbiAgY29uc3QgcG9sbGVyID0gZ2V0T3JDcmVhdGVWZXJzaW9uc1BvbGxlckZvclJvb21JZChyb29tLmlkKTtcbiAgdXNlRWZmZWN0NSgoKSA9PiB7XG4gICAgcG9sbGVyLmluYygpO1xuICAgIHBvbGxlci5wb2xsTm93SWZTdGFsZSgpO1xuICAgIHJldHVybiAoKSA9PiBwb2xsZXIuZGVjKCk7XG4gIH0sIFtwb2xsZXJdKTtcbiAgdXNlRWZmZWN0NShcbiAgICAoKSA9PiB2b2lkIHN0b3JlLm91dHB1dHMudmVyc2lvbnNCeVJvb21JZC5nZXRPckNyZWF0ZShyb29tLmlkKS53YWl0VW50aWxMb2FkZWQoKVxuICAgIC8vIE5PVEU6IERlbGliZXJhdGVseSAqbm90KiB1c2luZyBhIGRlcGVuZGVuY3kgYXJyYXkgaGVyZSFcbiAgICAvL1xuICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byBjYWxsIHdhaXRVbnRpbCBvbiAqZXZlcnkqIHJlbmRlci5cbiAgICAvLyBUaGlzIGlzIGhhcm1sZXNzIHRob3VnaCwgb24gbW9zdCByZW5kZXJzLCBleGNlcHQ6XG4gICAgLy8gMS4gVGhlIHZlcnkgZmlyc3QgcmVuZGVyLCBpbiB3aGljaCBjYXNlIHdlJ2xsIHdhbnQgdG8gdHJpZ2dlciB0aGUgaW5pdGlhbCBwYWdlIGZldGNoLlxuICAgIC8vIDIuIEFsbCBvdGhlciBzdWJzZXF1ZW50IHJlbmRlcnMgbm93IFwianVzdFwiIHJldHVybiB0aGUgc2FtZSBwcm9taXNlIChhIHF1aWNrIG9wZXJhdGlvbikuXG4gICAgLy8gMy4gSWYgZXZlciB0aGUgcHJvbWlzZSB3b3VsZCBmYWlsLCB0aGVuIGFmdGVyIDUgc2Vjb25kcyBpdCB3b3VsZCByZXNldCwgYW5kIG9uIHRoZSB2ZXJ5XG4gICAgLy8gICAgKm5leHQqIHJlbmRlciBhZnRlciB0aGF0LCBhICpuZXcqIGZldGNoL3Byb21pc2Ugd2lsbCBnZXQgY3JlYXRlZC5cbiAgKTtcbiAgcmV0dXJuIHVzZVNpZ25hbChzdG9yZS5vdXRwdXRzLnZlcnNpb25zQnlSb29tSWQuZ2V0T3JDcmVhdGUocm9vbS5pZCkuc2lnbmFsKTtcbn1cbmZ1bmN0aW9uIHVzZUhpc3RvcnlWZXJzaW9uc1N1c3BlbnNlKCkge1xuICBlbnN1cmVOb3RTZXJ2ZXJTaWRlKCk7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCBzdG9yZSA9IGdldFJvb21FeHRyYXNGb3JDbGllbnQoY2xpZW50KS5zdG9yZTtcbiAgdXNlKHN0b3JlLm91dHB1dHMudmVyc2lvbnNCeVJvb21JZC5nZXRPckNyZWF0ZShyb29tLmlkKS53YWl0VW50aWxMb2FkZWQoKSk7XG4gIGNvbnN0IHJlc3VsdCA9IHVzZUhpc3RvcnlWZXJzaW9ucygpO1xuICBhc3NlcnQyKCFyZXN1bHQuZXJyb3IsIFwiRGlkIG5vdCBleHBlY3QgZXJyb3JcIik7XG4gIGFzc2VydDIoIXJlc3VsdC5pc0xvYWRpbmcsIFwiRGlkIG5vdCBleHBlY3QgbG9hZGluZ1wiKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHVzZVVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncygpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHJldHVybiB1c2VDYWxsYmFjazMoXG4gICAgKHNldHRpbmdzKSA9PiB7XG4gICAgICBjb25zdCB7IHN0b3JlLCBvbk11dGF0aW9uRmFpbHVyZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICAgICAgY29uc3Qgb3B0aW1pc3RpY0lkID0gc3RvcmUub3B0aW1pc3RpY1VwZGF0ZXMuYWRkKHtcbiAgICAgICAgdHlwZTogXCJ1cGRhdGUtbm90aWZpY2F0aW9uLXNldHRpbmdzXCIsXG4gICAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgICAgc2V0dGluZ3NcbiAgICAgIH0pO1xuICAgICAgcm9vbS51cGRhdGVOb3RpZmljYXRpb25TZXR0aW5ncyhzZXR0aW5ncykudGhlbihcbiAgICAgICAgKHNldHRpbmdzMikgPT4ge1xuICAgICAgICAgIHN0b3JlLnVwZGF0ZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyhyb29tLmlkLCBvcHRpbWlzdGljSWQsIHNldHRpbmdzMik7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnIpID0+IG9uTXV0YXRpb25GYWlsdXJlKFxuICAgICAgICAgIG9wdGltaXN0aWNJZCxcbiAgICAgICAgICB7IHR5cGU6IFwiVVBEQVRFX05PVElGSUNBVElPTl9TRVRUSU5HU19FUlJPUlwiLCByb29tSWQ6IHJvb20uaWQgfSxcbiAgICAgICAgICBlcnJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtjbGllbnQsIHJvb21dXG4gICk7XG59XG5mdW5jdGlvbiB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZVJlYWR5KCkge1xuICBlbnN1cmVOb3RTZXJ2ZXJTaWRlKCk7XG4gIGNvbnN0IHJvb20gPSB1c2VSb29tKCk7XG4gIHVzZShyb29tLndhaXRVbnRpbFByZXNlbmNlUmVhZHkoKSk7XG59XG5mdW5jdGlvbiB1c2VTZWxmU3VzcGVuc2Uoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgdXNlU3VzcGVuZFVudGlsUHJlc2VuY2VSZWFkeSgpO1xuICByZXR1cm4gdXNlU2VsZihcbiAgICBzZWxlY3RvcixcbiAgICBpc0VxdWFsXG4gICk7XG59XG5mdW5jdGlvbiB1c2VPdGhlcnNTdXNwZW5zZShzZWxlY3RvciwgaXNFcXVhbCkge1xuICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZVJlYWR5KCk7XG4gIHJldHVybiB1c2VPdGhlcnMoXG4gICAgc2VsZWN0b3IsXG4gICAgaXNFcXVhbFxuICApO1xufVxuZnVuY3Rpb24gdXNlT3RoZXJzQ29ubmVjdGlvbklkc1N1c3BlbnNlKCkge1xuICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZVJlYWR5KCk7XG4gIHJldHVybiB1c2VPdGhlcnNDb25uZWN0aW9uSWRzKCk7XG59XG5mdW5jdGlvbiB1c2VPdGhlcnNNYXBwZWRTdXNwZW5zZShpdGVtU2VsZWN0b3IsIGl0ZW1Jc0VxdWFsKSB7XG4gIHVzZVN1c3BlbmRVbnRpbFByZXNlbmNlUmVhZHkoKTtcbiAgcmV0dXJuIHVzZU90aGVyc01hcHBlZChpdGVtU2VsZWN0b3IsIGl0ZW1Jc0VxdWFsKTtcbn1cbmZ1bmN0aW9uIHVzZU90aGVyU3VzcGVuc2UoY29ubmVjdGlvbklkLCBzZWxlY3RvciwgaXNFcXVhbCkge1xuICB1c2VTdXNwZW5kVW50aWxQcmVzZW5jZVJlYWR5KCk7XG4gIHJldHVybiB1c2VPdGhlcihjb25uZWN0aW9uSWQsIHNlbGVjdG9yLCBpc0VxdWFsKTtcbn1cbmZ1bmN0aW9uIHVzZVN1c3BlbmRVbnRpbFN0b3JhZ2VSZWFkeSgpIHtcbiAgZW5zdXJlTm90U2VydmVyU2lkZSgpO1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICB1c2Uocm9vbS53YWl0VW50aWxTdG9yYWdlUmVhZHkoKSk7XG59XG5mdW5jdGlvbiB1c2VTdG9yYWdlU3VzcGVuc2Uoc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgdXNlU3VzcGVuZFVudGlsU3RvcmFnZVJlYWR5KCk7XG4gIHJldHVybiB1c2VTdG9yYWdlKFxuICAgIHNlbGVjdG9yLFxuICAgIGlzRXF1YWxcbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZVN0b3JhZ2VTdGF0dXNTdXNwZW5zZShvcHRpb25zKSB7XG4gIHVzZVN1c3BlbmRVbnRpbFN0b3JhZ2VSZWFkeSgpO1xuICByZXR1cm4gdXNlU3RvcmFnZVN0YXR1cyhvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHVzZVRocmVhZHNTdXNwZW5zZShvcHRpb25zID0ge30pIHtcbiAgZW5zdXJlTm90U2VydmVyU2lkZSgpO1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3Qgcm9vbSA9IHVzZVJvb20oKTtcbiAgY29uc3QgeyBzdG9yZSB9ID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpO1xuICBjb25zdCBxdWVyeUtleSA9IG1ha2VSb29tVGhyZWFkc1F1ZXJ5S2V5KHJvb20uaWQsIG9wdGlvbnMucXVlcnkpO1xuICB1c2Uoc3RvcmUub3V0cHV0cy5sb2FkaW5nUm9vbVRocmVhZHMuZ2V0T3JDcmVhdGUocXVlcnlLZXkpLndhaXRVbnRpbExvYWRlZCgpKTtcbiAgY29uc3QgcmVzdWx0ID0gdXNlVGhyZWFkcyhvcHRpb25zKTtcbiAgYXNzZXJ0MighcmVzdWx0LmVycm9yLCBcIkRpZCBub3QgZXhwZWN0IGVycm9yXCIpO1xuICBhc3NlcnQyKCFyZXN1bHQuaXNMb2FkaW5nLCBcIkRpZCBub3QgZXhwZWN0IGxvYWRpbmdcIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzZWxlY3RvckZvcl91c2VBdHRhY2htZW50VXJsKHN0YXRlKSB7XG4gIGlmIChzdGF0ZSA9PT0gdm9pZCAwIHx8IHN0YXRlPy5pc0xvYWRpbmcpIHtcbiAgICByZXR1cm4gc3RhdGUgPz8geyBpc0xvYWRpbmc6IHRydWUgfTtcbiAgfVxuICBpZiAoc3RhdGUuZXJyb3IpIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgYXNzZXJ0MihzdGF0ZS5kYXRhICE9PSB2b2lkIDAsIFwiVW5leHBlY3RlZCBtaXNzaW5nIGF0dGFjaG1lbnQgVVJMXCIpO1xuICByZXR1cm4ge1xuICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgdXJsOiBzdGF0ZS5kYXRhXG4gIH07XG59XG5mdW5jdGlvbiB1c2VBdHRhY2htZW50VXJsKGF0dGFjaG1lbnRJZCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICByZXR1cm4gdXNlUm9vbUF0dGFjaG1lbnRVcmwoYXR0YWNobWVudElkLCByb29tLmlkKTtcbn1cbmZ1bmN0aW9uIHVzZVJvb21BdHRhY2htZW50VXJsKGF0dGFjaG1lbnRJZCwgcm9vbUlkKSB7XG4gIGNvbnN0IGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICBjb25zdCBzdG9yZSA9IGNsaWVudFtrSW50ZXJuYWwzXS5odHRwQ2xpZW50LmdldE9yQ3JlYXRlQXR0YWNobWVudFVybHNTdG9yZShyb29tSWQpO1xuICBjb25zdCBnZXRBdHRhY2htZW50VXJsU3RhdGUgPSB1c2VDYWxsYmFjazMoXG4gICAgKCkgPT4gc3RvcmUuZ2V0SXRlbVN0YXRlKGF0dGFjaG1lbnRJZCksXG4gICAgW3N0b3JlLCBhdHRhY2htZW50SWRdXG4gICk7XG4gIHVzZUVmZmVjdDUoKCkgPT4ge1xuICAgIHZvaWQgc3RvcmUuZW5xdWV1ZShhdHRhY2htZW50SWQpO1xuICB9LCBbc3RvcmUsIGF0dGFjaG1lbnRJZF0pO1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgc3RvcmUuc3Vic2NyaWJlLFxuICAgIGdldEF0dGFjaG1lbnRVcmxTdGF0ZSxcbiAgICBnZXRBdHRhY2htZW50VXJsU3RhdGUsXG4gICAgc2VsZWN0b3JGb3JfdXNlQXR0YWNobWVudFVybCxcbiAgICBzaGFsbG93NVxuICApO1xufVxuZnVuY3Rpb24gdXNlQXR0YWNobWVudFVybFN1c3BlbnNlKGF0dGFjaG1lbnRJZCkge1xuICBjb25zdCByb29tID0gdXNlUm9vbSgpO1xuICBjb25zdCB7IGF0dGFjaG1lbnRVcmxzU3RvcmUgfSA9IHJvb21ba0ludGVybmFsM107XG4gIGNvbnN0IGdldEF0dGFjaG1lbnRVcmxTdGF0ZSA9IHVzZUNhbGxiYWNrMyhcbiAgICAoKSA9PiBhdHRhY2htZW50VXJsc1N0b3JlLmdldEl0ZW1TdGF0ZShhdHRhY2htZW50SWQpLFxuICAgIFthdHRhY2htZW50VXJsc1N0b3JlLCBhdHRhY2htZW50SWRdXG4gICk7XG4gIGNvbnN0IGF0dGFjaG1lbnRVcmxTdGF0ZSA9IGdldEF0dGFjaG1lbnRVcmxTdGF0ZSgpO1xuICBpZiAoIWF0dGFjaG1lbnRVcmxTdGF0ZSB8fCBhdHRhY2htZW50VXJsU3RhdGUuaXNMb2FkaW5nKSB7XG4gICAgdGhyb3cgYXR0YWNobWVudFVybHNTdG9yZS5lbnF1ZXVlKGF0dGFjaG1lbnRJZCk7XG4gIH1cbiAgaWYgKGF0dGFjaG1lbnRVcmxTdGF0ZS5lcnJvcikge1xuICAgIHRocm93IGF0dGFjaG1lbnRVcmxTdGF0ZS5lcnJvcjtcbiAgfVxuICBjb25zdCBzdGF0ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlMyhcbiAgICBhdHRhY2htZW50VXJsc1N0b3JlLnN1YnNjcmliZSxcbiAgICBnZXRBdHRhY2htZW50VXJsU3RhdGUsXG4gICAgZ2V0QXR0YWNobWVudFVybFN0YXRlXG4gICk7XG4gIGFzc2VydDIoc3RhdGUgIT09IHZvaWQgMCwgXCJVbmV4cGVjdGVkIG1pc3Npbmcgc3RhdGVcIik7XG4gIGFzc2VydDIoIXN0YXRlLmlzTG9hZGluZywgXCJVbmV4cGVjdGVkIGxvYWRpbmcgc3RhdGVcIik7XG4gIGFzc2VydDIoIXN0YXRlLmVycm9yLCBcIlVuZXhwZWN0ZWQgZXJyb3Igc3RhdGVcIik7XG4gIHJldHVybiB7XG4gICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICB1cmw6IHN0YXRlLmRhdGEsXG4gICAgZXJyb3I6IHZvaWQgMFxuICB9O1xufVxudmFyIE5PX1BFUk1JU1NJT05TID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbmZ1bmN0aW9uIHVzZVJvb21QZXJtaXNzaW9ucyhyb29tSWQpIHtcbiAgY29uc3QgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIGNvbnN0IHN0b3JlID0gZ2V0Um9vbUV4dHJhc0ZvckNsaWVudChjbGllbnQpLnN0b3JlO1xuICByZXR1cm4gdXNlU2lnbmFsKFxuICAgIHN0b3JlLnBlcm1pc3Npb25IaW50cy5zaWduYWwsXG4gICAgKGhpbnRzKSA9PiBoaW50cy5nZXQocm9vbUlkKSA/PyBOT19QRVJNSVNTSU9OU1xuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlUm9vbUNvbnRleHQoY2xpZW50KSB7XG4gIHJldHVybiBnZXRPckNyZWF0ZVJvb21Db250ZXh0QnVuZGxlKGNsaWVudCk7XG59XG52YXIgX1Jvb21Qcm92aWRlciA9IFJvb21Qcm92aWRlcjtcbnZhciBfdXNlQnJvYWRjYXN0RXZlbnQgPSB1c2VCcm9hZGNhc3RFdmVudDtcbnZhciBfdXNlT3RoZXJzTGlzdGVuZXIgPSB1c2VPdGhlcnNMaXN0ZW5lcjtcbnZhciBfdXNlUm9vbSA9IHVzZVJvb207XG52YXIgX3VzZUlzSW5zaWRlUm9vbSA9IHVzZUlzSW5zaWRlUm9vbTtcbnZhciBfdXNlQWRkUmVhY3Rpb24gPSB1c2VBZGRSZWFjdGlvbjtcbnZhciBfdXNlTXV0YXRpb24gPSB1c2VNdXRhdGlvbjtcbnZhciBfdXNlQ3JlYXRlVGhyZWFkID0gdXNlQ3JlYXRlVGhyZWFkO1xudmFyIF91c2VEZWxldGVUaHJlYWQgPSB1c2VEZWxldGVUaHJlYWQ7XG52YXIgX3VzZUVkaXRUaHJlYWRNZXRhZGF0YSA9IHVzZUVkaXRUaHJlYWRNZXRhZGF0YTtcbnZhciBfdXNlRXZlbnRMaXN0ZW5lciA9IHVzZUV2ZW50TGlzdGVuZXI7XG52YXIgX3VzZU15UHJlc2VuY2UgPSB1c2VNeVByZXNlbmNlO1xudmFyIF91c2VPdGhlcnNNYXBwZWQgPSB1c2VPdGhlcnNNYXBwZWQ7XG52YXIgX3VzZU90aGVyc01hcHBlZFN1c3BlbnNlID0gdXNlT3RoZXJzTWFwcGVkU3VzcGVuc2U7XG52YXIgX3VzZVRocmVhZHMgPSB1c2VUaHJlYWRzO1xudmFyIF91c2VUaHJlYWRzU3VzcGVuc2UgPSB1c2VUaHJlYWRzU3VzcGVuc2U7XG52YXIgX3VzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncyA9IHVzZVJvb21Ob3RpZmljYXRpb25TZXR0aW5ncztcbnZhciBfdXNlUm9vbU5vdGlmaWNhdGlvblNldHRpbmdzU3VzcGVuc2UgPSB1c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NTdXNwZW5zZTtcbnZhciBfdXNlSGlzdG9yeVZlcnNpb25zID0gdXNlSGlzdG9yeVZlcnNpb25zO1xudmFyIF91c2VIaXN0b3J5VmVyc2lvbnNTdXNwZW5zZSA9IHVzZUhpc3RvcnlWZXJzaW9uc1N1c3BlbnNlO1xudmFyIF91c2VPdGhlciA9IHVzZU90aGVyO1xuZnVuY3Rpb24gX3VzZU90aGVycyguLi5hcmdzKSB7XG4gIHJldHVybiB1c2VPdGhlcnMoLi4uYXJncyk7XG59XG52YXIgX3VzZU90aGVyU3VzcGVuc2UgPSB1c2VPdGhlclN1c3BlbnNlO1xuZnVuY3Rpb24gX3VzZU90aGVyc1N1c3BlbnNlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIHVzZU90aGVyc1N1c3BlbnNlKC4uLmFyZ3MpO1xufVxudmFyIF91c2VTdG9yYWdlID0gdXNlU3RvcmFnZTtcbnZhciBfdXNlU3RvcmFnZVN1c3BlbnNlID0gdXNlU3RvcmFnZVN1c3BlbnNlO1xuZnVuY3Rpb24gX3VzZVNlbGYoLi4uYXJncykge1xuICByZXR1cm4gdXNlU2VsZiguLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIF91c2VTZWxmU3VzcGVuc2UoLi4uYXJncykge1xuICByZXR1cm4gdXNlU2VsZlN1c3BlbnNlKC4uLmFyZ3MpO1xufVxudmFyIF91c2VTdG9yYWdlUm9vdCA9IHVzZVN0b3JhZ2VSb290O1xudmFyIF91c2VVcGRhdGVNeVByZXNlbmNlID0gdXNlVXBkYXRlTXlQcmVzZW5jZTtcblxuZXhwb3J0IHtcbiAgUm9vbUNvbnRleHQsXG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yLFxuICB1c2VTaWduYWwsXG4gIENsaWVudENvbnRleHQsXG4gIGdldFVtYnJlbGxhU3RvcmVGb3JDbGllbnQsXG4gIHVzZUNsaWVudE9yTnVsbCxcbiAgdXNlQ2xpZW50LFxuICBMaXZlYmxvY2tzUHJvdmlkZXIsXG4gIGNyZWF0ZUxpdmVibG9ja3NDb250ZXh0LFxuICB1c2VJbmJveE5vdGlmaWNhdGlvbnMsXG4gIHVzZUluYm94Tm90aWZpY2F0aW9uc1N1c3BlbnNlLFxuICB1c2VNYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLFxuICB1c2VNYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQsXG4gIHVzZURlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9ucyxcbiAgdXNlRGVsZXRlSW5ib3hOb3RpZmljYXRpb24sXG4gIHVzZVVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50LFxuICB1c2VVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudFN1c3BlbnNlLFxuICB1c2VOb3RpZmljYXRpb25TZXR0aW5ncyxcbiAgdXNlTm90aWZpY2F0aW9uU2V0dGluZ3NTdXNwZW5zZSxcbiAgdXNlVXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gIHVzZVJvb21JbmZvLFxuICB1c2VSb29tSW5mb1N1c3BlbnNlLFxuICBfdXNlSW5ib3hOb3RpZmljYXRpb25UaHJlYWQsXG4gIF91c2VVc2VyLFxuICBfdXNlVXNlclN1c3BlbnNlLFxuICBfdXNlVXNlclRocmVhZHNfZXhwZXJpbWVudGFsLFxuICBfdXNlVXNlclRocmVhZHNTdXNwZW5zZV9leHBlcmltZW50YWwsXG4gIHVzZVN5bmNTdGF0dXMsXG4gIHVzZUVycm9yTGlzdGVuZXIsXG4gIHVzZVN0YXR1cyxcbiAgdXNlUmVwb3J0VGV4dEVkaXRvcixcbiAgdXNlWWpzUHJvdmlkZXIsXG4gIHVzZUNyZWF0ZVRleHRNZW50aW9uLFxuICB1c2VEZWxldGVUZXh0TWVudGlvbixcbiAgdXNlUmVzb2x2ZU1lbnRpb25TdWdnZXN0aW9ucyxcbiAgdXNlTWVudGlvblN1Z2dlc3Rpb25zQ2FjaGUsXG4gIHVzZVN0b3JhZ2VTdGF0dXMsXG4gIHVzZUJhdGNoLFxuICB1c2VMb3N0Q29ubmVjdGlvbkxpc3RlbmVyLFxuICB1c2VIaXN0b3J5LFxuICB1c2VVbmRvLFxuICB1c2VSZWRvLFxuICB1c2VDYW5VbmRvLFxuICB1c2VDYW5SZWRvLFxuICB1c2VPdGhlcnNDb25uZWN0aW9uSWRzLFxuICB1c2VDcmVhdGVSb29tVGhyZWFkLFxuICB1c2VEZWxldGVSb29tVGhyZWFkLFxuICB1c2VFZGl0Um9vbVRocmVhZE1ldGFkYXRhLFxuICB1c2VDcmVhdGVDb21tZW50LFxuICB1c2VDcmVhdGVSb29tQ29tbWVudCxcbiAgdXNlRWRpdENvbW1lbnQsXG4gIHVzZUVkaXRSb29tQ29tbWVudCxcbiAgdXNlRGVsZXRlQ29tbWVudCxcbiAgdXNlRGVsZXRlUm9vbUNvbW1lbnQsXG4gIHVzZUFkZFJvb21Db21tZW50UmVhY3Rpb24sXG4gIHVzZVJlbW92ZVJlYWN0aW9uLFxuICB1c2VSZW1vdmVSb29tQ29tbWVudFJlYWN0aW9uLFxuICB1c2VNYXJrVGhyZWFkQXNSZWFkLFxuICB1c2VNYXJrUm9vbVRocmVhZEFzUmVhZCxcbiAgdXNlTWFya1RocmVhZEFzUmVzb2x2ZWQsXG4gIHVzZU1hcmtSb29tVGhyZWFkQXNSZXNvbHZlZCxcbiAgdXNlTWFya1RocmVhZEFzVW5yZXNvbHZlZCxcbiAgdXNlTWFya1Jvb21UaHJlYWRBc1VucmVzb2x2ZWQsXG4gIHVzZVRocmVhZFN1YnNjcmlwdGlvbixcbiAgdXNlSGlzdG9yeVZlcnNpb25EYXRhLFxuICB1c2VVcGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gIHVzZU90aGVyc0Nvbm5lY3Rpb25JZHNTdXNwZW5zZSxcbiAgdXNlU3RvcmFnZVN0YXR1c1N1c3BlbnNlLFxuICB1c2VBdHRhY2htZW50VXJsLFxuICB1c2VSb29tQXR0YWNobWVudFVybCxcbiAgdXNlQXR0YWNobWVudFVybFN1c3BlbnNlLFxuICB1c2VSb29tUGVybWlzc2lvbnMsXG4gIGNyZWF0ZVJvb21Db250ZXh0LFxuICBfUm9vbVByb3ZpZGVyLFxuICBfdXNlQnJvYWRjYXN0RXZlbnQsXG4gIF91c2VPdGhlcnNMaXN0ZW5lcixcbiAgX3VzZVJvb20sXG4gIF91c2VJc0luc2lkZVJvb20sXG4gIF91c2VBZGRSZWFjdGlvbixcbiAgX3VzZU11dGF0aW9uLFxuICBfdXNlQ3JlYXRlVGhyZWFkLFxuICBfdXNlRGVsZXRlVGhyZWFkLFxuICBfdXNlRWRpdFRocmVhZE1ldGFkYXRhLFxuICBfdXNlRXZlbnRMaXN0ZW5lcixcbiAgX3VzZU15UHJlc2VuY2UsXG4gIF91c2VPdGhlcnNNYXBwZWQsXG4gIF91c2VPdGhlcnNNYXBwZWRTdXNwZW5zZSxcbiAgX3VzZVRocmVhZHMsXG4gIF91c2VUaHJlYWRzU3VzcGVuc2UsXG4gIF91c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gIF91c2VSb29tTm90aWZpY2F0aW9uU2V0dGluZ3NTdXNwZW5zZSxcbiAgX3VzZUhpc3RvcnlWZXJzaW9ucyxcbiAgX3VzZUhpc3RvcnlWZXJzaW9uc1N1c3BlbnNlLFxuICBfdXNlT3RoZXIsXG4gIF91c2VPdGhlcnMsXG4gIF91c2VPdGhlclN1c3BlbnNlLFxuICBfdXNlT3RoZXJzU3VzcGVuc2UsXG4gIF91c2VTdG9yYWdlLFxuICBfdXNlU3RvcmFnZVN1c3BlbnNlLFxuICBfdXNlU2VsZixcbiAgX3VzZVNlbGZTdXNwZW5zZSxcbiAgX3VzZVN0b3JhZ2VSb290LFxuICBfdXNlVXBkYXRlTXlQcmVzZW5jZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLVVSVkJTWFlXLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react/dist/chunk-URVBSXYW.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/react/dist/chunk-XJJ7XDZK.js":
/*!***************************************************************!*\
  !*** ./node_modules/@liveblocks/react/dist/chunk-XJJ7XDZK.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientSideSuspense: () => (/* binding */ ClientSideSuspense),\n/* harmony export */   PKG_FORMAT: () => (/* binding */ PKG_FORMAT),\n/* harmony export */   PKG_NAME: () => (/* binding */ PKG_NAME),\n/* harmony export */   PKG_VERSION: () => (/* binding */ PKG_VERSION)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/react\";\nvar PKG_VERSION = \"2.22.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/ClientSideSuspense.tsx\n\n\nfunction ClientSideSuspense(props) {\n  const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    setMounted(true);\n  }, []);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, { fallback: props.fallback, children: mounted ? typeof props.children === \"function\" ? props.children() : props.children : props.fallback });\n}\n\n\n//# sourceMappingURL=chunk-XJJ7XDZK.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QvZGlzdC9jaHVuay1YSko3WERaSy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNzRDtBQUNkO0FBQ3hDO0FBQ0EsZ0NBQWdDLCtDQUFRO0FBQ3hDLEVBQUUsZ0RBQVM7QUFDWDtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsc0RBQUcsQ0FBQywyQ0FBUSxJQUFJLHlJQUF5STtBQUNsTDs7QUFPRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGVhcm4tcmwvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QvZGlzdC9jaHVuay1YSko3WERaSy5qcz8zMmI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgUEtHX05BTUUgPSBcIkBsaXZlYmxvY2tzL3JlYWN0XCI7XG52YXIgUEtHX1ZFUlNJT04gPSBcIjIuMjIuMFwiO1xudmFyIFBLR19GT1JNQVQgPSBcImVzbVwiO1xuXG4vLyBzcmMvQ2xpZW50U2lkZVN1c3BlbnNlLnRzeFxuaW1wb3J0IHsgU3VzcGVuc2UsIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuZnVuY3Rpb24gQ2xpZW50U2lkZVN1c3BlbnNlKHByb3BzKSB7XG4gIGNvbnN0IFttb3VudGVkLCBzZXRNb3VudGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRNb3VudGVkKHRydWUpO1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFN1c3BlbnNlLCB7IGZhbGxiYWNrOiBwcm9wcy5mYWxsYmFjaywgY2hpbGRyZW46IG1vdW50ZWQgPyB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIiA/IHByb3BzLmNoaWxkcmVuKCkgOiBwcm9wcy5jaGlsZHJlbiA6IHByb3BzLmZhbGxiYWNrIH0pO1xufVxuXG5leHBvcnQge1xuICBQS0dfTkFNRSxcbiAgUEtHX1ZFUlNJT04sXG4gIFBLR19GT1JNQVQsXG4gIENsaWVudFNpZGVTdXNwZW5zZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLVhKSjdYRFpLLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/react/dist/chunk-XJJ7XDZK.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@liveblocks/yjs/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@liveblocks/yjs/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LiveblocksYjsProvider: () => (/* binding */ LiveblocksYjsProvider),\n/* harmony export */   getYjsProviderForRoom: () => (/* binding */ getYjsProviderForRoom)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @liveblocks/core */ \"(ssr)/./node_modules/@liveblocks/core/dist/index.js\");\n/* harmony import */ var js_base64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js-base64 */ \"(ssr)/./node_modules/js-base64/base64.mjs\");\n/* harmony import */ var y_indexeddb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! y-indexeddb */ \"(ssr)/./node_modules/y-indexeddb/src/y-indexeddb.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n// src/index.ts\n\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/yjs\";\nvar PKG_VERSION = \"2.22.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/provider.ts\n\n\n\n// ../../node_modules/lib0/map.js\nvar create = () => /* @__PURE__ */ new Map();\nvar setIfUndefined = (map, key, createT) => {\n  let set = map.get(key);\n  if (set === void 0) {\n    map.set(key, set = createT());\n  }\n  return set;\n};\n\n// ../../node_modules/lib0/set.js\nvar create2 = () => /* @__PURE__ */ new Set();\n\n// ../../node_modules/lib0/array.js\nvar from = Array.from;\nvar isArray = Array.isArray;\n\n// ../../node_modules/lib0/observable.js\nvar Observable = class {\n  constructor() {\n    this._observers = create();\n  }\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on(name, f) {\n    setIfUndefined(this._observers, name, create2).add(f);\n  }\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once(name, f) {\n    const _f = (...args) => {\n      this.off(name, _f);\n      f(...args);\n    };\n    this.on(name, _f);\n  }\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off(name, f) {\n    const observers = this._observers.get(name);\n    if (observers !== void 0) {\n      observers.delete(f);\n      if (observers.size === 0) {\n        this._observers.delete(name);\n      }\n    }\n  }\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit(name, args) {\n    return from((this._observers.get(name) || create()).values()).forEach((f) => f(...args));\n  }\n  destroy() {\n    this._observers = create();\n  }\n};\n\n// src/provider.ts\n\n\n\n// src/awareness.ts\nvar Y_PRESENCE_KEY = \"__yjs\";\nvar Y_PRESENCE_ID_KEY = \"__yjs_clientid\";\nvar Awareness = class extends Observable {\n  room;\n  doc;\n  states = /* @__PURE__ */ new Map();\n  // used to map liveblock's ActorId to Yjs ClientID, both unique numbers representing a client\n  actorToClientMap = /* @__PURE__ */ new Map();\n  // Meta is used to keep track and timeout users who disconnect. Liveblocks provides this for us, so we don't need to\n  // manage it here. Unfortunately, it's expected to exist by various integrations, so it's an empty map.\n  meta = /* @__PURE__ */ new Map();\n  // _checkInterval this would hold a timer to remove users, but Liveblock's presence already handles this\n  // unfortunately it's typed by various integrations\n  _checkInterval = 0;\n  othersUnsub;\n  constructor(doc, room) {\n    super();\n    this.doc = doc;\n    this.room = room;\n    this.room.updatePresence({\n      [Y_PRESENCE_ID_KEY]: this.doc.clientID\n    });\n    this.othersUnsub = this.room.events.others.subscribe((event) => {\n      let updates;\n      if (event.type === \"leave\") {\n        const targetClientId = this.actorToClientMap.get(\n          event.user.connectionId\n        );\n        if (targetClientId !== void 0) {\n          updates = { added: [], updated: [], removed: [targetClientId] };\n        }\n        this.rebuildActorToClientMap(event.others);\n      }\n      if (event.type === \"enter\" || event.type === \"update\") {\n        this.rebuildActorToClientMap(event.others);\n        const targetClientId = this.actorToClientMap.get(\n          event.user.connectionId\n        );\n        if (targetClientId !== void 0) {\n          updates = {\n            added: event.type === \"enter\" ? [targetClientId] : [],\n            updated: event.type === \"update\" ? [targetClientId] : [],\n            removed: []\n          };\n        }\n      }\n      if (event.type === \"reset\") {\n        this.rebuildActorToClientMap(event.others);\n      }\n      if (updates !== void 0) {\n        this.emit(\"change\", [updates, \"presence\"]);\n        this.emit(\"update\", [updates, \"presence\"]);\n      }\n    });\n  }\n  rebuildActorToClientMap(others) {\n    this.actorToClientMap.clear();\n    others.forEach((user) => {\n      if (user.presence[Y_PRESENCE_ID_KEY] !== void 0) {\n        this.actorToClientMap.set(\n          user.connectionId,\n          user.presence[Y_PRESENCE_ID_KEY]\n        );\n      }\n    });\n  }\n  destroy() {\n    this.emit(\"destroy\", [this]);\n    this.othersUnsub();\n    this.setLocalState(null);\n    super.destroy();\n  }\n  getLocalState() {\n    const presence = this.room.getPresence();\n    if (Object.keys(presence).length === 0 || typeof presence[Y_PRESENCE_KEY] === \"undefined\") {\n      return null;\n    }\n    return presence[Y_PRESENCE_KEY];\n  }\n  setLocalState(state) {\n    const presence = this.room.getSelf()?.presence;\n    if (state === null) {\n      if (presence === void 0) {\n        return;\n      }\n      this.room.updatePresence({ ...presence, [Y_PRESENCE_KEY]: null });\n      this.emit(\"update\", [\n        { added: [], updated: [], removed: [this.doc.clientID] },\n        \"local\"\n      ]);\n      return;\n    }\n    const yPresence = presence?.[Y_PRESENCE_KEY];\n    const added = yPresence === void 0 ? [this.doc.clientID] : [];\n    const updated = yPresence === void 0 ? [] : [this.doc.clientID];\n    this.room.updatePresence({\n      [Y_PRESENCE_KEY]: {\n        ...yPresence || {},\n        ...state || {}\n      }\n    });\n    this.emit(\"update\", [{ added, updated, removed: [] }, \"local\"]);\n  }\n  setLocalStateField(field, value) {\n    const presence = this.room.getSelf()?.presence[Y_PRESENCE_KEY];\n    const update = { [field]: value };\n    this.room.updatePresence({\n      [Y_PRESENCE_KEY]: { ...presence || {}, ...update }\n    });\n  }\n  // Translate liveblocks presence to yjs awareness\n  getStates() {\n    const others = this.room.getOthers();\n    const states = others.reduce((acc, otherUser) => {\n      const otherPresence = otherUser.presence[Y_PRESENCE_KEY];\n      const otherClientId = otherUser.presence[Y_PRESENCE_ID_KEY];\n      if (otherPresence !== void 0 && otherClientId !== void 0) {\n        acc.set(otherClientId, otherPresence || {});\n      }\n      return acc;\n    }, /* @__PURE__ */ new Map());\n    const localPresence = this.room.getSelf()?.presence[Y_PRESENCE_KEY];\n    if (localPresence !== void 0) {\n      states.set(this.doc.clientID, localPresence);\n    }\n    return states;\n  }\n};\n\n// src/doc.ts\n\n\n\nvar yDocHandler = class extends Observable {\n  unsubscribers = [];\n  _synced = false;\n  doc;\n  updateRoomDoc;\n  fetchRoomDoc;\n  useV2Encoding;\n  constructor({\n    doc,\n    isRoot,\n    updateDoc,\n    fetchDoc,\n    useV2Encoding\n  }) {\n    super();\n    this.doc = doc;\n    this.useV2Encoding = useV2Encoding;\n    this.doc.on(useV2Encoding ? \"updateV2\" : \"update\", this.updateHandler);\n    this.updateRoomDoc = (update) => {\n      updateDoc(update, isRoot ? void 0 : this.doc.guid);\n    };\n    this.fetchRoomDoc = (vector) => {\n      fetchDoc(vector, isRoot ? void 0 : this.doc.guid);\n    };\n    this.syncDoc();\n  }\n  handleServerUpdate = ({\n    update,\n    stateVector,\n    readOnly,\n    v2\n  }) => {\n    const applyUpdate2 = v2 ? yjs__WEBPACK_IMPORTED_MODULE_0__.applyUpdateV2 : yjs__WEBPACK_IMPORTED_MODULE_0__.applyUpdate;\n    applyUpdate2(this.doc, update, \"backend\");\n    if (stateVector) {\n      if (!readOnly) {\n        try {\n          const encodeUpdate = this.useV2Encoding ? yjs__WEBPACK_IMPORTED_MODULE_0__.encodeStateAsUpdateV2 : yjs__WEBPACK_IMPORTED_MODULE_0__.encodeStateAsUpdate;\n          const localUpdate = encodeUpdate(\n            this.doc,\n            js_base64__WEBPACK_IMPORTED_MODULE_1__.Base64.toUint8Array(stateVector)\n          );\n          this.updateRoomDoc(localUpdate);\n        } catch (e) {\n          console.warn(e);\n        }\n      }\n      this.synced = true;\n    }\n  };\n  syncDoc = () => {\n    this.synced = false;\n    const encodedVector = js_base64__WEBPACK_IMPORTED_MODULE_1__.Base64.fromUint8Array(yjs__WEBPACK_IMPORTED_MODULE_0__.encodeStateVector(this.doc));\n    this.fetchRoomDoc(encodedVector);\n  };\n  // The sync'd property is required by some provider implementations\n  get synced() {\n    return this._synced;\n  }\n  set synced(state) {\n    if (this._synced !== state) {\n      this._synced = state;\n      this.emit(\"synced\", [state]);\n      this.emit(\"sync\", [state]);\n    }\n  }\n  updateHandler = (update, origin) => {\n    const isFromLocal = origin instanceof y_indexeddb__WEBPACK_IMPORTED_MODULE_2__.IndexeddbPersistence;\n    if (origin !== \"backend\" && !isFromLocal) {\n      this.updateRoomDoc(update);\n    }\n  };\n  destroy() {\n    this.doc.off(\"update\", this.updateHandler);\n    this.unsubscribers.forEach((unsub) => unsub());\n    this._observers = /* @__PURE__ */ new Map();\n    this.doc.destroy();\n  }\n};\n\n// src/provider.ts\nvar LiveblocksYjsProvider = class extends Observable {\n  room;\n  rootDoc;\n  options;\n  indexeddbProvider = null;\n  isPaused = false;\n  unsubscribers = [];\n  awareness;\n  rootDocHandler;\n  subdocHandlers = /* @__PURE__ */ new Map();\n  permanentUserData;\n  pending = [];\n  constructor(room, doc, options = {}) {\n    super();\n    this.rootDoc = doc;\n    this.room = room;\n    this.options = options;\n    this.rootDocHandler = new yDocHandler({\n      doc,\n      isRoot: true,\n      updateDoc: this.updateDoc,\n      fetchDoc: this.fetchDoc,\n      useV2Encoding: this.options.useV2Encoding_experimental ?? false\n    });\n    if (this.options.enablePermanentUserData) {\n      this.permanentUserData = new yjs__WEBPACK_IMPORTED_MODULE_0__.PermanentUserData(doc);\n    }\n    room[_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.kInternal].setYjsProvider(this);\n    this.awareness = new Awareness(this.rootDoc, this.room);\n    this.unsubscribers.push(\n      this.room.events.status.subscribe((status) => {\n        if (status === \"connected\") {\n          this.rootDocHandler.syncDoc();\n        } else {\n          this.rootDocHandler.synced = false;\n        }\n        this.emit(\"status\", [this.getStatus()]);\n      })\n    );\n    this.unsubscribers.push(\n      this.room.events.ydoc.subscribe((message) => {\n        const { type } = message;\n        if (type === _liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.ClientMsgCode.UPDATE_YDOC) {\n          return;\n        }\n        const { stateVector, update: updateStr, guid, v2 } = message;\n        const canWrite = this.room.getSelf()?.canWrite ?? true;\n        const update = js_base64__WEBPACK_IMPORTED_MODULE_1__.Base64.toUint8Array(updateStr);\n        let foundPendingUpdate = false;\n        const updateId = this.getUniqueUpdateId(update);\n        this.pending = this.pending.filter((pendingUpdate) => {\n          if (pendingUpdate === updateId) {\n            foundPendingUpdate = true;\n            return false;\n          }\n          return true;\n        });\n        if (!foundPendingUpdate) {\n          if (guid !== void 0) {\n            this.subdocHandlers.get(guid)?.handleServerUpdate({\n              update,\n              stateVector,\n              readOnly: !canWrite,\n              v2\n            });\n          } else {\n            this.rootDocHandler.handleServerUpdate({\n              update,\n              stateVector,\n              readOnly: !canWrite,\n              v2\n            });\n          }\n        }\n        this.emit(\"status\", [this.getStatus()]);\n      })\n    );\n    if (options.offlineSupport_experimental) {\n      this.setupOfflineSupport();\n    }\n    this.rootDocHandler.on(\"synced\", () => {\n      const state = this.rootDocHandler.synced;\n      for (const [_, handler] of this.subdocHandlers) {\n        handler.syncDoc();\n      }\n      this.emit(\"synced\", [state]);\n      this.emit(\"sync\", [state]);\n      this.emit(\"status\", [this.getStatus()]);\n    });\n    this.rootDoc.on(\"subdocs\", this.handleSubdocs);\n    this.syncDoc();\n  }\n  setupOfflineSupport = () => {\n    this.indexeddbProvider = new y_indexeddb__WEBPACK_IMPORTED_MODULE_2__.IndexeddbPersistence(\n      this.room.id,\n      this.rootDoc\n    );\n    const onIndexedDbSync = () => {\n      this.rootDocHandler.synced = true;\n    };\n    this.indexeddbProvider.on(\"synced\", onIndexedDbSync);\n    this.unsubscribers.push(() => {\n      this.indexeddbProvider?.off(\"synced\", onIndexedDbSync);\n    });\n  };\n  handleSubdocs = ({\n    loaded,\n    removed,\n    added\n  }) => {\n    loaded.forEach(this.createSubdocHandler);\n    if (this.options.autoloadSubdocs) {\n      for (const subdoc of added) {\n        if (!this.subdocHandlers.has(subdoc.guid)) {\n          subdoc.load();\n        }\n      }\n    }\n    for (const subdoc of removed) {\n      if (this.subdocHandlers.has(subdoc.guid)) {\n        this.subdocHandlers.get(subdoc.guid)?.destroy();\n        this.subdocHandlers.delete(subdoc.guid);\n      }\n    }\n  };\n  getUniqueUpdateId = (update) => {\n    const clock = (0,yjs__WEBPACK_IMPORTED_MODULE_0__.parseUpdateMeta)(update).to.get(this.rootDoc.clientID) ?? \"-1\";\n    return this.rootDoc.clientID + \":\" + clock;\n  };\n  updateDoc = (update, guid) => {\n    const canWrite = this.room.getSelf()?.canWrite ?? true;\n    if (canWrite && !this.isPaused) {\n      const updateId = this.getUniqueUpdateId(update);\n      this.pending.push(updateId);\n      this.room.updateYDoc(\n        js_base64__WEBPACK_IMPORTED_MODULE_1__.Base64.fromUint8Array(update),\n        guid,\n        this.useV2Encoding\n      );\n      this.emit(\"status\", [this.getStatus()]);\n    }\n  };\n  fetchDoc = (vector, guid) => {\n    this.room.fetchYDoc(vector, guid, this.useV2Encoding);\n  };\n  createSubdocHandler = (subdoc) => {\n    if (this.subdocHandlers.has(subdoc.guid)) {\n      this.subdocHandlers.get(subdoc.guid)?.syncDoc();\n      return;\n    }\n    const handler = new yDocHandler({\n      doc: subdoc,\n      isRoot: false,\n      updateDoc: this.updateDoc,\n      fetchDoc: this.fetchDoc,\n      useV2Encoding: this.options.useV2Encoding_experimental ?? false\n    });\n    this.subdocHandlers.set(subdoc.guid, handler);\n  };\n  // attempt to load a subdoc of a given guid\n  loadSubdoc = (guid) => {\n    for (const subdoc of this.rootDoc.subdocs) {\n      if (subdoc.guid === guid) {\n        subdoc.load();\n        return true;\n      }\n    }\n    return false;\n  };\n  syncDoc = () => {\n    this.rootDocHandler.syncDoc();\n    for (const [_, handler] of this.subdocHandlers) {\n      handler.syncDoc();\n    }\n  };\n  get useV2Encoding() {\n    return this.options.useV2Encoding_experimental ?? false;\n  }\n  // The sync'd property is required by some provider implementations\n  get synced() {\n    return this.rootDocHandler.synced;\n  }\n  async pause() {\n    await this.indexeddbProvider?.destroy();\n    this.indexeddbProvider = null;\n    this.isPaused = true;\n  }\n  unpause() {\n    this.isPaused = false;\n    if (this.options.offlineSupport_experimental) {\n      this.setupOfflineSupport();\n    }\n    this.rootDocHandler.syncDoc();\n  }\n  getStatus() {\n    if (!this.synced) {\n      return \"loading\";\n    }\n    return this.pending.length === 0 ? \"synchronized\" : \"synchronizing\";\n  }\n  destroy() {\n    this.unsubscribers.forEach((unsub) => unsub());\n    this.awareness.destroy();\n    this.rootDocHandler.destroy();\n    this._observers = /* @__PURE__ */ new Map();\n    for (const [_, handler] of this.subdocHandlers) {\n      handler.destroy();\n    }\n    this.subdocHandlers.clear();\n    super.destroy();\n  }\n  async clearOfflineData() {\n    if (!this.indexeddbProvider) return;\n    return this.indexeddbProvider.clearData();\n  }\n  getYDoc() {\n    return this.rootDoc;\n  }\n  // Some provider implementations expect to be able to call connect/disconnect, implement as noop\n  disconnect() {\n  }\n  connect() {\n  }\n};\n\n// src/providerContext.ts\n\nvar providersMap = /* @__PURE__ */ new WeakMap();\nvar getYjsProviderForRoom = (room, options = {}) => {\n  const provider = providersMap.get(room);\n  if (provider !== void 0) {\n    return provider;\n  }\n  const doc = new yjs__WEBPACK_IMPORTED_MODULE_0__.Doc();\n  const newProvider = new LiveblocksYjsProvider(room, doc, options);\n  room.events.roomWillDestroy.subscribeOnce(() => {\n    newProvider.destroy();\n  });\n  providersMap.set(room, newProvider);\n  return newProvider;\n};\n\n// src/index.ts\n(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_3__.detectDupes)(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MveWpzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzREO0FBQ2Q7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDNEU7QUFDbkI7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxQ0FBcUM7QUFDdEU7QUFDQSxVQUFVLHNEQUFzRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTCwyQkFBMkIsNkJBQTZCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0MsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNtQztBQUNnQjtBQUMxQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDhCQUE4Qiw4Q0FBZSxHQUFHLDRDQUFhO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHNEQUF1QixHQUFHLG9EQUFxQjtBQUNuRztBQUNBO0FBQ0EsWUFBWSw2Q0FBTTtBQUNsQjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkNBQU0sZ0JBQWdCLGtEQUFtQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDZEQUFvQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUNBQW1DLGtEQUFpQjtBQUNwRDtBQUNBLFNBQVMsdURBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIscUJBQXFCLDJEQUFhO0FBQ2xDO0FBQ0E7QUFDQSxnQkFBZ0IsMkNBQTJDO0FBQzNEO0FBQ0EsdUJBQXVCLDZDQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw2REFBcUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0RBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkNBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzBCO0FBQzFCO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9DQUFHO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBVztBQUlUO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZWFybi1ybC8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy95anMvZGlzdC9pbmRleC5qcz9mMWY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IHsgZGV0ZWN0RHVwZXMgfSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuXG4vLyBzcmMvdmVyc2lvbi50c1xudmFyIFBLR19OQU1FID0gXCJAbGl2ZWJsb2Nrcy95anNcIjtcbnZhciBQS0dfVkVSU0lPTiA9IFwiMi4yMi4wXCI7XG52YXIgUEtHX0ZPUk1BVCA9IFwiZXNtXCI7XG5cbi8vIHNyYy9wcm92aWRlci50c1xuaW1wb3J0IHsgQ2xpZW50TXNnQ29kZSwga0ludGVybmFsIH0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmltcG9ydCB7IEJhc2U2NCBhcyBCYXNlNjQyIH0gZnJvbSBcImpzLWJhc2U2NFwiO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbGliMC9tYXAuanNcbnZhciBjcmVhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xudmFyIHNldElmVW5kZWZpbmVkID0gKG1hcCwga2V5LCBjcmVhdGVUKSA9PiB7XG4gIGxldCBzZXQgPSBtYXAuZ2V0KGtleSk7XG4gIGlmIChzZXQgPT09IHZvaWQgMCkge1xuICAgIG1hcC5zZXQoa2V5LCBzZXQgPSBjcmVhdGVUKCkpO1xuICB9XG4gIHJldHVybiBzZXQ7XG59O1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbGliMC9zZXQuanNcbnZhciBjcmVhdGUyID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2xpYjAvYXJyYXkuanNcbnZhciBmcm9tID0gQXJyYXkuZnJvbTtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2xpYjAvb2JzZXJ2YWJsZS5qc1xudmFyIE9ic2VydmFibGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX29ic2VydmVycyA9IGNyZWF0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge059IG5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZlxuICAgKi9cbiAgb24obmFtZSwgZikge1xuICAgIHNldElmVW5kZWZpbmVkKHRoaXMuX29ic2VydmVycywgbmFtZSwgY3JlYXRlMikuYWRkKGYpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge059IG5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZlxuICAgKi9cbiAgb25jZShuYW1lLCBmKSB7XG4gICAgY29uc3QgX2YgPSAoLi4uYXJncykgPT4ge1xuICAgICAgdGhpcy5vZmYobmFtZSwgX2YpO1xuICAgICAgZiguLi5hcmdzKTtcbiAgICB9O1xuICAgIHRoaXMub24obmFtZSwgX2YpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge059IG5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZlxuICAgKi9cbiAgb2ZmKG5hbWUsIGYpIHtcbiAgICBjb25zdCBvYnNlcnZlcnMgPSB0aGlzLl9vYnNlcnZlcnMuZ2V0KG5hbWUpO1xuICAgIGlmIChvYnNlcnZlcnMgIT09IHZvaWQgMCkge1xuICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShmKTtcbiAgICAgIGlmIChvYnNlcnZlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMuZGVsZXRlKG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRW1pdCBhIG5hbWVkIGV2ZW50LiBBbGwgcmVnaXN0ZXJlZCBldmVudCBsaXN0ZW5lcnMgdGhhdCBsaXN0ZW4gdG8gdGhlXG4gICAqIHNwZWNpZmllZCBuYW1lIHdpbGwgcmVjZWl2ZSB0aGUgZXZlbnQuXG4gICAqXG4gICAqIEB0b2RvIFRoaXMgc2hvdWxkIGNhdGNoIGV4Y2VwdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHtOfSBuYW1lIFRoZSBldmVudCBuYW1lLlxuICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGFyZ3MgVGhlIGFyZ3VtZW50cyB0aGF0IGFyZSBhcHBsaWVkIHRvIHRoZSBldmVudCBsaXN0ZW5lci5cbiAgICovXG4gIGVtaXQobmFtZSwgYXJncykge1xuICAgIHJldHVybiBmcm9tKCh0aGlzLl9vYnNlcnZlcnMuZ2V0KG5hbWUpIHx8IGNyZWF0ZSgpKS52YWx1ZXMoKSkuZm9yRWFjaCgoZikgPT4gZiguLi5hcmdzKSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9vYnNlcnZlcnMgPSBjcmVhdGUoKTtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3ZpZGVyLnRzXG5pbXBvcnQgeyBJbmRleGVkZGJQZXJzaXN0ZW5jZSBhcyBJbmRleGVkZGJQZXJzaXN0ZW5jZTIgfSBmcm9tIFwieS1pbmRleGVkZGJcIjtcbmltcG9ydCB7IHBhcnNlVXBkYXRlTWV0YSwgUGVybWFuZW50VXNlckRhdGEgfSBmcm9tIFwieWpzXCI7XG5cbi8vIHNyYy9hd2FyZW5lc3MudHNcbnZhciBZX1BSRVNFTkNFX0tFWSA9IFwiX195anNcIjtcbnZhciBZX1BSRVNFTkNFX0lEX0tFWSA9IFwiX195anNfY2xpZW50aWRcIjtcbnZhciBBd2FyZW5lc3MgPSBjbGFzcyBleHRlbmRzIE9ic2VydmFibGUge1xuICByb29tO1xuICBkb2M7XG4gIHN0YXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIC8vIHVzZWQgdG8gbWFwIGxpdmVibG9jaydzIEFjdG9ySWQgdG8gWWpzIENsaWVudElELCBib3RoIHVuaXF1ZSBudW1iZXJzIHJlcHJlc2VudGluZyBhIGNsaWVudFxuICBhY3RvclRvQ2xpZW50TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgLy8gTWV0YSBpcyB1c2VkIHRvIGtlZXAgdHJhY2sgYW5kIHRpbWVvdXQgdXNlcnMgd2hvIGRpc2Nvbm5lY3QuIExpdmVibG9ja3MgcHJvdmlkZXMgdGhpcyBmb3IgdXMsIHNvIHdlIGRvbid0IG5lZWQgdG9cbiAgLy8gbWFuYWdlIGl0IGhlcmUuIFVuZm9ydHVuYXRlbHksIGl0J3MgZXhwZWN0ZWQgdG8gZXhpc3QgYnkgdmFyaW91cyBpbnRlZ3JhdGlvbnMsIHNvIGl0J3MgYW4gZW1wdHkgbWFwLlxuICBtZXRhID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgLy8gX2NoZWNrSW50ZXJ2YWwgdGhpcyB3b3VsZCBob2xkIGEgdGltZXIgdG8gcmVtb3ZlIHVzZXJzLCBidXQgTGl2ZWJsb2NrJ3MgcHJlc2VuY2UgYWxyZWFkeSBoYW5kbGVzIHRoaXNcbiAgLy8gdW5mb3J0dW5hdGVseSBpdCdzIHR5cGVkIGJ5IHZhcmlvdXMgaW50ZWdyYXRpb25zXG4gIF9jaGVja0ludGVydmFsID0gMDtcbiAgb3RoZXJzVW5zdWI7XG4gIGNvbnN0cnVjdG9yKGRvYywgcm9vbSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgdGhpcy5yb29tID0gcm9vbTtcbiAgICB0aGlzLnJvb20udXBkYXRlUHJlc2VuY2Uoe1xuICAgICAgW1lfUFJFU0VOQ0VfSURfS0VZXTogdGhpcy5kb2MuY2xpZW50SURcbiAgICB9KTtcbiAgICB0aGlzLm90aGVyc1Vuc3ViID0gdGhpcy5yb29tLmV2ZW50cy5vdGhlcnMuc3Vic2NyaWJlKChldmVudCkgPT4ge1xuICAgICAgbGV0IHVwZGF0ZXM7XG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJsZWF2ZVwiKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldENsaWVudElkID0gdGhpcy5hY3RvclRvQ2xpZW50TWFwLmdldChcbiAgICAgICAgICBldmVudC51c2VyLmNvbm5lY3Rpb25JZFxuICAgICAgICApO1xuICAgICAgICBpZiAodGFyZ2V0Q2xpZW50SWQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHVwZGF0ZXMgPSB7IGFkZGVkOiBbXSwgdXBkYXRlZDogW10sIHJlbW92ZWQ6IFt0YXJnZXRDbGllbnRJZF0gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYnVpbGRBY3RvclRvQ2xpZW50TWFwKGV2ZW50Lm90aGVycyk7XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJlbnRlclwiIHx8IGV2ZW50LnR5cGUgPT09IFwidXBkYXRlXCIpIHtcbiAgICAgICAgdGhpcy5yZWJ1aWxkQWN0b3JUb0NsaWVudE1hcChldmVudC5vdGhlcnMpO1xuICAgICAgICBjb25zdCB0YXJnZXRDbGllbnRJZCA9IHRoaXMuYWN0b3JUb0NsaWVudE1hcC5nZXQoXG4gICAgICAgICAgZXZlbnQudXNlci5jb25uZWN0aW9uSWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHRhcmdldENsaWVudElkICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB1cGRhdGVzID0ge1xuICAgICAgICAgICAgYWRkZWQ6IGV2ZW50LnR5cGUgPT09IFwiZW50ZXJcIiA/IFt0YXJnZXRDbGllbnRJZF0gOiBbXSxcbiAgICAgICAgICAgIHVwZGF0ZWQ6IGV2ZW50LnR5cGUgPT09IFwidXBkYXRlXCIgPyBbdGFyZ2V0Q2xpZW50SWRdIDogW10sXG4gICAgICAgICAgICByZW1vdmVkOiBbXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChldmVudC50eXBlID09PSBcInJlc2V0XCIpIHtcbiAgICAgICAgdGhpcy5yZWJ1aWxkQWN0b3JUb0NsaWVudE1hcChldmVudC5vdGhlcnMpO1xuICAgICAgfVxuICAgICAgaWYgKHVwZGF0ZXMgIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgW3VwZGF0ZXMsIFwicHJlc2VuY2VcIl0pO1xuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgW3VwZGF0ZXMsIFwicHJlc2VuY2VcIl0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJlYnVpbGRBY3RvclRvQ2xpZW50TWFwKG90aGVycykge1xuICAgIHRoaXMuYWN0b3JUb0NsaWVudE1hcC5jbGVhcigpO1xuICAgIG90aGVycy5mb3JFYWNoKCh1c2VyKSA9PiB7XG4gICAgICBpZiAodXNlci5wcmVzZW5jZVtZX1BSRVNFTkNFX0lEX0tFWV0gIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLmFjdG9yVG9DbGllbnRNYXAuc2V0KFxuICAgICAgICAgIHVzZXIuY29ubmVjdGlvbklkLFxuICAgICAgICAgIHVzZXIucHJlc2VuY2VbWV9QUkVTRU5DRV9JRF9LRVldXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmVtaXQoXCJkZXN0cm95XCIsIFt0aGlzXSk7XG4gICAgdGhpcy5vdGhlcnNVbnN1YigpO1xuICAgIHRoaXMuc2V0TG9jYWxTdGF0ZShudWxsKTtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cbiAgZ2V0TG9jYWxTdGF0ZSgpIHtcbiAgICBjb25zdCBwcmVzZW5jZSA9IHRoaXMucm9vbS5nZXRQcmVzZW5jZSgpO1xuICAgIGlmIChPYmplY3Qua2V5cyhwcmVzZW5jZSkubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBwcmVzZW5jZVtZX1BSRVNFTkNFX0tFWV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcHJlc2VuY2VbWV9QUkVTRU5DRV9LRVldO1xuICB9XG4gIHNldExvY2FsU3RhdGUoc3RhdGUpIHtcbiAgICBjb25zdCBwcmVzZW5jZSA9IHRoaXMucm9vbS5nZXRTZWxmKCk/LnByZXNlbmNlO1xuICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgaWYgKHByZXNlbmNlID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5yb29tLnVwZGF0ZVByZXNlbmNlKHsgLi4ucHJlc2VuY2UsIFtZX1BSRVNFTkNFX0tFWV06IG51bGwgfSk7XG4gICAgICB0aGlzLmVtaXQoXCJ1cGRhdGVcIiwgW1xuICAgICAgICB7IGFkZGVkOiBbXSwgdXBkYXRlZDogW10sIHJlbW92ZWQ6IFt0aGlzLmRvYy5jbGllbnRJRF0gfSxcbiAgICAgICAgXCJsb2NhbFwiXG4gICAgICBdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeVByZXNlbmNlID0gcHJlc2VuY2U/LltZX1BSRVNFTkNFX0tFWV07XG4gICAgY29uc3QgYWRkZWQgPSB5UHJlc2VuY2UgPT09IHZvaWQgMCA/IFt0aGlzLmRvYy5jbGllbnRJRF0gOiBbXTtcbiAgICBjb25zdCB1cGRhdGVkID0geVByZXNlbmNlID09PSB2b2lkIDAgPyBbXSA6IFt0aGlzLmRvYy5jbGllbnRJRF07XG4gICAgdGhpcy5yb29tLnVwZGF0ZVByZXNlbmNlKHtcbiAgICAgIFtZX1BSRVNFTkNFX0tFWV06IHtcbiAgICAgICAgLi4ueVByZXNlbmNlIHx8IHt9LFxuICAgICAgICAuLi5zdGF0ZSB8fCB7fVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdChcInVwZGF0ZVwiLCBbeyBhZGRlZCwgdXBkYXRlZCwgcmVtb3ZlZDogW10gfSwgXCJsb2NhbFwiXSk7XG4gIH1cbiAgc2V0TG9jYWxTdGF0ZUZpZWxkKGZpZWxkLCB2YWx1ZSkge1xuICAgIGNvbnN0IHByZXNlbmNlID0gdGhpcy5yb29tLmdldFNlbGYoKT8ucHJlc2VuY2VbWV9QUkVTRU5DRV9LRVldO1xuICAgIGNvbnN0IHVwZGF0ZSA9IHsgW2ZpZWxkXTogdmFsdWUgfTtcbiAgICB0aGlzLnJvb20udXBkYXRlUHJlc2VuY2Uoe1xuICAgICAgW1lfUFJFU0VOQ0VfS0VZXTogeyAuLi5wcmVzZW5jZSB8fCB7fSwgLi4udXBkYXRlIH1cbiAgICB9KTtcbiAgfVxuICAvLyBUcmFuc2xhdGUgbGl2ZWJsb2NrcyBwcmVzZW5jZSB0byB5anMgYXdhcmVuZXNzXG4gIGdldFN0YXRlcygpIHtcbiAgICBjb25zdCBvdGhlcnMgPSB0aGlzLnJvb20uZ2V0T3RoZXJzKCk7XG4gICAgY29uc3Qgc3RhdGVzID0gb3RoZXJzLnJlZHVjZSgoYWNjLCBvdGhlclVzZXIpID0+IHtcbiAgICAgIGNvbnN0IG90aGVyUHJlc2VuY2UgPSBvdGhlclVzZXIucHJlc2VuY2VbWV9QUkVTRU5DRV9LRVldO1xuICAgICAgY29uc3Qgb3RoZXJDbGllbnRJZCA9IG90aGVyVXNlci5wcmVzZW5jZVtZX1BSRVNFTkNFX0lEX0tFWV07XG4gICAgICBpZiAob3RoZXJQcmVzZW5jZSAhPT0gdm9pZCAwICYmIG90aGVyQ2xpZW50SWQgIT09IHZvaWQgMCkge1xuICAgICAgICBhY2Muc2V0KG90aGVyQ2xpZW50SWQsIG90aGVyUHJlc2VuY2UgfHwge30pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBjb25zdCBsb2NhbFByZXNlbmNlID0gdGhpcy5yb29tLmdldFNlbGYoKT8ucHJlc2VuY2VbWV9QUkVTRU5DRV9LRVldO1xuICAgIGlmIChsb2NhbFByZXNlbmNlICE9PSB2b2lkIDApIHtcbiAgICAgIHN0YXRlcy5zZXQodGhpcy5kb2MuY2xpZW50SUQsIGxvY2FsUHJlc2VuY2UpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGVzO1xuICB9XG59O1xuXG4vLyBzcmMvZG9jLnRzXG5pbXBvcnQgeyBCYXNlNjQgfSBmcm9tIFwianMtYmFzZTY0XCI7XG5pbXBvcnQgeyBJbmRleGVkZGJQZXJzaXN0ZW5jZSB9IGZyb20gXCJ5LWluZGV4ZWRkYlwiO1xuaW1wb3J0ICogYXMgWSBmcm9tIFwieWpzXCI7XG52YXIgeURvY0hhbmRsZXIgPSBjbGFzcyBleHRlbmRzIE9ic2VydmFibGUge1xuICB1bnN1YnNjcmliZXJzID0gW107XG4gIF9zeW5jZWQgPSBmYWxzZTtcbiAgZG9jO1xuICB1cGRhdGVSb29tRG9jO1xuICBmZXRjaFJvb21Eb2M7XG4gIHVzZVYyRW5jb2Rpbmc7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkb2MsXG4gICAgaXNSb290LFxuICAgIHVwZGF0ZURvYyxcbiAgICBmZXRjaERvYyxcbiAgICB1c2VWMkVuY29kaW5nXG4gIH0pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIHRoaXMudXNlVjJFbmNvZGluZyA9IHVzZVYyRW5jb2Rpbmc7XG4gICAgdGhpcy5kb2Mub24odXNlVjJFbmNvZGluZyA/IFwidXBkYXRlVjJcIiA6IFwidXBkYXRlXCIsIHRoaXMudXBkYXRlSGFuZGxlcik7XG4gICAgdGhpcy51cGRhdGVSb29tRG9jID0gKHVwZGF0ZSkgPT4ge1xuICAgICAgdXBkYXRlRG9jKHVwZGF0ZSwgaXNSb290ID8gdm9pZCAwIDogdGhpcy5kb2MuZ3VpZCk7XG4gICAgfTtcbiAgICB0aGlzLmZldGNoUm9vbURvYyA9ICh2ZWN0b3IpID0+IHtcbiAgICAgIGZldGNoRG9jKHZlY3RvciwgaXNSb290ID8gdm9pZCAwIDogdGhpcy5kb2MuZ3VpZCk7XG4gICAgfTtcbiAgICB0aGlzLnN5bmNEb2MoKTtcbiAgfVxuICBoYW5kbGVTZXJ2ZXJVcGRhdGUgPSAoe1xuICAgIHVwZGF0ZSxcbiAgICBzdGF0ZVZlY3RvcixcbiAgICByZWFkT25seSxcbiAgICB2MlxuICB9KSA9PiB7XG4gICAgY29uc3QgYXBwbHlVcGRhdGUyID0gdjIgPyBZLmFwcGx5VXBkYXRlVjIgOiBZLmFwcGx5VXBkYXRlO1xuICAgIGFwcGx5VXBkYXRlMih0aGlzLmRvYywgdXBkYXRlLCBcImJhY2tlbmRcIik7XG4gICAgaWYgKHN0YXRlVmVjdG9yKSB7XG4gICAgICBpZiAoIXJlYWRPbmx5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZW5jb2RlVXBkYXRlID0gdGhpcy51c2VWMkVuY29kaW5nID8gWS5lbmNvZGVTdGF0ZUFzVXBkYXRlVjIgOiBZLmVuY29kZVN0YXRlQXNVcGRhdGU7XG4gICAgICAgICAgY29uc3QgbG9jYWxVcGRhdGUgPSBlbmNvZGVVcGRhdGUoXG4gICAgICAgICAgICB0aGlzLmRvYyxcbiAgICAgICAgICAgIEJhc2U2NC50b1VpbnQ4QXJyYXkoc3RhdGVWZWN0b3IpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVJvb21Eb2MobG9jYWxVcGRhdGUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnN5bmNlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuICBzeW5jRG9jID0gKCkgPT4ge1xuICAgIHRoaXMuc3luY2VkID0gZmFsc2U7XG4gICAgY29uc3QgZW5jb2RlZFZlY3RvciA9IEJhc2U2NC5mcm9tVWludDhBcnJheShZLmVuY29kZVN0YXRlVmVjdG9yKHRoaXMuZG9jKSk7XG4gICAgdGhpcy5mZXRjaFJvb21Eb2MoZW5jb2RlZFZlY3Rvcik7XG4gIH07XG4gIC8vIFRoZSBzeW5jJ2QgcHJvcGVydHkgaXMgcmVxdWlyZWQgYnkgc29tZSBwcm92aWRlciBpbXBsZW1lbnRhdGlvbnNcbiAgZ2V0IHN5bmNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3luY2VkO1xuICB9XG4gIHNldCBzeW5jZWQoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5fc3luY2VkICE9PSBzdGF0ZSkge1xuICAgICAgdGhpcy5fc3luY2VkID0gc3RhdGU7XG4gICAgICB0aGlzLmVtaXQoXCJzeW5jZWRcIiwgW3N0YXRlXSk7XG4gICAgICB0aGlzLmVtaXQoXCJzeW5jXCIsIFtzdGF0ZV0pO1xuICAgIH1cbiAgfVxuICB1cGRhdGVIYW5kbGVyID0gKHVwZGF0ZSwgb3JpZ2luKSA9PiB7XG4gICAgY29uc3QgaXNGcm9tTG9jYWwgPSBvcmlnaW4gaW5zdGFuY2VvZiBJbmRleGVkZGJQZXJzaXN0ZW5jZTtcbiAgICBpZiAob3JpZ2luICE9PSBcImJhY2tlbmRcIiAmJiAhaXNGcm9tTG9jYWwpIHtcbiAgICAgIHRoaXMudXBkYXRlUm9vbURvYyh1cGRhdGUpO1xuICAgIH1cbiAgfTtcbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRvYy5vZmYoXCJ1cGRhdGVcIiwgdGhpcy51cGRhdGVIYW5kbGVyKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlcnMuZm9yRWFjaCgodW5zdWIpID0+IHVuc3ViKCkpO1xuICAgIHRoaXMuX29ic2VydmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5kb2MuZGVzdHJveSgpO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIudHNcbnZhciBMaXZlYmxvY2tzWWpzUHJvdmlkZXIgPSBjbGFzcyBleHRlbmRzIE9ic2VydmFibGUge1xuICByb29tO1xuICByb290RG9jO1xuICBvcHRpb25zO1xuICBpbmRleGVkZGJQcm92aWRlciA9IG51bGw7XG4gIGlzUGF1c2VkID0gZmFsc2U7XG4gIHVuc3Vic2NyaWJlcnMgPSBbXTtcbiAgYXdhcmVuZXNzO1xuICByb290RG9jSGFuZGxlcjtcbiAgc3ViZG9jSGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBwZXJtYW5lbnRVc2VyRGF0YTtcbiAgcGVuZGluZyA9IFtdO1xuICBjb25zdHJ1Y3Rvcihyb29tLCBkb2MsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5yb290RG9jID0gZG9jO1xuICAgIHRoaXMucm9vbSA9IHJvb207XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnJvb3REb2NIYW5kbGVyID0gbmV3IHlEb2NIYW5kbGVyKHtcbiAgICAgIGRvYyxcbiAgICAgIGlzUm9vdDogdHJ1ZSxcbiAgICAgIHVwZGF0ZURvYzogdGhpcy51cGRhdGVEb2MsXG4gICAgICBmZXRjaERvYzogdGhpcy5mZXRjaERvYyxcbiAgICAgIHVzZVYyRW5jb2Rpbmc6IHRoaXMub3B0aW9ucy51c2VWMkVuY29kaW5nX2V4cGVyaW1lbnRhbCA/PyBmYWxzZVxuICAgIH0pO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlUGVybWFuZW50VXNlckRhdGEpIHtcbiAgICAgIHRoaXMucGVybWFuZW50VXNlckRhdGEgPSBuZXcgUGVybWFuZW50VXNlckRhdGEoZG9jKTtcbiAgICB9XG4gICAgcm9vbVtrSW50ZXJuYWxdLnNldFlqc1Byb3ZpZGVyKHRoaXMpO1xuICAgIHRoaXMuYXdhcmVuZXNzID0gbmV3IEF3YXJlbmVzcyh0aGlzLnJvb3REb2MsIHRoaXMucm9vbSk7XG4gICAgdGhpcy51bnN1YnNjcmliZXJzLnB1c2goXG4gICAgICB0aGlzLnJvb20uZXZlbnRzLnN0YXR1cy5zdWJzY3JpYmUoKHN0YXR1cykgPT4ge1xuICAgICAgICBpZiAoc3RhdHVzID09PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICAgICAgdGhpcy5yb290RG9jSGFuZGxlci5zeW5jRG9jKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yb290RG9jSGFuZGxlci5zeW5jZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJzdGF0dXNcIiwgW3RoaXMuZ2V0U3RhdHVzKCldKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlcnMucHVzaChcbiAgICAgIHRoaXMucm9vbS5ldmVudHMueWRvYy5zdWJzY3JpYmUoKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29uc3QgeyB0eXBlIH0gPSBtZXNzYWdlO1xuICAgICAgICBpZiAodHlwZSA9PT0gQ2xpZW50TXNnQ29kZS5VUERBVEVfWURPQykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0YXRlVmVjdG9yLCB1cGRhdGU6IHVwZGF0ZVN0ciwgZ3VpZCwgdjIgfSA9IG1lc3NhZ2U7XG4gICAgICAgIGNvbnN0IGNhbldyaXRlID0gdGhpcy5yb29tLmdldFNlbGYoKT8uY2FuV3JpdGUgPz8gdHJ1ZTtcbiAgICAgICAgY29uc3QgdXBkYXRlID0gQmFzZTY0Mi50b1VpbnQ4QXJyYXkodXBkYXRlU3RyKTtcbiAgICAgICAgbGV0IGZvdW5kUGVuZGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCB1cGRhdGVJZCA9IHRoaXMuZ2V0VW5pcXVlVXBkYXRlSWQodXBkYXRlKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nID0gdGhpcy5wZW5kaW5nLmZpbHRlcigocGVuZGluZ1VwZGF0ZSkgPT4ge1xuICAgICAgICAgIGlmIChwZW5kaW5nVXBkYXRlID09PSB1cGRhdGVJZCkge1xuICAgICAgICAgICAgZm91bmRQZW5kaW5nVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWZvdW5kUGVuZGluZ1VwZGF0ZSkge1xuICAgICAgICAgIGlmIChndWlkICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRoaXMuc3ViZG9jSGFuZGxlcnMuZ2V0KGd1aWQpPy5oYW5kbGVTZXJ2ZXJVcGRhdGUoe1xuICAgICAgICAgICAgICB1cGRhdGUsXG4gICAgICAgICAgICAgIHN0YXRlVmVjdG9yLFxuICAgICAgICAgICAgICByZWFkT25seTogIWNhbldyaXRlLFxuICAgICAgICAgICAgICB2MlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucm9vdERvY0hhbmRsZXIuaGFuZGxlU2VydmVyVXBkYXRlKHtcbiAgICAgICAgICAgICAgdXBkYXRlLFxuICAgICAgICAgICAgICBzdGF0ZVZlY3RvcixcbiAgICAgICAgICAgICAgcmVhZE9ubHk6ICFjYW5Xcml0ZSxcbiAgICAgICAgICAgICAgdjJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJzdGF0dXNcIiwgW3RoaXMuZ2V0U3RhdHVzKCldKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICBpZiAob3B0aW9ucy5vZmZsaW5lU3VwcG9ydF9leHBlcmltZW50YWwpIHtcbiAgICAgIHRoaXMuc2V0dXBPZmZsaW5lU3VwcG9ydCgpO1xuICAgIH1cbiAgICB0aGlzLnJvb3REb2NIYW5kbGVyLm9uKFwic3luY2VkXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5yb290RG9jSGFuZGxlci5zeW5jZWQ7XG4gICAgICBmb3IgKGNvbnN0IFtfLCBoYW5kbGVyXSBvZiB0aGlzLnN1YmRvY0hhbmRsZXJzKSB7XG4gICAgICAgIGhhbmRsZXIuc3luY0RvYygpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFwic3luY2VkXCIsIFtzdGF0ZV0pO1xuICAgICAgdGhpcy5lbWl0KFwic3luY1wiLCBbc3RhdGVdKTtcbiAgICAgIHRoaXMuZW1pdChcInN0YXR1c1wiLCBbdGhpcy5nZXRTdGF0dXMoKV0pO1xuICAgIH0pO1xuICAgIHRoaXMucm9vdERvYy5vbihcInN1YmRvY3NcIiwgdGhpcy5oYW5kbGVTdWJkb2NzKTtcbiAgICB0aGlzLnN5bmNEb2MoKTtcbiAgfVxuICBzZXR1cE9mZmxpbmVTdXBwb3J0ID0gKCkgPT4ge1xuICAgIHRoaXMuaW5kZXhlZGRiUHJvdmlkZXIgPSBuZXcgSW5kZXhlZGRiUGVyc2lzdGVuY2UyKFxuICAgICAgdGhpcy5yb29tLmlkLFxuICAgICAgdGhpcy5yb290RG9jXG4gICAgKTtcbiAgICBjb25zdCBvbkluZGV4ZWREYlN5bmMgPSAoKSA9PiB7XG4gICAgICB0aGlzLnJvb3REb2NIYW5kbGVyLnN5bmNlZCA9IHRydWU7XG4gICAgfTtcbiAgICB0aGlzLmluZGV4ZWRkYlByb3ZpZGVyLm9uKFwic3luY2VkXCIsIG9uSW5kZXhlZERiU3luYyk7XG4gICAgdGhpcy51bnN1YnNjcmliZXJzLnB1c2goKCkgPT4ge1xuICAgICAgdGhpcy5pbmRleGVkZGJQcm92aWRlcj8ub2ZmKFwic3luY2VkXCIsIG9uSW5kZXhlZERiU3luYyk7XG4gICAgfSk7XG4gIH07XG4gIGhhbmRsZVN1YmRvY3MgPSAoe1xuICAgIGxvYWRlZCxcbiAgICByZW1vdmVkLFxuICAgIGFkZGVkXG4gIH0pID0+IHtcbiAgICBsb2FkZWQuZm9yRWFjaCh0aGlzLmNyZWF0ZVN1YmRvY0hhbmRsZXIpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b2xvYWRTdWJkb2NzKSB7XG4gICAgICBmb3IgKGNvbnN0IHN1YmRvYyBvZiBhZGRlZCkge1xuICAgICAgICBpZiAoIXRoaXMuc3ViZG9jSGFuZGxlcnMuaGFzKHN1YmRvYy5ndWlkKSkge1xuICAgICAgICAgIHN1YmRvYy5sb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBzdWJkb2Mgb2YgcmVtb3ZlZCkge1xuICAgICAgaWYgKHRoaXMuc3ViZG9jSGFuZGxlcnMuaGFzKHN1YmRvYy5ndWlkKSkge1xuICAgICAgICB0aGlzLnN1YmRvY0hhbmRsZXJzLmdldChzdWJkb2MuZ3VpZCk/LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5zdWJkb2NIYW5kbGVycy5kZWxldGUoc3ViZG9jLmd1aWQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZ2V0VW5pcXVlVXBkYXRlSWQgPSAodXBkYXRlKSA9PiB7XG4gICAgY29uc3QgY2xvY2sgPSBwYXJzZVVwZGF0ZU1ldGEodXBkYXRlKS50by5nZXQodGhpcy5yb290RG9jLmNsaWVudElEKSA/PyBcIi0xXCI7XG4gICAgcmV0dXJuIHRoaXMucm9vdERvYy5jbGllbnRJRCArIFwiOlwiICsgY2xvY2s7XG4gIH07XG4gIHVwZGF0ZURvYyA9ICh1cGRhdGUsIGd1aWQpID0+IHtcbiAgICBjb25zdCBjYW5Xcml0ZSA9IHRoaXMucm9vbS5nZXRTZWxmKCk/LmNhbldyaXRlID8/IHRydWU7XG4gICAgaWYgKGNhbldyaXRlICYmICF0aGlzLmlzUGF1c2VkKSB7XG4gICAgICBjb25zdCB1cGRhdGVJZCA9IHRoaXMuZ2V0VW5pcXVlVXBkYXRlSWQodXBkYXRlKTtcbiAgICAgIHRoaXMucGVuZGluZy5wdXNoKHVwZGF0ZUlkKTtcbiAgICAgIHRoaXMucm9vbS51cGRhdGVZRG9jKFxuICAgICAgICBCYXNlNjQyLmZyb21VaW50OEFycmF5KHVwZGF0ZSksXG4gICAgICAgIGd1aWQsXG4gICAgICAgIHRoaXMudXNlVjJFbmNvZGluZ1xuICAgICAgKTtcbiAgICAgIHRoaXMuZW1pdChcInN0YXR1c1wiLCBbdGhpcy5nZXRTdGF0dXMoKV0pO1xuICAgIH1cbiAgfTtcbiAgZmV0Y2hEb2MgPSAodmVjdG9yLCBndWlkKSA9PiB7XG4gICAgdGhpcy5yb29tLmZldGNoWURvYyh2ZWN0b3IsIGd1aWQsIHRoaXMudXNlVjJFbmNvZGluZyk7XG4gIH07XG4gIGNyZWF0ZVN1YmRvY0hhbmRsZXIgPSAoc3ViZG9jKSA9PiB7XG4gICAgaWYgKHRoaXMuc3ViZG9jSGFuZGxlcnMuaGFzKHN1YmRvYy5ndWlkKSkge1xuICAgICAgdGhpcy5zdWJkb2NIYW5kbGVycy5nZXQoc3ViZG9jLmd1aWQpPy5zeW5jRG9jKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgeURvY0hhbmRsZXIoe1xuICAgICAgZG9jOiBzdWJkb2MsXG4gICAgICBpc1Jvb3Q6IGZhbHNlLFxuICAgICAgdXBkYXRlRG9jOiB0aGlzLnVwZGF0ZURvYyxcbiAgICAgIGZldGNoRG9jOiB0aGlzLmZldGNoRG9jLFxuICAgICAgdXNlVjJFbmNvZGluZzogdGhpcy5vcHRpb25zLnVzZVYyRW5jb2RpbmdfZXhwZXJpbWVudGFsID8/IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5zdWJkb2NIYW5kbGVycy5zZXQoc3ViZG9jLmd1aWQsIGhhbmRsZXIpO1xuICB9O1xuICAvLyBhdHRlbXB0IHRvIGxvYWQgYSBzdWJkb2Mgb2YgYSBnaXZlbiBndWlkXG4gIGxvYWRTdWJkb2MgPSAoZ3VpZCkgPT4ge1xuICAgIGZvciAoY29uc3Qgc3ViZG9jIG9mIHRoaXMucm9vdERvYy5zdWJkb2NzKSB7XG4gICAgICBpZiAoc3ViZG9jLmd1aWQgPT09IGd1aWQpIHtcbiAgICAgICAgc3ViZG9jLmxvYWQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgc3luY0RvYyA9ICgpID0+IHtcbiAgICB0aGlzLnJvb3REb2NIYW5kbGVyLnN5bmNEb2MoKTtcbiAgICBmb3IgKGNvbnN0IFtfLCBoYW5kbGVyXSBvZiB0aGlzLnN1YmRvY0hhbmRsZXJzKSB7XG4gICAgICBoYW5kbGVyLnN5bmNEb2MoKTtcbiAgICB9XG4gIH07XG4gIGdldCB1c2VWMkVuY29kaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudXNlVjJFbmNvZGluZ19leHBlcmltZW50YWwgPz8gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHN5bmMnZCBwcm9wZXJ0eSBpcyByZXF1aXJlZCBieSBzb21lIHByb3ZpZGVyIGltcGxlbWVudGF0aW9uc1xuICBnZXQgc3luY2VkKCkge1xuICAgIHJldHVybiB0aGlzLnJvb3REb2NIYW5kbGVyLnN5bmNlZDtcbiAgfVxuICBhc3luYyBwYXVzZSgpIHtcbiAgICBhd2FpdCB0aGlzLmluZGV4ZWRkYlByb3ZpZGVyPy5kZXN0cm95KCk7XG4gICAgdGhpcy5pbmRleGVkZGJQcm92aWRlciA9IG51bGw7XG4gICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XG4gIH1cbiAgdW5wYXVzZSgpIHtcbiAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZsaW5lU3VwcG9ydF9leHBlcmltZW50YWwpIHtcbiAgICAgIHRoaXMuc2V0dXBPZmZsaW5lU3VwcG9ydCgpO1xuICAgIH1cbiAgICB0aGlzLnJvb3REb2NIYW5kbGVyLnN5bmNEb2MoKTtcbiAgfVxuICBnZXRTdGF0dXMoKSB7XG4gICAgaWYgKCF0aGlzLnN5bmNlZCkge1xuICAgICAgcmV0dXJuIFwibG9hZGluZ1wiO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wZW5kaW5nLmxlbmd0aCA9PT0gMCA/IFwic3luY2hyb25pemVkXCIgOiBcInN5bmNocm9uaXppbmdcIjtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5zdWJzY3JpYmVycy5mb3JFYWNoKCh1bnN1YikgPT4gdW5zdWIoKSk7XG4gICAgdGhpcy5hd2FyZW5lc3MuZGVzdHJveSgpO1xuICAgIHRoaXMucm9vdERvY0hhbmRsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuX29ic2VydmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBbXywgaGFuZGxlcl0gb2YgdGhpcy5zdWJkb2NIYW5kbGVycykge1xuICAgICAgaGFuZGxlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuc3ViZG9jSGFuZGxlcnMuY2xlYXIoKTtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cbiAgYXN5bmMgY2xlYXJPZmZsaW5lRGF0YSgpIHtcbiAgICBpZiAoIXRoaXMuaW5kZXhlZGRiUHJvdmlkZXIpIHJldHVybjtcbiAgICByZXR1cm4gdGhpcy5pbmRleGVkZGJQcm92aWRlci5jbGVhckRhdGEoKTtcbiAgfVxuICBnZXRZRG9jKCkge1xuICAgIHJldHVybiB0aGlzLnJvb3REb2M7XG4gIH1cbiAgLy8gU29tZSBwcm92aWRlciBpbXBsZW1lbnRhdGlvbnMgZXhwZWN0IHRvIGJlIGFibGUgdG8gY2FsbCBjb25uZWN0L2Rpc2Nvbm5lY3QsIGltcGxlbWVudCBhcyBub29wXG4gIGRpc2Nvbm5lY3QoKSB7XG4gIH1cbiAgY29ubmVjdCgpIHtcbiAgfVxufTtcblxuLy8gc3JjL3Byb3ZpZGVyQ29udGV4dC50c1xuaW1wb3J0IHsgRG9jIH0gZnJvbSBcInlqc1wiO1xudmFyIHByb3ZpZGVyc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIGdldFlqc1Byb3ZpZGVyRm9yUm9vbSA9IChyb29tLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgcHJvdmlkZXIgPSBwcm92aWRlcnNNYXAuZ2V0KHJvb20pO1xuICBpZiAocHJvdmlkZXIgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBwcm92aWRlcjtcbiAgfVxuICBjb25zdCBkb2MgPSBuZXcgRG9jKCk7XG4gIGNvbnN0IG5ld1Byb3ZpZGVyID0gbmV3IExpdmVibG9ja3NZanNQcm92aWRlcihyb29tLCBkb2MsIG9wdGlvbnMpO1xuICByb29tLmV2ZW50cy5yb29tV2lsbERlc3Ryb3kuc3Vic2NyaWJlT25jZSgoKSA9PiB7XG4gICAgbmV3UHJvdmlkZXIuZGVzdHJveSgpO1xuICB9KTtcbiAgcHJvdmlkZXJzTWFwLnNldChyb29tLCBuZXdQcm92aWRlcik7XG4gIHJldHVybiBuZXdQcm92aWRlcjtcbn07XG5cbi8vIHNyYy9pbmRleC50c1xuZGV0ZWN0RHVwZXMoUEtHX05BTUUsIFBLR19WRVJTSU9OLCBQS0dfRk9STUFUKTtcbmV4cG9ydCB7XG4gIExpdmVibG9ja3NZanNQcm92aWRlcixcbiAgZ2V0WWpzUHJvdmlkZXJGb3JSb29tXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@liveblocks/yjs/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@liveblocks/core/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@liveblocks/core/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientMsgCode: () => (/* binding */ ClientMsgCode),\n/* harmony export */   CommentsApiError: () => (/* binding */ CommentsApiError),\n/* harmony export */   CrdtType: () => (/* binding */ CrdtType),\n/* harmony export */   DefaultMap: () => (/* binding */ DefaultMap),\n/* harmony export */   DerivedSignal: () => (/* binding */ DerivedSignal),\n/* harmony export */   HttpError: () => (/* binding */ HttpError),\n/* harmony export */   LiveList: () => (/* binding */ LiveList),\n/* harmony export */   LiveMap: () => (/* binding */ LiveMap),\n/* harmony export */   LiveObject: () => (/* binding */ LiveObject),\n/* harmony export */   LiveblocksError: () => (/* binding */ LiveblocksError),\n/* harmony export */   MutableSignal: () => (/* binding */ MutableSignal),\n/* harmony export */   NotificationsApiError: () => (/* binding */ NotificationsApiError),\n/* harmony export */   OpCode: () => (/* binding */ OpCode),\n/* harmony export */   Permission: () => (/* binding */ Permission),\n/* harmony export */   Promise_withResolvers: () => (/* binding */ Promise_withResolvers),\n/* harmony export */   ServerMsgCode: () => (/* binding */ ServerMsgCode),\n/* harmony export */   Signal: () => (/* binding */ Signal),\n/* harmony export */   SortedList: () => (/* binding */ SortedList),\n/* harmony export */   TextEditorType: () => (/* binding */ TextEditorType),\n/* harmony export */   WebsocketCloseCodes: () => (/* binding */ WebsocketCloseCodes),\n/* harmony export */   ackOp: () => (/* binding */ ackOp),\n/* harmony export */   asPos: () => (/* binding */ asPos),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertNever: () => (/* binding */ assertNever),\n/* harmony export */   autoRetry: () => (/* binding */ autoRetry),\n/* harmony export */   b64decode: () => (/* binding */ b64decode),\n/* harmony export */   batch: () => (/* binding */ batch),\n/* harmony export */   checkBounds: () => (/* binding */ checkBounds),\n/* harmony export */   chunk: () => (/* binding */ chunk),\n/* harmony export */   cloneLson: () => (/* binding */ cloneLson),\n/* harmony export */   compactObject: () => (/* binding */ compactObject),\n/* harmony export */   console: () => (/* binding */ fancy_console_exports),\n/* harmony export */   convertToCommentData: () => (/* binding */ convertToCommentData),\n/* harmony export */   convertToCommentUserReaction: () => (/* binding */ convertToCommentUserReaction),\n/* harmony export */   convertToInboxNotificationData: () => (/* binding */ convertToInboxNotificationData),\n/* harmony export */   convertToThreadData: () => (/* binding */ convertToThreadData),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   createCommentAttachmentId: () => (/* binding */ createCommentAttachmentId),\n/* harmony export */   createCommentId: () => (/* binding */ createCommentId),\n/* harmony export */   createInboxNotificationId: () => (/* binding */ createInboxNotificationId),\n/* harmony export */   createManagedPool: () => (/* binding */ createManagedPool),\n/* harmony export */   createThreadId: () => (/* binding */ createThreadId),\n/* harmony export */   createUserNotificationSettings: () => (/* binding */ createUserNotificationSettings),\n/* harmony export */   deprecate: () => (/* binding */ deprecate),\n/* harmony export */   deprecateIf: () => (/* binding */ deprecateIf),\n/* harmony export */   detectDupes: () => (/* binding */ detectDupes),\n/* harmony export */   entries: () => (/* binding */ entries),\n/* harmony export */   errorIf: () => (/* binding */ errorIf),\n/* harmony export */   freeze: () => (/* binding */ freeze),\n/* harmony export */   generateCommentUrl: () => (/* binding */ generateCommentUrl),\n/* harmony export */   getMentionedIdsFromCommentBody: () => (/* binding */ getMentionedIdsFromCommentBody),\n/* harmony export */   html: () => (/* binding */ html),\n/* harmony export */   htmlSafe: () => (/* binding */ htmlSafe),\n/* harmony export */   isChildCrdt: () => (/* binding */ isChildCrdt),\n/* harmony export */   isCommentBodyLink: () => (/* binding */ isCommentBodyLink),\n/* harmony export */   isCommentBodyMention: () => (/* binding */ isCommentBodyMention),\n/* harmony export */   isCommentBodyText: () => (/* binding */ isCommentBodyText),\n/* harmony export */   isJsonArray: () => (/* binding */ isJsonArray),\n/* harmony export */   isJsonObject: () => (/* binding */ isJsonObject),\n/* harmony export */   isJsonScalar: () => (/* binding */ isJsonScalar),\n/* harmony export */   isLiveNode: () => (/* binding */ isLiveNode),\n/* harmony export */   isNotificationChannelEnabled: () => (/* binding */ isNotificationChannelEnabled),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRootCrdt: () => (/* binding */ isRootCrdt),\n/* harmony export */   isStartsWithOperator: () => (/* binding */ isStartsWithOperator),\n/* harmony export */   kInternal: () => (/* binding */ kInternal),\n/* harmony export */   keys: () => (/* binding */ keys),\n/* harmony export */   legacy_patchImmutableObject: () => (/* binding */ legacy_patchImmutableObject),\n/* harmony export */   lsonToJson: () => (/* binding */ lsonToJson),\n/* harmony export */   makeAbortController: () => (/* binding */ makeAbortController),\n/* harmony export */   makeEventSource: () => (/* binding */ makeEventSource),\n/* harmony export */   makePoller: () => (/* binding */ makePoller),\n/* harmony export */   makePosition: () => (/* binding */ makePosition),\n/* harmony export */   mapValues: () => (/* binding */ mapValues),\n/* harmony export */   memoizeOnSuccess: () => (/* binding */ memoizeOnSuccess),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   nn: () => (/* binding */ nn),\n/* harmony export */   objectToQuery: () => (/* binding */ objectToQuery),\n/* harmony export */   patchLiveObjectKey: () => (/* binding */ patchLiveObjectKey),\n/* harmony export */   patchUserNotificationSettings: () => (/* binding */ patchUserNotificationSettings),\n/* harmony export */   raise: () => (/* binding */ raise),\n/* harmony export */   resolveUsersInCommentBody: () => (/* binding */ resolveUsersInCommentBody),\n/* harmony export */   shallow: () => (/* binding */ shallow),\n/* harmony export */   stableStringify: () => (/* binding */ stableStringify),\n/* harmony export */   stringifyCommentBody: () => (/* binding */ stringifyCommentBody),\n/* harmony export */   throwUsageError: () => (/* binding */ throwUsageError),\n/* harmony export */   toAbsoluteUrl: () => (/* binding */ toAbsoluteUrl),\n/* harmony export */   toPlainLson: () => (/* binding */ toPlainLson),\n/* harmony export */   tryParseJson: () => (/* binding */ tryParseJson),\n/* harmony export */   url: () => (/* binding */ url),\n/* harmony export */   urljoin: () => (/* binding */ urljoin),\n/* harmony export */   wait: () => (/* binding */ wait),\n/* harmony export */   withTimeout: () => (/* binding */ withTimeout)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/core\";\nvar PKG_VERSION = \"2.22.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/dupe-detection.ts\nvar g = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {};\nvar crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nvar dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nvar SPACE = \" \";\nfunction error(msg) {\n  if (false) {} else {\n    throw new Error(msg);\n  }\n}\nfunction detectDupes(pkgName, pkgVersion, pkgFormat) {\n  const pkgId = Symbol.for(pkgName);\n  const pkgBuildInfo = pkgFormat ? `${pkgVersion || \"dev\"} (${pkgFormat})` : pkgVersion || \"dev\";\n  if (!g[pkgId]) {\n    g[pkgId] = pkgBuildInfo;\n  } else if (g[pkgId] === pkgBuildInfo) {\n  } else {\n    const msg = [\n      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${dupesDocs + SPACE}`,\n      \"\",\n      \"Conflicts:\",\n      `- ${pkgName} ${g[pkgId]} (already loaded)`,\n      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`\n    ].join(\"\\n\");\n    error(msg);\n  }\n  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n    error(\n      [\n        `Cross-linked versions of Liveblocks found, which will cause issues! See ${crossLinkedDocs + SPACE}`,\n        \"\",\n        \"Conflicts:\",\n        `- ${PKG_NAME} is at ${PKG_VERSION}`,\n        `- ${pkgName} is at ${pkgVersion}`,\n        \"\",\n        \"Always upgrade all Liveblocks packages to the same version number.\"\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// src/convert-plain-data.ts\nfunction convertToCommentData(data) {\n  const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const reactions = data.reactions.map((reaction) => ({\n    ...reaction,\n    createdAt: new Date(reaction.createdAt)\n  }));\n  if (data.body) {\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt\n    };\n  } else {\n    const deletedAt = new Date(data.deletedAt);\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n      deletedAt\n    };\n  }\n}\nfunction convertToThreadData(data) {\n  const createdAt = new Date(data.createdAt);\n  const updatedAt = new Date(data.updatedAt);\n  const comments = data.comments.map(\n    (comment) => convertToCommentData(comment)\n  );\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    comments\n  };\n}\nfunction convertToCommentUserReaction(data) {\n  return {\n    ...data,\n    createdAt: new Date(data.createdAt)\n  };\n}\nfunction convertToInboxNotificationData(data) {\n  const notifiedAt = new Date(data.notifiedAt);\n  const readAt = data.readAt ? new Date(data.readAt) : null;\n  if (\"activities\" in data) {\n    const activities = data.activities.map((activity) => ({\n      ...activity,\n      createdAt: new Date(activity.createdAt)\n    }));\n    return {\n      ...data,\n      notifiedAt,\n      readAt,\n      activities\n    };\n  }\n  return {\n    ...data,\n    notifiedAt,\n    readAt\n  };\n}\nfunction convertToThreadDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\nfunction convertToInboxNotificationDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\n\n// src/lib/fancy-console.ts\nvar fancy_console_exports = {};\n__export(fancy_console_exports, {\n  error: () => error2,\n  errorWithTitle: () => errorWithTitle,\n  warn: () => warn,\n  warnWithTitle: () => warnWithTitle\n});\nvar badge = \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nvar bold = \"font-weight:600\";\nfunction wrap(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (message, ...args) => console[method](\"%cLiveblocks\", badge, message, ...args)\n  );\n}\nvar warn = wrap(\"warn\");\nvar error2 = wrap(\"error\");\nfunction wrapWithTitle(method) {\n  return typeof window === \"undefined\" || \"development\" === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (title, message, ...args) => console[method](\n      `%cLiveblocks%c ${title}`,\n      badge,\n      bold,\n      message,\n      ...args\n    )\n  );\n}\nvar warnWithTitle = wrapWithTitle(\"warn\");\nvar errorWithTitle = wrapWithTitle(\"error\");\n\n// src/lib/guards.ts\nfunction isPlainObject(blob) {\n  return blob !== null && typeof blob === \"object\" && Object.prototype.toString.call(blob) === \"[object Object]\";\n}\nfunction isStartsWithOperator(blob) {\n  return isPlainObject(blob) && typeof blob.startsWith === \"string\";\n}\n\n// src/lib/utils.ts\nfunction raise(msg) {\n  throw new Error(msg);\n}\nfunction entries(obj) {\n  return Object.entries(obj);\n}\nfunction keys(obj) {\n  return Object.keys(obj);\n}\nfunction values(obj) {\n  return Object.values(obj);\n}\nfunction create(obj, descriptors) {\n  if (typeof descriptors !== \"undefined\") {\n    return Object.create(obj, descriptors);\n  }\n  return Object.create(obj);\n}\nfunction mapValues(obj, mapFn) {\n  const result = {};\n  for (const pair of Object.entries(obj)) {\n    const key = pair[0];\n    if (key === \"__proto__\") {\n      continue;\n    }\n    const value = pair[1];\n    result[key] = mapFn(value, key);\n  }\n  return result;\n}\nfunction tryParseJson(rawMessage) {\n  try {\n    return JSON.parse(rawMessage);\n  } catch (e) {\n    return void 0;\n  }\n}\nfunction deepClone(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nfunction b64decode(b64value) {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(\n      atob(formattedValue).split(\"\").map(function(c) {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(\"\")\n    );\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n}\nfunction compact(items) {\n  return items.filter(\n    (item) => item !== null && item !== void 0\n  );\n}\nfunction compactObject(obj) {\n  const newObj = { ...obj };\n  Object.keys(obj).forEach((k) => {\n    const key = k;\n    if (newObj[key] === void 0) {\n      delete newObj[key];\n    }\n  });\n  return newObj;\n}\nfunction wait(millis) {\n  return new Promise((res) => setTimeout(res, millis));\n}\nasync function withTimeout(promise, millis, errmsg) {\n  let timerID;\n  const timer$ = new Promise((_, reject) => {\n    timerID = setTimeout(() => {\n      reject(new Error(errmsg));\n    }, millis);\n  });\n  return Promise.race([promise, timer$]).finally(() => clearTimeout(timerID));\n}\nfunction memoizeOnSuccess(factoryFn) {\n  let cached = null;\n  return () => {\n    if (cached === null) {\n      cached = factoryFn().catch((err) => {\n        setTimeout(() => {\n          cached = null;\n        }, 5e3);\n        throw err;\n      });\n    }\n    return cached;\n  };\n}\n\n// src/lib/autoRetry.ts\nvar HttpError = class _HttpError extends Error {\n  response;\n  details;\n  constructor(message, response, details) {\n    super(message);\n    this.name = \"HttpError\";\n    this.response = response;\n    this.details = details;\n  }\n  static async fromResponse(response) {\n    let bodyAsText;\n    try {\n      bodyAsText = await response.text();\n    } catch {\n    }\n    const bodyAsJson = bodyAsText ? tryParseJson(bodyAsText) : void 0;\n    let bodyAsJsonObject;\n    if (isPlainObject(bodyAsJson)) {\n      bodyAsJsonObject = bodyAsJson;\n    }\n    let message = \"\";\n    message ||= typeof bodyAsJsonObject?.message === \"string\" ? bodyAsJsonObject.message : \"\";\n    message ||= typeof bodyAsJsonObject?.error === \"string\" ? bodyAsJsonObject.error : \"\";\n    if (bodyAsJson === void 0) {\n      message ||= bodyAsText || \"\";\n    }\n    message ||= response.statusText;\n    let path;\n    try {\n      path = new URL(response.url).pathname;\n    } catch {\n    }\n    message += path !== void 0 ? ` (got status ${response.status} from ${path})` : ` (got status ${response.status})`;\n    const details = bodyAsJsonObject;\n    return new _HttpError(message, response, details);\n  }\n  /**\n   * Convenience accessor for response.status.\n   */\n  get status() {\n    return this.response.status;\n  }\n};\nvar DONT_RETRY_4XX = (x) => x instanceof HttpError && x.status >= 400 && x.status < 500;\nasync function autoRetry(promiseFn, maxTries, backoff, shouldStopRetrying = DONT_RETRY_4XX) {\n  const fallbackBackoff = backoff.length > 0 ? backoff[backoff.length - 1] : 0;\n  let attempt = 0;\n  while (true) {\n    attempt++;\n    try {\n      return await promiseFn();\n    } catch (err) {\n      if (shouldStopRetrying(err)) {\n        throw err;\n      }\n      if (attempt >= maxTries) {\n        throw new Error(`Failed after ${maxTries} attempts: ${String(err)}`);\n      }\n    }\n    const delay = backoff[attempt - 1] ?? fallbackBackoff;\n    warn(\n      `Attempt ${attempt} was unsuccessful. Retrying in ${delay} milliseconds.`\n    );\n    await wait(delay);\n  }\n}\n\n// src/lib/controlledPromise.ts\nfunction controlledPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return [promise, resolve, reject];\n}\nfunction Promise_withResolvers() {\n  const [promise, resolve, reject] = controlledPromise();\n  return { promise, resolve, reject };\n}\n\n// src/lib/EventSource.ts\nfunction makeEventSource() {\n  const _observers = /* @__PURE__ */ new Set();\n  function subscribe(callback) {\n    _observers.add(callback);\n    return () => _observers.delete(callback);\n  }\n  function subscribeOnce(callback) {\n    const unsub = subscribe((event) => {\n      unsub();\n      return callback(event);\n    });\n    return unsub;\n  }\n  async function waitUntil(predicate) {\n    let unsub;\n    return new Promise((res) => {\n      unsub = subscribe((event) => {\n        if (predicate === void 0 || predicate(event)) {\n          res(event);\n        }\n      });\n    }).finally(() => unsub?.());\n  }\n  function notify(event) {\n    let called = false;\n    for (const callback of _observers) {\n      callback(event);\n      called = true;\n    }\n    return called;\n  }\n  function count() {\n    return _observers.size;\n  }\n  return {\n    // Private/internal control over event emission\n    notify,\n    subscribe,\n    subscribeOnce,\n    count,\n    waitUntil,\n    [Symbol.dispose]: () => {\n      _observers.clear();\n    },\n    // Publicly exposable subscription API\n    observable: {\n      subscribe,\n      subscribeOnce,\n      waitUntil\n    }\n  };\n}\nfunction makeBufferableEventSource() {\n  const eventSource2 = makeEventSource();\n  let _buffer = null;\n  function pause() {\n    _buffer = [];\n  }\n  function unpause() {\n    if (_buffer === null) {\n      return;\n    }\n    for (const event of _buffer) {\n      eventSource2.notify(event);\n    }\n    _buffer = null;\n  }\n  function notifyOrBuffer(event) {\n    if (_buffer !== null) {\n      _buffer.push(event);\n      return false;\n    } else {\n      return eventSource2.notify(event);\n    }\n  }\n  return {\n    ...eventSource2,\n    notify: notifyOrBuffer,\n    pause,\n    unpause,\n    [Symbol.dispose]: () => {\n      eventSource2[Symbol.dispose]();\n      if (_buffer !== null) {\n        _buffer.length = 0;\n      }\n    }\n  };\n}\n\n// src/lib/freeze.ts\nvar freeze =  false ? (\n  /* istanbul ignore next */\n  0\n) : Object.freeze;\n\n// src/lib/signals.ts\nvar kSinks = Symbol(\"kSinks\");\nvar kTrigger = Symbol(\"kTrigger\");\nvar signalsToTrigger = null;\nvar trackedReads = null;\nfunction batch(callback) {\n  if (signalsToTrigger !== null) {\n    callback();\n    return;\n  }\n  signalsToTrigger = /* @__PURE__ */ new Set();\n  try {\n    callback();\n  } finally {\n    for (const signal of signalsToTrigger) {\n      signal[kTrigger]();\n    }\n    signalsToTrigger = null;\n  }\n}\nfunction enqueueTrigger(signal) {\n  if (!signalsToTrigger) raise(\"Expected to be in an active batch\");\n  signalsToTrigger.add(signal);\n}\nfunction merge(target, patch) {\n  let updated = false;\n  const newValue = { ...target };\n  Object.keys(patch).forEach((k) => {\n    const key = k;\n    const val = patch[key];\n    if (newValue[key] !== val) {\n      if (val === void 0) {\n        delete newValue[key];\n      } else {\n        newValue[key] = val;\n      }\n      updated = true;\n    }\n  });\n  return updated ? newValue : target;\n}\nvar AbstractSignal = class {\n  /** @internal */\n  equals;\n  #eventSource;\n  /** @internal */\n  [kSinks];\n  constructor(equals) {\n    this.equals = equals ?? Object.is;\n    this.#eventSource = makeEventSource();\n    this[kSinks] = /* @__PURE__ */ new Set();\n    this.get = this.get.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n    this.subscribeOnce = this.subscribeOnce.bind(this);\n  }\n  [Symbol.dispose]() {\n    this.#eventSource[Symbol.dispose]();\n    this.#eventSource = \"(disposed)\";\n    this.equals = \"(disposed)\";\n  }\n  get hasWatchers() {\n    if (this.#eventSource.count() > 0) return true;\n    for (const sink of this[kSinks]) {\n      if (sink.hasWatchers) {\n        return true;\n      }\n    }\n    return false;\n  }\n  [kTrigger]() {\n    this.#eventSource.notify();\n    for (const sink of this[kSinks]) {\n      enqueueTrigger(sink);\n    }\n  }\n  subscribe(callback) {\n    if (this.#eventSource.count() === 0) {\n      this.get();\n    }\n    return this.#eventSource.subscribe(callback);\n  }\n  subscribeOnce(callback) {\n    const unsub = this.subscribe(() => {\n      unsub();\n      return callback();\n    });\n    return unsub;\n  }\n  waitUntil() {\n    throw new Error(\"waitUntil not supported on Signals\");\n  }\n  markSinksDirty() {\n    for (const sink of this[kSinks]) {\n      sink.markDirty();\n    }\n  }\n  addSink(sink) {\n    this[kSinks].add(sink);\n  }\n  removeSink(sink) {\n    this[kSinks].delete(sink);\n  }\n  asReadonly() {\n    return this;\n  }\n};\nvar Signal = class extends AbstractSignal {\n  #value;\n  constructor(value, equals) {\n    super(equals);\n    this.#value = freeze(value);\n  }\n  [Symbol.dispose]() {\n    super[Symbol.dispose]();\n    this.#value = \"(disposed)\";\n  }\n  get() {\n    trackedReads?.add(this);\n    return this.#value;\n  }\n  set(newValue) {\n    batch(() => {\n      if (typeof newValue === \"function\") {\n        newValue = newValue(this.#value);\n      }\n      if (!this.equals(this.#value, newValue)) {\n        this.#value = freeze(newValue);\n        this.markSinksDirty();\n        enqueueTrigger(this);\n      }\n    });\n  }\n};\nvar PatchableSignal = class extends Signal {\n  constructor(data) {\n    super(freeze(compactObject(data)));\n  }\n  set() {\n    throw new Error(\"Don't call .set() directly, use .patch()\");\n  }\n  /**\n   * Patches the current object.\n   */\n  patch(patch) {\n    super.set((old) => merge(old, patch));\n  }\n};\nvar INITIAL = Symbol();\nvar DerivedSignal = class _DerivedSignal extends AbstractSignal {\n  #prevValue;\n  #dirty;\n  // When true, the value in #value may not be up-to-date and needs re-checking\n  #sources;\n  #deps;\n  #transform;\n  // prettier-ignore\n  static from(...args) {\n    const last = args.pop();\n    if (typeof last !== \"function\")\n      raise(\"Invalid .from() call, last argument expected to be a function\");\n    if (typeof args[args.length - 1] === \"function\") {\n      const equals = last;\n      const transform = args.pop();\n      return new _DerivedSignal(args, transform, equals);\n    } else {\n      const transform = last;\n      return new _DerivedSignal(args, transform);\n    }\n  }\n  constructor(deps, transform, equals) {\n    super(equals);\n    this.#dirty = true;\n    this.#prevValue = INITIAL;\n    this.#deps = deps;\n    this.#sources = /* @__PURE__ */ new Set();\n    this.#transform = transform;\n  }\n  [Symbol.dispose]() {\n    for (const src of this.#sources) {\n      src.removeSink(this);\n    }\n    this.#prevValue = \"(disposed)\";\n    this.#sources = \"(disposed)\";\n    this.#deps = \"(disposed)\";\n    this.#transform = \"(disposed)\";\n  }\n  get isDirty() {\n    return this.#dirty;\n  }\n  #recompute() {\n    const oldTrackedReads = trackedReads;\n    let derived;\n    trackedReads = /* @__PURE__ */ new Set();\n    try {\n      derived = this.#transform(...this.#deps.map((p) => p.get()));\n    } finally {\n      const oldSources = this.#sources;\n      this.#sources = /* @__PURE__ */ new Set();\n      for (const sig of trackedReads) {\n        this.#sources.add(sig);\n        oldSources.delete(sig);\n      }\n      for (const oldSource of oldSources) {\n        oldSource.removeSink(this);\n      }\n      for (const newSource of this.#sources) {\n        newSource.addSink(this);\n      }\n      trackedReads = oldTrackedReads;\n    }\n    this.#dirty = false;\n    if (!this.equals(this.#prevValue, derived)) {\n      this.#prevValue = derived;\n      return true;\n    }\n    return false;\n  }\n  markDirty() {\n    if (!this.#dirty) {\n      this.#dirty = true;\n      this.markSinksDirty();\n    }\n  }\n  get() {\n    if (this.#dirty) {\n      this.#recompute();\n    }\n    trackedReads?.add(this);\n    return this.#prevValue;\n  }\n  /**\n   * Called by the Signal system if one or more of the dependent signals have\n   * changed. In the case of a DerivedSignal, we'll only want to re-evaluate\n   * the actual value if it's being watched, or any of their sinks are being\n   * watched actively.\n   */\n  [kTrigger]() {\n    if (!this.hasWatchers) {\n      return;\n    }\n    const updated = this.#recompute();\n    if (updated) {\n      super[kTrigger]();\n    }\n  }\n};\nvar MutableSignal = class extends AbstractSignal {\n  #state;\n  constructor(initialState) {\n    super();\n    this.#state = initialState;\n  }\n  [Symbol.dispose]() {\n    super[Symbol.dispose]();\n    this.#state = \"(disposed)\";\n  }\n  get() {\n    trackedReads?.add(this);\n    return this.#state;\n  }\n  /**\n   * Invokes a callback function that is allowed to mutate the given state\n   * value. Do not change the value outside of the callback.\n   *\n   * If the callback explicitly returns `false`, it's assumed that the state\n   * was not changed.\n   */\n  mutate(callback) {\n    batch(() => {\n      const result = callback ? callback(this.#state) : true;\n      if (result !== null && typeof result === \"object\" && \"then\" in result) {\n        raise(\"MutableSignal.mutate() does not support async callbacks\");\n      }\n      if (result !== false) {\n        this.markSinksDirty();\n        enqueueTrigger(this);\n      }\n    });\n  }\n};\n\n// src/lib/stringify.ts\nfunction replacer(_key, value) {\n  return value !== null && typeof value === \"object\" && !Array.isArray(value) ? Object.keys(value).sort().reduce((sorted, key) => {\n    sorted[key] = value[key];\n    return sorted;\n  }, {}) : value;\n}\nfunction stableStringify(value) {\n  return JSON.stringify(value, replacer);\n}\nfunction stringifyOrLog(value) {\n  try {\n    return JSON.stringify(value);\n  } catch (err) {\n    console.error(`Could not stringify: ${err.message}`);\n    console.error(value);\n    throw err;\n  }\n}\n\n// src/lib/batch.ts\nvar DEFAULT_SIZE = 50;\nvar BatchCall = class {\n  input;\n  resolve;\n  reject;\n  promise;\n  constructor(input) {\n    this.input = input;\n    const { promise, resolve, reject } = Promise_withResolvers();\n    this.promise = promise;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n};\nvar Batch = class {\n  #queue = [];\n  #callback;\n  #size;\n  #delay;\n  #delayTimeoutId;\n  error = false;\n  constructor(callback, options) {\n    this.#callback = callback;\n    this.#size = options.size ?? DEFAULT_SIZE;\n    this.#delay = options.delay;\n  }\n  #clearDelayTimeout() {\n    if (this.#delayTimeoutId !== void 0) {\n      clearTimeout(this.#delayTimeoutId);\n      this.#delayTimeoutId = void 0;\n    }\n  }\n  #schedule() {\n    if (this.#queue.length === this.#size) {\n      void this.#flush();\n    } else if (this.#queue.length === 1) {\n      this.#clearDelayTimeout();\n      this.#delayTimeoutId = setTimeout(() => void this.#flush(), this.#delay);\n    }\n  }\n  async #flush() {\n    if (this.#queue.length === 0) {\n      return;\n    }\n    const calls = this.#queue.splice(0);\n    const inputs = calls.map((call) => call.input);\n    try {\n      const results = await this.#callback(inputs);\n      this.error = false;\n      calls.forEach((call, index) => {\n        const result = results?.[index];\n        if (!Array.isArray(results)) {\n          call.reject(new Error(\"Callback must return an array.\"));\n        } else if (calls.length !== results.length) {\n          call.reject(\n            new Error(\n              `Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`\n            )\n          );\n        } else if (result instanceof Error) {\n          call.reject(result);\n        } else {\n          call.resolve(result);\n        }\n      });\n    } catch (error3) {\n      this.error = true;\n      calls.forEach((call) => {\n        call.reject(error3);\n      });\n    }\n  }\n  get(input) {\n    const existingCall = this.#queue.find(\n      (call2) => stableStringify(call2.input) === stableStringify(input)\n    );\n    if (existingCall) {\n      return existingCall.promise;\n    }\n    const call = new BatchCall(input);\n    this.#queue.push(call);\n    this.#schedule();\n    return call.promise;\n  }\n  clear() {\n    this.#queue = [];\n    this.error = false;\n    this.#clearDelayTimeout();\n  }\n};\nfunction createBatchStore(batch2) {\n  const signal = new MutableSignal(/* @__PURE__ */ new Map());\n  function getCacheKey(args) {\n    return stableStringify(args);\n  }\n  function update(cacheKey, state) {\n    signal.mutate((cache) => {\n      cache.set(cacheKey, state);\n    });\n  }\n  function invalidate(inputs) {\n    signal.mutate((cache) => {\n      if (Array.isArray(inputs)) {\n        for (const input of inputs) {\n          cache.delete(getCacheKey(input));\n        }\n      } else {\n        cache.clear();\n      }\n    });\n  }\n  async function enqueue(input) {\n    const cacheKey = getCacheKey(input);\n    const cache = signal.get();\n    if (cache.has(cacheKey)) {\n      return;\n    }\n    try {\n      update(cacheKey, { isLoading: true });\n      const result = await batch2.get(input);\n      update(cacheKey, { isLoading: false, data: result });\n    } catch (error3) {\n      update(cacheKey, {\n        isLoading: false,\n        error: error3\n      });\n    }\n  }\n  function getItemState(input) {\n    const cacheKey = getCacheKey(input);\n    const cache = signal.get();\n    return cache.get(cacheKey);\n  }\n  function _cacheKeys() {\n    const cache = signal.get();\n    return [...cache.keys()];\n  }\n  return {\n    subscribe: signal.subscribe,\n    enqueue,\n    getItemState,\n    invalidate,\n    batch: batch2,\n    _cacheKeys\n  };\n}\n\n// src/lib/chunk.ts\nfunction chunk(array, size) {\n  const chunks = [];\n  for (let i = 0, j = array.length; i < j; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\n\n// src/lib/nanoid.ts\nvar nanoid = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce(\n  (t2, e) => t2 += (e &= 63) < 36 ? e.toString(36) : e < 62 ? (e - 26).toString(36).toUpperCase() : e < 63 ? \"_\" : \"-\",\n  \"\"\n);\n\n// src/lib/createIds.ts\nvar THREAD_ID_PREFIX = \"th\";\nvar COMMENT_ID_PREFIX = \"cm\";\nvar COMMENT_ATTACHMENT_ID_PREFIX = \"at\";\nvar INBOX_NOTIFICATION_ID_PREFIX = \"in\";\nfunction createOptimisticId(prefix) {\n  return `${prefix}_${nanoid()}`;\n}\nfunction createThreadId() {\n  return createOptimisticId(THREAD_ID_PREFIX);\n}\nfunction createCommentId() {\n  return createOptimisticId(COMMENT_ID_PREFIX);\n}\nfunction createCommentAttachmentId() {\n  return createOptimisticId(COMMENT_ATTACHMENT_ID_PREFIX);\n}\nfunction createInboxNotificationId() {\n  return createOptimisticId(INBOX_NOTIFICATION_ID_PREFIX);\n}\n\n// src/lib/DefaultMap.ts\nvar DefaultMap = class extends Map {\n  #defaultFn;\n  /**\n   * If the default function is not provided to the constructor, it has to be\n   * provided in each .getOrCreate() call individually.\n   */\n  constructor(defaultFn, entries2) {\n    super(entries2);\n    this.#defaultFn = defaultFn;\n  }\n  /**\n   * Gets the value at the given key, or creates it.\n   *\n   * Difference from normal Map: if the key does not exist, it will be created\n   * on the fly using the factory function, and that value will get returned\n   * instead of `undefined`.\n   */\n  getOrCreate(key, defaultFn) {\n    if (super.has(key)) {\n      return super.get(key);\n    } else {\n      const fn = defaultFn ?? this.#defaultFn ?? raise(\"DefaultMap used without a factory function\");\n      const value = fn(key);\n      this.set(key, value);\n      return value;\n    }\n  }\n};\n\n// src/lib/objectToQuery.ts\nvar identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\nfunction objectToQuery(obj) {\n  let filterList = [];\n  const entries2 = Object.entries(obj);\n  const keyValuePairs = [];\n  const keyValuePairsWithOperator = [];\n  const indexedKeys = [];\n  entries2.forEach(([key, value]) => {\n    if (!identifierRegex.test(key)) {\n      throw new Error(\"Key must only contain letters, numbers, _\");\n    }\n    if (isSimpleValue(value)) {\n      keyValuePairs.push([key, value]);\n    } else if (isPlainObject(value)) {\n      if (isStartsWithOperator(value)) {\n        keyValuePairsWithOperator.push([key, value]);\n      } else {\n        indexedKeys.push([key, value]);\n      }\n    }\n  });\n  filterList = [\n    ...getFiltersFromKeyValuePairs(keyValuePairs),\n    ...getFiltersFromKeyValuePairsWithOperator(keyValuePairsWithOperator)\n  ];\n  indexedKeys.forEach(([key, value]) => {\n    const nestedEntries = Object.entries(value);\n    const nKeyValuePairs = [];\n    const nKeyValuePairsWithOperator = [];\n    nestedEntries.forEach(([nestedKey, nestedValue]) => {\n      if (isStringEmpty(nestedKey)) {\n        throw new Error(\"Key cannot be empty\");\n      }\n      if (isSimpleValue(nestedValue)) {\n        nKeyValuePairs.push([formatFilterKey(key, nestedKey), nestedValue]);\n      } else if (isStartsWithOperator(nestedValue)) {\n        nKeyValuePairsWithOperator.push([\n          formatFilterKey(key, nestedKey),\n          nestedValue\n        ]);\n      }\n    });\n    filterList = [\n      ...filterList,\n      ...getFiltersFromKeyValuePairs(nKeyValuePairs),\n      ...getFiltersFromKeyValuePairsWithOperator(nKeyValuePairsWithOperator)\n    ];\n  });\n  return filterList.map(({ key, operator, value }) => `${key}${operator}${quote(value)}`).join(\" \");\n}\nvar getFiltersFromKeyValuePairs = (keyValuePairs) => {\n  const filters = [];\n  keyValuePairs.forEach(([key, value]) => {\n    filters.push({\n      key,\n      operator: \":\",\n      value\n    });\n  });\n  return filters;\n};\nvar getFiltersFromKeyValuePairsWithOperator = (keyValuePairsWithOperator) => {\n  const filters = [];\n  keyValuePairsWithOperator.forEach(([key, value]) => {\n    if (\"startsWith\" in value && typeof value.startsWith === \"string\") {\n      filters.push({\n        key,\n        operator: \"^\",\n        value: value.startsWith\n      });\n    }\n  });\n  return filters;\n};\nvar isSimpleValue = (value) => {\n  return typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\" || value === null;\n};\nvar formatFilterKey = (key, nestedKey) => {\n  if (nestedKey) {\n    return `${key}[${quote(nestedKey)}]`;\n  }\n  return key;\n};\nvar isStringEmpty = (value) => {\n  return !value || value.toString().trim() === \"\";\n};\nfunction quote(input) {\n  const result = JSON.stringify(input);\n  if (typeof input !== \"string\") {\n    return result;\n  }\n  if (result.includes(\"'\")) {\n    return result;\n  }\n  return `'${result.slice(1, -1).replace(/\\\\\"/g, '\"')}'`;\n}\n\n// src/lib/url.ts\nfunction toURLSearchParams(params) {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\nfunction urljoin(baseUrl, path, params) {\n  const url2 = new URL(path, baseUrl);\n  if (params !== void 0) {\n    url2.search = (params instanceof URLSearchParams ? params : toURLSearchParams(params)).toString();\n  }\n  return url2.toString();\n}\nfunction url(strings, ...values2) {\n  return strings.reduce(\n    (result, str, i) => result + encodeURIComponent(values2[i - 1] ?? \"\") + str\n  );\n}\n\n// src/api-client.ts\nfunction createApiClient({\n  baseUrl,\n  authManager,\n  fetchPolyfill\n}) {\n  const httpClient = new HttpClient(baseUrl, fetchPolyfill);\n  async function getThreadsSince(options) {\n    const result = await httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/threads/delta`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        since: options.since.toISOString()\n      },\n      { signal: options.signal }\n    );\n    return {\n      threads: {\n        updated: result.data.map(convertToThreadData),\n        deleted: result.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      inboxNotifications: {\n        updated: result.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: result.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      requestedAt: new Date(result.meta.requestedAt),\n      permissionHints: result.meta.permissionHints\n    };\n  }\n  async function getThreads(options) {\n    let query;\n    if (options.query) {\n      query = objectToQuery(options.query);\n    }\n    const PAGE_SIZE = 50;\n    try {\n      const result = await httpClient.get(\n        url`/v2/c/rooms/${options.roomId}/threads`,\n        await authManager.getAuthValue({\n          requestedScope: \"comments:read\",\n          roomId: options.roomId\n        }),\n        {\n          cursor: options.cursor,\n          query,\n          limit: PAGE_SIZE\n        }\n      );\n      return {\n        threads: result.data.map(convertToThreadData),\n        inboxNotifications: result.inboxNotifications.map(\n          convertToInboxNotificationData\n        ),\n        nextCursor: result.meta.nextCursor,\n        requestedAt: new Date(result.meta.requestedAt),\n        permissionHints: result.meta.permissionHints\n      };\n    } catch (err) {\n      if (err instanceof HttpError && err.status === 404) {\n        return {\n          threads: [],\n          inboxNotifications: [],\n          nextCursor: null,\n          //\n          // HACK\n          // requestedAt needs to be a *server* timestamp here. However, on\n          // this 404 error response, there is no such timestamp. So out of\n          // pure necessity we'll fall back to a local timestamp instead (and\n          // allow for a possible 6 hour clock difference between client and\n          // server).\n          //\n          requestedAt: new Date(Date.now() - 6 * 60 * 60 * 1e3),\n          permissionHints: {}\n        };\n      }\n      throw err;\n    }\n  }\n  async function createThread(options) {\n    const commentId = options.commentId ?? createCommentId();\n    const threadId = options.threadId ?? createThreadId();\n    const thread = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        id: threadId,\n        comment: {\n          id: commentId,\n          body: options.body,\n          attachmentIds: options.attachmentIds\n        },\n        metadata: options.metadata\n      }\n    );\n    return convertToThreadData(thread);\n  }\n  async function deleteThread(options) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function getThread(options) {\n    const response = await httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/thread-with-notification/${options.threadId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        thread: convertToThreadData(json.thread),\n        inboxNotification: json.inboxNotification ? convertToInboxNotificationData(json.inboxNotification) : void 0\n      };\n    } else if (response.status === 404) {\n      return {\n        thread: void 0,\n        inboxNotification: void 0\n      };\n    } else {\n      throw new Error(\n        `There was an error while getting thread ${options.threadId}.`\n      );\n    }\n  }\n  async function editThreadMetadata(options) {\n    return await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/metadata`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      options.metadata\n    );\n  }\n  async function createComment(options) {\n    const commentId = options.commentId ?? createCommentId();\n    const comment = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        id: commentId,\n        body: options.body,\n        attachmentIds: options.attachmentIds\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function editComment(options) {\n    const comment = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        body: options.body,\n        attachmentIds: options.attachmentIds\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function deleteComment(options) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function addReaction(options) {\n    const reaction = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/reactions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      { emoji: options.emoji }\n    );\n    return convertToCommentUserReaction(reaction);\n  }\n  async function removeReaction(options) {\n    await httpClient.delete(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/comments/${options.commentId}/reactions/${options.emoji}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function markThreadAsResolved(options) {\n    await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/mark-as-resolved`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function markThreadAsUnresolved(options) {\n    await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/threads/${options.threadId}/mark-as-unresolved`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function uploadAttachment(options) {\n    const roomId = options.roomId;\n    const abortSignal = options.signal;\n    const attachment = options.attachment;\n    const abortError = abortSignal ? new DOMException(\n      `Upload of attachment ${options.attachment.id} was aborted.`,\n      \"AbortError\"\n    ) : void 0;\n    if (abortSignal?.aborted) {\n      throw abortError;\n    }\n    const handleRetryError = (err) => {\n      if (abortSignal?.aborted) {\n        throw abortError;\n      }\n      if (err instanceof HttpError && err.status === 413) {\n        throw err;\n      }\n      return false;\n    };\n    const ATTACHMENT_PART_SIZE = 5 * 1024 * 1024;\n    const RETRY_ATTEMPTS = 10;\n    const RETRY_DELAYS = [\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3,\n      2e3\n    ];\n    function splitFileIntoParts(file) {\n      const parts = [];\n      let start = 0;\n      while (start < file.size) {\n        const end = Math.min(start + ATTACHMENT_PART_SIZE, file.size);\n        parts.push({\n          partNumber: parts.length + 1,\n          part: file.slice(start, end)\n        });\n        start = end;\n      }\n      return parts;\n    }\n    if (attachment.size <= ATTACHMENT_PART_SIZE) {\n      return autoRetry(\n        async () => httpClient.putBlob(\n          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.name)}`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          attachment.file,\n          { fileSize: attachment.size },\n          { signal: abortSignal }\n        ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n    } else {\n      let uploadId;\n      const uploadedParts = [];\n      const createMultiPartUpload = await autoRetry(\n        async () => httpClient.post(\n          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.name)}`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          void 0,\n          { signal: abortSignal },\n          { fileSize: attachment.size }\n        ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n      try {\n        uploadId = createMultiPartUpload.uploadId;\n        const parts = splitFileIntoParts(attachment.file);\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n        const batches = chunk(parts, 5);\n        for (const parts2 of batches) {\n          const uploadedPartsPromises = [];\n          for (const { part, partNumber } of parts2) {\n            uploadedPartsPromises.push(\n              autoRetry(\n                async () => httpClient.putBlob(\n                  url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${createMultiPartUpload.uploadId}/${String(partNumber)}`,\n                  await authManager.getAuthValue({\n                    requestedScope: \"comments:read\",\n                    roomId\n                  }),\n                  part,\n                  void 0,\n                  { signal: abortSignal }\n                ),\n                RETRY_ATTEMPTS,\n                RETRY_DELAYS,\n                handleRetryError\n              )\n            );\n          }\n          uploadedParts.push(...await Promise.all(uploadedPartsPromises));\n        }\n        if (abortSignal?.aborted) {\n          throw abortError;\n        }\n        const sortedUploadedParts = uploadedParts.sort(\n          (a, b) => a.partNumber - b.partNumber\n        );\n        return httpClient.post(\n          url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${uploadId}/complete`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          { parts: sortedUploadedParts },\n          { signal: abortSignal }\n        );\n      } catch (error3) {\n        if (uploadId && error3?.name && (error3.name === \"AbortError\" || error3.name === \"TimeoutError\")) {\n          try {\n            await httpClient.rawDelete(\n              url`/v2/c/rooms/${roomId}/attachments/${attachment.id}/multipart/${uploadId}`,\n              await authManager.getAuthValue({\n                requestedScope: \"comments:read\",\n                roomId\n              })\n            );\n          } catch (error4) {\n          }\n        }\n        throw error3;\n      }\n    }\n  }\n  const attachmentUrlsBatchStoresByRoom = new DefaultMap((roomId) => {\n    const batch2 = new Batch(\n      async (batchedAttachmentIds) => {\n        const attachmentIds = batchedAttachmentIds.flat();\n        const { urls } = await httpClient.post(\n          url`/v2/c/rooms/${roomId}/attachments/presigned-urls`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          { attachmentIds }\n        );\n        return urls.map(\n          (url2) => url2 ?? new Error(\"There was an error while getting this attachment's URL\")\n        );\n      },\n      { delay: 50 }\n    );\n    return createBatchStore(batch2);\n  });\n  function getOrCreateAttachmentUrlsStore(roomId) {\n    return attachmentUrlsBatchStoresByRoom.getOrCreate(roomId);\n  }\n  function getAttachmentUrl(options) {\n    const batch2 = getOrCreateAttachmentUrlsStore(options.roomId).batch;\n    return batch2.get(options.attachmentId);\n  }\n  async function getNotificationSettings(options) {\n    return httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/notification-settings`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      void 0,\n      {\n        signal: options.signal\n      }\n    );\n  }\n  async function updateNotificationSettings(options) {\n    return httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/notification-settings`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      options.settings\n    );\n  }\n  const markAsReadBatchesByRoom = new DefaultMap(\n    (roomId) => new Batch(\n      async (batchedInboxNotificationIds) => {\n        const inboxNotificationIds = batchedInboxNotificationIds.flat();\n        await httpClient.post(\n          url`/v2/c/rooms/${roomId}/inbox-notifications/read`,\n          await authManager.getAuthValue({\n            requestedScope: \"comments:read\",\n            roomId\n          }),\n          { inboxNotificationIds }\n        );\n        return inboxNotificationIds;\n      },\n      { delay: 50 }\n    )\n  );\n  async function markRoomInboxNotificationAsRead(options) {\n    const batch2 = markAsReadBatchesByRoom.getOrCreate(options.roomId);\n    return batch2.get(options.inboxNotificationId);\n  }\n  async function createTextMention(options) {\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/text-mentions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        userId: options.userId,\n        mentionId: options.mentionId\n      }\n    );\n  }\n  async function deleteTextMention(options) {\n    await httpClient.rawDelete(\n      url`/v2/c/rooms/${options.roomId}/text-mentions/${options.mentionId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function getTextVersion(options) {\n    return httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/y-version/${options.versionId}`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function createTextVersion(options) {\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/version`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n  }\n  async function reportTextEditor(options) {\n    await httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/text-metadata`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      {\n        type: options.type,\n        rootKey: options.rootKey\n      }\n    );\n  }\n  async function executeContextualPrompt(options) {\n    const result = await httpClient.post(\n      url`/v2/c/rooms/${options.roomId}/ai/contextual-prompt`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId\n      }),\n      {\n        prompt: options.prompt,\n        context: {\n          beforeSelection: options.context.beforeSelection,\n          selection: options.context.selection,\n          afterSelection: options.context.afterSelection\n        },\n        previous: options.previous\n      },\n      { signal: options.signal }\n    );\n    if (!result || result.content.length === 0) {\n      throw new Error(\"No content returned from server\");\n    }\n    return result.content[0].text;\n  }\n  async function listTextVersions(options) {\n    const result = await httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/versions`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      })\n    );\n    return {\n      versions: result.versions.map(({ createdAt, ...version }) => {\n        return {\n          createdAt: new Date(createdAt),\n          ...version\n        };\n      }),\n      requestedAt: new Date(result.meta.requestedAt)\n    };\n  }\n  async function listTextVersionsSince(options) {\n    const result = await httpClient.get(\n      url`/v2/c/rooms/${options.roomId}/versions/delta`,\n      await authManager.getAuthValue({\n        requestedScope: \"comments:read\",\n        roomId: options.roomId\n      }),\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n    return {\n      versions: result.versions.map(({ createdAt, ...version }) => {\n        return {\n          createdAt: new Date(createdAt),\n          ...version\n        };\n      }),\n      requestedAt: new Date(result.meta.requestedAt)\n    };\n  }\n  async function streamStorage(options) {\n    const result = await httpClient.rawGet(\n      url`/v2/c/rooms/${options.roomId}/storage`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId\n      })\n    );\n    return await result.json();\n  }\n  async function sendMessages(options) {\n    return httpClient.rawPost(\n      url`/v2/c/rooms/${options.roomId}/send-message`,\n      await authManager.getAuthValue({\n        requestedScope: \"room:read\",\n        roomId: options.roomId\n      }),\n      {\n        nonce: options.nonce,\n        messages: options.messages\n      }\n    );\n  }\n  async function getInboxNotifications(options) {\n    const PAGE_SIZE = 50;\n    const json = await httpClient.get(\n      url`/v2/c/inbox-notifications`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        cursor: options?.cursor,\n        limit: PAGE_SIZE\n      }\n    );\n    return {\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      threads: json.threads.map(convertToThreadData),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getInboxNotificationsSince(options) {\n    const json = await httpClient.get(\n      url`/v2/c/inbox-notifications/delta`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n    return {\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getUnreadInboxNotificationsCount() {\n    const { count } = await httpClient.get(\n      url`/v2/c/inbox-notifications/count`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n    return count;\n  }\n  async function markAllInboxNotificationsAsRead() {\n    await httpClient.post(\n      url`/v2/c/inbox-notifications/read`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        inboxNotificationIds: \"all\"\n      }\n    );\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await httpClient.post(\n      url`/v2/c/inbox-notifications/read`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        inboxNotificationIds\n      }\n    );\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: 50 }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  async function deleteAllInboxNotifications() {\n    await httpClient.delete(\n      url`/v2/c/inbox-notifications`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n  }\n  async function deleteInboxNotification(inboxNotificationId) {\n    await httpClient.delete(\n      url`/v2/c/inbox-notifications/${inboxNotificationId}`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" })\n    );\n  }\n  async function getUserNotificationSettings(options) {\n    return httpClient.get(\n      url`/v2/c/notification-settings`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      void 0,\n      { signal: options?.signal }\n    );\n  }\n  async function updateUserNotificationSettings(settings) {\n    return httpClient.post(\n      url`/v2/c/notification-settings`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      settings\n    );\n  }\n  async function getUserThreads_experimental(options) {\n    let query;\n    if (options?.query) {\n      query = objectToQuery(options.query);\n    }\n    const PAGE_SIZE = 50;\n    const json = await httpClient.get(\n      url`/v2/c/threads`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      {\n        cursor: options?.cursor,\n        query,\n        limit: PAGE_SIZE\n      }\n    );\n    return {\n      threads: json.threads.map(convertToThreadData),\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt),\n      permissionHints: json.meta.permissionHints\n    };\n  }\n  async function getUserThreadsSince_experimental(options) {\n    const json = await httpClient.get(\n      url`/v2/c/threads/delta`,\n      await authManager.getAuthValue({ requestedScope: \"comments:read\" }),\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n    return {\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      requestedAt: new Date(json.meta.requestedAt),\n      permissionHints: json.meta.permissionHints\n    };\n  }\n  return {\n    // Room threads\n    getThreads,\n    getThreadsSince,\n    createThread,\n    getThread,\n    deleteThread,\n    editThreadMetadata,\n    createComment,\n    editComment,\n    deleteComment,\n    addReaction,\n    removeReaction,\n    markThreadAsResolved,\n    markThreadAsUnresolved,\n    markRoomInboxNotificationAsRead,\n    // Room notifications\n    getNotificationSettings,\n    updateNotificationSettings,\n    // Room text editor\n    createTextMention,\n    deleteTextMention,\n    getTextVersion,\n    createTextVersion,\n    reportTextEditor,\n    listTextVersions,\n    listTextVersionsSince,\n    // Room attachments\n    getAttachmentUrl,\n    uploadAttachment,\n    getOrCreateAttachmentUrlsStore,\n    // Room storage\n    streamStorage,\n    sendMessages,\n    // Notification\n    getInboxNotifications,\n    getInboxNotificationsSince,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead,\n    deleteAllInboxNotifications,\n    deleteInboxNotification,\n    getUserNotificationSettings,\n    updateUserNotificationSettings,\n    // User threads\n    getUserThreads_experimental,\n    getUserThreadsSince_experimental,\n    // AI\n    executeContextualPrompt\n  };\n}\nfunction getBearerTokenFromAuthValue(authValue) {\n  if (authValue.type === \"public\") {\n    return authValue.publicApiKey;\n  } else {\n    return authValue.token.raw;\n  }\n}\nvar HttpClient = class {\n  #baseUrl;\n  #fetchPolyfill;\n  constructor(baseUrl, fetchPolyfill) {\n    this.#baseUrl = baseUrl;\n    this.#fetchPolyfill = fetchPolyfill;\n  }\n  // ------------------------------------------------------------------\n  // Public methods\n  // ------------------------------------------------------------------\n  /**\n   * Constructs and makes the HTTP request, but does not handle the response.\n   *\n   * This is what .rawFetch() does:     This method!\n   *   1. Set Content-Type header\n   *   2. Set Authorization header\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\n   *\n   * This is what .fetch() does ON TOP of that:\n   *   4. Parse response body as Json\n   *   5. ...but silently return `{}` if that parsing fails\n   *   6. Throw HttpError if response is an error\n   */\n  async #rawFetch(endpoint, authValue, options, params) {\n    if (!endpoint.startsWith(\"/v2/c/\")) {\n      raise(\"This client can only be used to make /v2/c/* requests\");\n    }\n    const url2 = urljoin(this.#baseUrl, endpoint, params);\n    return await this.#fetchPolyfill(url2, {\n      ...options,\n      headers: {\n        // These headers are default, but can be overriden by custom headers\n        \"Content-Type\": \"application/json; charset=utf-8\",\n        // Possible header overrides\n        ...options?.headers,\n        // Cannot be overriden by custom headers\n        Authorization: `Bearer ${getBearerTokenFromAuthValue(authValue)}`,\n        \"X-LB-Client\": PKG_VERSION || \"dev\"\n      }\n    });\n  }\n  /**\n   * Constructs, makes the HTTP request, and handles the response by parsing\n   * JSON and/or throwing an HttpError if it failed.\n   *\n   * This is what .rawFetch() does:\n   *   1. Set Content-Type header\n   *   2. Set Authorization header\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\n   *\n   * This is what .fetch() does ON TOP of that:    This method!\n   *   4. Parse response body as Json\n   *   5. ...but silently return `{}` if that parsing fails ()\n   *   6. Throw HttpError if response is an error\n   */\n  async #fetch(endpoint, authValue, options, params) {\n    const response = await this.#rawFetch(endpoint, authValue, options, params);\n    if (!response.ok) {\n      throw await HttpError.fromResponse(response);\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch {\n      body = {};\n    }\n    return body;\n  }\n  /**\n   * Makes a GET request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .get() instead.\n   */\n  async rawGet(endpoint, authValue, params, options) {\n    return await this.#rawFetch(endpoint, authValue, options, params);\n  }\n  /**\n   * Makes a POST request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .post() instead.\n   */\n  async rawPost(endpoint, authValue, body) {\n    return await this.#rawFetch(endpoint, authValue, {\n      method: \"POST\",\n      body: stringifyOrLog(body)\n    });\n  }\n  /**\n   * Makes a DELETE request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .delete() instead.\n   */\n  async rawDelete(endpoint, authValue) {\n    return await this.#rawFetch(endpoint, authValue, { method: \"DELETE\" });\n  }\n  /**\n   * Makes a GET request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async get(endpoint, authValue, params, options) {\n    return await this.#fetch(endpoint, authValue, options, params);\n  }\n  /**\n   * Makes a POST request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async post(endpoint, authValue, body, options, params) {\n    return await this.#fetch(\n      endpoint,\n      authValue,\n      {\n        ...options,\n        method: \"POST\",\n        body: stringifyOrLog(body)\n      },\n      params\n    );\n  }\n  /**\n   * Makes a DELETE request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async delete(endpoint, authValue) {\n    return await this.#fetch(endpoint, authValue, { method: \"DELETE\" });\n  }\n  /**\n   * Makes a PUT request for a Blob body, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async putBlob(endpoint, authValue, blob, params, options) {\n    return await this.#fetch(\n      endpoint,\n      authValue,\n      {\n        ...options,\n        method: \"PUT\",\n        headers: {\n          \"Content-Type\": \"application/octet-stream\"\n        },\n        body: blob\n      },\n      params\n    );\n  }\n};\n\n// src/lib/assert.ts\nfunction assertNever(_value, errmsg) {\n  throw new Error(errmsg);\n}\nfunction assert(condition, errmsg) {\n  if (true) {\n    if (!condition) {\n      const err = new Error(errmsg);\n      err.name = \"Assertion failure\";\n      throw err;\n    }\n  }\n}\nfunction nn(value, errmsg = \"Expected value to be non-nullable\") {\n  assert(value !== null && value !== void 0, errmsg);\n  return value;\n}\n\n// src/lib/fsm.ts\nfunction distance(state1, state2) {\n  if (state1 === state2) {\n    return [0, 0];\n  }\n  const chunks1 = state1.split(\".\");\n  const chunks2 = state2.split(\".\");\n  const minLen = Math.min(chunks1.length, chunks2.length);\n  let shared = 0;\n  for (; shared < minLen; shared++) {\n    if (chunks1[shared] !== chunks2[shared]) {\n      break;\n    }\n  }\n  const up = chunks1.length - shared;\n  const down = chunks2.length - shared;\n  return [up, down];\n}\nfunction patterns(targetState, levels) {\n  const parts = targetState.split(\".\");\n  if (levels < 1 || levels > parts.length + 1) {\n    throw new Error(\"Invalid number of levels\");\n  }\n  const result = [];\n  if (levels > parts.length) {\n    result.push(\"*\");\n  }\n  for (let i = parts.length - levels + 1; i < parts.length; i++) {\n    const slice = parts.slice(0, i);\n    if (slice.length > 0) {\n      result.push(slice.join(\".\") + \".*\");\n    }\n  }\n  result.push(targetState);\n  return result;\n}\nvar SafeContext = class {\n  #curr;\n  constructor(initialContext) {\n    this.#curr = initialContext;\n  }\n  get current() {\n    return this.#curr;\n  }\n  /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */\n  allowPatching(callback) {\n    const self = this;\n    let allowed = true;\n    const patchableContext = {\n      ...this.#curr,\n      patch(patch) {\n        if (allowed) {\n          self.#curr = Object.assign({}, self.#curr, patch);\n          for (const pair of Object.entries(patch)) {\n            const [key, value] = pair;\n            if (key !== \"patch\") {\n              this[key] = value;\n            }\n          }\n        } else {\n          throw new Error(\"Can no longer patch stale context\");\n        }\n      }\n    };\n    callback(patchableContext);\n    allowed = false;\n    return;\n  }\n};\nvar nextId = 1;\nvar FSM = class {\n  id;\n  // Indicates whether this state machine is still being configured, has\n  // started, or has terminated\n  #runningState;\n  #currentContext;\n  #states;\n  #currentStateOrNull;\n  #allowedTransitions;\n  #eventHub;\n  events;\n  //\n  // The cleanup stack is a stack of (optional) callback functions that will\n  // be run when exiting the current state. If a state (or state group) does\n  // not have an exit handler, then the entry for that level may be\n  // `undefined`, but there will be an explicit entry in the stack for it.\n  //\n  // This will always be true:\n  //\n  //   cleanupStack.length == currentState.split('.').length + 1\n  //\n  // Each stack level represents a different state \"group\".\n  //\n  // For example, if you are in a state named `foo.bar.qux`, then the stack\n  // will contain the exit handler for `foo.bar.qux` (at the top), then\n  // `foo.bar.*`, then `foo.*`, and finally, `*`.\n  //\n  #cleanupStack;\n  #enterFns;\n  // Used to provide better error messages\n  #knownEventTypes;\n  /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */\n  get #initialState() {\n    const result = this.#states.values()[Symbol.iterator]().next();\n    if (result.done) {\n      throw new Error(\"No states defined yet\");\n    } else {\n      return result.value;\n    }\n  }\n  get currentState() {\n    if (this.#currentStateOrNull === null) {\n      if (this.#runningState === 0 /* NOT_STARTED_YET */) {\n        throw new Error(\"Not started yet\");\n      } else {\n        throw new Error(\"Already stopped\");\n      }\n    }\n    return this.#currentStateOrNull;\n  }\n  /**\n   * Starts the machine by entering the initial state.\n   */\n  start() {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"State machine has already started\");\n    }\n    this.#runningState = 1 /* STARTED */;\n    this.#currentStateOrNull = this.#initialState;\n    this.#enter(null);\n    return this;\n  }\n  /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */\n  stop() {\n    if (this.#runningState !== 1 /* STARTED */) {\n      throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n    }\n    this.#exit(null);\n    this.#runningState = 2 /* STOPPED */;\n    this.#currentStateOrNull = null;\n  }\n  constructor(initialContext) {\n    this.id = nextId++;\n    this.#runningState = 0 /* NOT_STARTED_YET */;\n    this.#currentStateOrNull = null;\n    this.#states = /* @__PURE__ */ new Set();\n    this.#enterFns = /* @__PURE__ */ new Map();\n    this.#cleanupStack = [];\n    this.#knownEventTypes = /* @__PURE__ */ new Set();\n    this.#allowedTransitions = /* @__PURE__ */ new Map();\n    this.#currentContext = new SafeContext(initialContext);\n    this.#eventHub = {\n      didReceiveEvent: makeEventSource(),\n      willTransition: makeEventSource(),\n      didIgnoreEvent: makeEventSource(),\n      willExitState: makeEventSource(),\n      didEnterState: makeEventSource()\n    };\n    this.events = {\n      didReceiveEvent: this.#eventHub.didReceiveEvent.observable,\n      willTransition: this.#eventHub.willTransition.observable,\n      didIgnoreEvent: this.#eventHub.didIgnoreEvent.observable,\n      willExitState: this.#eventHub.willExitState.observable,\n      didEnterState: this.#eventHub.didEnterState.observable\n    };\n  }\n  get context() {\n    return this.#currentContext.current;\n  }\n  /**\n   * Define an explicit finite state in the state machine.\n   */\n  addState(state) {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    this.#states.add(state);\n    return this;\n  }\n  onEnter(nameOrPattern, enterFn) {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    } else if (this.#enterFns.has(nameOrPattern)) {\n      throw new Error(\n        // TODO We _currently_ don't support multiple .onEnters() for the same\n        // state, but this is not a fundamental limitation. Just not\n        // implemented yet. If we wanted to, we could make this an array.\n        `enter/exit function for ${nameOrPattern} already exists`\n      );\n    }\n    this.#enterFns.set(nameOrPattern, enterFn);\n    return this;\n  }\n  /**\n   * Defines a promise-based state. When the state is entered, the promise is\n   * created. When the promise resolves, the machine will transition to the\n   * provided `onOK` target state. When the promise rejects, the machine will\n   * transition to the `onError` target state.\n   *\n   * Optionally, a `maxTimeout` can be set. If the timeout happens before the\n   * promise is settled, then the machine will also transition to the `onError`\n   * target state.\n   *\n   * @param stateOrPattern  The state name, or state group pattern name.\n   * @param promiseFn       The callback to be invoked when the state is entered.\n   * @param onOK            The state to transition to when the promise resolves.\n   * @param onError         The state to transition to when the promise\n   *                        rejects, or when the timeout happens before the\n   *                        promise has been settled.\n   * @param maxTimeout      Optional timeout in milliseconds.\n   *\n   * When the promise callback function is invoked, it's provided with an\n   * AbortSignal (2nd argument).\n   * If a state transition happens while the promise is pending (for example,\n   * an event, or a timeout happens), then an abort signal will be used to\n   * indicate this. Implementers can use this abort signal to terminate the\n   * in-flight promise, or ignore its results, etc.\n   */\n  onEnterAsync(nameOrPattern, promiseFn, onOK, onError, maxTimeout) {\n    return this.onEnter(nameOrPattern, () => {\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n      const timeoutId = maxTimeout ? setTimeout(() => {\n        const reason = new Error(\"Timed out\");\n        this.#transition({ type: \"ASYNC_ERROR\", reason }, onError);\n      }, maxTimeout) : void 0;\n      let done = false;\n      void promiseFn(this.#currentContext.current, signal).then(\n        // On OK\n        (data) => {\n          if (!signal.aborted) {\n            done = true;\n            this.#transition({ type: \"ASYNC_OK\", data }, onOK);\n          }\n        },\n        // On Error\n        (reason) => {\n          if (!signal.aborted) {\n            done = true;\n            this.#transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }\n        }\n      );\n      return () => {\n        clearTimeout(timeoutId);\n        if (!done) {\n          abortController.abort();\n        }\n      };\n    });\n  }\n  #getStatesMatching(nameOrPattern) {\n    const matches = [];\n    if (nameOrPattern === \"*\") {\n      for (const state of this.#states) {\n        matches.push(state);\n      }\n    } else if (nameOrPattern.endsWith(\".*\")) {\n      const prefix = nameOrPattern.slice(0, -1);\n      for (const state of this.#states) {\n        if (state.startsWith(prefix)) {\n          matches.push(state);\n        }\n      }\n    } else {\n      const name = nameOrPattern;\n      if (this.#states.has(name)) {\n        matches.push(name);\n      }\n    }\n    if (matches.length === 0) {\n      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n    }\n    return matches;\n  }\n  /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */\n  addTransitions(nameOrPattern, mapping) {\n    if (this.#runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    for (const srcState of this.#getStatesMatching(nameOrPattern)) {\n      let map = this.#allowedTransitions.get(srcState);\n      if (map === void 0) {\n        map = /* @__PURE__ */ new Map();\n        this.#allowedTransitions.set(srcState, map);\n      }\n      for (const [type, target_] of Object.entries(mapping)) {\n        if (map.has(type)) {\n          throw new Error(\n            `Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`\n          );\n        }\n        const target = target_;\n        this.#knownEventTypes.add(type);\n        if (target !== void 0) {\n          const targetFn = typeof target === \"function\" ? target : () => target;\n          map.set(type, targetFn);\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern  The state name, or state group pattern name.\n   * @param after           Number of milliseconds after which to take the\n   *                        transition. If in the mean time, another transition\n   *                        is taken, the timer will get cancelled.\n   * @param target          The target state to go to.\n   */\n  addTimedTransition(stateOrPattern, after2, target) {\n    return this.onEnter(stateOrPattern, () => {\n      const ms = typeof after2 === \"function\" ? after2(this.#currentContext.current) : after2;\n      const timeoutID = setTimeout(() => {\n        this.#transition({ type: \"TIMER\" }, target);\n      }, ms);\n      return () => {\n        clearTimeout(timeoutID);\n      };\n    });\n  }\n  #getTargetFn(eventName) {\n    return this.#allowedTransitions.get(this.currentState)?.get(eventName);\n  }\n  /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */\n  #exit(levels) {\n    this.#eventHub.willExitState.notify(this.currentState);\n    this.#currentContext.allowPatching((patchableContext) => {\n      levels = levels ?? this.#cleanupStack.length;\n      for (let i = 0; i < levels; i++) {\n        this.#cleanupStack.pop()?.(patchableContext);\n      }\n    });\n  }\n  /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */\n  #enter(levels) {\n    const enterPatterns = patterns(\n      this.currentState,\n      levels ?? this.currentState.split(\".\").length + 1\n    );\n    this.#currentContext.allowPatching((patchableContext) => {\n      for (const pattern of enterPatterns) {\n        const enterFn = this.#enterFns.get(pattern);\n        const cleanupFn = enterFn?.(patchableContext);\n        if (typeof cleanupFn === \"function\") {\n          this.#cleanupStack.push(cleanupFn);\n        } else {\n          this.#cleanupStack.push(null);\n        }\n      }\n    });\n    this.#eventHub.didEnterState.notify(this.currentState);\n  }\n  /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */\n  send(event) {\n    if (!this.#knownEventTypes.has(event.type)) {\n      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n    }\n    if (this.#runningState === 2 /* STOPPED */) {\n      return;\n    }\n    const targetFn = this.#getTargetFn(event.type);\n    if (targetFn !== void 0) {\n      return this.#transition(event, targetFn);\n    } else {\n      this.#eventHub.didIgnoreEvent.notify(event);\n    }\n  }\n  #transition(event, target) {\n    this.#eventHub.didReceiveEvent.notify(event);\n    const oldState = this.currentState;\n    const targetFn = typeof target === \"function\" ? target : () => target;\n    const nextTarget = targetFn(event, this.#currentContext.current);\n    let nextState;\n    let effects = void 0;\n    if (nextTarget === null) {\n      this.#eventHub.didIgnoreEvent.notify(event);\n      return;\n    }\n    if (typeof nextTarget === \"string\") {\n      nextState = nextTarget;\n    } else {\n      nextState = nextTarget.target;\n      effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [nextTarget.effect];\n    }\n    if (!this.#states.has(nextState)) {\n      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n    }\n    this.#eventHub.willTransition.notify({ from: oldState, to: nextState });\n    const [up, down] = distance(this.currentState, nextState);\n    if (up > 0) {\n      this.#exit(up);\n    }\n    this.#currentStateOrNull = nextState;\n    if (effects !== void 0) {\n      const effectsToRun = effects;\n      this.#currentContext.allowPatching((patchableContext) => {\n        for (const effect of effectsToRun) {\n          if (typeof effect === \"function\") {\n            effect(patchableContext, event);\n          } else {\n            patchableContext.patch(effect);\n          }\n        }\n      });\n    }\n    if (down > 0) {\n      this.#enter(down);\n    }\n  }\n};\n\n// src/protocol/ServerMsg.ts\nvar ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2) => {\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_JOINED\"] = 101] = \"USER_JOINED\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_LEFT\"] = 102] = \"USER_LEFT\";\n  ServerMsgCode2[ServerMsgCode2[\"BROADCASTED_EVENT\"] = 103] = \"BROADCASTED_EVENT\";\n  ServerMsgCode2[ServerMsgCode2[\"ROOM_STATE\"] = 104] = \"ROOM_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"INITIAL_STORAGE_STATE\"] = 200] = \"INITIAL_STORAGE_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ServerMsgCode2[ServerMsgCode2[\"REJECT_STORAGE_OP\"] = 299] = \"REJECT_STORAGE_OP\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_YDOC\"] = 300] = \"UPDATE_YDOC\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_CREATED\"] = 400] = \"THREAD_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_DELETED\"] = 407] = \"THREAD_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_METADATA_UPDATED\"] = 401] = \"THREAD_METADATA_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_UPDATED\"] = 408] = \"THREAD_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_CREATED\"] = 402] = \"COMMENT_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_EDITED\"] = 403] = \"COMMENT_EDITED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_DELETED\"] = 404] = \"COMMENT_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_ADDED\"] = 405] = \"COMMENT_REACTION_ADDED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_REMOVED\"] = 406] = \"COMMENT_REACTION_REMOVED\";\n  return ServerMsgCode2;\n})(ServerMsgCode || {});\n\n// src/types/IWebSocket.ts\nvar WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2) => {\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_NORMAL\"] = 1e3] = \"CLOSE_NORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"UNEXPECTED_CONDITION\"] = 1011] = \"UNEXPECTED_CONDITION\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TRY_AGAIN_LATER\"] = 1013] = \"TRY_AGAIN_LATER\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"INVALID_MESSAGE_FORMAT\"] = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"ROOM_ID_UPDATED\"] = 4006] = \"ROOM_ID_UPDATED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"KICKED\"] = 4100] = \"KICKED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TOKEN_EXPIRED\"] = 4109] = \"TOKEN_EXPIRED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_WITHOUT_RETRY\"] = 4999] = \"CLOSE_WITHOUT_RETRY\";\n  return WebsocketCloseCodes2;\n})(WebsocketCloseCodes || {});\nfunction shouldDisconnect(code) {\n  return code === 4999 /* CLOSE_WITHOUT_RETRY */ || code >= 4e3 && code < 4100;\n}\nfunction shouldReauth(code) {\n  return code >= 4100 && code < 4200;\n}\nfunction shouldRetryWithoutReauth(code) {\n  return code === 1013 /* TRY_AGAIN_LATER */ || code >= 4200 && code < 4300;\n}\n\n// src/connection.ts\nfunction isIdle(status) {\n  return status === \"initial\" || status === \"disconnected\";\n}\nfunction toNewConnectionStatus(machine) {\n  const state = machine.currentState;\n  switch (state) {\n    case \"@ok.connected\":\n    case \"@ok.awaiting-pong\":\n      return \"connected\";\n    case \"@idle.initial\":\n      return \"initial\";\n    case \"@auth.busy\":\n    case \"@auth.backoff\":\n    case \"@connecting.busy\":\n    case \"@connecting.backoff\":\n    case \"@idle.zombie\":\n      return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n    case \"@idle.failed\":\n      return \"disconnected\";\n    // istanbul ignore next\n    default:\n      return assertNever(state, \"Unknown state\");\n  }\n}\nvar BACKOFF_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];\nvar RESET_DELAY = BACKOFF_DELAYS[0] - 1;\nvar BACKOFF_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];\nvar HEARTBEAT_INTERVAL = 3e4;\nvar PONG_TIMEOUT = 2e3;\nvar AUTH_TIMEOUT = 1e4;\nvar SOCKET_CONNECT_TIMEOUT = 1e4;\nvar StopRetrying = class extends Error {\n  constructor(reason) {\n    super(reason);\n  }\n};\nfunction nextBackoffDelay(currentDelay, delays) {\n  return delays.find((delay) => delay > currentDelay) ?? delays[delays.length - 1];\n}\nfunction increaseBackoffDelay(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS)\n  });\n}\nfunction increaseBackoffDelayAggressively(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)\n  });\n}\nfunction resetSuccessCount(context) {\n  context.patch({ successCount: 0 });\n}\nfunction log(level, message) {\n  const logger = level === 2 /* ERROR */ ? error2 : level === 1 /* WARN */ ? warn : (\n    /* black hole */\n    () => {\n    }\n  );\n  return () => {\n    logger(message);\n  };\n}\nfunction logPrematureErrorOrCloseEvent(e) {\n  const conn = \"Connection to Liveblocks websocket server\";\n  return (ctx) => {\n    if (e instanceof Error) {\n      warn(`${conn} could not be established. ${String(e)}`);\n    } else {\n      warn(\n        isCloseEvent(e) ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.` : `${conn} could not be established.`\n      );\n    }\n  };\n}\nfunction logCloseEvent(event) {\n  const details = [`code: ${event.code}`];\n  if (event.reason) {\n    details.push(`reason: ${event.reason}`);\n  }\n  return (ctx) => {\n    warn(\n      `Connection to Liveblocks websocket server closed (${details.join(\", \")}). Retrying in ${ctx.backoffDelay}ms.`\n    );\n  };\n}\nvar logPermanentClose = log(\n  1 /* WARN */,\n  \"Connection to WebSocket closed permanently. Won't retry.\"\n);\nfunction isCloseEvent(error3) {\n  return !(error3 instanceof Error) && error3.type === \"close\";\n}\nfunction enableTracing(machine) {\n  const start = (/* @__PURE__ */ new Date()).getTime();\n  function log2(...args) {\n    warn(\n      `${(((/* @__PURE__ */ new Date()).getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`,\n      ...args\n    );\n  }\n  const unsubs = [\n    machine.events.didReceiveEvent.subscribe((e) => log2(`Event ${e.type}`)),\n    machine.events.willTransition.subscribe(\n      ({ from, to }) => log2(\"Transitioning\", from, \"\\u2192\", to)\n    ),\n    machine.events.didIgnoreEvent.subscribe(\n      (e) => log2(\"Ignored event\", e.type, e, \"(current state won't handle it)\")\n    )\n    // machine.events.willExitState.subscribe((s) => log(\"Exiting state\", s)),\n    // machine.events.didEnterState.subscribe((s) => log(\"Entering state\", s)),\n  ];\n  return () => {\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  };\n}\nfunction defineConnectivityEvents(machine) {\n  const statusDidChange = makeEventSource();\n  const didConnect = makeEventSource();\n  const didDisconnect = makeEventSource();\n  let lastStatus = null;\n  const unsubscribe = machine.events.didEnterState.subscribe(() => {\n    const currStatus = toNewConnectionStatus(machine);\n    if (currStatus !== lastStatus) {\n      statusDidChange.notify(currStatus);\n    }\n    if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n      didDisconnect.notify();\n    } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n      didConnect.notify();\n    }\n    lastStatus = currStatus;\n  });\n  return {\n    statusDidChange: statusDidChange.observable,\n    didConnect: didConnect.observable,\n    didDisconnect: didDisconnect.observable,\n    unsubscribe\n  };\n}\nvar assign = (patch) => (ctx) => ctx.patch(patch);\nfunction createConnectionStateMachine(delegates, options) {\n  const onMessage = makeBufferableEventSource();\n  onMessage.pause();\n  const onConnectionError = makeEventSource();\n  function fireErrorEvent(message, code) {\n    return () => {\n      onConnectionError.notify({ message, code });\n    };\n  }\n  const initialContext = {\n    successCount: 0,\n    authValue: null,\n    socket: null,\n    backoffDelay: RESET_DELAY\n  };\n  const machine = new FSM(initialContext).addState(\"@idle.initial\").addState(\"@idle.failed\").addState(\"@idle.zombie\").addState(\"@auth.busy\").addState(\"@auth.backoff\").addState(\"@connecting.busy\").addState(\"@connecting.backoff\").addState(\"@ok.connected\").addState(\"@ok.awaiting-pong\");\n  machine.addTransitions(\"*\", {\n    RECONNECT: {\n      target: \"@auth.backoff\",\n      effect: [increaseBackoffDelay, resetSuccessCount]\n    },\n    DISCONNECT: \"@idle.initial\"\n  });\n  machine.onEnter(\"@idle.*\", resetSuccessCount).addTransitions(\"@idle.*\", {\n    CONNECT: (_, ctx) => (\n      // If we still have a known authValue, try to reconnect to the socket directly,\n      // otherwise, try to obtain a new authValue\n      ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\"\n    )\n  });\n  machine.addTransitions(\"@auth.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@auth.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@auth.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@auth.busy\"\n  ).onEnterAsync(\n    \"@auth.busy\",\n    () => withTimeout(\n      delegates.authenticate(),\n      AUTH_TIMEOUT,\n      \"Timed out during auth\"\n    ),\n    // On successful authentication\n    (okEvent) => ({\n      target: \"@connecting.busy\",\n      effect: assign({\n        authValue: okEvent.data\n      })\n    }),\n    // Auth failed\n    (failedEvent) => {\n      if (failedEvent.reason instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, failedEvent.reason.message),\n            fireErrorEvent(failedEvent.reason.message, -1)\n          ]\n        };\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [\n          increaseBackoffDelay,\n          log(\n            2 /* ERROR */,\n            `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`\n          )\n        ]\n      };\n    }\n  );\n  const onSocketError = (event) => machine.send({ type: \"EXPLICIT_SOCKET_ERROR\", event });\n  const onSocketClose = (event) => machine.send({ type: \"EXPLICIT_SOCKET_CLOSE\", event });\n  const onSocketMessage = (event) => event.data === \"pong\" ? machine.send({ type: \"PONG\" }) : onMessage.notify(event);\n  function teardownSocket(socket) {\n    if (socket) {\n      socket.removeEventListener(\"error\", onSocketError);\n      socket.removeEventListener(\"close\", onSocketClose);\n      socket.removeEventListener(\"message\", onSocketMessage);\n      socket.close();\n    }\n  }\n  machine.addTransitions(\"@connecting.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@connecting.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@connecting.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@connecting.busy\"\n  ).onEnterAsync(\n    \"@connecting.busy\",\n    //\n    // Use the \"createSocket\" delegate function (provided to the\n    // ManagedSocket) to create the actual WebSocket connection instance.\n    // Then, set up all the necessary event listeners, and wait for the\n    // \"open\" event to occur.\n    //\n    // When the \"open\" event happens, we're ready to transition to the\n    // OK state. This is done by resolving the Promise.\n    //\n    async (ctx, signal) => {\n      let capturedPrematureEvent = null;\n      let unconfirmedSocket = null;\n      const connect$ = new Promise(\n        (resolve, rej) => {\n          if (ctx.authValue === null) {\n            throw new Error(\"No auth authValue\");\n          }\n          const socket = delegates.createSocket(ctx.authValue);\n          unconfirmedSocket = socket;\n          function reject(event) {\n            capturedPrematureEvent = event;\n            socket.removeEventListener(\"message\", onSocketMessage);\n            rej(event);\n          }\n          const [actor$, didReceiveActor] = controlledPromise();\n          if (!options.waitForActorId) {\n            didReceiveActor();\n          }\n          function waitForActorId(event) {\n            const serverMsg = tryParseJson(event.data);\n            if (serverMsg?.type === 104 /* ROOM_STATE */) {\n              didReceiveActor();\n            }\n          }\n          socket.addEventListener(\"message\", onSocketMessage);\n          if (options.waitForActorId) {\n            socket.addEventListener(\"message\", waitForActorId);\n          }\n          socket.addEventListener(\"error\", reject);\n          socket.addEventListener(\"close\", reject);\n          socket.addEventListener(\"open\", () => {\n            socket.addEventListener(\"error\", onSocketError);\n            socket.addEventListener(\"close\", onSocketClose);\n            const unsub = () => {\n              socket.removeEventListener(\"error\", reject);\n              socket.removeEventListener(\"close\", reject);\n              socket.removeEventListener(\"message\", waitForActorId);\n            };\n            void actor$.then(() => {\n              resolve([socket, unsub]);\n            });\n          });\n        }\n      );\n      return withTimeout(\n        connect$,\n        SOCKET_CONNECT_TIMEOUT,\n        \"Timed out during websocket connection\"\n      ).then(\n        //\n        // Part 3:\n        // By now, our \"open\" event has fired, and the promise has been\n        // resolved. Two possible scenarios:\n        //\n        // 1. The happy path. Most likely.\n        // 2. Uh-oh. A premature close/error event has been observed. Let's\n        //    reject the promise after all.\n        //\n        // Any close/error event that will get scheduled after this point\n        // onwards, will be caught in the OK state, and dealt with\n        // accordingly.\n        //\n        ([socket, unsub]) => {\n          unsub();\n          if (signal.aborted) {\n            throw new Error(\"Aborted\");\n          }\n          if (capturedPrematureEvent) {\n            throw capturedPrematureEvent;\n          }\n          return socket;\n        }\n      ).catch((e) => {\n        teardownSocket(unconfirmedSocket);\n        throw e;\n      });\n    },\n    // Only transition to OK state after a successfully opened WebSocket connection\n    (okEvent) => ({\n      target: \"@ok.connected\",\n      effect: assign({\n        socket: okEvent.data,\n        backoffDelay: RESET_DELAY\n      })\n    }),\n    // If the WebSocket connection cannot be established\n    (failure) => {\n      const err = failure.reason;\n      if (err instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, err.message),\n            fireErrorEvent(err.message, -1)\n          ]\n        };\n      }\n      if (isCloseEvent(err)) {\n        if (err.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        }\n        if (shouldRetryWithoutReauth(err.code)) {\n          return {\n            target: \"@connecting.backoff\",\n            effect: [\n              increaseBackoffDelayAggressively,\n              logPrematureErrorOrCloseEvent(err)\n            ]\n          };\n        }\n        if (shouldDisconnect(err.code)) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(2 /* ERROR */, err.reason),\n              fireErrorEvent(err.reason, err.code)\n            ]\n          };\n        }\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)]\n      };\n    }\n  );\n  const sendHeartbeat = {\n    target: \"@ok.awaiting-pong\",\n    effect: (ctx) => {\n      ctx.socket?.send(\"ping\");\n    }\n  };\n  const maybeHeartbeat = () => {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const canZombie = doc?.visibilityState === \"hidden\" && delegates.canZombie();\n    return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n  };\n  machine.addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions(\"@ok.connected\", {\n    NAVIGATOR_OFFLINE: maybeHeartbeat,\n    // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n    WINDOW_GOT_FOCUS: sendHeartbeat\n  });\n  machine.addTransitions(\"@idle.zombie\", {\n    WINDOW_GOT_FOCUS: \"@connecting.backoff\"\n    // When in zombie state, the client will try to wake up automatically when the window regains focus\n  });\n  machine.onEnter(\"@ok.*\", (ctx) => {\n    ctx.patch({ successCount: ctx.successCount + 1 });\n    const timerID = setTimeout(\n      // On the next tick, start delivering all messages that have already\n      // been received, and continue synchronous delivery of all future\n      // incoming messages.\n      onMessage.unpause,\n      0\n    );\n    return (ctx2) => {\n      teardownSocket(ctx2.socket);\n      ctx2.patch({ socket: null });\n      clearTimeout(timerID);\n      onMessage.pause();\n    };\n  }).addTransitions(\"@ok.awaiting-pong\", { PONG: \"@ok.connected\" }).addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n    target: \"@connecting.busy\",\n    // Log implicit connection loss and drop the current open socket\n    effect: log(\n      1 /* WARN */,\n      \"Received no pong from server, assume implicit connection loss.\"\n    )\n  }).addTransitions(\"@ok.*\", {\n    // When a socket receives an error, this can cause the closing of the\n    // socket, or not. So always check to see if the socket is still OPEN or\n    // not. When still OPEN, don't transition.\n    EXPLICIT_SOCKET_ERROR: (_, context) => {\n      if (context.socket?.readyState === 1) {\n        return null;\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: increaseBackoffDelay\n      };\n    },\n    EXPLICIT_SOCKET_CLOSE: (e) => {\n      if (shouldDisconnect(e.event.code)) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            logPermanentClose,\n            fireErrorEvent(e.event.reason, e.event.code)\n          ]\n        };\n      }\n      if (shouldReauth(e.event.code)) {\n        if (e.event.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        } else {\n          return {\n            target: \"@auth.backoff\",\n            effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n          };\n        }\n      }\n      if (shouldRetryWithoutReauth(e.event.code)) {\n        return {\n          target: \"@connecting.backoff\",\n          effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)]\n        };\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n      };\n    }\n  });\n  if (typeof document !== \"undefined\") {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    const root = win ?? doc;\n    machine.onEnter(\"*\", (ctx) => {\n      function onNetworkOffline() {\n        machine.send({ type: \"NAVIGATOR_OFFLINE\" });\n      }\n      function onNetworkBackOnline() {\n        machine.send({ type: \"NAVIGATOR_ONLINE\" });\n      }\n      function onVisibilityChange() {\n        if (doc?.visibilityState === \"visible\") {\n          machine.send({ type: \"WINDOW_GOT_FOCUS\" });\n        }\n      }\n      win?.addEventListener(\"online\", onNetworkBackOnline);\n      win?.addEventListener(\"offline\", onNetworkOffline);\n      root?.addEventListener(\"visibilitychange\", onVisibilityChange);\n      return () => {\n        root?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n        win?.removeEventListener(\"online\", onNetworkBackOnline);\n        win?.removeEventListener(\"offline\", onNetworkOffline);\n        teardownSocket(ctx.socket);\n      };\n    });\n  }\n  const cleanups = [];\n  const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);\n  cleanups.push(unsubscribe);\n  if (options.enableDebugLogging) {\n    cleanups.push(enableTracing(machine));\n  }\n  machine.start();\n  return {\n    machine,\n    cleanups,\n    // Observable events that will be emitted by this machine\n    events: {\n      statusDidChange,\n      didConnect,\n      didDisconnect,\n      onMessage: onMessage.observable,\n      onConnectionError: onConnectionError.observable\n    }\n  };\n}\nvar ManagedSocket = class {\n  #machine;\n  #cleanups;\n  events;\n  constructor(delegates, enableDebugLogging = false, waitForActorId = true) {\n    const { machine, events, cleanups } = createConnectionStateMachine(\n      delegates,\n      { waitForActorId, enableDebugLogging }\n    );\n    this.#machine = machine;\n    this.events = events;\n    this.#cleanups = cleanups;\n  }\n  getStatus() {\n    try {\n      return toNewConnectionStatus(this.#machine);\n    } catch {\n      return \"initial\";\n    }\n  }\n  /**\n   * Returns the current auth authValue.\n   */\n  get authValue() {\n    return this.#machine.context.authValue;\n  }\n  /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */\n  connect() {\n    this.#machine.send({ type: \"CONNECT\" });\n  }\n  /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */\n  reconnect() {\n    this.#machine.send({ type: \"RECONNECT\" });\n  }\n  /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */\n  disconnect() {\n    this.#machine.send({ type: \"DISCONNECT\" });\n  }\n  /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */\n  destroy() {\n    this.#machine.stop();\n    let cleanup;\n    while (cleanup = this.#cleanups.pop()) {\n      cleanup();\n    }\n  }\n  /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */\n  send(data) {\n    const socket = this.#machine.context?.socket;\n    if (socket === null) {\n      warn(\"Cannot send: not connected yet\", data);\n    } else if (socket.readyState !== 1) {\n      warn(\"Cannot send: WebSocket no longer open\", data);\n    } else {\n      socket.send(data);\n    }\n  }\n  /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */\n  _privateSendMachineEvent(event) {\n    this.#machine.send(event);\n  }\n};\n\n// src/protocol/AuthToken.ts\nvar Permission = /* @__PURE__ */ ((Permission2) => {\n  Permission2[\"Read\"] = \"room:read\";\n  Permission2[\"Write\"] = \"room:write\";\n  Permission2[\"PresenceWrite\"] = \"room:presence:write\";\n  Permission2[\"CommentsWrite\"] = \"comments:write\";\n  Permission2[\"CommentsRead\"] = \"comments:read\";\n  return Permission2;\n})(Permission || {});\nfunction canWriteStorage(scopes) {\n  return scopes.includes(\"room:write\" /* Write */);\n}\nfunction canComment(scopes) {\n  return scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:write\" /* Write */);\n}\nfunction isValidAuthTokenPayload(data) {\n  return isPlainObject(data) && (data.k === \"acc\" /* ACCESS_TOKEN */ || data.k === \"id\" /* ID_TOKEN */ || data.k === \"sec-legacy\" /* SECRET_LEGACY */);\n}\nfunction parseAuthToken(rawTokenString) {\n  const tokenParts = rawTokenString.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n  const payload = tryParseJson(b64decode(tokenParts[1]));\n  if (!(payload && isValidAuthTokenPayload(payload))) {\n    throw new Error(\n      \"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n    );\n  }\n  return {\n    raw: rawTokenString,\n    parsed: payload\n  };\n}\n\n// src/auth-manager.ts\nfunction createAuthManager(authOptions, onAuthenticate) {\n  const authentication = prepareAuthentication(authOptions);\n  const seenTokens = /* @__PURE__ */ new Set();\n  const tokens = [];\n  const expiryTimes = [];\n  const requestPromises = /* @__PURE__ */ new Map();\n  function reset() {\n    seenTokens.clear();\n    tokens.length = 0;\n    expiryTimes.length = 0;\n    requestPromises.clear();\n  }\n  function hasCorrespondingScopes(requestedScope, scopes) {\n    if (requestedScope === \"comments:read\") {\n      return scopes.includes(\"comments:read\" /* CommentsRead */) || scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    } else if (requestedScope === \"room:read\") {\n      return scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    }\n    return false;\n  }\n  function getCachedToken(requestOptions) {\n    const now = Math.ceil(Date.now() / 1e3);\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      const expiresAt = expiryTimes[i];\n      if (expiresAt <= now) {\n        tokens.splice(i, 1);\n        expiryTimes.splice(i, 1);\n        continue;\n      }\n      if (token.parsed.k === \"id\" /* ID_TOKEN */) {\n        return token;\n      } else if (token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n        if (!requestOptions.roomId && Object.entries(token.parsed.perms).length === 0) {\n          return token;\n        }\n        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\n          if (!requestOptions.roomId) {\n            if (resource.includes(\"*\") && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n              return token;\n            }\n          } else if (resource.includes(\"*\") && requestOptions.roomId.startsWith(resource.replace(\"*\", \"\")) || requestOptions.roomId === resource && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n            return token;\n          }\n        }\n      }\n    }\n    return void 0;\n  }\n  async function makeAuthRequest(options) {\n    const fetcher = authOptions.polyfills?.fetch ?? (typeof window === \"undefined\" ? void 0 : window.fetch);\n    if (authentication.type === \"private\") {\n      if (fetcher === void 0) {\n        throw new StopRetrying(\n          \"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\"\n        );\n      }\n      const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n        room: options.roomId\n      });\n      const parsed = parseAuthToken(response.token);\n      if (seenTokens.has(parsed.raw)) {\n        throw new StopRetrying(\n          \"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\"\n        );\n      }\n      onAuthenticate?.(parsed.parsed);\n      return parsed;\n    }\n    if (authentication.type === \"custom\") {\n      const response = await authentication.callback(options.roomId);\n      if (response && typeof response === \"object\") {\n        if (typeof response.token === \"string\") {\n          const parsed = parseAuthToken(response.token);\n          onAuthenticate?.(parsed.parsed);\n          return parsed;\n        } else if (typeof response.error === \"string\") {\n          const reason = `Authentication failed: ${\"reason\" in response && typeof response.reason === \"string\" ? response.reason : \"Forbidden\"}`;\n          if (response.error === \"forbidden\") {\n            throw new StopRetrying(reason);\n          } else {\n            throw new Error(reason);\n          }\n        }\n      }\n      throw new Error(\n        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }'\n      );\n    }\n    throw new Error(\n      \"Unexpected authentication type. Must be private or custom.\"\n    );\n  }\n  async function getAuthValue(requestOptions) {\n    if (authentication.type === \"public\") {\n      return { type: \"public\", publicApiKey: authentication.publicApiKey };\n    }\n    const cachedToken = getCachedToken(requestOptions);\n    if (cachedToken !== void 0) {\n      return { type: \"secret\", token: cachedToken };\n    }\n    let currentPromise;\n    if (requestOptions.roomId) {\n      currentPromise = requestPromises.get(requestOptions.roomId);\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(requestOptions.roomId, currentPromise);\n      }\n    } else {\n      currentPromise = requestPromises.get(\"liveblocks-user-token\");\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(\"liveblocks-user-token\", currentPromise);\n      }\n    }\n    try {\n      const token = await currentPromise;\n      const BUFFER = 30;\n      const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;\n      seenTokens.add(token.raw);\n      if (token.parsed.k !== \"sec-legacy\" /* SECRET_LEGACY */) {\n        tokens.push(token);\n        expiryTimes.push(expiresAt);\n      }\n      return { type: \"secret\", token };\n    } finally {\n      if (requestOptions.roomId) {\n        requestPromises.delete(requestOptions.roomId);\n      } else {\n        requestPromises.delete(\"liveblocks-user-token\");\n      }\n    }\n  }\n  return {\n    reset,\n    getAuthValue\n  };\n}\nfunction prepareAuthentication(authOptions) {\n  const { publicApiKey, authEndpoint } = authOptions;\n  if (authEndpoint !== void 0 && publicApiKey !== void 0) {\n    throw new Error(\n      \"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n    );\n  }\n  if (typeof publicApiKey === \"string\") {\n    if (publicApiKey.startsWith(\"sk_\")) {\n      throw new Error(\n        \"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    } else if (!publicApiKey.startsWith(\"pk_\")) {\n      throw new Error(\n        \"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    }\n    return {\n      type: \"public\",\n      publicApiKey\n    };\n  }\n  if (typeof authEndpoint === \"string\") {\n    return {\n      type: \"private\",\n      url: authEndpoint\n    };\n  } else if (typeof authEndpoint === \"function\") {\n    return {\n      type: \"custom\",\n      callback: authEndpoint\n    };\n  } else if (authEndpoint !== void 0) {\n    throw new Error(\n      \"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\"\n    );\n  }\n  throw new Error(\n    \"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n  );\n}\nasync function fetchAuthEndpoint(fetch, endpoint, body) {\n  const res = await fetch(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: stringifyOrLog(body)\n  });\n  if (!res.ok) {\n    const reason = `${(await res.text()).trim() || \"reason not provided in auth response\"} (${res.status} returned by POST ${endpoint})`;\n    if (res.status === 401 || res.status === 403) {\n      throw new StopRetrying(`Unauthorized: ${reason}`);\n    } else {\n      throw new Error(`Failed to authenticate: ${reason}`);\n    }\n  }\n  let data;\n  try {\n    data = await res.json();\n  } catch (er) {\n    throw new Error(\n      `Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(\n        er\n      )}`\n    );\n  }\n  if (!isPlainObject(data) || typeof data.token !== \"string\") {\n    throw new Error(\n      `Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${stringifyOrLog(\n        data\n      )}`\n    );\n  }\n  const { token } = data;\n  return { token };\n}\n\n// src/constants.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\n\n// src/internal.ts\nvar kInternal = Symbol();\n\n// src/devtools/bridge.ts\nvar _bridgeActive = false;\nfunction activateBridge(allowed) {\n  _bridgeActive = allowed;\n}\nfunction sendToPanel(message, options) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  const fullMsg = {\n    ...message,\n    source: \"liveblocks-devtools-client\"\n  };\n  if (!(options?.force || _bridgeActive)) {\n    return;\n  }\n  window.postMessage(fullMsg, \"*\");\n}\nvar eventSource = makeEventSource();\nif ( true && typeof window !== \"undefined\") {\n  window.addEventListener(\"message\", (event) => {\n    if (event.source === window && event.data?.source === \"liveblocks-devtools-panel\") {\n      eventSource.notify(event.data);\n    } else {\n    }\n  });\n}\nvar onMessageFromPanel = eventSource.observable;\n\n// src/devtools/index.ts\nvar VERSION = PKG_VERSION || \"dev\";\nvar _devtoolsSetupHasRun = false;\nfunction setupDevTools(getAllRooms) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  if (_devtoolsSetupHasRun) {\n    return;\n  }\n  _devtoolsSetupHasRun = true;\n  onMessageFromPanel.subscribe((msg) => {\n    switch (msg.msg) {\n      // When a devtool panel sends an explicit \"connect\" message back to this\n      // live running client (in response to the \"wake-up-devtools\" message,\n      // or when the devtool panel is opened for the first time), it means that it's okay to\n      // start emitting messages.\n      // Before this explicit acknowledgement, any call to sendToPanel() will\n      // be a no-op.\n      case \"connect\": {\n        activateBridge(true);\n        for (const roomId of getAllRooms()) {\n          sendToPanel({\n            msg: \"room::available\",\n            roomId,\n            clientVersion: VERSION\n          });\n        }\n        break;\n      }\n    }\n  });\n  sendToPanel({ msg: \"wake-up-devtools\" }, { force: true });\n}\nvar unsubsByRoomId = /* @__PURE__ */ new Map();\nfunction stopSyncStream(roomId) {\n  const unsubs = unsubsByRoomId.get(roomId) ?? [];\n  unsubsByRoomId.delete(roomId);\n  for (const unsub of unsubs) {\n    unsub();\n  }\n}\nfunction startSyncStream(room) {\n  stopSyncStream(room.id);\n  fullSync(room);\n  unsubsByRoomId.set(room.id, [\n    // When the connection status changes\n    room.events.status.subscribe(() => partialSyncConnection(room)),\n    // When storage initializes, send the update\n    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),\n    // Any time storage updates, send the new storage root\n    room.events.storageBatch.subscribe(() => partialSyncStorage(room)),\n    // Any time \"me\" or \"others\" updates, send the new values accordingly\n    room.events.self.subscribe(() => partialSyncMe(room)),\n    room.events.others.subscribe(() => partialSyncOthers(room)),\n    // Any time ydoc is updated, forward the update\n    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),\n    // Any time a custom room event is received, forward it\n    room.events.customEvent.subscribe(\n      (eventData) => forwardEvent(room, eventData)\n    )\n  ]);\n}\nfunction syncYdocUpdate(room, update) {\n  sendToPanel({\n    msg: \"room::sync::ydoc\",\n    roomId: room.id,\n    update\n  });\n}\nvar loadedAt = Date.now();\nvar eventCounter = 0;\nfunction nextEventId() {\n  return `event-${loadedAt}-${eventCounter++}`;\n}\nfunction forwardEvent(room, eventData) {\n  sendToPanel({\n    msg: \"room::events::custom-event\",\n    roomId: room.id,\n    event: {\n      type: \"CustomEvent\",\n      id: nextEventId(),\n      key: \"Event\",\n      connectionId: eventData.connectionId,\n      payload: eventData.event\n    }\n  });\n}\nfunction partialSyncConnection(room) {\n  sendToPanel({\n    msg: \"room::sync::partial\",\n    roomId: room.id,\n    status: room.getStatus()\n  });\n}\nfunction partialSyncStorage(room) {\n  const root = room.getStorageSnapshot();\n  if (root) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      storage: root.toTreeNode(\"root\").payload\n    });\n  }\n}\nfunction partialSyncMe(room) {\n  const me = room[kInternal].getSelf_forDevTools();\n  if (me) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      me\n    });\n  }\n}\nfunction partialSyncOthers(room) {\n  const others = room[kInternal].getOthers_forDevTools();\n  if (others) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      others\n    });\n  }\n}\nfunction fullSync(room) {\n  const root = room.getStorageSnapshot();\n  const me = room[kInternal].getSelf_forDevTools();\n  const others = room[kInternal].getOthers_forDevTools();\n  room.fetchYDoc(\"\");\n  sendToPanel({\n    msg: \"room::sync::full\",\n    roomId: room.id,\n    status: room.getStatus(),\n    storage: root?.toTreeNode(\"root\").payload ?? null,\n    me,\n    others\n  });\n}\nvar roomChannelListeners = /* @__PURE__ */ new Map();\nfunction stopRoomChannelListener(roomId) {\n  const listener = roomChannelListeners.get(roomId);\n  roomChannelListeners.delete(roomId);\n  if (listener) {\n    listener();\n  }\n}\nfunction linkDevTools(roomId, room) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  sendToPanel({ msg: \"room::available\", roomId, clientVersion: VERSION });\n  stopRoomChannelListener(roomId);\n  roomChannelListeners.set(\n    roomId,\n    // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg) => {\n      switch (msg.msg) {\n        // Sent by the devtool panel when it wants to receive the sync stream\n        // for a room\n        case \"room::subscribe\": {\n          if (msg.roomId === roomId) {\n            startSyncStream(room);\n          }\n          break;\n        }\n        case \"room::unsubscribe\": {\n          if (msg.roomId === roomId) {\n            stopSyncStream(roomId);\n          }\n          break;\n        }\n      }\n    })\n  );\n}\nfunction unlinkDevTools(roomId) {\n  if ( false || typeof window === \"undefined\") {\n    return;\n  }\n  stopSyncStream(roomId);\n  stopRoomChannelListener(roomId);\n  sendToPanel({\n    msg: \"room::unavailable\",\n    roomId\n  });\n}\n\n// src/protocol/UserNotificationSettings.ts\nvar kPlain = Symbol(\"user-notification-settings-plain\");\nfunction createUserNotificationSettings(plain) {\n  const channels = [\n    \"email\",\n    \"slack\",\n    \"teams\",\n    \"webPush\"\n  ];\n  const descriptors = {\n    [kPlain]: {\n      value: plain,\n      enumerable: false\n    }\n  };\n  for (const channel of channels) {\n    descriptors[channel] = {\n      enumerable: true,\n      /**\n       * In the TypeScript standard library definitions, the built-in interface for a property descriptor\n       * does not include a specialized type for the this context in the getter or setter functions.\n       * As a result, both the get and set methods implicitly have this: any.\n       * The reason is that property descriptors in JavaScript are used across various objects with\n       * no enforced shape for this. And so the standard library definitions have to remain as broad as possible\n       * to support any valid JavaScript usage (e.g `Object.defineProperty`).\n       *\n       * So we can safely tells that this getter is typed as `this: UserNotificationSettings` because we're\n       * creating a well known shaped object  `UserNotificationSettings`.\n       */\n      get() {\n        const value = this[kPlain][channel];\n        if (typeof value === \"undefined\") {\n          error2(\n            `In order to use the '${channel}' channel, please set up your project first. For more information: https://liveblocks.io/docs/errors/enable-a-notification-channel`\n          );\n          return null;\n        }\n        return value;\n      }\n    };\n  }\n  return create(null, descriptors);\n}\nfunction patchUserNotificationSettings(existing, patch) {\n  const outcoming = createUserNotificationSettings({\n    ...existing[kPlain]\n  });\n  for (const channel of keys(patch)) {\n    const updates = patch[channel];\n    if (updates !== void 0) {\n      const kindUpdates = Object.fromEntries(\n        entries(updates).filter(([, value]) => value !== void 0)\n      );\n      outcoming[kPlain][channel] = {\n        ...outcoming[kPlain][channel],\n        ...kindUpdates\n      };\n    }\n  }\n  return outcoming;\n}\nfunction isNotificationChannelEnabled(settings) {\n  return settings !== null ? values(settings).every((enabled) => enabled === true) : false;\n}\n\n// src/lib/position.ts\nvar MIN_CODE = 32;\nvar MAX_CODE = 126;\nvar NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\nvar ZERO = nthDigit(0);\nvar ONE = nthDigit(1);\nvar ZERO_NINE = ZERO + nthDigit(-1);\nfunction nthDigit(n) {\n  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n  if (code < MIN_CODE || code > MAX_CODE) {\n    throw new Error(`Invalid n value: ${n}`);\n  }\n  return String.fromCharCode(code);\n}\nfunction makePosition(x, y) {\n  if (x !== void 0 && y !== void 0) {\n    return between(x, y);\n  } else if (x !== void 0) {\n    return after(x);\n  } else if (y !== void 0) {\n    return before(y);\n  } else {\n    return ONE;\n  }\n}\nfunction before(pos) {\n  const lastIndex = pos.length - 1;\n  for (let i = 0; i <= lastIndex; i++) {\n    const code = pos.charCodeAt(i);\n    if (code <= MIN_CODE) {\n      continue;\n    }\n    if (i === lastIndex) {\n      if (code === MIN_CODE + 1) {\n        return pos.substring(0, i) + ZERO_NINE;\n      } else {\n        return pos.substring(0, i) + String.fromCharCode(code - 1);\n      }\n    } else {\n      return pos.substring(0, i + 1);\n    }\n  }\n  return ONE;\n}\nfunction after(pos) {\n  for (let i = 0; i <= pos.length - 1; i++) {\n    const code = pos.charCodeAt(i);\n    if (code >= MAX_CODE) {\n      continue;\n    }\n    return pos.substring(0, i) + String.fromCharCode(code + 1);\n  }\n  return pos + ONE;\n}\nfunction between(lo, hi) {\n  if (lo < hi) {\n    return _between(lo, hi);\n  } else if (lo > hi) {\n    return _between(hi, lo);\n  } else {\n    throw new Error(\"Cannot compute value between two equal positions\");\n  }\n}\nfunction _between(lo, hi) {\n  let index = 0;\n  const loLen = lo.length;\n  const hiLen = hi.length;\n  while (true) {\n    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n    if (loCode === hiCode) {\n      index++;\n      continue;\n    }\n    if (hiCode - loCode === 1) {\n      const size = index + 1;\n      let prefix = lo.substring(0, size);\n      if (prefix.length < size) {\n        prefix += ZERO.repeat(size - prefix.length);\n      }\n      const suffix = lo.substring(size);\n      const nines = \"\";\n      return prefix + _between(suffix, nines);\n    } else {\n      return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);\n    }\n  }\n}\nfunction takeN(pos, n) {\n  return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);\n}\nvar MIN_NON_ZERO_CODE = MIN_CODE + 1;\nfunction isPos(str) {\n  if (str === \"\") {\n    return false;\n  }\n  const lastIdx = str.length - 1;\n  const last = str.charCodeAt(lastIdx);\n  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n    return false;\n  }\n  for (let i = 0; i < lastIdx; i++) {\n    const code = str.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction convertToPos(str) {\n  const codes = [];\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n  }\n  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {\n    codes.length--;\n  }\n  return codes.length > 0 ? String.fromCharCode(...codes) : (\n    // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n    ONE\n  );\n}\nfunction asPos(str) {\n  return isPos(str) ? str : convertToPos(str);\n}\n\n// src/protocol/Op.ts\nvar OpCode = /* @__PURE__ */ ((OpCode2) => {\n  OpCode2[OpCode2[\"INIT\"] = 0] = \"INIT\";\n  OpCode2[OpCode2[\"SET_PARENT_KEY\"] = 1] = \"SET_PARENT_KEY\";\n  OpCode2[OpCode2[\"CREATE_LIST\"] = 2] = \"CREATE_LIST\";\n  OpCode2[OpCode2[\"UPDATE_OBJECT\"] = 3] = \"UPDATE_OBJECT\";\n  OpCode2[OpCode2[\"CREATE_OBJECT\"] = 4] = \"CREATE_OBJECT\";\n  OpCode2[OpCode2[\"DELETE_CRDT\"] = 5] = \"DELETE_CRDT\";\n  OpCode2[OpCode2[\"DELETE_OBJECT_KEY\"] = 6] = \"DELETE_OBJECT_KEY\";\n  OpCode2[OpCode2[\"CREATE_MAP\"] = 7] = \"CREATE_MAP\";\n  OpCode2[OpCode2[\"CREATE_REGISTER\"] = 8] = \"CREATE_REGISTER\";\n  return OpCode2;\n})(OpCode || {});\nfunction ackOp(opId) {\n  return {\n    type: 5 /* DELETE_CRDT */,\n    id: \"ACK\",\n    // (H)ACK\n    opId\n  };\n}\nfunction isAckOp(op) {\n  return op.type === 5 /* DELETE_CRDT */ && op.id === \"ACK\";\n}\n\n// src/crdts/AbstractCrdt.ts\nfunction createManagedPool(roomId, options) {\n  const {\n    getCurrentConnectionId,\n    onDispatch,\n    isStorageWritable = () => true\n  } = options;\n  let clock = 0;\n  let opClock = 0;\n  const nodes = /* @__PURE__ */ new Map();\n  return {\n    roomId,\n    nodes,\n    getNode: (id) => nodes.get(id),\n    addNode: (id, node) => void nodes.set(id, node),\n    deleteNode: (id) => void nodes.delete(id),\n    generateId: () => `${getCurrentConnectionId()}:${clock++}`,\n    generateOpId: () => `${getCurrentConnectionId()}:${opClock++}`,\n    dispatch(ops, reverse, storageUpdates) {\n      onDispatch?.(ops, reverse, storageUpdates);\n    },\n    assertStorageIsWritable: () => {\n      if (!isStorageWritable()) {\n        throw new Error(\n          \"Cannot write to storage with a read only user, please ensure the user has write permissions\"\n        );\n      }\n    }\n  };\n}\nfunction crdtAsLiveNode(value) {\n  return value;\n}\nfunction HasParent(node, key, pos = asPos(key)) {\n  return Object.freeze({ type: \"HasParent\", node, key, pos });\n}\nvar NoParent = Object.freeze({ type: \"NoParent\" });\nfunction Orphaned(oldKey, oldPos = asPos(oldKey)) {\n  return Object.freeze({ type: \"Orphaned\", oldKey, oldPos });\n}\nvar AbstractCrdt = class {\n  //                  ^^^^^^^^^^^^ TODO: Make this an interface\n  #pool;\n  #id;\n  #parent = NoParent;\n  /** @internal */\n  _getParentKeyOrThrow() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _parentPos() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.pos;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldPos;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _pool() {\n    return this.#pool;\n  }\n  get roomId() {\n    return this.#pool ? this.#pool.roomId : null;\n  }\n  /** @internal */\n  get _id() {\n    return this.#id;\n  }\n  /** @internal */\n  get parent() {\n    return this.#parent;\n  }\n  /** @internal */\n  get _parentKey() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        return null;\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _apply(op, _isLocal) {\n    switch (op.type) {\n      case 5 /* DELETE_CRDT */: {\n        if (this.parent.type === \"HasParent\") {\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\n        }\n        return { modified: false };\n      }\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _setParentLink(newParentNode, newParentKey) {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          this.#parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n      case \"Orphaned\":\n      case \"NoParent\": {\n        this.#parent = HasParent(newParentNode, newParentKey);\n        return;\n      }\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _attach(id, pool) {\n    if (this.#id || this.#pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n    pool.addNode(id, crdtAsLiveNode(this));\n    this.#id = id;\n    this.#pool = pool;\n  }\n  /** @internal */\n  _detach() {\n    if (this.#pool && this.#id) {\n      this.#pool.deleteNode(this.#id);\n    }\n    switch (this.parent.type) {\n      case \"HasParent\": {\n        this.#parent = Orphaned(this.parent.key, this.parent.pos);\n        break;\n      }\n      case \"NoParent\": {\n        this.#parent = NoParent;\n        break;\n      }\n      case \"Orphaned\": {\n        break;\n      }\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n    this.#pool = void 0;\n  }\n  /** This caches the result of the last .toImmutable() call for this Live node. */\n  #cachedImmutable;\n  #cachedTreeNodeKey;\n  /** This caches the result of the last .toTreeNode() call for this Live node. */\n  #cachedTreeNode;\n  /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */\n  invalidate() {\n    if (this.#cachedImmutable !== void 0 || this.#cachedTreeNode !== void 0) {\n      this.#cachedImmutable = void 0;\n      this.#cachedTreeNode = void 0;\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n  /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */\n  toTreeNode(key) {\n    if (this.#cachedTreeNode === void 0 || this.#cachedTreeNodeKey !== key) {\n      this.#cachedTreeNodeKey = key;\n      this.#cachedTreeNode = this._toTreeNode(key);\n    }\n    return this.#cachedTreeNode;\n  }\n  /**\n   * Return an immutable snapshot of this Live node and its children.\n   */\n  toImmutable() {\n    if (this.#cachedImmutable === void 0) {\n      this.#cachedImmutable = this._toImmutable();\n    }\n    return this.#cachedImmutable;\n  }\n};\n\n// src/protocol/SerializedCrdt.ts\nvar CrdtType = /* @__PURE__ */ ((CrdtType2) => {\n  CrdtType2[CrdtType2[\"OBJECT\"] = 0] = \"OBJECT\";\n  CrdtType2[CrdtType2[\"LIST\"] = 1] = \"LIST\";\n  CrdtType2[CrdtType2[\"MAP\"] = 2] = \"MAP\";\n  CrdtType2[CrdtType2[\"REGISTER\"] = 3] = \"REGISTER\";\n  return CrdtType2;\n})(CrdtType || {});\nfunction isRootCrdt(crdt) {\n  return crdt.type === 0 /* OBJECT */ && !isChildCrdt(crdt);\n}\nfunction isChildCrdt(crdt) {\n  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;\n}\n\n// src/crdts/LiveRegister.ts\nvar LiveRegister = class _LiveRegister extends AbstractCrdt {\n  #data;\n  constructor(data) {\n    super();\n    this.#data = data;\n  }\n  get data() {\n    return this.#data;\n  }\n  /** @internal */\n  static _deserialize([id, item], _parentToChildren, pool) {\n    const register = new _LiveRegister(item.data);\n    register._attach(id, pool);\n    return register;\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    }\n    return [\n      {\n        type: 8 /* CREATE_REGISTER */,\n        opId: pool?.generateOpId(),\n        id: this._id,\n        parentId,\n        parentKey,\n        data: this.data\n      }\n    ];\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n    return {\n      type: 3 /* REGISTER */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data\n    };\n  }\n  /** @internal */\n  _attachChild(_op) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _detachChild(_crdt) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"Json\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this.#data\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    return this.#data;\n  }\n  clone() {\n    return deepClone(this.data);\n  }\n};\n\n// src/crdts/LiveList.ts\nfunction compareNodePosition(itemA, itemB) {\n  const posA = itemA._parentPos;\n  const posB = itemB._parentPos;\n  return posA === posB ? 0 : posA < posB ? -1 : 1;\n}\nvar LiveList = class _LiveList extends AbstractCrdt {\n  // TODO: Naive array at first, find a better data structure. Maybe an Order statistics tree?\n  #items;\n  #implicitlyDeletedItems;\n  #unacknowledgedSets;\n  constructor(items) {\n    super();\n    this.#items = [];\n    this.#implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();\n    this.#unacknowledgedSets = /* @__PURE__ */ new Map();\n    let position = void 0;\n    for (const item of items) {\n      const newPosition = makePosition(position);\n      const node = lsonToLiveNode(item);\n      node._setParentLink(this, newPosition);\n      this.#items.push(node);\n      position = newPosition;\n    }\n  }\n  /** @internal */\n  static _deserialize([id], parentToChildren, pool) {\n    const list = new _LiveList([]);\n    list._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return list;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(list, crdt.parentKey);\n      list._insertAndSort(child);\n    }\n    return list;\n  }\n  /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 2 /* CREATE_LIST */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const item of this.#items) {\n      const parentKey2 = item._getParentKeyOrThrow();\n      const childOps = HACK_addIntentAndDeletedIdToOperation(\n        item._toOps(this._id, parentKey2, pool),\n        void 0\n      );\n      const childOpId = childOps[0].opId;\n      if (childOpId !== void 0) {\n        this.#unacknowledgedSets.set(parentKey2, childOpId);\n      }\n      ops.push(...childOps);\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   *\n   * Adds a new item into the sorted list, in the correct position.\n   */\n  _insertAndSort(item) {\n    this.#items.push(item);\n    this._sortItems();\n  }\n  /** @internal */\n  _sortItems() {\n    this.#items.sort(compareNodePosition);\n    this.invalidate();\n  }\n  /** @internal */\n  _indexOfPosition(position) {\n    return this.#items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const item of this.#items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this.#items) {\n      item._detach();\n    }\n  }\n  #applySetRemote(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    child._attach(id, this._pool);\n    child._setParentLink(this, key);\n    const deletedId = op.deletedId;\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = this.#items[indexOfItemWithSamePosition];\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n        this.#items[indexOfItemWithSamePosition] = child;\n        return {\n          modified: makeUpdate(this, [\n            setDelta(indexOfItemWithSamePosition, child)\n          ]),\n          reverse: []\n        };\n      } else {\n        this.#implicitlyDeletedItems.add(itemWithSamePosition);\n        this.#items[indexOfItemWithSamePosition] = child;\n        const delta = [\n          setDelta(indexOfItemWithSamePosition, child)\n        ];\n        const deleteDelta2 = this.#detachItemAssociatedToSetOperation(\n          op.deletedId\n        );\n        if (deleteDelta2) {\n          delta.push(deleteDelta2);\n        }\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: []\n        };\n      }\n    } else {\n      const updates = [];\n      const deleteDelta2 = this.#detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deleteDelta2) {\n        updates.push(deleteDelta2);\n      }\n      this._insertAndSort(child);\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates)\n      };\n    }\n  }\n  #applySetAck(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const delta = [];\n    const deletedDelta = this.#detachItemAssociatedToSetOperation(op.deletedId);\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n    const unacknowledgedOpId = this.#unacknowledgedSets.get(op.parentKey);\n    if (unacknowledgedOpId !== void 0) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };\n      } else {\n        this.#unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n    const existingItem = this.#items.find((item) => item._id === op.id);\n    if (existingItem !== void 0) {\n      if (existingItem._parentKey === op.parentKey) {\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: []\n        };\n      }\n      if (indexOfItemWithSamePosition !== -1) {\n        this.#implicitlyDeletedItems.add(\n          this.#items[indexOfItemWithSamePosition]\n        );\n        const [prevNode] = this.#items.splice(indexOfItemWithSamePosition, 1);\n        delta.push(deleteDelta(indexOfItemWithSamePosition, prevNode));\n      }\n      const prevIndex = this.#items.indexOf(existingItem);\n      existingItem._setParentLink(this, op.parentKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(existingItem);\n      if (newIndex !== prevIndex) {\n        delta.push(moveDelta(prevIndex, newIndex, existingItem));\n      }\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: []\n      };\n    } else {\n      const orphan = this._pool.getNode(op.id);\n      if (orphan && this.#implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, op.parentKey);\n        this.#implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const recreatedItemIndex = this.#items.indexOf(orphan);\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),\n            ...delta\n          ]),\n          reverse: []\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          this.#items.splice(indexOfItemWithSamePosition, 1);\n        }\n        const { newItem, newIndex } = this.#createAttachItemAndSort(\n          op,\n          op.parentKey\n        );\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),\n            ...delta\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /**\n   * Returns the update delta of the deletion or null\n   */\n  #detachItemAssociatedToSetOperation(deletedId) {\n    if (deletedId === void 0 || this._pool === void 0) {\n      return null;\n    }\n    const deletedItem = this._pool.getNode(deletedId);\n    if (deletedItem === void 0) {\n      return null;\n    }\n    const result = this._detachChild(deletedItem);\n    if (result.modified === false) {\n      return null;\n    }\n    return result.modified.updates[0];\n  }\n  #applyRemoteInsert(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const key = asPos(op.parentKey);\n    const existingItemIndex = this._indexOfPosition(key);\n    if (existingItemIndex !== -1) {\n      this.#shiftItemPosition(existingItemIndex, key);\n    }\n    const { newItem, newIndex } = this.#createAttachItemAndSort(op, key);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: []\n    };\n  }\n  #applyInsertAck(op) {\n    const existingItem = this.#items.find((item) => item._id === op.id);\n    const key = asPos(op.parentKey);\n    const itemIndexAtPosition = this._indexOfPosition(key);\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        return {\n          modified: false\n        };\n      } else {\n        const oldPositionIndex = this.#items.indexOf(existingItem);\n        if (itemIndexAtPosition !== -1) {\n          this.#shiftItemPosition(itemIndexAtPosition, key);\n        }\n        existingItem._setParentLink(this, key);\n        this._sortItems();\n        const newIndex = this._indexOfPosition(key);\n        if (newIndex === oldPositionIndex) {\n          return { modified: false };\n        }\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(oldPositionIndex, newIndex, existingItem)\n          ]),\n          reverse: []\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n      if (orphan && this.#implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, key);\n        this.#implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const newIndex = this._indexOfPosition(key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: []\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this.#shiftItemPosition(itemIndexAtPosition, key);\n        }\n        const { newItem, newIndex } = this.#createAttachItemAndSort(op, key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: []\n        };\n      }\n    }\n  }\n  #applyInsertUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const existingItemIndex = this._indexOfPosition(key);\n    let newKey = key;\n    if (existingItemIndex !== -1) {\n      const before2 = this.#items[existingItemIndex]?._parentPos;\n      const after2 = this.#items[existingItemIndex + 1]?._parentPos;\n      newKey = makePosition(before2, after2);\n      child._setParentLink(this, newKey);\n    }\n    this._insertAndSort(child);\n    const newIndex = this._indexOfPosition(newKey);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{ type: 5 /* DELETE_CRDT */, id }]\n    };\n  }\n  #applySetUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (this._pool?.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    this.#unacknowledgedSets.set(key, nn(op.opId));\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const newKey = key;\n    if (indexOfItemWithSameKey !== -1) {\n      const existingItem = this.#items[indexOfItemWithSameKey];\n      existingItem._detach();\n      this.#items[indexOfItemWithSameKey] = child;\n      const reverse = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(nn(this._id), key, this._pool),\n        op.id\n      );\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n      const deletedDelta = this.#detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n      return {\n        modified: makeUpdate(this, delta),\n        reverse\n      };\n    } else {\n      this._insertAndSort(child);\n      this.#detachItemAssociatedToSetOperation(op.deletedId);\n      const newIndex = this._indexOfPosition(newKey);\n      return {\n        reverse: [{ type: 5 /* DELETE_CRDT */, id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)])\n      };\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    let result;\n    if (op.intent === \"set\") {\n      if (source === 1 /* REMOTE */) {\n        result = this.#applySetRemote(op);\n      } else if (source === 2 /* ACK */) {\n        result = this.#applySetAck(op);\n      } else {\n        result = this.#applySetUndoRedo(op);\n      }\n    } else {\n      if (source === 1 /* REMOTE */) {\n        result = this.#applyRemoteInsert(op);\n      } else if (source === 2 /* ACK */) {\n        result = this.#applyInsertAck(op);\n      } else {\n        result = this.#applyInsertUndoRedo(op);\n      }\n    }\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n    return result;\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n      const indexToDelete = this.#items.indexOf(child);\n      if (indexToDelete === -1) {\n        return {\n          modified: false\n        };\n      }\n      const [previousNode] = this.#items.splice(indexToDelete, 1);\n      this.invalidate();\n      child._detach();\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete, previousNode)]),\n        reverse\n      };\n    }\n    return { modified: false };\n  }\n  #applySetChildKeyRemote(newKey, child) {\n    if (this.#implicitlyDeletedItems.has(child)) {\n      this.#implicitlyDeletedItems.delete(child);\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      const newIndex = this.#items.indexOf(child);\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: []\n      };\n    }\n    const previousKey = child._parentKey;\n    if (newKey === previousKey) {\n      return {\n        modified: false\n      };\n    }\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex === -1) {\n      const previousIndex = this.#items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    } else {\n      this.#items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n      );\n      const previousIndex = this.#items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    }\n  }\n  #applySetChildKeyAck(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    if (this.#implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n      this.#implicitlyDeletedItems.delete(child);\n      if (existingItemIndex !== -1) {\n        this.#items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      return {\n        modified: false\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false\n        };\n      }\n      const previousIndex = this.#items.indexOf(child);\n      const existingItemIndex = this._indexOfPosition(newKey);\n      if (existingItemIndex !== -1) {\n        this.#items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this.#items.indexOf(child);\n      if (previousIndex === newIndex) {\n        return {\n          modified: false\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child)\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  #applySetChildKeyUndoRedo(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    const previousIndex = this.#items.indexOf(child);\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex !== -1) {\n      this.#items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, this.#items[existingItemIndex + 1]?._parentPos)\n      );\n    }\n    child._setParentLink(this, newKey);\n    this._sortItems();\n    const newIndex = this.#items.indexOf(child);\n    if (previousIndex === newIndex) {\n      return {\n        modified: false\n      };\n    }\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [\n        {\n          type: 1 /* SET_PARENT_KEY */,\n          id: nn(child._id),\n          parentKey: previousKey\n        }\n      ]\n    };\n  }\n  /** @internal */\n  _setChildKey(newKey, child, source) {\n    if (source === 1 /* REMOTE */) {\n      return this.#applySetChildKeyRemote(newKey, child);\n    } else if (source === 2 /* ACK */) {\n      return this.#applySetChildKeyAck(newKey, child);\n    } else {\n      return this.#applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n    return {\n      type: 1 /* LIST */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns the number of elements.\n   */\n  get length() {\n    return this.#items.length;\n  }\n  /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */\n  push(element) {\n    this._pool?.assertStorageIsWritable();\n    return this.insert(element, this.length);\n  }\n  /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */\n  insert(element, index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index > this.#items.length) {\n      throw new Error(\n        `Cannot insert list item at index \"\u001d${index}\". index should be between 0 and ${this.#items.length}`\n      );\n    }\n    const before2 = this.#items[index - 1] ? this.#items[index - 1]._parentPos : void 0;\n    const after2 = this.#items[index] ? this.#items[index]._parentPos : void 0;\n    const position = makePosition(before2, after2);\n    const value = lsonToLiveNode(element);\n    value._setParentLink(this, position);\n    this._insertAndSort(value);\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      this._pool.dispatch(\n        value._toOps(this._id, position, this._pool),\n        [{ type: 5 /* DELETE_CRDT */, id }],\n        /* @__PURE__ */ new Map([\n          [this._id, makeUpdate(this, [insertDelta(index, value)])]\n        ])\n      );\n    }\n  }\n  /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */\n  move(index, targetIndex) {\n    this._pool?.assertStorageIsWritable();\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n    if (targetIndex >= this.#items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n    if (index >= this.#items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n    let beforePosition = null;\n    let afterPosition = null;\n    if (index < targetIndex) {\n      afterPosition = targetIndex === this.#items.length - 1 ? void 0 : this.#items[targetIndex + 1]._parentPos;\n      beforePosition = this.#items[targetIndex]._parentPos;\n    } else {\n      afterPosition = this.#items[targetIndex]._parentPos;\n      beforePosition = targetIndex === 0 ? void 0 : this.#items[targetIndex - 1]._parentPos;\n    }\n    const position = makePosition(beforePosition, afterPosition);\n    const item = this.#items[index];\n    const previousPosition = item._getParentKeyOrThrow();\n    item._setParentLink(this, position);\n    this._sortItems();\n    if (this._pool && this._id) {\n      const storageUpdates = /* @__PURE__ */ new Map([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]\n      ]);\n      this._pool.dispatch(\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            opId: this._pool.generateOpId(),\n            parentKey: position\n          }\n        ],\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            parentKey: previousPosition\n          }\n        ],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */\n  delete(index) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this.#items.length) {\n      throw new Error(\n        `Cannot delete list item at index \"${index}\". index should be between 0 and ${this.#items.length - 1}`\n      );\n    }\n    const item = this.#items[index];\n    item._detach();\n    const [prev] = this.#items.splice(index, 1);\n    this.invalidate();\n    if (this._pool) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index, prev)])\n        );\n        this._pool.dispatch(\n          [\n            {\n              id: childRecordId,\n              opId: this._pool.generateOpId(),\n              type: 5 /* DELETE_CRDT */\n            }\n          ],\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\n          storageUpdates\n        );\n      }\n    }\n  }\n  clear() {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool) {\n      const ops = [];\n      const reverseOps = [];\n      const updateDelta = [];\n      for (const item of this.#items) {\n        item._detach();\n        const childId = item._id;\n        if (childId) {\n          ops.push({\n            type: 5 /* DELETE_CRDT */,\n            id: childId,\n            opId: this._pool.generateOpId()\n          });\n          reverseOps.push(\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\n          );\n          updateDelta.push(deleteDelta(0, item));\n        }\n      }\n      this.#items = [];\n      this.invalidate();\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this.#items) {\n        item._detach();\n      }\n      this.#items = [];\n      this.invalidate();\n    }\n  }\n  set(index, item) {\n    this._pool?.assertStorageIsWritable();\n    if (index < 0 || index >= this.#items.length) {\n      throw new Error(\n        `Cannot set list item at index \"\u001d${index}\". index should be between 0 and ${this.#items.length - 1}`\n      );\n    }\n    const existingItem = this.#items[index];\n    const position = existingItem._getParentKeyOrThrow();\n    const existingId = existingItem._id;\n    existingItem._detach();\n    const value = lsonToLiveNode(item);\n    value._setParentLink(this, position);\n    this.#items[index] = value;\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n      const ops = HACK_addIntentAndDeletedIdToOperation(\n        value._toOps(this._id, position, this._pool),\n        existingId\n      );\n      this.#unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(this._id, position, void 0),\n        id\n      );\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n  /**\n   * Returns an Array of all the elements in the LiveList.\n   */\n  toArray() {\n    return this.#items.map(\n      (entry) => liveNodeToLson(entry)\n      //                               ^^^^^^^^\n      //                               FIXME! This isn't safe.\n    );\n  }\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */\n  every(predicate) {\n    return this.toArray().every(predicate);\n  }\n  /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */\n  filter(predicate) {\n    return this.toArray().filter(predicate);\n  }\n  /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */\n  find(predicate) {\n    return this.toArray().find(predicate);\n  }\n  /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */\n  findIndex(predicate) {\n    return this.toArray().findIndex(predicate);\n  }\n  /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */\n  forEach(callbackfn) {\n    return this.toArray().forEach(callbackfn);\n  }\n  /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */\n  get(index) {\n    if (index < 0 || index >= this.#items.length) {\n      return void 0;\n    }\n    return liveNodeToLson(this.#items[index]);\n  }\n  /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */\n  indexOf(searchElement, fromIndex) {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n  /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */\n  lastIndexOf(searchElement, fromIndex) {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n  /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */\n  map(callback) {\n    return this.#items.map(\n      (entry, i) => callback(\n        liveNodeToLson(entry),\n        //                    ^^^^^^^^\n        //                    FIXME! This isn't safe.\n        i\n      )\n    );\n  }\n  /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */\n  some(predicate) {\n    return this.toArray().some(predicate);\n  }\n  [Symbol.iterator]() {\n    return new LiveListIterator(this.#items);\n  }\n  #createAttachItemAndSort(op, key) {\n    const newItem = creationOpToLiveNode(op);\n    newItem._attach(op.id, nn(this._pool));\n    newItem._setParentLink(this, key);\n    this._insertAndSort(newItem);\n    const newIndex = this._indexOfPosition(key);\n    return { newItem, newIndex };\n  }\n  #shiftItemPosition(index, key) {\n    const shiftedPosition = makePosition(\n      key,\n      this.#items.length > index + 1 ? this.#items[index + 1]?._parentPos : void 0\n    );\n    this.#items[index]._setParentLink(this, shiftedPosition);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveList\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: this.#items.map(\n        (item, index) => item.toTreeNode(index.toString())\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = this.#items.map((node) => node.toImmutable());\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveList(this.#items.map((item) => item.clone()));\n  }\n};\nvar LiveListIterator = class {\n  #innerIterator;\n  constructor(items) {\n    this.#innerIterator = items[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const result = this.#innerIterator.next();\n    if (result.done) {\n      return {\n        done: true,\n        value: void 0\n      };\n    }\n    const value = liveNodeToLson(result.value);\n    return { value };\n  }\n};\nfunction makeUpdate(liveList, deltaUpdates) {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates\n  };\n}\nfunction setDelta(index, item) {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction deleteDelta(index, deletedNode) {\n  return {\n    type: \"delete\",\n    index,\n    deletedItem: deletedNode instanceof LiveRegister ? deletedNode.data : deletedNode\n  };\n}\nfunction insertDelta(index, item) {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction moveDelta(previousIndex, index, item) {\n  return {\n    type: \"move\",\n    index,\n    item: item instanceof LiveRegister ? item.data : item,\n    previousIndex\n  };\n}\nfunction HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {\n  return ops.map((op, index) => {\n    if (index === 0) {\n      const firstOp = op;\n      return {\n        ...firstOp,\n        intent: \"set\",\n        deletedId\n      };\n    } else {\n      return op;\n    }\n  });\n}\n\n// src/crdts/LiveMap.ts\nvar LiveMap = class _LiveMap extends AbstractCrdt {\n  #map;\n  #unacknowledgedSet;\n  constructor(entries2) {\n    super();\n    this.#unacknowledgedSet = /* @__PURE__ */ new Map();\n    if (entries2) {\n      const mappedEntries = [];\n      for (const [key, value] of entries2) {\n        const node = lsonToLiveNode(value);\n        node._setParentLink(this, key);\n        mappedEntries.push([key, node]);\n      }\n      this.#map = new Map(mappedEntries);\n    } else {\n      this.#map = /* @__PURE__ */ new Map();\n    }\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: pool?.generateOpId(),\n      type: 7 /* CREATE_MAP */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const [key, value] of this.#map) {\n      ops.push(...value._toOps(this._id, key, pool));\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, _item], parentToChildren, pool) {\n    const map = new _LiveMap();\n    map._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return map;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(map, crdt.parentKey);\n      map.#map.set(crdt.parentKey, child);\n      map.invalidate();\n    }\n    return map;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey, opId } = op;\n    const key = parentKey;\n    const child = creationOpToLiveNode(op);\n    if (this._pool.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    if (source === 2 /* ACK */) {\n      const lastUpdateOpId = this.#unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId) {\n        this.#unacknowledgedSet.delete(key);\n        return { modified: false };\n      } else if (lastUpdateOpId !== void 0) {\n        return { modified: false };\n      }\n    } else if (source === 1 /* REMOTE */) {\n      this.#unacknowledgedSet.delete(key);\n    }\n    const previousValue = this.#map.get(key);\n    let reverse;\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else {\n      reverse = [{ type: 5 /* DELETE_CRDT */, id }];\n    }\n    child._setParentLink(this, key);\n    child._attach(id, this._pool);\n    this.#map.set(key, child);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      },\n      reverse\n    };\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this.#map.values()) {\n      item._detach();\n    }\n  }\n  /** @internal */\n  _detachChild(child) {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n    const reverse = child._toOps(id, parentKey, this._pool);\n    for (const [key, value] of this.#map) {\n      if (value === child) {\n        this.#map.delete(key);\n        this.invalidate();\n      }\n    }\n    child._detach();\n    const storageUpdate = {\n      node: this,\n      type: \"LiveMap\",\n      updates: { [parentKey]: { type: \"delete\" } }\n    };\n    return { modified: storageUpdate, reverse };\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n    return {\n      type: 2 /* MAP */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */\n  get(key) {\n    const value = this.#map.get(key);\n    if (value === void 0) {\n      return void 0;\n    }\n    return liveNodeToLson(value);\n  }\n  /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    const oldValue = this.#map.get(key);\n    if (oldValue) {\n      oldValue._detach();\n    }\n    const item = lsonToLiveNode(value);\n    item._setParentLink(this, key);\n    this.#map.set(key, item);\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      item._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      });\n      const ops = item._toOps(this._id, key, this._pool);\n      this.#unacknowledgedSet.set(key, nn(ops[0].opId));\n      this._pool.dispatch(\n        item._toOps(this._id, key, this._pool),\n        oldValue ? oldValue._toOps(this._id, key) : [{ type: 5 /* DELETE_CRDT */, id }],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Returns the number of elements in the LiveMap.\n   */\n  get size() {\n    return this.#map.size;\n  }\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */\n  has(key) {\n    return this.#map.has(key);\n  }\n  /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const item = this.#map.get(key);\n    if (item === void 0) {\n      return false;\n    }\n    item._detach();\n    this.#map.delete(key);\n    this.invalidate();\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"delete\" } }\n      });\n      this._pool.dispatch(\n        [\n          {\n            type: 5 /* DELETE_CRDT */,\n            id: item._id,\n            opId: this._pool.generateOpId()\n          }\n        ],\n        item._toOps(thisId, key),\n        storageUpdates\n      );\n    }\n    return true;\n  }\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */\n  entries() {\n    const innerIterator = this.#map.entries();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const entry = iteratorValue.value;\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]);\n        return {\n          value: [key, value]\n        };\n      }\n    };\n  }\n  /**\n   * Same function object as the initial value of the entries method.\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */\n  keys() {\n    return this.#map.keys();\n  }\n  /**\n   * Returns a new Iterator object that contains the values for each element.\n   */\n  values() {\n    const innerIterator = this.#map.values();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const value = liveNodeToLson(iteratorValue.value);\n        return { value };\n      }\n    };\n  }\n  /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */\n  forEach(callback) {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveMap\",\n      id: this._id ?? nanoid(),\n      key,\n      payload: Array.from(this.#map.entries()).map(\n        ([key2, val]) => val.toTreeNode(key2)\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = /* @__PURE__ */ new Map();\n    for (const [key, value] of this.#map) {\n      result.set(key, value.toImmutable());\n    }\n    return freeze(result);\n  }\n  clone() {\n    return new _LiveMap(\n      Array.from(this.#map).map(([key, node]) => [key, node.clone()])\n    );\n  }\n};\n\n// src/crdts/LiveObject.ts\nvar LiveObject = class _LiveObject extends AbstractCrdt {\n  #map;\n  #propToLastUpdate;\n  static #buildRootAndParentToChildren(items) {\n    const parentToChildren = /* @__PURE__ */ new Map();\n    let root = null;\n    for (const [id, crdt] of items) {\n      if (isRootCrdt(crdt)) {\n        root = [id, crdt];\n      } else {\n        const tuple = [id, crdt];\n        const children = parentToChildren.get(crdt.parentId);\n        if (children !== void 0) {\n          children.push(tuple);\n        } else {\n          parentToChildren.set(crdt.parentId, [tuple]);\n        }\n      }\n    }\n    if (root === null) {\n      throw new Error(\"Root can't be null\");\n    }\n    return [root, parentToChildren];\n  }\n  /** @private Do not use this API directly */\n  static _fromItems(items, pool) {\n    const [root, parentToChildren] = _LiveObject.#buildRootAndParentToChildren(items);\n    return _LiveObject._deserialize(\n      root,\n      parentToChildren,\n      pool\n    );\n  }\n  constructor(obj = {}) {\n    super();\n    this.#propToLastUpdate = /* @__PURE__ */ new Map();\n    const o = compactObject(obj);\n    for (const key of Object.keys(o)) {\n      const value = o[key];\n      if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n    this.#map = new Map(Object.entries(o));\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const opId = pool?.generateOpId();\n    const ops = [];\n    const op = {\n      type: 4 /* CREATE_OBJECT */,\n      id: this._id,\n      opId,\n      parentId,\n      parentKey,\n      data: {}\n    };\n    ops.push(op);\n    for (const [key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        ops.push(...value._toOps(this._id, key, pool));\n      } else {\n        op.data[key] = value;\n      }\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, item], parentToChildren, pool) {\n    const liveObj = new _LiveObject(item.data);\n    liveObj._attach(id, pool);\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n  /** @internal */\n  static _deserializeChildren(liveObj, parentToChildren, pool) {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (children === void 0) {\n      return liveObj;\n    }\n    for (const [id, crdt] of children) {\n      const child = deserializeToLson([id, crdt], parentToChildren, pool);\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n      liveObj.#map.set(crdt.parentKey, child);\n      liveObj.invalidate();\n    }\n    return liveObj;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this.#map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, opId, parentKey: key } = op;\n    const child = creationOpToLson(op);\n    if (this._pool.getNode(id) !== void 0) {\n      if (this.#propToLastUpdate.get(key) === opId) {\n        this.#propToLastUpdate.delete(key);\n      }\n      return { modified: false };\n    }\n    if (source === 0 /* UNDOREDO_RECONNECT */) {\n      this.#propToLastUpdate.set(key, nn(opId));\n    } else if (this.#propToLastUpdate.get(key) === void 0) {\n    } else if (this.#propToLastUpdate.get(key) === opId) {\n      this.#propToLastUpdate.delete(key);\n      return { modified: false };\n    } else {\n      return { modified: false };\n    }\n    const thisId = nn(this._id);\n    const previousValue = this.#map.get(key);\n    let reverse;\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else if (previousValue === void 0) {\n      reverse = [{ type: 6 /* DELETE_OBJECT_KEY */, id: thisId, key }];\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id: thisId,\n          data: { [key]: previousValue }\n        }\n      ];\n    }\n    this.#map.set(key, child);\n    this.invalidate();\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n      child._attach(id, this._pool);\n    }\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [key]: { type: \"update\" } }\n      }\n    };\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(id, parentKey, this._pool);\n      for (const [key, value] of this.#map) {\n        if (value === child) {\n          this.#map.delete(key);\n          this.invalidate();\n        }\n      }\n      child._detach();\n      const storageUpdate = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: { type: \"delete\" }\n        }\n      };\n      return { modified: storageUpdate, reverse };\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const value of this.#map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    if (op.type === 3 /* UPDATE_OBJECT */) {\n      return this.#applyUpdate(op, isLocal);\n    } else if (op.type === 6 /* DELETE_OBJECT_KEY */) {\n      return this.#applyDeleteObjectKey(op, isLocal);\n    }\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    const data = {};\n    for (const [key, value] of this.#map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: 0 /* OBJECT */,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data\n      };\n    } else {\n      return {\n        type: 0 /* OBJECT */,\n        data\n      };\n    }\n  }\n  #applyUpdate(op, isLocal) {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse = [];\n    const reverseUpdate = {\n      type: 3 /* UPDATE_OBJECT */,\n      id,\n      data: {}\n    };\n    for (const key in op.data) {\n      const oldValue = this.#map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverse.push(...oldValue._toOps(id, key));\n        oldValue._detach();\n      } else if (oldValue !== void 0) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === void 0) {\n        reverse.push({ type: 6 /* DELETE_OBJECT_KEY */, id, key });\n      }\n    }\n    const updateDelta = {};\n    for (const key in op.data) {\n      const value = op.data[key];\n      if (value === void 0) {\n        continue;\n      }\n      if (isLocal) {\n        this.#propToLastUpdate.set(key, nn(op.opId));\n      } else if (this.#propToLastUpdate.get(key) === void 0) {\n        isModified = true;\n      } else if (this.#propToLastUpdate.get(key) === op.opId) {\n        this.#propToLastUpdate.delete(key);\n        continue;\n      } else {\n        continue;\n      }\n      const oldValue = this.#map.get(key);\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      isModified = true;\n      updateDelta[key] = { type: \"update\" };\n      this.#map.set(key, value);\n      this.invalidate();\n    }\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n    return isModified ? {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: updateDelta\n      },\n      reverse\n    } : { modified: false };\n  }\n  #applyDeleteObjectKey(op, isLocal) {\n    const key = op.key;\n    if (this.#map.has(key) === false) {\n      return { modified: false };\n    }\n    if (!isLocal && this.#propToLastUpdate.get(key) !== void 0) {\n      return { modified: false };\n    }\n    const oldValue = this.#map.get(key);\n    const id = nn(this._id);\n    let reverse = [];\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n      oldValue._detach();\n    } else if (oldValue !== void 0) {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id,\n          data: { [key]: oldValue }\n        }\n      ];\n    }\n    this.#map.delete(key);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [op.key]: { type: \"delete\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * Transform the LiveObject into a javascript object\n   */\n  toObject() {\n    return Object.fromEntries(this.#map);\n  }\n  /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */\n  set(key, value) {\n    this._pool?.assertStorageIsWritable();\n    this.update({ [key]: value });\n  }\n  /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */\n  get(key) {\n    return this.#map.get(key);\n  }\n  /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */\n  delete(key) {\n    this._pool?.assertStorageIsWritable();\n    const keyAsString = key;\n    const oldValue = this.#map.get(keyAsString);\n    if (oldValue === void 0) {\n      return;\n    }\n    if (this._pool === void 0 || this._id === void 0) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      this.#map.delete(keyAsString);\n      this.invalidate();\n      return;\n    }\n    let reverse;\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          data: { [keyAsString]: oldValue },\n          id: this._id\n        }\n      ];\n    }\n    this.#map.delete(keyAsString);\n    this.invalidate();\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: { [key]: { type: \"delete\" } }\n    });\n    this._pool.dispatch(\n      [\n        {\n          type: 6 /* DELETE_OBJECT_KEY */,\n          key: keyAsString,\n          id: this._id,\n          opId: this._pool.generateOpId()\n        }\n      ],\n      reverse,\n      storageUpdates\n    );\n  }\n  /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */\n  update(patch) {\n    this._pool?.assertStorageIsWritable();\n    if (this._pool === void 0 || this._id === void 0) {\n      for (const key in patch) {\n        const newValue = patch[key];\n        if (newValue === void 0) {\n          continue;\n        }\n        const oldValue = this.#map.get(key);\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n        this.#map.set(key, newValue);\n        this.invalidate();\n      }\n      return;\n    }\n    const ops = [];\n    const reverseOps = [];\n    const opId = this._pool.generateOpId();\n    const updatedProps = {};\n    const reverseUpdateOp = {\n      id: this._id,\n      type: 3 /* UPDATE_OBJECT */,\n      data: {}\n    };\n    const updateDelta = {};\n    for (const key in patch) {\n      const newValue = patch[key];\n      if (newValue === void 0) {\n        continue;\n      }\n      const oldValue = this.#map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverseOps.push(...oldValue._toOps(this._id, key));\n        oldValue._detach();\n      } else if (oldValue === void 0) {\n        reverseOps.push({ type: 6 /* DELETE_OBJECT_KEY */, id: this._id, key });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n        newValue._attach(this._pool.generateId(), this._pool);\n        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n        const createCrdtOp = newAttachChildOps.find(\n          (op) => op.parentId === this._id\n        );\n        if (createCrdtOp) {\n          this.#propToLastUpdate.set(key, nn(createCrdtOp.opId));\n        }\n        ops.push(...newAttachChildOps);\n      } else {\n        updatedProps[key] = newValue;\n        this.#propToLastUpdate.set(key, opId);\n      }\n      this.#map.set(key, newValue);\n      this.invalidate();\n      updateDelta[key] = { type: \"update\" };\n    }\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: 3 /* UPDATE_OBJECT */,\n        data: updatedProps\n      });\n    }\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta\n    });\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  toTreeNode(key) {\n    return super.toTreeNode(key);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    const nodeId = this._id ?? nanoid();\n    return {\n      type: \"LiveObject\",\n      id: nodeId,\n      key,\n      payload: Array.from(this.#map.entries()).map(\n        ([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : { type: \"Json\", id: `${nodeId}:${key2}`, key: key2, payload: value }\n      )\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = {};\n    for (const [key, val] of this.#map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n    return  false ? 0 : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveObject(\n      Object.fromEntries(\n        Array.from(this.#map).map(([key, value]) => [\n          key,\n          isLiveStructure(value) ? value.clone() : deepClone(value)\n        ])\n      )\n    );\n  }\n};\n\n// src/crdts/liveblocks-helpers.ts\nfunction creationOpToLiveNode(op) {\n  return lsonToLiveNode(creationOpToLson(op));\n}\nfunction creationOpToLson(op) {\n  switch (op.type) {\n    case 8 /* CREATE_REGISTER */:\n      return op.data;\n    case 4 /* CREATE_OBJECT */:\n      return new LiveObject(op.data);\n    case 7 /* CREATE_MAP */:\n      return new LiveMap();\n    case 2 /* CREATE_LIST */:\n      return new LiveList([]);\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\nfunction isSameNodeOrChildOf(node, parent) {\n  if (node === parent) {\n    return true;\n  }\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n  return false;\n}\nfunction deserialize([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction deserializeToLson([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return crdt.data;\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction isLiveStructure(value) {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\nfunction isLiveNode(value) {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\nfunction isLiveList(value) {\n  return value instanceof LiveList;\n}\nfunction isLiveMap(value) {\n  return value instanceof LiveMap;\n}\nfunction isLiveObject(value) {\n  return value instanceof LiveObject;\n}\nfunction isLiveRegister(value) {\n  return value instanceof LiveRegister;\n}\nfunction cloneLson(value) {\n  return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);\n}\nfunction liveNodeToLson(obj) {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\nfunction lsonToLiveNode(value) {\n  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\nfunction getTreesDiffOperations(currentItems, newItems) {\n  const ops = [];\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      ops.push({\n        type: 5 /* DELETE_CRDT */,\n        id\n      });\n    }\n  });\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n    if (currentCrdt) {\n      if (crdt.type === 0 /* OBJECT */) {\n        if (currentCrdt.type !== 0 /* OBJECT */ || stringifyOrLog(crdt.data) !== stringifyOrLog(currentCrdt.data)) {\n          ops.push({\n            type: 3 /* UPDATE_OBJECT */,\n            id,\n            data: crdt.data\n          });\n        }\n      }\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: 1 /* SET_PARENT_KEY */,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\")\n        });\n      }\n    } else {\n      switch (crdt.type) {\n        case 3 /* REGISTER */:\n          ops.push({\n            type: 8 /* CREATE_REGISTER */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 1 /* LIST */:\n          ops.push({\n            type: 2 /* CREATE_LIST */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n        case 0 /* OBJECT */:\n          if (crdt.parentId === void 0 || crdt.parentKey === void 0) {\n            throw new Error(\n              \"Internal error. Cannot serialize storage root into an operation\"\n            );\n          }\n          ops.push({\n            type: 4 /* CREATE_OBJECT */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 2 /* MAP */:\n          ops.push({\n            type: 7 /* CREATE_MAP */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n      }\n    }\n  });\n  return ops;\n}\nfunction mergeObjectStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeMapStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeListStorageUpdates(first, second) {\n  const updates = first.updates;\n  return {\n    ...second,\n    updates: updates.concat(second.updates)\n  };\n}\nfunction mergeStorageUpdates(first, second) {\n  if (first === void 0) {\n    return second;\n  }\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {\n  }\n  return second;\n}\nfunction isPlain(value) {\n  const type = typeof value;\n  return value === void 0 || value === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(value) || isPlainObject(value);\n}\nfunction findNonSerializableValue(value, path = \"\") {\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n  return false;\n}\n\n// src/lib/debug.ts\nfunction captureStackTrace(msg, traceRoot) {\n  const errorLike = { name: msg };\n  if (typeof Error.captureStackTrace !== \"function\") {\n    return void 0;\n  }\n  Error.captureStackTrace(errorLike, traceRoot);\n  return errorLike.stack;\n}\n\n// src/lib/Deque.ts\nvar Deque = class {\n  #data;\n  #front;\n  #back;\n  #size;\n  constructor() {\n    this.#data = {};\n    this.#front = 0;\n    this.#back = 1;\n    this.#size = 0;\n  }\n  get length() {\n    return this.#size;\n  }\n  *[Symbol.iterator]() {\n    const size = this.#size;\n    const front = this.#front;\n    for (let i = 0; i < size; i++) {\n      yield this.#data[front + i];\n    }\n  }\n  push(value) {\n    const values2 = Array.isArray(value) ? value : [value];\n    if (this.#back > Number.MAX_SAFE_INTEGER - values2.length - 1)\n      raise(\"Deque full\");\n    for (const value2 of values2) {\n      this.#data[this.#back++ - 1] = value2;\n    }\n    this.#size += values2.length;\n  }\n  pop() {\n    if (this.#size < 1) return void 0;\n    this.#back--;\n    const value = this.#data[this.#back - 1];\n    delete this.#data[this.#back - 1];\n    this.#size--;\n    return value;\n  }\n  pushLeft(value) {\n    const values2 = Array.isArray(value) ? value : [value];\n    if (this.#front < Number.MIN_SAFE_INTEGER + values2.length)\n      raise(\"Deque full\");\n    for (let i = values2.length - 1; i >= 0; i--) {\n      this.#data[--this.#front] = values2[i];\n    }\n    this.#size += values2.length;\n  }\n  popLeft() {\n    if (this.#size < 1) return void 0;\n    const value = this.#data[this.#front];\n    delete this.#data[this.#front];\n    this.#front++;\n    this.#size--;\n    return value;\n  }\n};\n\n// src/lib/Json.ts\nfunction isJsonScalar(data) {\n  return data === null || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\";\n}\nfunction isJsonArray(data) {\n  return Array.isArray(data);\n}\nfunction isJsonObject(data) {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n\n// src/protocol/ClientMsg.ts\nvar ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2) => {\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ClientMsgCode2[ClientMsgCode2[\"BROADCAST_EVENT\"] = 103] = \"BROADCAST_EVENT\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_STORAGE\"] = 200] = \"FETCH_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_YDOC\"] = 300] = \"FETCH_YDOC\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_YDOC\"] = 301] = \"UPDATE_YDOC\";\n  return ClientMsgCode2;\n})(ClientMsgCode || {});\n\n// src/refs/ManagedOthers.ts\nfunction makeUser(conn, presence) {\n  const { connectionId, id, info } = conn;\n  const canWrite = canWriteStorage(conn.scopes);\n  return freeze(\n    compactObject({\n      connectionId,\n      id,\n      info,\n      canWrite,\n      canComment: canComment(conn.scopes),\n      isReadOnly: !canWrite,\n      // Deprecated, kept for backward-compatibility\n      presence\n    })\n  );\n}\nvar ManagedOthers = class {\n  // Track mutable state internally, but signal to the outside when the\n  // observable derived state changes only\n  #internal;\n  #userCache;\n  // The \"clean\" signal that is exposed to the outside world\n  signal;\n  constructor() {\n    this.#internal = new MutableSignal({\n      connections: /* @__PURE__ */ new Map(),\n      presences: /* @__PURE__ */ new Map()\n    });\n    this.signal = DerivedSignal.from(\n      this.#internal,\n      (_ignore) => compact(\n        Array.from(this.#internal.get().presences.keys()).map(\n          (connectionId) => this.getUser(Number(connectionId))\n        )\n      )\n    );\n    this.#userCache = /* @__PURE__ */ new Map();\n  }\n  // Shorthand for .signal.get()\n  get() {\n    return this.signal.get();\n  }\n  connectionIds() {\n    return this.#internal.get().connections.keys();\n  }\n  clearOthers() {\n    this.#internal.mutate((state) => {\n      state.connections.clear();\n      state.presences.clear();\n      this.#userCache.clear();\n    });\n  }\n  #_getUser(connectionId) {\n    const state = this.#internal.get();\n    const conn = state.connections.get(connectionId);\n    const presence = state.presences.get(connectionId);\n    if (conn !== void 0 && presence !== void 0) {\n      return makeUser(conn, presence);\n    }\n    return void 0;\n  }\n  getUser(connectionId) {\n    const cachedUser = this.#userCache.get(connectionId);\n    if (cachedUser) {\n      return cachedUser;\n    }\n    const computedUser = this.#_getUser(connectionId);\n    if (computedUser) {\n      this.#userCache.set(connectionId, computedUser);\n      return computedUser;\n    }\n    return void 0;\n  }\n  #invalidateUser(connectionId) {\n    this.#userCache.delete(connectionId);\n  }\n  /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */\n  setConnection(connectionId, metaUserId, metaUserInfo, scopes) {\n    this.#internal.mutate((state) => {\n      state.connections.set(\n        connectionId,\n        freeze({\n          connectionId,\n          id: metaUserId,\n          info: metaUserInfo,\n          scopes\n        })\n      );\n      if (!state.presences.has(connectionId)) {\n        return false;\n      }\n      return this.#invalidateUser(connectionId);\n    });\n  }\n  /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */\n  removeConnection(connectionId) {\n    this.#internal.mutate((state) => {\n      state.connections.delete(connectionId);\n      state.presences.delete(connectionId);\n      this.#invalidateUser(connectionId);\n    });\n  }\n  /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */\n  setOther(connectionId, presence) {\n    this.#internal.mutate((state) => {\n      state.presences.set(connectionId, freeze(compactObject(presence)));\n      if (!state.connections.has(connectionId)) {\n        return false;\n      }\n      return this.#invalidateUser(connectionId);\n    });\n  }\n  /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */\n  patchOther(connectionId, patch) {\n    this.#internal.mutate((state) => {\n      const oldPresence = state.presences.get(connectionId);\n      if (oldPresence === void 0) {\n        return false;\n      }\n      const newPresence = merge(oldPresence, patch);\n      if (oldPresence === newPresence) {\n        return false;\n      }\n      state.presences.set(connectionId, freeze(newPresence));\n      return this.#invalidateUser(connectionId);\n    });\n  }\n};\n\n// src/types/LiveblocksError.ts\nvar LiveblocksError = class _LiveblocksError extends Error {\n  context;\n  constructor(message, context, cause) {\n    super(message, { cause });\n    this.context = context;\n    this.name = \"LiveblocksError\";\n  }\n  /** Convenience accessor for error.context.roomId (if available) */\n  get roomId() {\n    return this.context.roomId;\n  }\n  /** @deprecated Prefer using `context.code` instead, to enable type narrowing */\n  get code() {\n    return this.context.code;\n  }\n  /**\n   * Creates a LiveblocksError from a generic error, by attaching Liveblocks\n   * contextual information like room ID, thread ID, etc.\n   */\n  static from(context, cause) {\n    return new _LiveblocksError(\n      defaultMessageFromContext(context),\n      context,\n      cause\n    );\n  }\n};\nfunction defaultMessageFromContext(context) {\n  switch (context.type) {\n    case \"ROOM_CONNECTION_ERROR\": {\n      switch (context.code) {\n        case 4001:\n          return \"Not allowed to connect to the room\";\n        case 4005:\n          return \"Room is already full\";\n        case 4006:\n          return \"Kicked out of the room, because the room ID changed\";\n        default:\n          return \"Could not connect to the room\";\n      }\n    }\n    case \"CREATE_THREAD_ERROR\":\n      return \"Could not create new thread\";\n    case \"DELETE_THREAD_ERROR\":\n      return \"Could not delete thread\";\n    case \"EDIT_THREAD_METADATA_ERROR\":\n      return \"Could not edit thread metadata\";\n    case \"MARK_THREAD_AS_RESOLVED_ERROR\":\n      return \"Could not mark thread as resolved\";\n    case \"MARK_THREAD_AS_UNRESOLVED_ERROR\":\n      return \"Could not mark thread as unresolved\";\n    case \"CREATE_COMMENT_ERROR\":\n      return \"Could not create new comment\";\n    case \"EDIT_COMMENT_ERROR\":\n      return \"Could not edit comment\";\n    case \"DELETE_COMMENT_ERROR\":\n      return \"Could not delete comment\";\n    case \"ADD_REACTION_ERROR\":\n      return \"Could not add reaction\";\n    case \"REMOVE_REACTION_ERROR\":\n      return \"Could not remove reaction\";\n    case \"MARK_INBOX_NOTIFICATION_AS_READ_ERROR\":\n      return \"Could not mark inbox notification as read\";\n    case \"DELETE_INBOX_NOTIFICATION_ERROR\":\n      return \"Could not delete inbox notification\";\n    case \"MARK_ALL_INBOX_NOTIFICATIONS_AS_READ_ERROR\":\n      return \"Could not mark all inbox notifications as read\";\n    case \"DELETE_ALL_INBOX_NOTIFICATIONS_ERROR\":\n      return \"Could not delete all inbox notifications\";\n    case \"UPDATE_NOTIFICATION_SETTINGS_ERROR\":\n      return \"Could not update notification settings\";\n    case \"UPDATE_USER_NOTIFICATION_SETTINGS_ERROR\":\n      return \"Could not update user notification settings\";\n    default:\n      return assertNever(context, \"Unhandled case\");\n  }\n}\n\n// src/room.ts\nvar MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 512;\nfunction makeIdFactory(connectionId) {\n  let count = 0;\n  return () => `${connectionId}:${count++}`;\n}\nfunction userToTreeNode(key, user) {\n  return {\n    type: \"User\",\n    id: `${user.connectionId}`,\n    key,\n    payload: {\n      connectionId: user.connectionId,\n      id: user.id,\n      info: user.info,\n      presence: user.presence,\n      isReadOnly: !user.canWrite\n    }\n  };\n}\nfunction installBackgroundTabSpy() {\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const inBackgroundSince = { current: null };\n  function onVisibilityChange() {\n    if (doc?.visibilityState === \"hidden\") {\n      inBackgroundSince.current = inBackgroundSince.current ?? Date.now();\n    } else {\n      inBackgroundSince.current = null;\n    }\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  const unsub = () => {\n    doc?.removeEventListener(\"visibilitychange\", onVisibilityChange);\n  };\n  return [inBackgroundSince, unsub];\n}\nfunction createRoom(options, config) {\n  const roomId = config.roomId;\n  const initialPresence = options.initialPresence;\n  const initialStorage = options.initialStorage;\n  const httpClient = config.roomHttpClient;\n  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n  const delegates = {\n    ...config.delegates,\n    // A connection is allowed to go into \"zombie state\" only if all of the\n    // following conditions apply:\n    //\n    // - The `backgroundKeepAliveTimeout` client option is configured\n    // - The browser window has been in the background for at least\n    //   `backgroundKeepAliveTimeout` milliseconds\n    // - There are no pending changes\n    //\n    canZombie() {\n      return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== \"synchronizing\";\n    }\n  };\n  const managedSocket = new ManagedSocket(\n    delegates,\n    config.enableDebugLogging\n  );\n  const context = {\n    buffer: {\n      flushTimerID: void 0,\n      lastFlushedAt: 0,\n      presenceUpdates: (\n        // Queue up the initial presence message as a Full Presence update\n        {\n          type: \"full\",\n          data: initialPresence\n        }\n      ),\n      messages: [],\n      storageOperations: []\n    },\n    staticSessionInfoSig: new Signal(null),\n    dynamicSessionInfoSig: new Signal(null),\n    myPresence: new PatchableSignal(initialPresence),\n    others: new ManagedOthers(),\n    initialStorage,\n    idFactory: null,\n    // The Yjs provider associated to this room\n    yjsProvider: void 0,\n    yjsProviderDidChange: makeEventSource(),\n    // Storage\n    pool: createManagedPool(roomId, {\n      getCurrentConnectionId,\n      onDispatch,\n      isStorageWritable\n    }),\n    root: void 0,\n    undoStack: [],\n    redoStack: [],\n    pausedHistory: null,\n    activeBatch: null,\n    unacknowledgedOps: /* @__PURE__ */ new Map(),\n    // Debug\n    opStackTraces:  true ? /* @__PURE__ */ new Map() : 0\n  };\n  let lastTokenKey;\n  function onStatusDidChange(newStatus) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getBearerTokenFromAuthValue(authValue);\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfoSig.set({\n            userId: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.id : token.uid,\n            userInfo: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.info : token.ui\n          });\n        } else {\n          context.staticSessionInfoSig.set({\n            userId: void 0,\n            userInfo: void 0\n          });\n        }\n      }\n    }\n    eventHub.status.notify(newStatus);\n    notifySelfChanged();\n  }\n  let _connectionLossTimerId;\n  let _hasLostConnection = false;\n  function handleConnectionLossEvent(newStatus) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        eventHub.lostConnection.notify(\"lost\");\n        _hasLostConnection = true;\n        context.others.clearOthers();\n        notify({ others: [{ type: \"reset\" }] });\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n      if (_hasLostConnection) {\n        if (newStatus === \"disconnected\") {\n          eventHub.lostConnection.notify(\"failed\");\n        } else {\n          eventHub.lostConnection.notify(\"restored\");\n        }\n        _hasLostConnection = false;\n      }\n    }\n  }\n  function onDidConnect() {\n    context.buffer.presenceUpdates = {\n      type: \"full\",\n      data: (\n        // Because context.me.current is a readonly object, we'll have to\n        // make a copy here. Otherwise, type errors happen later when\n        // \"patching\" my presence.\n        { ...context.myPresence.get() }\n      )\n    };\n    if (_getStorage$ !== null) {\n      refreshStorage({ flush: false });\n    }\n    flushNowOrSoon();\n  }\n  function onDidDisconnect() {\n    clearTimeout(context.buffer.flushTimerID);\n  }\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onConnectionError.subscribe(({ message, code }) => {\n    const type = \"ROOM_CONNECTION_ERROR\";\n    const err = new LiveblocksError(message, { type, code, roomId });\n    const didNotify = config.errorEventSource.notify(err);\n    if (!didNotify) {\n      if (true) {\n        error2(\n          `Connection to websocket server closed. Reason: ${message} (code: ${code}).`\n        );\n      }\n    }\n  });\n  function onDispatch(ops, reverse, storageUpdates) {\n    if (true) {\n      const stackTrace = captureStackTrace(\"Storage mutation\", onDispatch);\n      if (stackTrace) {\n        for (const op of ops) {\n          if (op.opId) {\n            nn(context.opStackTraces).set(op.opId, stackTrace);\n          }\n        }\n      }\n    }\n    if (context.activeBatch) {\n      for (const op of ops) {\n        context.activeBatch.ops.push(op);\n      }\n      for (const [key, value] of storageUpdates) {\n        context.activeBatch.updates.storageUpdates.set(\n          key,\n          mergeStorageUpdates(\n            context.activeBatch.updates.storageUpdates.get(key),\n            value\n          )\n        );\n      }\n      context.activeBatch.reverseOps.pushLeft(reverse);\n    } else {\n      addToUndoStack(reverse);\n      context.redoStack.length = 0;\n      dispatchOps(ops);\n      notify({ storageUpdates });\n    }\n  }\n  function isStorageWritable() {\n    const scopes = context.dynamicSessionInfoSig.get()?.scopes;\n    return scopes !== void 0 ? canWriteStorage(scopes) : true;\n  }\n  const eventHub = {\n    status: makeEventSource(),\n    // New/recommended API\n    lostConnection: makeEventSource(),\n    customEvent: makeEventSource(),\n    self: makeEventSource(),\n    myPresence: makeEventSource(),\n    others: makeEventSource(),\n    storageBatch: makeEventSource(),\n    history: makeEventSource(),\n    storageDidLoad: makeEventSource(),\n    storageStatus: makeEventSource(),\n    ydoc: makeEventSource(),\n    comments: makeEventSource(),\n    roomWillDestroy: makeEventSource()\n  };\n  async function createTextMention(userId, mentionId) {\n    return httpClient.createTextMention({ roomId, userId, mentionId });\n  }\n  async function deleteTextMention(mentionId) {\n    return httpClient.deleteTextMention({ roomId, mentionId });\n  }\n  async function reportTextEditor(type, rootKey) {\n    await httpClient.reportTextEditor({ roomId, type, rootKey });\n  }\n  async function listTextVersions() {\n    return httpClient.listTextVersions({ roomId });\n  }\n  async function listTextVersionsSince(options2) {\n    return httpClient.listTextVersionsSince({\n      roomId,\n      since: options2.since,\n      signal: options2.signal\n    });\n  }\n  async function getTextVersion(versionId) {\n    return httpClient.getTextVersion({ roomId, versionId });\n  }\n  async function createTextVersion() {\n    return httpClient.createTextVersion({ roomId });\n  }\n  async function executeContextualPrompt(options2) {\n    return httpClient.executeContextualPrompt({\n      roomId,\n      ...options2\n    });\n  }\n  function* chunkOps(msg) {\n    const { ops, ...rest } = msg;\n    if (ops.length < 2) {\n      throw new Error(\"Cannot split ops into smaller chunks\");\n    }\n    const mid = Math.floor(ops.length / 2);\n    const firstHalf = ops.slice(0, mid);\n    const secondHalf = ops.slice(mid);\n    for (const halfOps of [firstHalf, secondHalf]) {\n      const half = { ops: halfOps, ...rest };\n      const text = stringifyOrLog([half]);\n      if (!isTooBigForWebSocket(text)) {\n        yield text;\n      } else {\n        yield* chunkOps(half);\n      }\n    }\n  }\n  function* chunkMessages(messages) {\n    if (messages.length < 2) {\n      if (messages[0].type === 201 /* UPDATE_STORAGE */) {\n        yield* chunkOps(messages[0]);\n        return;\n      } else {\n        throw new Error(\n          \"Cannot split into chunks smaller than the allowed message size\"\n        );\n      }\n    }\n    const mid = Math.floor(messages.length / 2);\n    const firstHalf = messages.slice(0, mid);\n    const secondHalf = messages.slice(mid);\n    for (const half of [firstHalf, secondHalf]) {\n      const text = stringifyOrLog(half);\n      if (!isTooBigForWebSocket(text)) {\n        yield text;\n      } else {\n        yield* chunkMessages(half);\n      }\n    }\n  }\n  function isTooBigForWebSocket(text) {\n    if (text.length * 4 < MAX_SOCKET_MESSAGE_SIZE) {\n      return false;\n    }\n    return new TextEncoder().encode(text).length >= MAX_SOCKET_MESSAGE_SIZE;\n  }\n  function sendMessages(messages) {\n    const strategy = config.largeMessageStrategy ?? \"default\";\n    const text = stringifyOrLog(messages);\n    if (!isTooBigForWebSocket(text)) {\n      return managedSocket.send(text);\n    }\n    switch (strategy) {\n      case \"default\": {\n        error2(\"Message is too large for websockets, not sending. Configure largeMessageStrategy option to deal with this.\");\n        return;\n      }\n      case \"split\": {\n        warn(\"Message is too large for websockets, splitting into smaller chunks\");\n        for (const chunk2 of chunkMessages(messages)) {\n          managedSocket.send(chunk2);\n        }\n        return;\n      }\n      case \"experimental-fallback-to-http\": {\n        warn(\"Message is too large for websockets, so sending over HTTP instead\");\n        const nonce = context.dynamicSessionInfoSig.get()?.nonce ?? raise(\"Session is not authorized to send message over HTTP\");\n        void httpClient.sendMessages({ roomId, nonce, messages }).then((resp) => {\n          if (!resp.ok && resp.status === 403) {\n            managedSocket.reconnect();\n          }\n        });\n        return;\n      }\n    }\n  }\n  const self = DerivedSignal.from(\n    context.staticSessionInfoSig,\n    context.dynamicSessionInfoSig,\n    context.myPresence,\n    (staticSession, dynamicSession, myPresence) => {\n      if (staticSession === null || dynamicSession === null) {\n        return null;\n      } else {\n        const canWrite = canWriteStorage(dynamicSession.scopes);\n        return {\n          connectionId: dynamicSession.actor,\n          id: staticSession.userId,\n          info: staticSession.userInfo,\n          presence: myPresence,\n          canWrite,\n          canComment: canComment(dynamicSession.scopes)\n        };\n      }\n    }\n  );\n  let _lastSelf;\n  function notifySelfChanged() {\n    const currSelf = self.get();\n    if (currSelf !== null && currSelf !== _lastSelf) {\n      eventHub.self.notify(currSelf);\n      _lastSelf = currSelf;\n    }\n  }\n  const selfAsTreeNode = DerivedSignal.from(\n    self,\n    (me) => me !== null ? userToTreeNode(\"Me\", me) : null\n  );\n  function createOrUpdateRootFromMessage(message) {\n    if (message.items.length === 0) {\n      throw new Error(\"Internal error: cannot load storage without items\");\n    }\n    if (context.root !== void 0) {\n      updateRoot(message.items);\n    } else {\n      context.root = LiveObject._fromItems(message.items, context.pool);\n    }\n    const canWrite = self.get()?.canWrite ?? true;\n    const stackSizeBefore = context.undoStack.length;\n    for (const key in context.initialStorage) {\n      if (context.root.get(key) === void 0) {\n        if (canWrite) {\n          context.root.set(key, cloneLson(context.initialStorage[key]));\n        } else {\n          warn(\n            `Attempted to populate missing storage key '${key}', but current user has no write access`\n          );\n        }\n      }\n    }\n    context.undoStack.length = stackSizeBefore;\n  }\n  function updateRoot(items) {\n    if (context.root === void 0) {\n      return;\n    }\n    const currentItems = /* @__PURE__ */ new Map();\n    for (const [id, node] of context.pool.nodes) {\n      currentItems.set(id, node._serialize());\n    }\n    const ops = getTreesDiffOperations(currentItems, new Map(items));\n    const result = applyOps(ops, false);\n    notify(result.updates);\n  }\n  function _addToRealUndoStack(historyOps) {\n    if (context.undoStack.length >= 50) {\n      context.undoStack.shift();\n    }\n    context.undoStack.push(historyOps);\n    onHistoryChange();\n  }\n  function addToUndoStack(historyOps) {\n    if (context.pausedHistory !== null) {\n      context.pausedHistory.pushLeft(historyOps);\n    } else {\n      _addToRealUndoStack(historyOps);\n    }\n  }\n  function notify(updates) {\n    const storageUpdates = updates.storageUpdates;\n    const othersUpdates = updates.others;\n    if (othersUpdates !== void 0 && othersUpdates.length > 0) {\n      const others = context.others.get();\n      for (const event of othersUpdates) {\n        eventHub.others.notify({ ...event, others });\n      }\n    }\n    if (updates.presence ?? false) {\n      notifySelfChanged();\n      eventHub.myPresence.notify(context.myPresence.get());\n    }\n    if (storageUpdates !== void 0 && storageUpdates.size > 0) {\n      const updates2 = Array.from(storageUpdates.values());\n      eventHub.storageBatch.notify(updates2);\n    }\n    notifyStorageStatus();\n  }\n  function getCurrentConnectionId() {\n    const info = context.dynamicSessionInfoSig.get();\n    if (info) {\n      return info.actor;\n    }\n    throw new Error(\n      \"Internal. Tried to get connection id but connection was never open\"\n    );\n  }\n  function applyOps(rawOps, isLocal) {\n    const output = {\n      reverse: new Deque(),\n      storageUpdates: /* @__PURE__ */ new Map(),\n      presence: false\n    };\n    const createdNodeIds = /* @__PURE__ */ new Set();\n    const ops = rawOps.map((op) => {\n      if (op.type !== \"presence\" && !op.opId) {\n        return { ...op, opId: context.pool.generateOpId() };\n      } else {\n        return op;\n      }\n    });\n    for (const op of ops) {\n      if (op.type === \"presence\") {\n        const reverse = {\n          type: \"presence\",\n          data: {}\n        };\n        for (const key in op.data) {\n          reverse.data[key] = context.myPresence.get()[key];\n        }\n        context.myPresence.patch(op.data);\n        if (context.buffer.presenceUpdates === null) {\n          context.buffer.presenceUpdates = { type: \"partial\", data: op.data };\n        } else {\n          for (const key in op.data) {\n            context.buffer.presenceUpdates.data[key] = op.data[key];\n          }\n        }\n        output.reverse.pushLeft(reverse);\n        output.presence = true;\n      } else {\n        let source;\n        if (isLocal) {\n          source = 0 /* UNDOREDO_RECONNECT */;\n        } else {\n          const opId = nn(op.opId);\n          if (true) {\n            nn(context.opStackTraces).delete(opId);\n          }\n          const deleted = context.unacknowledgedOps.delete(opId);\n          source = deleted ? 2 /* ACK */ : 1 /* REMOTE */;\n        }\n        const applyOpResult = applyOp(op, source);\n        if (applyOpResult.modified) {\n          const nodeId = applyOpResult.modified.node._id;\n          if (!(nodeId && createdNodeIds.has(nodeId))) {\n            output.storageUpdates.set(\n              nn(applyOpResult.modified.node._id),\n              mergeStorageUpdates(\n                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),\n                applyOpResult.modified\n              )\n            );\n            output.reverse.pushLeft(applyOpResult.reverse);\n          }\n          if (op.type === 2 /* CREATE_LIST */ || op.type === 7 /* CREATE_MAP */ || op.type === 4 /* CREATE_OBJECT */) {\n            createdNodeIds.add(nn(op.id));\n          }\n        }\n      }\n    }\n    return {\n      ops,\n      reverse: Array.from(output.reverse),\n      updates: {\n        storageUpdates: output.storageUpdates,\n        presence: output.presence\n      }\n    };\n  }\n  function applyOp(op, source) {\n    if (isAckOp(op)) {\n      return { modified: false };\n    }\n    switch (op.type) {\n      case 6 /* DELETE_OBJECT_KEY */:\n      case 3 /* UPDATE_OBJECT */:\n      case 5 /* DELETE_CRDT */: {\n        const node = context.pool.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */);\n      }\n      case 1 /* SET_PARENT_KEY */: {\n        const node = context.pool.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n          return node.parent.node._setChildKey(\n            asPos(op.parentKey),\n            node,\n            source\n          );\n        }\n        return { modified: false };\n      }\n      case 4 /* CREATE_OBJECT */:\n      case 2 /* CREATE_LIST */:\n      case 7 /* CREATE_MAP */:\n      case 8 /* CREATE_REGISTER */: {\n        if (op.parentId === void 0) {\n          return { modified: false };\n        }\n        const parentNode = context.pool.nodes.get(op.parentId);\n        if (parentNode === void 0) {\n          return { modified: false };\n        }\n        return parentNode._attachChild(op, source);\n      }\n    }\n  }\n  function updatePresence(patch, options2) {\n    const oldValues = {};\n    if (context.buffer.presenceUpdates === null) {\n      context.buffer.presenceUpdates = {\n        type: \"partial\",\n        data: {}\n      };\n    }\n    for (const key in patch) {\n      const overrideValue = patch[key];\n      if (overrideValue === void 0) {\n        continue;\n      }\n      context.buffer.presenceUpdates.data[key] = overrideValue;\n      oldValues[key] = context.myPresence.get()[key];\n    }\n    context.myPresence.patch(patch);\n    if (context.activeBatch) {\n      if (options2?.addToHistory) {\n        context.activeBatch.reverseOps.pushLeft({\n          type: \"presence\",\n          data: oldValues\n        });\n      }\n      context.activeBatch.updates.presence = true;\n    } else {\n      flushNowOrSoon();\n      if (options2?.addToHistory) {\n        addToUndoStack([{ type: \"presence\", data: oldValues }]);\n      }\n      notify({ presence: true });\n    }\n  }\n  function onUpdatePresenceMessage(message) {\n    if (message.targetActor !== void 0) {\n      const oldUser = context.others.getUser(message.actor);\n      context.others.setOther(message.actor, message.data);\n      const newUser = context.others.getUser(message.actor);\n      if (oldUser === void 0 && newUser !== void 0) {\n        return { type: \"enter\", user: newUser };\n      }\n    } else {\n      context.others.patchOther(message.actor, message.data), message;\n    }\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      return {\n        type: \"update\",\n        updates: message.data,\n        user\n      };\n    } else {\n      return void 0;\n    }\n  }\n  function onUserLeftMessage(message) {\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      context.others.removeConnection(message.actor);\n      return { type: \"leave\", user };\n    }\n    return null;\n  }\n  function onRoomStateMessage(message) {\n    context.dynamicSessionInfoSig.set({\n      actor: message.actor,\n      nonce: message.nonce,\n      scopes: message.scopes\n    });\n    context.idFactory = makeIdFactory(message.actor);\n    notifySelfChanged();\n    for (const connectionId of context.others.connectionIds()) {\n      const user = message.users[connectionId];\n      if (user === void 0) {\n        context.others.removeConnection(connectionId);\n      }\n    }\n    for (const key in message.users) {\n      const user = message.users[key];\n      const connectionId = Number(key);\n      context.others.setConnection(\n        connectionId,\n        user.id,\n        user.info,\n        user.scopes\n      );\n    }\n    return { type: \"reset\" };\n  }\n  function canUndo() {\n    return context.undoStack.length > 0;\n  }\n  function canRedo() {\n    return context.redoStack.length > 0;\n  }\n  function onHistoryChange() {\n    eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });\n  }\n  function onUserJoinedMessage(message) {\n    context.others.setConnection(\n      message.actor,\n      message.id,\n      message.info,\n      message.scopes\n    );\n    context.buffer.messages.push({\n      type: 100 /* UPDATE_PRESENCE */,\n      data: context.myPresence.get(),\n      targetActor: message.actor\n    });\n    flushNowOrSoon();\n    const user = context.others.getUser(message.actor);\n    return user ? { type: \"enter\", user } : void 0;\n  }\n  function parseServerMessage(data) {\n    if (!isJsonObject(data)) {\n      return null;\n    }\n    return data;\n  }\n  function parseServerMessages(text) {\n    const data = tryParseJson(text);\n    if (data === void 0) {\n      return null;\n    } else if (isJsonArray(data)) {\n      return compact(data.map((item) => parseServerMessage(item)));\n    } else {\n      return compact([parseServerMessage(data)]);\n    }\n  }\n  function applyAndSendOps(offlineOps) {\n    if (offlineOps.size === 0) {\n      return;\n    }\n    const messages = [];\n    const inOps = Array.from(offlineOps.values());\n    const result = applyOps(inOps, true);\n    messages.push({\n      type: 201 /* UPDATE_STORAGE */,\n      ops: result.ops\n    });\n    notify(result.updates);\n    sendMessages(messages);\n  }\n  function handleServerMessage(event) {\n    if (typeof event.data !== \"string\") {\n      return;\n    }\n    const messages = parseServerMessages(event.data);\n    if (messages === null || messages.length === 0) {\n      return;\n    }\n    const updates = {\n      storageUpdates: /* @__PURE__ */ new Map(),\n      others: []\n    };\n    for (const message of messages) {\n      switch (message.type) {\n        case 101 /* USER_JOINED */: {\n          const userJoinedUpdate = onUserJoinedMessage(message);\n          if (userJoinedUpdate) {\n            updates.others.push(userJoinedUpdate);\n          }\n          break;\n        }\n        case 100 /* UPDATE_PRESENCE */: {\n          const othersPresenceUpdate = onUpdatePresenceMessage(message);\n          if (othersPresenceUpdate) {\n            updates.others.push(othersPresenceUpdate);\n          }\n          break;\n        }\n        case 103 /* BROADCASTED_EVENT */: {\n          const others = context.others.get();\n          eventHub.customEvent.notify({\n            connectionId: message.actor,\n            user: message.actor < 0 ? null : others.find((u) => u.connectionId === message.actor) ?? null,\n            event: message.event\n          });\n          break;\n        }\n        case 102 /* USER_LEFT */: {\n          const event2 = onUserLeftMessage(message);\n          if (event2) {\n            updates.others.push(event2);\n          }\n          break;\n        }\n        case 300 /* UPDATE_YDOC */: {\n          eventHub.ydoc.notify(message);\n          break;\n        }\n        case 104 /* ROOM_STATE */: {\n          updates.others.push(onRoomStateMessage(message));\n          break;\n        }\n        case 200 /* INITIAL_STORAGE_STATE */: {\n          processInitialStorage(message);\n          break;\n        }\n        // Write event\n        case 201 /* UPDATE_STORAGE */: {\n          const applyResult = applyOps(message.ops, false);\n          for (const [key, value] of applyResult.updates.storageUpdates) {\n            updates.storageUpdates.set(\n              key,\n              mergeStorageUpdates(updates.storageUpdates.get(key), value)\n            );\n          }\n          break;\n        }\n        // Receiving a RejectedOps message in the client means that the server is no\n        // longer in sync with the client. Trying to synchronize the client again by\n        // rolling back particular Ops may be hard/impossible. It's fine to not try and\n        // accept the out-of-sync reality and throw an error. We look at this kind of bug\n        // as a developer-owned bug. In production, these errors are not expected to happen.\n        case 299 /* REJECT_STORAGE_OP */: {\n          errorWithTitle(\n            \"Storage mutation rejection error\",\n            message.reason\n          );\n          if (true) {\n            const traces = /* @__PURE__ */ new Set();\n            for (const opId of message.opIds) {\n              const trace = context.opStackTraces?.get(opId);\n              if (trace) {\n                traces.add(trace);\n              }\n            }\n            if (traces.size > 0) {\n              warnWithTitle(\n                \"The following function calls caused the rejected storage mutations:\",\n                `\n\n${Array.from(traces).join(\"\\n\\n\")}`\n              );\n            }\n            throw new Error(\n              `Storage mutations rejected by server: ${message.reason}`\n            );\n          }\n          break;\n        }\n        case 400 /* THREAD_CREATED */:\n        case 407 /* THREAD_DELETED */:\n        case 401 /* THREAD_METADATA_UPDATED */:\n        case 408 /* THREAD_UPDATED */:\n        case 405 /* COMMENT_REACTION_ADDED */:\n        case 406 /* COMMENT_REACTION_REMOVED */:\n        case 402 /* COMMENT_CREATED */:\n        case 403 /* COMMENT_EDITED */:\n        case 404 /* COMMENT_DELETED */: {\n          eventHub.comments.notify(message);\n          break;\n        }\n      }\n    }\n    notify(updates);\n  }\n  function flushNowOrSoon() {\n    const storageOps = context.buffer.storageOperations;\n    if (storageOps.length > 0) {\n      for (const op of storageOps) {\n        context.unacknowledgedOps.set(nn(op.opId), op);\n      }\n      notifyStorageStatus();\n    }\n    if (managedSocket.getStatus() !== \"connected\") {\n      context.buffer.storageOperations = [];\n      return;\n    }\n    const now = Date.now();\n    const elapsedMillis = now - context.buffer.lastFlushedAt;\n    if (elapsedMillis >= config.throttleDelay) {\n      const messagesToFlush = serializeBuffer();\n      if (messagesToFlush.length === 0) {\n        return;\n      }\n      sendMessages(messagesToFlush);\n      context.buffer = {\n        flushTimerID: void 0,\n        lastFlushedAt: now,\n        messages: [],\n        storageOperations: [],\n        presenceUpdates: null\n      };\n    } else {\n      clearTimeout(context.buffer.flushTimerID);\n      context.buffer.flushTimerID = setTimeout(\n        flushNowOrSoon,\n        config.throttleDelay - elapsedMillis\n      );\n    }\n  }\n  function serializeBuffer() {\n    const messages = [];\n    if (context.buffer.presenceUpdates) {\n      messages.push(\n        context.buffer.presenceUpdates.type === \"full\" ? {\n          type: 100 /* UPDATE_PRESENCE */,\n          // Populating the `targetActor` field turns this message into\n          // a Full Presence update message (not a patch), which will get\n          // interpreted by other clients as such.\n          targetActor: -1,\n          data: context.buffer.presenceUpdates.data\n        } : {\n          type: 100 /* UPDATE_PRESENCE */,\n          data: context.buffer.presenceUpdates.data\n        }\n      );\n    }\n    for (const event of context.buffer.messages) {\n      messages.push(event);\n    }\n    if (context.buffer.storageOperations.length > 0) {\n      messages.push({\n        type: 201 /* UPDATE_STORAGE */,\n        ops: context.buffer.storageOperations\n      });\n    }\n    return messages;\n  }\n  function updateYDoc(update, guid, isV2) {\n    const clientMsg = {\n      type: 301 /* UPDATE_YDOC */,\n      update,\n      guid,\n      v2: isV2\n    };\n    context.buffer.messages.push(clientMsg);\n    eventHub.ydoc.notify(clientMsg);\n    flushNowOrSoon();\n  }\n  function broadcastEvent(event, options2 = {\n    shouldQueueEventIfNotReady: false\n  }) {\n    if (managedSocket.getStatus() !== \"connected\" && !options2.shouldQueueEventIfNotReady) {\n      return;\n    }\n    context.buffer.messages.push({\n      type: 103 /* BROADCAST_EVENT */,\n      event\n    });\n    flushNowOrSoon();\n  }\n  function dispatchOps(ops) {\n    const { storageOperations } = context.buffer;\n    for (const op of ops) {\n      storageOperations.push(op);\n    }\n    flushNowOrSoon();\n  }\n  let _getStorage$ = null;\n  let _resolveStoragePromise = null;\n  function processInitialStorage(message) {\n    const unacknowledgedOps = new Map(context.unacknowledgedOps);\n    createOrUpdateRootFromMessage(message);\n    applyAndSendOps(unacknowledgedOps);\n    _resolveStoragePromise?.();\n    notifyStorageStatus();\n    eventHub.storageDidLoad.notify();\n  }\n  async function streamStorage() {\n    if (!managedSocket.authValue) return;\n    const items = await httpClient.streamStorage({ roomId });\n    processInitialStorage({ type: 200 /* INITIAL_STORAGE_STATE */, items });\n  }\n  function refreshStorage(options2) {\n    const messages = context.buffer.messages;\n    if (config.unstable_streamData) {\n      void streamStorage();\n    } else if (!messages.some((msg) => msg.type === 200 /* FETCH_STORAGE */)) {\n      messages.push({ type: 200 /* FETCH_STORAGE */ });\n    }\n    if (options2.flush) {\n      flushNowOrSoon();\n    }\n  }\n  function startLoadingStorage() {\n    if (_getStorage$ === null) {\n      refreshStorage({ flush: true });\n      _getStorage$ = new Promise((resolve) => {\n        _resolveStoragePromise = resolve;\n      });\n      notifyStorageStatus();\n    }\n    return _getStorage$;\n  }\n  function getStorageSnapshot() {\n    const root = context.root;\n    if (root !== void 0) {\n      return root;\n    } else {\n      void startLoadingStorage();\n      return null;\n    }\n  }\n  async function getStorage() {\n    if (context.root !== void 0) {\n      return Promise.resolve({\n        root: context.root\n      });\n    }\n    await startLoadingStorage();\n    return {\n      root: nn(context.root)\n    };\n  }\n  function fetchYDoc(vector, guid, isV2) {\n    if (!context.buffer.messages.find((m) => {\n      return m.type === 300 /* FETCH_YDOC */ && m.vector === vector && m.guid === guid && m.v2 === isV2;\n    })) {\n      context.buffer.messages.push({\n        type: 300 /* FETCH_YDOC */,\n        vector,\n        guid,\n        v2: isV2\n      });\n    }\n    flushNowOrSoon();\n  }\n  function undo() {\n    if (context.activeBatch) {\n      throw new Error(\"undo is not allowed during a batch\");\n    }\n    const historyOps = context.undoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    notify(result.updates);\n    context.redoStack.push(result.reverse);\n    onHistoryChange();\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function redo() {\n    if (context.activeBatch) {\n      throw new Error(\"redo is not allowed during a batch\");\n    }\n    const historyOps = context.redoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    notify(result.updates);\n    context.undoStack.push(result.reverse);\n    onHistoryChange();\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function clear() {\n    context.undoStack.length = 0;\n    context.redoStack.length = 0;\n  }\n  function batch2(callback) {\n    if (context.activeBatch) {\n      return callback();\n    }\n    let returnValue = void 0;\n    context.activeBatch = {\n      ops: [],\n      updates: {\n        storageUpdates: /* @__PURE__ */ new Map(),\n        presence: false,\n        others: []\n      },\n      reverseOps: new Deque()\n    };\n    try {\n      returnValue = callback();\n    } finally {\n      const currentBatch = context.activeBatch;\n      context.activeBatch = null;\n      if (currentBatch.reverseOps.length > 0) {\n        addToUndoStack(Array.from(currentBatch.reverseOps));\n      }\n      if (currentBatch.ops.length > 0) {\n        context.redoStack.length = 0;\n      }\n      if (currentBatch.ops.length > 0) {\n        dispatchOps(currentBatch.ops);\n      }\n      notify(currentBatch.updates);\n      flushNowOrSoon();\n    }\n    return returnValue;\n  }\n  function pauseHistory() {\n    if (context.pausedHistory === null) {\n      context.pausedHistory = new Deque();\n    }\n  }\n  function resumeHistory() {\n    const historyOps = context.pausedHistory;\n    context.pausedHistory = null;\n    if (historyOps !== null && historyOps.length > 0) {\n      _addToRealUndoStack(Array.from(historyOps));\n    }\n  }\n  const syncSourceForStorage = config.createSyncSource();\n  function getStorageStatus() {\n    if (context.root === void 0) {\n      return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n    } else {\n      return context.unacknowledgedOps.size === 0 ? \"synchronized\" : \"synchronizing\";\n    }\n  }\n  let _lastStorageStatus = getStorageStatus();\n  function notifyStorageStatus() {\n    const storageStatus = getStorageStatus();\n    if (_lastStorageStatus !== storageStatus) {\n      _lastStorageStatus = storageStatus;\n      eventHub.storageStatus.notify(storageStatus);\n    }\n    syncSourceForStorage.setSyncStatus(\n      storageStatus === \"synchronizing\" ? \"synchronizing\" : \"synchronized\"\n    );\n  }\n  function isPresenceReady() {\n    return self.get() !== null;\n  }\n  async function waitUntilPresenceReady() {\n    while (!isPresenceReady()) {\n      const { promise, resolve } = Promise_withResolvers();\n      const unsub1 = events.self.subscribeOnce(resolve);\n      const unsub2 = events.status.subscribeOnce(resolve);\n      await promise;\n      unsub1();\n      unsub2();\n    }\n  }\n  function isStorageReady() {\n    return getStorageSnapshot() !== null;\n  }\n  async function waitUntilStorageReady() {\n    while (!isStorageReady()) {\n      await getStorage();\n    }\n  }\n  const others_forDevTools = DerivedSignal.from(\n    context.others.signal,\n    (others) => others.map((other, index) => userToTreeNode(`Other ${index}`, other))\n  );\n  const events = {\n    status: eventHub.status.observable,\n    lostConnection: eventHub.lostConnection.observable,\n    customEvent: eventHub.customEvent.observable,\n    others: eventHub.others.observable,\n    self: eventHub.self.observable,\n    myPresence: eventHub.myPresence.observable,\n    /** @deprecated */\n    storage: eventHub.storageBatch.observable,\n    storageBatch: eventHub.storageBatch.observable,\n    history: eventHub.history.observable,\n    storageDidLoad: eventHub.storageDidLoad.observable,\n    storageStatus: eventHub.storageStatus.observable,\n    ydoc: eventHub.ydoc.observable,\n    comments: eventHub.comments.observable,\n    roomWillDestroy: eventHub.roomWillDestroy.observable\n  };\n  async function getThreadsSince(options2) {\n    return httpClient.getThreadsSince({\n      roomId,\n      since: options2.since,\n      signal: options2.signal\n    });\n  }\n  async function getThreads(options2) {\n    return httpClient.getThreads({\n      roomId,\n      query: options2?.query,\n      cursor: options2?.cursor\n    });\n  }\n  async function getThread(threadId) {\n    return httpClient.getThread({ roomId, threadId });\n  }\n  async function createThread(options2) {\n    return httpClient.createThread({\n      roomId,\n      threadId: options2.threadId,\n      commentId: options2.commentId,\n      metadata: options2.metadata,\n      body: options2.body,\n      attachmentIds: options2.attachmentIds\n    });\n  }\n  async function deleteThread(threadId) {\n    return httpClient.deleteThread({ roomId, threadId });\n  }\n  async function editThreadMetadata({\n    metadata,\n    threadId\n  }) {\n    return httpClient.editThreadMetadata({ roomId, threadId, metadata });\n  }\n  async function markThreadAsResolved(threadId) {\n    return httpClient.markThreadAsResolved({ roomId, threadId });\n  }\n  async function markThreadAsUnresolved(threadId) {\n    return httpClient.markThreadAsUnresolved({\n      roomId,\n      threadId\n    });\n  }\n  async function createComment(options2) {\n    return httpClient.createComment({\n      roomId,\n      threadId: options2.threadId,\n      commentId: options2.commentId,\n      body: options2.body,\n      attachmentIds: options2.attachmentIds\n    });\n  }\n  async function editComment(options2) {\n    return httpClient.editComment({\n      roomId,\n      threadId: options2.threadId,\n      commentId: options2.commentId,\n      body: options2.body,\n      attachmentIds: options2.attachmentIds\n    });\n  }\n  async function deleteComment({\n    threadId,\n    commentId\n  }) {\n    return httpClient.deleteComment({ roomId, threadId, commentId });\n  }\n  async function addReaction({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    return httpClient.addReaction({ roomId, threadId, commentId, emoji });\n  }\n  async function removeReaction({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    return await httpClient.removeReaction({\n      roomId,\n      threadId,\n      commentId,\n      emoji\n    });\n  }\n  function prepareAttachment(file) {\n    return {\n      type: \"localAttachment\",\n      status: \"idle\",\n      id: createCommentAttachmentId(),\n      name: file.name,\n      size: file.size,\n      mimeType: file.type,\n      file\n    };\n  }\n  async function uploadAttachment(attachment, options2 = {}) {\n    return httpClient.uploadAttachment({\n      roomId,\n      attachment,\n      signal: options2.signal\n    });\n  }\n  function getAttachmentUrl(attachmentId) {\n    return httpClient.getAttachmentUrl({ roomId, attachmentId });\n  }\n  function getNotificationSettings(options2) {\n    return httpClient.getNotificationSettings({\n      roomId,\n      signal: options2?.signal\n    });\n  }\n  function updateNotificationSettings(settings) {\n    return httpClient.updateNotificationSettings({ roomId, settings });\n  }\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await httpClient.markRoomInboxNotificationAsRead({\n      roomId,\n      inboxNotificationId\n    });\n  }\n  const syncSourceForYjs = config.createSyncSource();\n  function yjsStatusDidChange(status) {\n    return syncSourceForYjs.setSyncStatus(\n      status === \"synchronizing\" ? \"synchronizing\" : \"synchronized\"\n    );\n  }\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        get presenceBuffer() {\n          return deepClone(context.buffer.presenceUpdates?.data ?? null);\n        },\n        // prettier-ignore\n        get undoStack() {\n          return deepClone(context.undoStack);\n        },\n        // prettier-ignore\n        get nodeCount() {\n          return context.pool.nodes.size;\n        },\n        // prettier-ignore\n        getYjsProvider() {\n          return context.yjsProvider;\n        },\n        setYjsProvider(newProvider) {\n          context.yjsProvider?.off(\"status\", yjsStatusDidChange);\n          context.yjsProvider = newProvider;\n          newProvider?.on(\"status\", yjsStatusDidChange);\n          context.yjsProviderDidChange.notify();\n        },\n        yjsProviderDidChange: context.yjsProviderDidChange.observable,\n        // send metadata when using a text editor\n        reportTextEditor,\n        // create a text mention when using a text editor\n        createTextMention,\n        // delete a text mention when using a text editor\n        deleteTextMention,\n        // list versions of the document\n        listTextVersions,\n        // List versions of the document since the specified date\n        listTextVersionsSince,\n        // get a specific version\n        getTextVersion,\n        // create a version\n        createTextVersion,\n        // execute a contextual prompt\n        executeContextualPrompt,\n        // Support for the Liveblocks browser extension\n        getSelf_forDevTools: () => selfAsTreeNode.get(),\n        getOthers_forDevTools: () => others_forDevTools.get(),\n        // prettier-ignore\n        simulate: {\n          // These exist only for our E2E testing app\n          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: \"EXPLICIT_SOCKET_CLOSE\", event }),\n          rawSend: (data) => managedSocket.send(data)\n        },\n        attachmentUrlsStore: httpClient.getOrCreateAttachmentUrlsStore(roomId)\n      },\n      id: roomId,\n      subscribe: makeClassicSubscribeFn(\n        roomId,\n        events,\n        config.errorEventSource\n      ),\n      connect: () => managedSocket.connect(),\n      reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      destroy: () => {\n        const { roomWillDestroy, ...eventsExceptDestroy } = eventHub;\n        for (const source of Object.values(eventsExceptDestroy)) {\n          source[Symbol.dispose]();\n        }\n        eventHub.roomWillDestroy.notify();\n        context.yjsProvider?.off(\"status\", yjsStatusDidChange);\n        syncSourceForStorage.destroy();\n        syncSourceForYjs.destroy();\n        uninstallBgTabSpy();\n        managedSocket.destroy();\n        roomWillDestroy[Symbol.dispose]();\n      },\n      // Presence\n      updatePresence,\n      updateYDoc,\n      broadcastEvent,\n      // Storage\n      batch: batch2,\n      history: {\n        undo,\n        redo,\n        canUndo,\n        canRedo,\n        clear,\n        pause: pauseHistory,\n        resume: resumeHistory\n      },\n      fetchYDoc,\n      getStorage,\n      getStorageSnapshot,\n      getStorageStatus,\n      isPresenceReady,\n      isStorageReady,\n      waitUntilPresenceReady: memoizeOnSuccess(waitUntilPresenceReady),\n      waitUntilStorageReady: memoizeOnSuccess(waitUntilStorageReady),\n      events,\n      // Core\n      getStatus: () => managedSocket.getStatus(),\n      getSelf: () => self.get(),\n      // Presence\n      getPresence: () => context.myPresence.get(),\n      getOthers: () => context.others.get(),\n      // Comments\n      getThreads,\n      getThreadsSince,\n      getThread,\n      createThread,\n      deleteThread,\n      editThreadMetadata,\n      markThreadAsResolved,\n      markThreadAsUnresolved,\n      createComment,\n      editComment,\n      deleteComment,\n      addReaction,\n      removeReaction,\n      prepareAttachment,\n      uploadAttachment,\n      getAttachmentUrl,\n      // Notifications\n      getNotificationSettings,\n      updateNotificationSettings,\n      markInboxNotificationAsRead\n    },\n    // Explictly make the internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    kInternal,\n    { enumerable: false }\n  );\n}\nfunction makeClassicSubscribeFn(roomId, events, errorEvents) {\n  function subscribeToLiveStructureDeeply(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      const relatedUpdates = updates.filter(\n        (update) => isSameNodeOrChildOf(update.node, node)\n      );\n      if (relatedUpdates.length > 0) {\n        callback(relatedUpdates);\n      }\n    });\n  }\n  function subscribeToLiveStructureShallowly(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      for (const update of updates) {\n        if (update.node._id === node._id) {\n          callback(update.node);\n        }\n      }\n    });\n  }\n  function subscribe(first, second, options) {\n    if (typeof first === \"string\" && isRoomEventName(first)) {\n      if (typeof second !== \"function\") {\n        throw new Error(\"Second argument must be a callback function\");\n      }\n      const callback = second;\n      switch (first) {\n        case \"event\":\n          return events.customEvent.subscribe(\n            callback\n          );\n        case \"my-presence\":\n          return events.myPresence.subscribe(callback);\n        case \"others\": {\n          const cb = callback;\n          return events.others.subscribe((event) => {\n            const { others, ...internalEvent } = event;\n            return cb(others, internalEvent);\n          });\n        }\n        case \"error\": {\n          return errorEvents.subscribe((err) => {\n            if (err.roomId === roomId) {\n              return callback(err);\n            }\n          });\n        }\n        case \"status\":\n          return events.status.subscribe(callback);\n        case \"lost-connection\":\n          return events.lostConnection.subscribe(\n            callback\n          );\n        case \"history\":\n          return events.history.subscribe(callback);\n        case \"storage-status\":\n          return events.storageStatus.subscribe(\n            callback\n          );\n        case \"comments\":\n          return events.comments.subscribe(\n            callback\n          );\n        // istanbul ignore next\n        default:\n          return assertNever(\n            first,\n            `\"${String(first)}\" is not a valid event name`\n          );\n      }\n    }\n    if (second === void 0 || typeof first === \"function\") {\n      if (typeof first === \"function\") {\n        const storageCallback = first;\n        return events.storageBatch.subscribe(storageCallback);\n      } else {\n        throw new Error(\"Please specify a listener callback\");\n      }\n    }\n    if (isLiveNode(first)) {\n      const node = first;\n      if (options?.isDeep) {\n        const storageCallback = second;\n        return subscribeToLiveStructureDeeply(node, storageCallback);\n      } else {\n        const nodeCallback = second;\n        return subscribeToLiveStructureShallowly(node, nodeCallback);\n      }\n    }\n    throw new Error(\n      `${String(first)} is not a value that can be subscribed to.`\n    );\n  }\n  return subscribe;\n}\nfunction isRoomEventName(value) {\n  return value === \"my-presence\" || value === \"others\" || value === \"event\" || value === \"error\" || value === \"history\" || value === \"status\" || value === \"storage-status\" || value === \"lost-connection\" || value === \"connection\" || value === \"comments\";\n}\nfunction makeAuthDelegateForRoom(roomId, authManager) {\n  return async () => {\n    return authManager.getAuthValue({ requestedScope: \"room:read\", roomId });\n  };\n}\nfunction makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {\n  return (authValue) => {\n    const ws = WebSocketPolyfill ?? (typeof WebSocket === \"undefined\" ? void 0 : WebSocket);\n    if (ws === void 0) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n    const url2 = new URL(baseUrl);\n    url2.protocol = url2.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url2.pathname = \"/v7\";\n    url2.searchParams.set(\"roomId\", roomId);\n    if (authValue.type === \"secret\") {\n      url2.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      url2.searchParams.set(\"pubkey\", authValue.publicApiKey);\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url2.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url2.toString());\n  };\n}\n\n// src/client.ts\nvar MIN_THROTTLE = 16;\nvar MAX_THROTTLE = 1e3;\nvar DEFAULT_THROTTLE = 100;\nvar MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;\nvar MIN_LOST_CONNECTION_TIMEOUT = 200;\nvar RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;\nvar MAX_LOST_CONNECTION_TIMEOUT = 3e4;\nvar DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;\nvar RESOLVE_USERS_BATCH_DELAY = 50;\nvar RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;\nfunction getBaseUrl(baseUrl) {\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nfunction createClient(options) {\n  const clientOptions = options;\n  const throttleDelay = getThrottle(clientOptions.throttle ?? DEFAULT_THROTTLE);\n  const lostConnectionTimeout = getLostConnectionTimeout(\n    clientOptions.lostConnectionTimeout ?? DEFAULT_LOST_CONNECTION_TIMEOUT\n  );\n  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(\n    clientOptions.backgroundKeepAliveTimeout\n  );\n  const baseUrl = getBaseUrl(clientOptions.baseUrl);\n  const currentUserId = new Signal(void 0);\n  const authManager = createAuthManager(options, (token) => {\n    const userId = token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.id : token.uid;\n    currentUserId.set(() => userId);\n  });\n  const fetchPolyfill = clientOptions.polyfills?.fetch || /* istanbul ignore next */\n  globalThis.fetch?.bind(globalThis);\n  const httpClient = createApiClient({\n    baseUrl,\n    fetchPolyfill,\n    authManager\n  });\n  const roomsById = /* @__PURE__ */ new Map();\n  function teardownRoom(room) {\n    unlinkDevTools(room.id);\n    roomsById.delete(room.id);\n    room.destroy();\n  }\n  function leaseRoom(details) {\n    const leave = () => {\n      const self = leave;\n      if (!details.unsubs.delete(self)) {\n        warn(\n          \"This leave function was already called. Calling it more than once has no effect.\"\n        );\n      } else {\n        if (details.unsubs.size === 0) {\n          teardownRoom(details.room);\n        }\n      }\n    };\n    details.unsubs.add(leave);\n    return {\n      room: details.room,\n      leave\n    };\n  }\n  function enterRoom(roomId, ...args) {\n    const existing = roomsById.get(roomId);\n    if (existing !== void 0) {\n      return leaseRoom(existing);\n    }\n    const options2 = args[0] ?? {};\n    const initialPresence = (typeof options2.initialPresence === \"function\" ? options2.initialPresence(roomId) : options2.initialPresence) ?? {};\n    const initialStorage = (typeof options2.initialStorage === \"function\" ? options2.initialStorage(roomId) : options2.initialStorage) ?? {};\n    const newRoom = createRoom(\n      { initialPresence, initialStorage },\n      {\n        roomId,\n        throttleDelay,\n        lostConnectionTimeout,\n        backgroundKeepAliveTimeout,\n        polyfills: clientOptions.polyfills,\n        delegates: clientOptions.mockedDelegates ?? {\n          createSocket: makeCreateSocketDelegateForRoom(\n            roomId,\n            baseUrl,\n            clientOptions.polyfills?.WebSocket\n          ),\n          authenticate: makeAuthDelegateForRoom(roomId, authManager)\n        },\n        enableDebugLogging: clientOptions.enableDebugLogging,\n        baseUrl,\n        errorEventSource: liveblocksErrorSource,\n        largeMessageStrategy: clientOptions.largeMessageStrategy ?? (clientOptions.unstable_fallbackToHTTP ? \"experimental-fallback-to-http\" : void 0),\n        unstable_streamData: !!clientOptions.unstable_streamData,\n        roomHttpClient: httpClient,\n        createSyncSource\n      }\n    );\n    const newRoomDetails = {\n      room: newRoom,\n      unsubs: /* @__PURE__ */ new Set()\n    };\n    roomsById.set(roomId, newRoomDetails);\n    setupDevTools(() => Array.from(roomsById.keys()));\n    linkDevTools(roomId, newRoom);\n    const shouldConnect = options2.autoConnect ?? true;\n    if (shouldConnect) {\n      if (typeof atob === \"undefined\") {\n        if (clientOptions.polyfills?.atob === void 0) {\n          throw new Error(\n            \"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\"\n          );\n        }\n        global.atob = clientOptions.polyfills.atob;\n      }\n      newRoom.connect();\n    }\n    return leaseRoom(newRoomDetails);\n  }\n  function getRoom(roomId) {\n    const room = roomsById.get(roomId)?.room;\n    return room ? room : null;\n  }\n  function logout() {\n    authManager.reset();\n    currentUserId.set(() => void 0);\n    for (const { room } of roomsById.values()) {\n      if (!isIdle(room.getStatus())) {\n        room.reconnect();\n      }\n    }\n  }\n  const resolveUsers = clientOptions.resolveUsers;\n  const warnIfNoResolveUsers = createDevelopmentWarning(\n    () => !resolveUsers,\n    \"Set the resolveUsers option in createClient to specify user info.\"\n  );\n  const batchedResolveUsers = new Batch(\n    async (batchedUserIds) => {\n      const userIds = batchedUserIds.flat();\n      const users = await resolveUsers?.({ userIds });\n      warnIfNoResolveUsers();\n      return users ?? userIds.map(() => void 0);\n    },\n    { delay: RESOLVE_USERS_BATCH_DELAY }\n  );\n  const usersStore = createBatchStore(batchedResolveUsers);\n  function invalidateResolvedUsers(userIds) {\n    usersStore.invalidate(userIds);\n  }\n  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;\n  const warnIfNoResolveRoomsInfo = createDevelopmentWarning(\n    () => !resolveRoomsInfo,\n    \"Set the resolveRoomsInfo option in createClient to specify room info.\"\n  );\n  const batchedResolveRoomsInfo = new Batch(\n    async (batchedRoomIds) => {\n      const roomIds = batchedRoomIds.flat();\n      const roomsInfo = await resolveRoomsInfo?.({ roomIds });\n      warnIfNoResolveRoomsInfo();\n      return roomsInfo ?? roomIds.map(() => void 0);\n    },\n    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }\n  );\n  const roomsInfoStore = createBatchStore(batchedResolveRoomsInfo);\n  function invalidateResolvedRoomsInfo(roomIds) {\n    roomsInfoStore.invalidate(roomIds);\n  }\n  const mentionSuggestionsCache = /* @__PURE__ */ new Map();\n  function invalidateResolvedMentionSuggestions() {\n    mentionSuggestionsCache.clear();\n  }\n  const syncStatusSources = [];\n  const syncStatusSignal = new Signal(\"synchronized\");\n  const liveblocksErrorSource = makeEventSource();\n  function getSyncStatus() {\n    const status = syncStatusSignal.get();\n    return status === \"synchronizing\" ? status : \"synchronized\";\n  }\n  function recompute() {\n    syncStatusSignal.set(\n      syncStatusSources.some((src) => src.get() === \"synchronizing\") ? \"synchronizing\" : syncStatusSources.some((src) => src.get() === \"has-local-changes\") ? \"has-local-changes\" : \"synchronized\"\n    );\n  }\n  function createSyncSource() {\n    const source = new Signal(\"synchronized\");\n    syncStatusSources.push(source);\n    const unsub = source.subscribe(() => recompute());\n    function setSyncStatus(status) {\n      source.set(status);\n    }\n    function destroy() {\n      unsub();\n      const index = syncStatusSources.findIndex((item) => item === source);\n      if (index > -1) {\n        const [ref] = syncStatusSources.splice(index, 1);\n        const wasStillPending = ref.get() !== \"synchronized\";\n        if (wasStillPending) {\n          recompute();\n        }\n      }\n    }\n    return { setSyncStatus, destroy };\n  }\n  {\n    const maybePreventClose = (e) => {\n      if (clientOptions.preventUnsavedChanges && syncStatusSignal.get() !== \"synchronized\") {\n        e.preventDefault();\n      }\n    };\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    win?.addEventListener(\"beforeunload\", maybePreventClose);\n  }\n  async function getNotificationSettings(options2) {\n    const plainSettings = await httpClient.getUserNotificationSettings(options2);\n    const settings = createUserNotificationSettings(plainSettings);\n    return settings;\n  }\n  async function updateNotificationSettings(settings) {\n    const plainSettings = await httpClient.updateUserNotificationSettings(settings);\n    const settingsObject = createUserNotificationSettings(plainSettings);\n    return settingsObject;\n  }\n  const client = Object.defineProperty(\n    {\n      enterRoom,\n      getRoom,\n      logout,\n      // Public inbox notifications API\n      getInboxNotifications: httpClient.getInboxNotifications,\n      getInboxNotificationsSince: httpClient.getInboxNotificationsSince,\n      getUnreadInboxNotificationsCount: httpClient.getUnreadInboxNotificationsCount,\n      markAllInboxNotificationsAsRead: httpClient.markAllInboxNotificationsAsRead,\n      markInboxNotificationAsRead: httpClient.markInboxNotificationAsRead,\n      deleteAllInboxNotifications: httpClient.deleteAllInboxNotifications,\n      deleteInboxNotification: httpClient.deleteInboxNotification,\n      // Public user notification settings API\n      getNotificationSettings,\n      updateNotificationSettings,\n      // Advanced resolvers APIs\n      resolvers: {\n        invalidateUsers: invalidateResolvedUsers,\n        invalidateRoomsInfo: invalidateResolvedRoomsInfo,\n        invalidateMentionSuggestions: invalidateResolvedMentionSuggestions\n      },\n      getSyncStatus,\n      events: {\n        error: liveblocksErrorSource,\n        syncStatus: syncStatusSignal\n      },\n      // Internal\n      [kInternal]: {\n        currentUserId,\n        mentionSuggestionsCache,\n        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,\n        usersStore,\n        roomsInfoStore,\n        getRoomIds() {\n          return Array.from(roomsById.keys());\n        },\n        httpClient,\n        // Type-level helper only, it's effectively only an identity-function at runtime\n        as: () => client,\n        createSyncSource,\n        emitError: (context, cause) => {\n          const error3 = LiveblocksError.from(context, cause);\n          const didNotify = liveblocksErrorSource.notify(error3);\n          if (!didNotify) {\n            error2(error3.message);\n          }\n        }\n      }\n    },\n    kInternal,\n    {\n      enumerable: false\n    }\n  );\n  return client;\n}\nfunction checkBounds(option, value, min, max, recommendedMin) {\n  if (typeof value !== \"number\" || value < min || max !== void 0 && value > max) {\n    throw new Error(\n      max !== void 0 ? `${option} should be between ${recommendedMin ?? min} and ${max}.` : `${option} should be at least ${recommendedMin ?? min}.`\n    );\n  }\n  return value;\n}\nfunction getBackgroundKeepAliveTimeout(value) {\n  if (value === void 0) return void 0;\n  return checkBounds(\n    \"backgroundKeepAliveTimeout\",\n    value,\n    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\n  );\n}\nfunction getThrottle(value) {\n  return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\nfunction getLostConnectionTimeout(value) {\n  return checkBounds(\n    \"lostConnectionTimeout\",\n    value,\n    MIN_LOST_CONNECTION_TIMEOUT,\n    MAX_LOST_CONNECTION_TIMEOUT,\n    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\n  );\n}\nfunction createDevelopmentWarning(condition, ...args) {\n  let hasWarned = false;\n  if (true) {\n    return () => {\n      if (!hasWarned && (typeof condition === \"function\" ? condition() : condition)) {\n        warn(...args);\n        hasWarned = true;\n      }\n    };\n  } else {}\n}\n\n// src/comments/comment-body.ts\nfunction isCommentBodyParagraph(element) {\n  return \"type\" in element && element.type === \"paragraph\";\n}\nfunction isCommentBodyText(element) {\n  return !(\"type\" in element) && \"text\" in element && typeof element.text === \"string\";\n}\nfunction isCommentBodyMention(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyLink(element) {\n  return \"type\" in element && element.type === \"link\";\n}\nvar commentBodyElementsGuards = {\n  paragraph: isCommentBodyParagraph,\n  text: isCommentBodyText,\n  link: isCommentBodyLink,\n  mention: isCommentBodyMention\n};\nvar commentBodyElementsTypes = {\n  paragraph: \"block\",\n  text: \"inline\",\n  link: \"inline\",\n  mention: \"inline\"\n};\nfunction traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {\n  if (!body || !body?.content) {\n    return;\n  }\n  const element = typeof elementOrVisitor === \"string\" ? elementOrVisitor : void 0;\n  const type = element ? commentBodyElementsTypes[element] : \"all\";\n  const guard = element ? commentBodyElementsGuards[element] : () => true;\n  const visitor = typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n  for (const block of body.content) {\n    if (type === \"all\" || type === \"block\") {\n      if (guard(block)) {\n        visitor?.(block);\n      }\n    }\n    if (type === \"all\" || type === \"inline\") {\n      for (const inline of block.children) {\n        if (guard(inline)) {\n          visitor?.(inline);\n        }\n      }\n    }\n  }\n}\nfunction getMentionedIdsFromCommentBody(body) {\n  const mentionedIds = /* @__PURE__ */ new Set();\n  traverseCommentBody(\n    body,\n    \"mention\",\n    (mention) => mentionedIds.add(mention.id)\n  );\n  return Array.from(mentionedIds);\n}\nasync function resolveUsersInCommentBody(body, resolveUsers) {\n  const resolvedUsers = /* @__PURE__ */ new Map();\n  if (!resolveUsers) {\n    return resolvedUsers;\n  }\n  const userIds = getMentionedIdsFromCommentBody(body);\n  const users = await resolveUsers({\n    userIds\n  });\n  for (const [index, userId] of userIds.entries()) {\n    const user = users?.[index];\n    if (user) {\n      resolvedUsers.set(userId, user);\n    }\n  }\n  return resolvedUsers;\n}\nvar htmlEscapables = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\"\n};\nvar htmlEscapablesRegex = new RegExp(\n  Object.keys(htmlEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction htmlSafe(value) {\n  return new HtmlSafeString([String(value)], []);\n}\nfunction joinHtml(strings) {\n  if (strings.length <= 0) {\n    return new HtmlSafeString([\"\"], []);\n  }\n  return new HtmlSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeHtml(value) {\n  if (value instanceof HtmlSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinHtml(value).toString();\n  }\n  return String(value).replace(\n    htmlEscapablesRegex,\n    (character) => htmlEscapables[character]\n  );\n}\nvar HtmlSafeString = class {\n  #strings;\n  #values;\n  constructor(strings, values2) {\n    this.#strings = strings;\n    this.#values = values2;\n  }\n  toString() {\n    return this.#strings.reduce((result, str, i) => {\n      return result + escapeHtml(nn(this.#values[i - 1])) + str;\n    });\n  }\n};\nfunction html(strings, ...values2) {\n  return new HtmlSafeString(strings, values2);\n}\nvar markdownEscapables = {\n  _: \"\\\\_\",\n  \"*\": \"\\\\*\",\n  \"#\": \"\\\\#\",\n  \"`\": \"\\\\`\",\n  \"~\": \"\\\\~\",\n  \"!\": \"\\\\!\",\n  \"|\": \"\\\\|\",\n  \"(\": \"\\\\(\",\n  \")\": \"\\\\)\",\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"[\": \"\\\\[\",\n  \"]\": \"\\\\]\"\n};\nvar markdownEscapablesRegex = new RegExp(\n  Object.keys(markdownEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction joinMarkdown(strings) {\n  if (strings.length <= 0) {\n    return new MarkdownSafeString([\"\"], []);\n  }\n  return new MarkdownSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeMarkdown(value) {\n  if (value instanceof MarkdownSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinMarkdown(value).toString();\n  }\n  return String(value).replace(\n    markdownEscapablesRegex,\n    (character) => markdownEscapables[character]\n  );\n}\nvar MarkdownSafeString = class {\n  #strings;\n  #values;\n  constructor(strings, values2) {\n    this.#strings = strings;\n    this.#values = values2;\n  }\n  toString() {\n    return this.#strings.reduce((result, str, i) => {\n      return result + escapeMarkdown(nn(this.#values[i - 1])) + str;\n    });\n  }\n};\nfunction markdown(strings, ...values2) {\n  return new MarkdownSafeString(strings, values2);\n}\nfunction toAbsoluteUrl(url2) {\n  if (url2.startsWith(\"http://\") || url2.startsWith(\"https://\")) {\n    return url2;\n  } else if (url2.startsWith(\"www.\")) {\n    return \"https://\" + url2;\n  }\n  return;\n}\nvar stringifyCommentBodyPlainElements = {\n  paragraph: ({ children }) => children,\n  text: ({ element }) => element.text,\n  link: ({ element }) => element.text ?? element.url,\n  mention: ({ element, user }) => {\n    return `@${user?.name ?? element.id}`;\n  }\n};\nvar stringifyCommentBodyHtmlElements = {\n  paragraph: ({ children }) => {\n    return children ? html`<p>${htmlSafe(children)}</p>` : children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return html`${children}`;\n    }\n    if (element.bold) {\n      children = html`<strong>${children}</strong>`;\n    }\n    if (element.italic) {\n      children = html`<em>${children}</em>`;\n    }\n    if (element.strikethrough) {\n      children = html`<s>${children}</s>`;\n    }\n    if (element.code) {\n      children = html`<code>${children}</code>`;\n    }\n    return html`${children}`;\n  },\n  link: ({ element, href }) => {\n    return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${element.text ? html`${element.text}` : element.url}</a>`;\n  },\n  mention: ({ element, user }) => {\n    return html`<span data-mention>@${user?.name ? html`${user?.name}` : element.id}</span>`;\n  }\n};\nvar stringifyCommentBodyMarkdownElements = {\n  paragraph: ({ children }) => {\n    return children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = markdown`**${children}**`;\n    }\n    if (element.italic) {\n      children = markdown`_${children}_`;\n    }\n    if (element.strikethrough) {\n      children = markdown`~~${children}~~`;\n    }\n    if (element.code) {\n      children = markdown`\\`${children}\\``;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return markdown`[${element.text ?? element.url}](${href})`;\n  },\n  mention: ({ element, user }) => {\n    return markdown`@${user?.name ?? element.id}`;\n  }\n};\nasync function stringifyCommentBody(body, options) {\n  const format = options?.format ?? \"plain\";\n  const separator = options?.separator ?? (format === \"markdown\" ? \"\\n\\n\" : \"\\n\");\n  const elements = {\n    ...format === \"html\" ? stringifyCommentBodyHtmlElements : format === \"markdown\" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,\n    ...options?.elements\n  };\n  const resolvedUsers = await resolveUsersInCommentBody(\n    body,\n    options?.resolveUsers\n  );\n  const blocks = body.content.flatMap((block, blockIndex) => {\n    switch (block.type) {\n      case \"paragraph\": {\n        const inlines = block.children.flatMap((inline, inlineIndex) => {\n          if (isCommentBodyMention(inline)) {\n            return inline.id ? [\n              elements.mention(\n                {\n                  element: inline,\n                  user: resolvedUsers.get(inline.id)\n                },\n                inlineIndex\n              )\n            ] : [];\n          }\n          if (isCommentBodyLink(inline)) {\n            return [\n              elements.link(\n                {\n                  element: inline,\n                  href: toAbsoluteUrl(inline.url) ?? inline.url\n                },\n                inlineIndex\n              )\n            ];\n          }\n          if (isCommentBodyText(inline)) {\n            return [elements.text({ element: inline }, inlineIndex)];\n          }\n          return [];\n        });\n        return [\n          elements.paragraph(\n            { element: block, children: inlines.join(\"\") },\n            blockIndex\n          )\n        ];\n      }\n      default:\n        return [];\n    }\n  });\n  return blocks.join(separator);\n}\n\n// src/comments/comment-url.ts\nvar PLACEHOLDER_BASE_URL = \"https://localhost:9999\";\nvar ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nfunction generateCommentUrl({\n  roomUrl,\n  commentId\n}) {\n  const isAbsolute = ABSOLUTE_URL_REGEX.test(roomUrl);\n  const urlObject = new URL(\n    roomUrl,\n    isAbsolute ? void 0 : PLACEHOLDER_BASE_URL\n  );\n  urlObject.hash = `#${commentId}`;\n  return isAbsolute ? urlObject.href : urlObject.href.replace(PLACEHOLDER_BASE_URL, \"\");\n}\n\n// src/crdts/utils.ts\nfunction toPlainLson(lson) {\n  if (lson instanceof LiveObject) {\n    return {\n      liveblocksType: \"LiveObject\",\n      data: Object.fromEntries(\n        Object.entries(lson.toObject()).flatMap(\n          ([key, value]) => value !== void 0 ? [[key, toPlainLson(value)]] : []\n        )\n      )\n    };\n  } else if (lson instanceof LiveMap) {\n    return {\n      liveblocksType: \"LiveMap\",\n      data: Object.fromEntries(\n        [...lson].map(([key, value]) => [key, toPlainLson(value)])\n      )\n    };\n  } else if (lson instanceof LiveList) {\n    return {\n      liveblocksType: \"LiveList\",\n      data: [...lson].map((item) => toPlainLson(item))\n    };\n  } else {\n    return lson;\n  }\n}\n\n// src/immutable.ts\nfunction lsonObjectToJson(obj) {\n  const result = {};\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== void 0) {\n      result[key] = lsonToJson(val);\n    }\n  }\n  return result;\n}\nfunction liveObjectToJson(liveObject) {\n  return lsonObjectToJson(liveObject.toObject());\n}\nfunction liveMapToJson(map) {\n  const result = {};\n  for (const [key, value] of map.entries()) {\n    result[key] = lsonToJson(value);\n  }\n  return result;\n}\nfunction lsonListToJson(value) {\n  return value.map(lsonToJson);\n}\nfunction liveListToJson(value) {\n  return lsonListToJson(value.toArray());\n}\nfunction lsonToJson(value) {\n  if (value instanceof LiveObject) {\n    return liveObjectToJson(value);\n  } else if (value instanceof LiveList) {\n    return liveListToJson(value);\n  } else if (value instanceof LiveMap) {\n    return liveMapToJson(value);\n  } else if (value instanceof LiveRegister) {\n    return value.data;\n  }\n  if (Array.isArray(value)) {\n    return lsonListToJson(value);\n  } else if (isPlainObject(value)) {\n    return lsonObjectToJson(value);\n  }\n  return value;\n}\nfunction deepLiveify(value) {\n  if (Array.isArray(value)) {\n    return new LiveList(value.map(deepLiveify));\n  } else if (isPlainObject(value)) {\n    const init = {};\n    for (const key in value) {\n      const val = value[key];\n      if (val === void 0) {\n        continue;\n      }\n      init[key] = deepLiveify(val);\n    }\n    return new LiveObject(init);\n  } else {\n    return value;\n  }\n}\nfunction patchLiveList(liveList, prev, next) {\n  let i = 0;\n  let prevEnd = prev.length - 1;\n  let nextEnd = next.length - 1;\n  let prevNode = prev[0];\n  let nextNode = next[0];\n  outer: {\n    while (prevNode === nextNode) {\n      ++i;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[i];\n      nextNode = next[i];\n    }\n    prevNode = prev[prevEnd];\n    nextNode = next[nextEnd];\n    while (prevNode === nextNode) {\n      prevEnd--;\n      nextEnd--;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[prevEnd];\n      nextNode = next[nextEnd];\n    }\n  }\n  if (i > prevEnd) {\n    if (i <= nextEnd) {\n      while (i <= nextEnd) {\n        liveList.insert(deepLiveify(next[i]), i);\n        i++;\n      }\n    }\n  } else if (i > nextEnd) {\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  } else {\n    while (i <= prevEnd && i <= nextEnd) {\n      prevNode = prev[i];\n      nextNode = next[i];\n      const liveListNode = liveList.get(i);\n      if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {\n        patchLiveObject(liveListNode, prevNode, nextNode);\n      } else {\n        liveList.set(i, deepLiveify(nextNode));\n      }\n      i++;\n    }\n    while (i <= nextEnd) {\n      liveList.insert(deepLiveify(next[i]), i);\n      i++;\n    }\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  }\n}\nfunction patchLiveObjectKey(liveObject, key, prev, next) {\n  if (true) {\n    const nonSerializableValue = findNonSerializableValue(next);\n    if (nonSerializableValue) {\n      error2(\n        `New state path: '${nonSerializableValue.path}' value: '${String(\n          nonSerializableValue.value\n        )}' is not serializable.\nOnly serializable value can be synced with Liveblocks.`\n      );\n      return;\n    }\n  }\n  const value = liveObject.get(key);\n  if (next === void 0) {\n    liveObject.delete(key);\n  } else if (value === void 0) {\n    liveObject.set(key, deepLiveify(next));\n  } else if (prev === next) {\n    return;\n  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n    patchLiveList(value, prev, next);\n  } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {\n    patchLiveObject(value, prev, next);\n  } else {\n    liveObject.set(key, deepLiveify(next));\n  }\n}\nfunction patchLiveObject(root, prev, next) {\n  const updates = {};\n  for (const key in next) {\n    patchLiveObjectKey(root, key, prev[key], next[key]);\n  }\n  for (const key in prev) {\n    if (next[key] === void 0) {\n      root.delete(key);\n    }\n  }\n  if (Object.keys(updates).length > 0) {\n    root.update(updates);\n  }\n}\nfunction getParentsPath(node) {\n  const path = [];\n  while (node.parent.type === \"HasParent\") {\n    if (isLiveList(node.parent.node)) {\n      path.push(node.parent.node._indexOfPosition(node.parent.key));\n    } else {\n      path.push(node.parent.key);\n    }\n    node = node.parent.node;\n  }\n  return path;\n}\nfunction legacy_patchImmutableObject(state, updates) {\n  return updates.reduce(\n    (state2, update) => legacy_patchImmutableObjectWithUpdate(state2, update),\n    state\n  );\n}\nfunction legacy_patchImmutableObjectWithUpdate(state, update) {\n  const path = getParentsPath(update.node);\n  return legacy_patchImmutableNode(state, path, update);\n}\nfunction legacy_patchImmutableNode(state, path, update) {\n  const pathItem = path.pop();\n  if (pathItem === void 0) {\n    switch (update.type) {\n      case \"LiveObject\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveObject but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const val = update.node.get(key);\n            if (val !== void 0) {\n              newState[key] = lsonToJson(val);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n      case \"LiveList\": {\n        if (!Array.isArray(state)) {\n          throw new Error(\n            \"Internal: received update on LiveList but state was not an array\"\n          );\n        }\n        let newState = state.map((x) => x);\n        for (const listUpdate of update.updates) {\n          if (listUpdate.type === \"set\") {\n            newState = newState.map(\n              (item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item\n            );\n          } else if (listUpdate.type === \"insert\") {\n            if (listUpdate.index === newState.length) {\n              newState.push(lsonToJson(listUpdate.item));\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index)\n              ];\n            }\n          } else if (listUpdate.type === \"delete\") {\n            newState.splice(listUpdate.index, 1);\n          } else if (listUpdate.type === \"move\") {\n            if (listUpdate.previousIndex > listUpdate.index) {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                ...newState.slice(listUpdate.previousIndex + 1)\n              ];\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.previousIndex),\n                ...newState.slice(\n                  listUpdate.previousIndex + 1,\n                  listUpdate.index + 1\n                ),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index + 1)\n              ];\n            }\n          }\n        }\n        return newState;\n      }\n      case \"LiveMap\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveMap but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (update.updates[key]?.type === \"update\") {\n            const value = update.node.get(key);\n            if (value !== void 0) {\n              newState[key] = lsonToJson(value);\n            }\n          } else if (update.updates[key]?.type === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n    }\n  }\n  if (Array.isArray(state)) {\n    const newArray = [...state];\n    newArray[pathItem] = legacy_patchImmutableNode(\n      state[pathItem],\n      path,\n      update\n    );\n    return newArray;\n  } else if (isJsonObject(state)) {\n    const node = state[pathItem];\n    if (node === void 0) {\n      return state;\n    } else {\n      const stateAsObj = state;\n      return {\n        ...stateAsObj,\n        [pathItem]: legacy_patchImmutableNode(node, path, update)\n      };\n    }\n  } else {\n    return state;\n  }\n}\n\n// src/lib/abortController.ts\nfunction makeAbortController(externalSignal) {\n  const ctl = new AbortController();\n  return {\n    signal: externalSignal ? AbortSignal.any([ctl.signal, externalSignal]) : ctl.signal,\n    abort: ctl.abort.bind(ctl)\n  };\n}\n\n// src/lib/deprecation.ts\nvar _emittedDeprecationWarnings = /* @__PURE__ */ new Set();\nfunction deprecate(message, key = message) {\n  if (true) {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n      errorWithTitle(\"Deprecation warning\", message);\n    }\n  }\n}\nfunction deprecateIf(condition, message, key = message) {\n  if (true) {\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\nfunction throwUsageError(message) {\n  if (true) {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    errorWithTitle(\"Usage error\", message);\n    throw usageError;\n  }\n}\nfunction errorIf(condition, message) {\n  if (true) {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n}\n\n// src/lib/Poller.ts\nvar BACKOFF_DELAYS2 = [1e3, 2e3, 4e3, 8e3, 1e4];\nfunction makePoller(callback, intervalMs, options) {\n  const startTime = performance.now();\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const win = typeof window !== \"undefined\" ? window : void 0;\n  const maxStaleTimeMs = options?.maxStaleTimeMs ?? Number.POSITIVE_INFINITY;\n  const context = {\n    inForeground: doc?.visibilityState !== \"hidden\",\n    lastSuccessfulPollAt: startTime,\n    count: 0,\n    backoff: 0\n  };\n  function mayPoll() {\n    return context.count > 0 && context.inForeground;\n  }\n  const fsm = new FSM({}).addState(\"@idle\").addState(\"@enabled\").addState(\"@polling\");\n  fsm.addTransitions(\"@idle\", { START: \"@enabled\" });\n  fsm.addTransitions(\"@enabled\", { STOP: \"@idle\", POLL: \"@polling\" });\n  fsm.addTimedTransition(\n    \"@enabled\",\n    () => {\n      const lastPoll = context.lastSuccessfulPollAt;\n      const nextPoll = lastPoll + intervalMs;\n      return Math.max(0, nextPoll - performance.now()) + context.backoff;\n    },\n    \"@polling\"\n  );\n  fsm.onEnterAsync(\n    \"@polling\",\n    async (_ctx, signal) => {\n      await callback(signal);\n      if (!signal.aborted) {\n        context.lastSuccessfulPollAt = performance.now();\n      }\n    },\n    // When OK\n    () => {\n      return {\n        target: mayPoll() ? \"@enabled\" : \"@idle\",\n        effect: () => {\n          context.backoff = 0;\n        }\n      };\n    },\n    // When error\n    () => {\n      return {\n        target: mayPoll() ? \"@enabled\" : \"@idle\",\n        effect: () => {\n          context.backoff = BACKOFF_DELAYS2.find((delay) => delay > context.backoff) ?? BACKOFF_DELAYS2[BACKOFF_DELAYS2.length - 1];\n        }\n      };\n    },\n    3e4\n    // Abort the poll if the callback takes more than 30 seconds to complete\n  );\n  function startOrStop() {\n    if (mayPoll()) {\n      fsm.send({ type: \"START\" });\n    } else {\n      fsm.send({ type: \"STOP\" });\n    }\n  }\n  function inc() {\n    context.count++;\n    startOrStop();\n  }\n  function dec() {\n    context.count--;\n    if (context.count < 0) {\n      context.count = 0;\n    }\n    startOrStop();\n  }\n  function pollNowIfStale() {\n    if (performance.now() - context.lastSuccessfulPollAt > maxStaleTimeMs) {\n      fsm.send({ type: \"POLL\" });\n    }\n  }\n  function setInForeground(inForeground) {\n    context.inForeground = inForeground;\n    startOrStop();\n    pollNowIfStale();\n  }\n  function onVisibilityChange() {\n    setInForeground(doc?.visibilityState !== \"hidden\");\n  }\n  doc?.addEventListener(\"visibilitychange\", onVisibilityChange);\n  win?.addEventListener(\"online\", onVisibilityChange);\n  win?.addEventListener(\"focus\", pollNowIfStale);\n  fsm.start();\n  return {\n    inc,\n    dec,\n    pollNowIfStale,\n    // Internal API, used by unit tests only to simulate visibility events\n    setInForeground\n  };\n}\n\n// src/lib/shallow.ts\nfunction shallowArray(xs, ys) {\n  if (xs.length !== ys.length) {\n    return false;\n  }\n  for (let i = 0; i < xs.length; i++) {\n    if (!Object.is(xs[i], ys[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction shallowObj(objA, objB) {\n  if (!isPlainObject(objA) || !isPlainObject(objB)) {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key])\n  );\n}\nfunction shallow(a, b) {\n  if (Object.is(a, b)) {\n    return true;\n  }\n  const isArrayA = Array.isArray(a);\n  const isArrayB = Array.isArray(b);\n  if (isArrayA || isArrayB) {\n    if (!isArrayA || !isArrayB) {\n      return false;\n    }\n    return shallowArray(a, b);\n  }\n  return shallowObj(a, b);\n}\n\n// src/lib/SortedList.ts\nfunction bisectRight(arr, x, lt) {\n  let lo = 0;\n  let hi = arr.length;\n  while (lo < hi) {\n    const mid = lo + (hi - lo >> 1);\n    if (lt(x, arr[mid])) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo;\n}\nvar SortedList = class _SortedList {\n  #data;\n  #lt;\n  constructor(alreadySortedList, lt) {\n    this.#lt = lt;\n    this.#data = alreadySortedList;\n  }\n  static from(arr, lt) {\n    const sorted = new _SortedList([], lt);\n    for (const item of arr) {\n      sorted.add(item);\n    }\n    return sorted;\n  }\n  static fromAlreadySorted(alreadySorted, lt) {\n    return new _SortedList(alreadySorted, lt);\n  }\n  /**\n   * Clones the sorted list to a new instance.\n   */\n  clone() {\n    return new _SortedList(this.#data.slice(), this.#lt);\n  }\n  /**\n   * Adds a new item to the sorted list, such that it remains sorted.\n   */\n  add(value) {\n    const idx = bisectRight(this.#data, value, this.#lt);\n    this.#data.splice(idx, 0, value);\n  }\n  /**\n   * Removes the given value from the sorted list, if it exists. The given\n   * value must be `===` to one of the list items. Only the first entry will be\n   * removed if the element exists in the sorted list multiple times.\n   */\n  remove(value) {\n    const idx = this.#data.indexOf(value);\n    if (idx >= 0) {\n      this.#data.splice(idx, 1);\n      return true;\n    }\n    return false;\n  }\n  get length() {\n    return this.#data.length;\n  }\n  *filter(predicate) {\n    for (const item of this.#data) {\n      if (predicate(item)) {\n        yield item;\n      }\n    }\n  }\n  [Symbol.iterator]() {\n    return this.#data[Symbol.iterator]();\n  }\n};\n\n// src/types/Others.ts\nvar TextEditorType = /* @__PURE__ */ ((TextEditorType2) => {\n  TextEditorType2[\"Lexical\"] = \"lexical\";\n  TextEditorType2[\"TipTap\"] = \"tiptap\";\n  return TextEditorType2;\n})(TextEditorType || {});\n\n// src/index.ts\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\nvar CommentsApiError = HttpError;\nvar NotificationsApiError = HttpError;\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY29yZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQixHQUFHLFVBQVU7QUFDeEU7QUFDQTtBQUNBLElBQUk7QUFDSixJQUFJO0FBQ0o7QUFDQSxxR0FBcUcsa0JBQWtCO0FBQ3ZIO0FBQ0E7QUFDQSxXQUFXLFNBQVMsRUFBRSxVQUFVO0FBQ2hDLFdBQVcsU0FBUyxFQUFFLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLHdCQUF3QjtBQUMzRztBQUNBO0FBQ0EsYUFBYSxVQUFVLFFBQVEsWUFBWTtBQUMzQyxhQUFhLFNBQVMsUUFBUSxXQUFXO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFL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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsTUFBcUM7QUFDbEQ7QUFDQSxFQUFFLENBQVE7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUJBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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RDtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQSx5QkFBeUIsa0NBQWtDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQixJQUFJO0FBQzVELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0JBQStCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxNQUFNLG1DQUFtQyxtQkFBbUI7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtCQUErQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU0sbUNBQW1DLHVCQUF1QjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE1BQU0sbUNBQW1DLHVCQUF1QjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQXFDLEdBQUcsQ0FBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsUUFBUTtBQUNSLGlCQUFpQjtBQUNqQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1CQUFtQiwrQkFBK0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsK0JBQStCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjs7QUFFdEI7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWEsR0FBRyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQXFDLCtCQUErQixDQUFNO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXLGVBQWUsR0FBRztBQUM5QyxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZUFBZTtBQUNyRTtBQUNBLCtDQUErQyxvQkFBb0I7QUFDbkU7QUFDQTtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQSw0REFBNEQsU0FBUyxTQUFTLEtBQUs7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMkJBQTJCO0FBQ3JFO0FBQ0E7QUFDQSwwQ0FBMEMsbUJBQW1CO0FBQzdEO0FBQ0E7QUFDQSx3Q0FBd0MsdUJBQXVCO0FBQy9EO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVDQUF1QyxtQkFBbUI7QUFDMUQ7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx5QkFBeUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSwwREFBMEQsSUFBSTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQXFDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxnQ0FBZ0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGVBQWU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpQ0FBaUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCLFlBQVk7QUFDbEU7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNCQUFzQjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUErRkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2xlYXJuLXJsLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL2NvcmUvZGlzdC9pbmRleC5qcz80YTFlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgUEtHX05BTUUgPSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbnZhciBQS0dfVkVSU0lPTiA9IFwiMi4yMi4wXCI7XG52YXIgUEtHX0ZPUk1BVCA9IFwiZXNtXCI7XG5cbi8vIHNyYy9kdXBlLWRldGVjdGlvbi50c1xudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9O1xudmFyIGNyb3NzTGlua2VkRG9jcyA9IFwiaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2Nyb3NzLWxpbmtlZFwiO1xudmFyIGR1cGVzRG9jcyA9IFwiaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2R1cGVzXCI7XG52YXIgU1BBQ0UgPSBcIiBcIjtcbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc29sZS5lcnJvcihtc2cpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICB9XG59XG5mdW5jdGlvbiBkZXRlY3REdXBlcyhwa2dOYW1lLCBwa2dWZXJzaW9uLCBwa2dGb3JtYXQpIHtcbiAgY29uc3QgcGtnSWQgPSBTeW1ib2wuZm9yKHBrZ05hbWUpO1xuICBjb25zdCBwa2dCdWlsZEluZm8gPSBwa2dGb3JtYXQgPyBgJHtwa2dWZXJzaW9uIHx8IFwiZGV2XCJ9ICgke3BrZ0Zvcm1hdH0pYCA6IHBrZ1ZlcnNpb24gfHwgXCJkZXZcIjtcbiAgaWYgKCFnW3BrZ0lkXSkge1xuICAgIGdbcGtnSWRdID0gcGtnQnVpbGRJbmZvO1xuICB9IGVsc2UgaWYgKGdbcGtnSWRdID09PSBwa2dCdWlsZEluZm8pIHtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtc2cgPSBbXG4gICAgICBgTXVsdGlwbGUgY29waWVzIG9mIExpdmVibG9ja3MgYXJlIGJlaW5nIGxvYWRlZCBpbiB5b3VyIHByb2plY3QuIFRoaXMgd2lsbCBjYXVzZSBpc3N1ZXMhIFNlZSAke2R1cGVzRG9jcyArIFNQQUNFfWAsXG4gICAgICBcIlwiLFxuICAgICAgXCJDb25mbGljdHM6XCIsXG4gICAgICBgLSAke3BrZ05hbWV9ICR7Z1twa2dJZF19IChhbHJlYWR5IGxvYWRlZClgLFxuICAgICAgYC0gJHtwa2dOYW1lfSAke3BrZ0J1aWxkSW5mb30gKHRyeWluZyB0byBsb2FkIHRoaXMgbm93KWBcbiAgICBdLmpvaW4oXCJcXG5cIik7XG4gICAgZXJyb3IobXNnKTtcbiAgfVxuICBpZiAocGtnVmVyc2lvbiAmJiBQS0dfVkVSU0lPTiAmJiBwa2dWZXJzaW9uICE9PSBQS0dfVkVSU0lPTikge1xuICAgIGVycm9yKFxuICAgICAgW1xuICAgICAgICBgQ3Jvc3MtbGlua2VkIHZlcnNpb25zIG9mIExpdmVibG9ja3MgZm91bmQsIHdoaWNoIHdpbGwgY2F1c2UgaXNzdWVzISBTZWUgJHtjcm9zc0xpbmtlZERvY3MgKyBTUEFDRX1gLFxuICAgICAgICBcIlwiLFxuICAgICAgICBcIkNvbmZsaWN0czpcIixcbiAgICAgICAgYC0gJHtQS0dfTkFNRX0gaXMgYXQgJHtQS0dfVkVSU0lPTn1gLFxuICAgICAgICBgLSAke3BrZ05hbWV9IGlzIGF0ICR7cGtnVmVyc2lvbn1gLFxuICAgICAgICBcIlwiLFxuICAgICAgICBcIkFsd2F5cyB1cGdyYWRlIGFsbCBMaXZlYmxvY2tzIHBhY2thZ2VzIHRvIHRoZSBzYW1lIHZlcnNpb24gbnVtYmVyLlwiXG4gICAgICBdLmpvaW4oXCJcXG5cIilcbiAgICApO1xuICB9XG59XG5cbi8vIHNyYy9jb252ZXJ0LXBsYWluLWRhdGEudHNcbmZ1bmN0aW9uIGNvbnZlcnRUb0NvbW1lbnREYXRhKGRhdGEpIHtcbiAgY29uc3QgZWRpdGVkQXQgPSBkYXRhLmVkaXRlZEF0ID8gbmV3IERhdGUoZGF0YS5lZGl0ZWRBdCkgOiB2b2lkIDA7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgY29uc3QgcmVhY3Rpb25zID0gZGF0YS5yZWFjdGlvbnMubWFwKChyZWFjdGlvbikgPT4gKHtcbiAgICAuLi5yZWFjdGlvbixcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKHJlYWN0aW9uLmNyZWF0ZWRBdClcbiAgfSkpO1xuICBpZiAoZGF0YS5ib2R5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICByZWFjdGlvbnMsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBlZGl0ZWRBdFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGVsZXRlZEF0ID0gbmV3IERhdGUoZGF0YS5kZWxldGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgcmVhY3Rpb25zLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgZWRpdGVkQXQsXG4gICAgICBkZWxldGVkQXRcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9UaHJlYWREYXRhKGRhdGEpIHtcbiAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICBjb25zdCB1cGRhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLnVwZGF0ZWRBdCk7XG4gIGNvbnN0IGNvbW1lbnRzID0gZGF0YS5jb21tZW50cy5tYXAoXG4gICAgKGNvbW1lbnQpID0+IGNvbnZlcnRUb0NvbW1lbnREYXRhKGNvbW1lbnQpXG4gICk7XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBjcmVhdGVkQXQsXG4gICAgdXBkYXRlZEF0LFxuICAgIGNvbW1lbnRzXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Db21tZW50VXNlclJlYWN0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEoZGF0YSkge1xuICBjb25zdCBub3RpZmllZEF0ID0gbmV3IERhdGUoZGF0YS5ub3RpZmllZEF0KTtcbiAgY29uc3QgcmVhZEF0ID0gZGF0YS5yZWFkQXQgPyBuZXcgRGF0ZShkYXRhLnJlYWRBdCkgOiBudWxsO1xuICBpZiAoXCJhY3Rpdml0aWVzXCIgaW4gZGF0YSkge1xuICAgIGNvbnN0IGFjdGl2aXRpZXMgPSBkYXRhLmFjdGl2aXRpZXMubWFwKChhY3Rpdml0eSkgPT4gKHtcbiAgICAgIC4uLmFjdGl2aXR5LFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShhY3Rpdml0eS5jcmVhdGVkQXQpXG4gICAgfSkpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgbm90aWZpZWRBdCxcbiAgICAgIHJlYWRBdCxcbiAgICAgIGFjdGl2aXRpZXNcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBub3RpZmllZEF0LFxuICAgIHJlYWRBdFxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvVGhyZWFkRGVsZXRlSW5mbyhkYXRhKSB7XG4gIGNvbnN0IGRlbGV0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuZGVsZXRlZEF0KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGRlbGV0ZWRBdFxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EZWxldGVJbmZvKGRhdGEpIHtcbiAgY29uc3QgZGVsZXRlZEF0ID0gbmV3IERhdGUoZGF0YS5kZWxldGVkQXQpO1xuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgZGVsZXRlZEF0XG4gIH07XG59XG5cbi8vIHNyYy9saWIvZmFuY3ktY29uc29sZS50c1xudmFyIGZhbmN5X2NvbnNvbGVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZmFuY3lfY29uc29sZV9leHBvcnRzLCB7XG4gIGVycm9yOiAoKSA9PiBlcnJvcjIsXG4gIGVycm9yV2l0aFRpdGxlOiAoKSA9PiBlcnJvcldpdGhUaXRsZSxcbiAgd2FybjogKCkgPT4gd2FybixcbiAgd2FybldpdGhUaXRsZTogKCkgPT4gd2FybldpdGhUaXRsZVxufSk7XG52YXIgYmFkZ2UgPSBcImJhY2tncm91bmQ6IzBlMGQxMjtib3JkZXItcmFkaXVzOjk5OTlweDtjb2xvcjojZmZmO3BhZGRpbmc6M3B4IDdweDtmb250LWZhbWlseTpzYW5zLXNlcmlmO2ZvbnQtd2VpZ2h0OjYwMDtcIjtcbnZhciBib2xkID0gXCJmb250LXdlaWdodDo2MDBcIjtcbmZ1bmN0aW9uIHdyYXAobWV0aG9kKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IGNvbnNvbGVbbWV0aG9kXSA6IChcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIChtZXNzYWdlLCAuLi5hcmdzKSA9PiBjb25zb2xlW21ldGhvZF0oXCIlY0xpdmVibG9ja3NcIiwgYmFkZ2UsIG1lc3NhZ2UsIC4uLmFyZ3MpXG4gICk7XG59XG52YXIgd2FybiA9IHdyYXAoXCJ3YXJuXCIpO1xudmFyIGVycm9yMiA9IHdyYXAoXCJlcnJvclwiKTtcbmZ1bmN0aW9uIHdyYXBXaXRoVGl0bGUobWV0aG9kKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IGNvbnNvbGVbbWV0aG9kXSA6IChcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICh0aXRsZSwgbWVzc2FnZSwgLi4uYXJncykgPT4gY29uc29sZVttZXRob2RdKFxuICAgICAgYCVjTGl2ZWJsb2NrcyVjICR7dGl0bGV9YCxcbiAgICAgIGJhZGdlLFxuICAgICAgYm9sZCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICAuLi5hcmdzXG4gICAgKVxuICApO1xufVxudmFyIHdhcm5XaXRoVGl0bGUgPSB3cmFwV2l0aFRpdGxlKFwid2FyblwiKTtcbnZhciBlcnJvcldpdGhUaXRsZSA9IHdyYXBXaXRoVGl0bGUoXCJlcnJvclwiKTtcblxuLy8gc3JjL2xpYi9ndWFyZHMudHNcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoYmxvYikge1xuICByZXR1cm4gYmxvYiAhPT0gbnVsbCAmJiB0eXBlb2YgYmxvYiA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYmxvYikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG5mdW5jdGlvbiBpc1N0YXJ0c1dpdGhPcGVyYXRvcihibG9iKSB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KGJsb2IpICYmIHR5cGVvZiBibG9iLnN0YXJ0c1dpdGggPT09IFwic3RyaW5nXCI7XG59XG5cbi8vIHNyYy9saWIvdXRpbHMudHNcbmZ1bmN0aW9uIHJhaXNlKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cbmZ1bmN0aW9uIGVudHJpZXMob2JqKSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhvYmopO1xufVxuZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG59XG5mdW5jdGlvbiB2YWx1ZXMob2JqKSB7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKG9iaik7XG59XG5mdW5jdGlvbiBjcmVhdGUob2JqLCBkZXNjcmlwdG9ycykge1xuICBpZiAodHlwZW9mIGRlc2NyaXB0b3JzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUob2JqLCBkZXNjcmlwdG9ycyk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5jcmVhdGUob2JqKTtcbn1cbmZ1bmN0aW9uIG1hcFZhbHVlcyhvYmosIG1hcEZuKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IHBhaXIgb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgIGNvbnN0IGtleSA9IHBhaXJbMF07XG4gICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gcGFpclsxXTtcbiAgICByZXN1bHRba2V5XSA9IG1hcEZuKHZhbHVlLCBrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0cnlQYXJzZUpzb24ocmF3TWVzc2FnZSkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHJhd01lc3NhZ2UpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gZGVlcENsb25lKHZhbHVlKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG59XG5mdW5jdGlvbiBiNjRkZWNvZGUoYjY0dmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBmb3JtYXR0ZWRWYWx1ZSA9IGI2NHZhbHVlLnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpO1xuICAgIGNvbnN0IGRlY29kZWRWYWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChcbiAgICAgIGF0b2IoZm9ybWF0dGVkVmFsdWUpLnNwbGl0KFwiXCIpLm1hcChmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiBcIiVcIiArIChcIjAwXCIgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG4gICAgICB9KS5qb2luKFwiXCIpXG4gICAgKTtcbiAgICByZXR1cm4gZGVjb2RlZFZhbHVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gYXRvYihiNjR2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBhY3QoaXRlbXMpIHtcbiAgcmV0dXJuIGl0ZW1zLmZpbHRlcihcbiAgICAoaXRlbSkgPT4gaXRlbSAhPT0gbnVsbCAmJiBpdGVtICE9PSB2b2lkIDBcbiAgKTtcbn1cbmZ1bmN0aW9uIGNvbXBhY3RPYmplY3Qob2JqKSB7XG4gIGNvbnN0IG5ld09iaiA9IHsgLi4ub2JqIH07XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaCgoaykgPT4ge1xuICAgIGNvbnN0IGtleSA9IGs7XG4gICAgaWYgKG5ld09ialtrZXldID09PSB2b2lkIDApIHtcbiAgICAgIGRlbGV0ZSBuZXdPYmpba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3T2JqO1xufVxuZnVuY3Rpb24gd2FpdChtaWxsaXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHNldFRpbWVvdXQocmVzLCBtaWxsaXMpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHdpdGhUaW1lb3V0KHByb21pc2UsIG1pbGxpcywgZXJybXNnKSB7XG4gIGxldCB0aW1lcklEO1xuICBjb25zdCB0aW1lciQgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgdGltZXJJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnJtc2cpKTtcbiAgICB9LCBtaWxsaXMpO1xuICB9KTtcbiAgcmV0dXJuIFByb21pc2UucmFjZShbcHJvbWlzZSwgdGltZXIkXSkuZmluYWxseSgoKSA9PiBjbGVhclRpbWVvdXQodGltZXJJRCkpO1xufVxuZnVuY3Rpb24gbWVtb2l6ZU9uU3VjY2VzcyhmYWN0b3J5Rm4pIHtcbiAgbGV0IGNhY2hlZCA9IG51bGw7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKGNhY2hlZCA9PT0gbnVsbCkge1xuICAgICAgY2FjaGVkID0gZmFjdG9yeUZuKCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjYWNoZWQgPSBudWxsO1xuICAgICAgICB9LCA1ZTMpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9hdXRvUmV0cnkudHNcbnZhciBIdHRwRXJyb3IgPSBjbGFzcyBfSHR0cEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICByZXNwb25zZTtcbiAgZGV0YWlscztcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcmVzcG9uc2UsIGRldGFpbHMpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIkh0dHBFcnJvclwiO1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmcm9tUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICBsZXQgYm9keUFzVGV4dDtcbiAgICB0cnkge1xuICAgICAgYm9keUFzVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgY29uc3QgYm9keUFzSnNvbiA9IGJvZHlBc1RleHQgPyB0cnlQYXJzZUpzb24oYm9keUFzVGV4dCkgOiB2b2lkIDA7XG4gICAgbGV0IGJvZHlBc0pzb25PYmplY3Q7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoYm9keUFzSnNvbikpIHtcbiAgICAgIGJvZHlBc0pzb25PYmplY3QgPSBib2R5QXNKc29uO1xuICAgIH1cbiAgICBsZXQgbWVzc2FnZSA9IFwiXCI7XG4gICAgbWVzc2FnZSB8fD0gdHlwZW9mIGJvZHlBc0pzb25PYmplY3Q/Lm1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBib2R5QXNKc29uT2JqZWN0Lm1lc3NhZ2UgOiBcIlwiO1xuICAgIG1lc3NhZ2UgfHw9IHR5cGVvZiBib2R5QXNKc29uT2JqZWN0Py5lcnJvciA9PT0gXCJzdHJpbmdcIiA/IGJvZHlBc0pzb25PYmplY3QuZXJyb3IgOiBcIlwiO1xuICAgIGlmIChib2R5QXNKc29uID09PSB2b2lkIDApIHtcbiAgICAgIG1lc3NhZ2UgfHw9IGJvZHlBc1RleHQgfHwgXCJcIjtcbiAgICB9XG4gICAgbWVzc2FnZSB8fD0gcmVzcG9uc2Uuc3RhdHVzVGV4dDtcbiAgICBsZXQgcGF0aDtcbiAgICB0cnkge1xuICAgICAgcGF0aCA9IG5ldyBVUkwocmVzcG9uc2UudXJsKS5wYXRobmFtZTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgbWVzc2FnZSArPSBwYXRoICE9PSB2b2lkIDAgPyBgIChnb3Qgc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzfSBmcm9tICR7cGF0aH0pYCA6IGAgKGdvdCBzdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9KWA7XG4gICAgY29uc3QgZGV0YWlscyA9IGJvZHlBc0pzb25PYmplY3Q7XG4gICAgcmV0dXJuIG5ldyBfSHR0cEVycm9yKG1lc3NhZ2UsIHJlc3BvbnNlLCBkZXRhaWxzKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVuaWVuY2UgYWNjZXNzb3IgZm9yIHJlc3BvbnNlLnN0YXR1cy5cbiAgICovXG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2Uuc3RhdHVzO1xuICB9XG59O1xudmFyIERPTlRfUkVUUllfNFhYID0gKHgpID0+IHggaW5zdGFuY2VvZiBIdHRwRXJyb3IgJiYgeC5zdGF0dXMgPj0gNDAwICYmIHguc3RhdHVzIDwgNTAwO1xuYXN5bmMgZnVuY3Rpb24gYXV0b1JldHJ5KHByb21pc2VGbiwgbWF4VHJpZXMsIGJhY2tvZmYsIHNob3VsZFN0b3BSZXRyeWluZyA9IERPTlRfUkVUUllfNFhYKSB7XG4gIGNvbnN0IGZhbGxiYWNrQmFja29mZiA9IGJhY2tvZmYubGVuZ3RoID4gMCA/IGJhY2tvZmZbYmFja29mZi5sZW5ndGggLSAxXSA6IDA7XG4gIGxldCBhdHRlbXB0ID0gMDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBhdHRlbXB0Kys7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBwcm9taXNlRm4oKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChzaG91bGRTdG9wUmV0cnlpbmcoZXJyKSkge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICBpZiAoYXR0ZW1wdCA+PSBtYXhUcmllcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCBhZnRlciAke21heFRyaWVzfSBhdHRlbXB0czogJHtTdHJpbmcoZXJyKX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGVsYXkgPSBiYWNrb2ZmW2F0dGVtcHQgLSAxXSA/PyBmYWxsYmFja0JhY2tvZmY7XG4gICAgd2FybihcbiAgICAgIGBBdHRlbXB0ICR7YXR0ZW1wdH0gd2FzIHVuc3VjY2Vzc2Z1bC4gUmV0cnlpbmcgaW4gJHtkZWxheX0gbWlsbGlzZWNvbmRzLmBcbiAgICApO1xuICAgIGF3YWl0IHdhaXQoZGVsYXkpO1xuICB9XG59XG5cbi8vIHNyYy9saWIvY29udHJvbGxlZFByb21pc2UudHNcbmZ1bmN0aW9uIGNvbnRyb2xsZWRQcm9taXNlKCkge1xuICBsZXQgcmVzb2x2ZTtcbiAgbGV0IHJlamVjdDtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIHJlc29sdmUgPSByZXM7XG4gICAgcmVqZWN0ID0gcmVqO1xuICB9KTtcbiAgcmV0dXJuIFtwcm9taXNlLCByZXNvbHZlLCByZWplY3RdO1xufVxuZnVuY3Rpb24gUHJvbWlzZV93aXRoUmVzb2x2ZXJzKCkge1xuICBjb25zdCBbcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0XSA9IGNvbnRyb2xsZWRQcm9taXNlKCk7XG4gIHJldHVybiB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9O1xufVxuXG4vLyBzcmMvbGliL0V2ZW50U291cmNlLnRzXG5mdW5jdGlvbiBtYWtlRXZlbnRTb3VyY2UoKSB7XG4gIGNvbnN0IF9vYnNlcnZlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmdW5jdGlvbiBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICBfb2JzZXJ2ZXJzLmFkZChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IF9vYnNlcnZlcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmVPbmNlKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgdW5zdWIgPSBzdWJzY3JpYmUoKGV2ZW50KSA9PiB7XG4gICAgICB1bnN1YigpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGV2ZW50KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdW5zdWI7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gd2FpdFVudGlsKHByZWRpY2F0ZSkge1xuICAgIGxldCB1bnN1YjtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcykgPT4ge1xuICAgICAgdW5zdWIgPSBzdWJzY3JpYmUoKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUgPT09IHZvaWQgMCB8fCBwcmVkaWNhdGUoZXZlbnQpKSB7XG4gICAgICAgICAgcmVzKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB1bnN1Yj8uKCkpO1xuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeShldmVudCkge1xuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIF9vYnNlcnZlcnMpIHtcbiAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBjYWxsZWQ7XG4gIH1cbiAgZnVuY3Rpb24gY291bnQoKSB7XG4gICAgcmV0dXJuIF9vYnNlcnZlcnMuc2l6ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC8vIFByaXZhdGUvaW50ZXJuYWwgY29udHJvbCBvdmVyIGV2ZW50IGVtaXNzaW9uXG4gICAgbm90aWZ5LFxuICAgIHN1YnNjcmliZSxcbiAgICBzdWJzY3JpYmVPbmNlLFxuICAgIGNvdW50LFxuICAgIHdhaXRVbnRpbCxcbiAgICBbU3ltYm9sLmRpc3Bvc2VdOiAoKSA9PiB7XG4gICAgICBfb2JzZXJ2ZXJzLmNsZWFyKCk7XG4gICAgfSxcbiAgICAvLyBQdWJsaWNseSBleHBvc2FibGUgc3Vic2NyaXB0aW9uIEFQSVxuICAgIG9ic2VydmFibGU6IHtcbiAgICAgIHN1YnNjcmliZSxcbiAgICAgIHN1YnNjcmliZU9uY2UsXG4gICAgICB3YWl0VW50aWxcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBtYWtlQnVmZmVyYWJsZUV2ZW50U291cmNlKCkge1xuICBjb25zdCBldmVudFNvdXJjZTIgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgbGV0IF9idWZmZXIgPSBudWxsO1xuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICBfYnVmZmVyID0gW107XG4gIH1cbiAgZnVuY3Rpb24gdW5wYXVzZSgpIHtcbiAgICBpZiAoX2J1ZmZlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIF9idWZmZXIpIHtcbiAgICAgIGV2ZW50U291cmNlMi5ub3RpZnkoZXZlbnQpO1xuICAgIH1cbiAgICBfYnVmZmVyID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBub3RpZnlPckJ1ZmZlcihldmVudCkge1xuICAgIGlmIChfYnVmZmVyICE9PSBudWxsKSB7XG4gICAgICBfYnVmZmVyLnB1c2goZXZlbnQpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZXZlbnRTb3VyY2UyLm5vdGlmeShldmVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZXZlbnRTb3VyY2UyLFxuICAgIG5vdGlmeTogbm90aWZ5T3JCdWZmZXIsXG4gICAgcGF1c2UsXG4gICAgdW5wYXVzZSxcbiAgICBbU3ltYm9sLmRpc3Bvc2VdOiAoKSA9PiB7XG4gICAgICBldmVudFNvdXJjZTJbU3ltYm9sLmRpc3Bvc2VdKCk7XG4gICAgICBpZiAoX2J1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgICBfYnVmZmVyLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbGliL2ZyZWV6ZS50c1xudmFyIGZyZWV6ZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IChcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgKHgpID0+IHhcbikgOiBPYmplY3QuZnJlZXplO1xuXG4vLyBzcmMvbGliL3NpZ25hbHMudHNcbnZhciBrU2lua3MgPSBTeW1ib2woXCJrU2lua3NcIik7XG52YXIga1RyaWdnZXIgPSBTeW1ib2woXCJrVHJpZ2dlclwiKTtcbnZhciBzaWduYWxzVG9UcmlnZ2VyID0gbnVsbDtcbnZhciB0cmFja2VkUmVhZHMgPSBudWxsO1xuZnVuY3Rpb24gYmF0Y2goY2FsbGJhY2spIHtcbiAgaWYgKHNpZ25hbHNUb1RyaWdnZXIgIT09IG51bGwpIHtcbiAgICBjYWxsYmFjaygpO1xuICAgIHJldHVybjtcbiAgfVxuICBzaWduYWxzVG9UcmlnZ2VyID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgdHJ5IHtcbiAgICBjYWxsYmFjaygpO1xuICB9IGZpbmFsbHkge1xuICAgIGZvciAoY29uc3Qgc2lnbmFsIG9mIHNpZ25hbHNUb1RyaWdnZXIpIHtcbiAgICAgIHNpZ25hbFtrVHJpZ2dlcl0oKTtcbiAgICB9XG4gICAgc2lnbmFsc1RvVHJpZ2dlciA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGVucXVldWVUcmlnZ2VyKHNpZ25hbCkge1xuICBpZiAoIXNpZ25hbHNUb1RyaWdnZXIpIHJhaXNlKFwiRXhwZWN0ZWQgdG8gYmUgaW4gYW4gYWN0aXZlIGJhdGNoXCIpO1xuICBzaWduYWxzVG9UcmlnZ2VyLmFkZChzaWduYWwpO1xufVxuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBwYXRjaCkge1xuICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xuICBjb25zdCBuZXdWYWx1ZSA9IHsgLi4udGFyZ2V0IH07XG4gIE9iamVjdC5rZXlzKHBhdGNoKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gaztcbiAgICBjb25zdCB2YWwgPSBwYXRjaFtrZXldO1xuICAgIGlmIChuZXdWYWx1ZVtrZXldICE9PSB2YWwpIHtcbiAgICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgICBkZWxldGUgbmV3VmFsdWVba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlW2tleV0gPSB2YWw7XG4gICAgICB9XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdXBkYXRlZCA/IG5ld1ZhbHVlIDogdGFyZ2V0O1xufVxudmFyIEFic3RyYWN0U2lnbmFsID0gY2xhc3Mge1xuICAvKiogQGludGVybmFsICovXG4gIGVxdWFscztcbiAgI2V2ZW50U291cmNlO1xuICAvKiogQGludGVybmFsICovXG4gIFtrU2lua3NdO1xuICBjb25zdHJ1Y3RvcihlcXVhbHMpIHtcbiAgICB0aGlzLmVxdWFscyA9IGVxdWFscyA/PyBPYmplY3QuaXM7XG4gICAgdGhpcy4jZXZlbnRTb3VyY2UgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgICB0aGlzW2tTaW5rc10gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuZ2V0ID0gdGhpcy5nZXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnN1YnNjcmliZSA9IHRoaXMuc3Vic2NyaWJlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zdWJzY3JpYmVPbmNlID0gdGhpcy5zdWJzY3JpYmVPbmNlLmJpbmQodGhpcyk7XG4gIH1cbiAgW1N5bWJvbC5kaXNwb3NlXSgpIHtcbiAgICB0aGlzLiNldmVudFNvdXJjZVtTeW1ib2wuZGlzcG9zZV0oKTtcbiAgICB0aGlzLiNldmVudFNvdXJjZSA9IFwiKGRpc3Bvc2VkKVwiO1xuICAgIHRoaXMuZXF1YWxzID0gXCIoZGlzcG9zZWQpXCI7XG4gIH1cbiAgZ2V0IGhhc1dhdGNoZXJzKCkge1xuICAgIGlmICh0aGlzLiNldmVudFNvdXJjZS5jb3VudCgpID4gMCkgcmV0dXJuIHRydWU7XG4gICAgZm9yIChjb25zdCBzaW5rIG9mIHRoaXNba1NpbmtzXSkge1xuICAgICAgaWYgKHNpbmsuaGFzV2F0Y2hlcnMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBba1RyaWdnZXJdKCkge1xuICAgIHRoaXMuI2V2ZW50U291cmNlLm5vdGlmeSgpO1xuICAgIGZvciAoY29uc3Qgc2luayBvZiB0aGlzW2tTaW5rc10pIHtcbiAgICAgIGVucXVldWVUcmlnZ2VyKHNpbmspO1xuICAgIH1cbiAgfVxuICBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy4jZXZlbnRTb3VyY2UuY291bnQoKSA9PT0gMCkge1xuICAgICAgdGhpcy5nZXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50U291cmNlLnN1YnNjcmliZShjYWxsYmFjayk7XG4gIH1cbiAgc3Vic2NyaWJlT25jZShjYWxsYmFjaykge1xuICAgIGNvbnN0IHVuc3ViID0gdGhpcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdW5zdWIoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH0pO1xuICAgIHJldHVybiB1bnN1YjtcbiAgfVxuICB3YWl0VW50aWwoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwid2FpdFVudGlsIG5vdCBzdXBwb3J0ZWQgb24gU2lnbmFsc1wiKTtcbiAgfVxuICBtYXJrU2lua3NEaXJ0eSgpIHtcbiAgICBmb3IgKGNvbnN0IHNpbmsgb2YgdGhpc1trU2lua3NdKSB7XG4gICAgICBzaW5rLm1hcmtEaXJ0eSgpO1xuICAgIH1cbiAgfVxuICBhZGRTaW5rKHNpbmspIHtcbiAgICB0aGlzW2tTaW5rc10uYWRkKHNpbmspO1xuICB9XG4gIHJlbW92ZVNpbmsoc2luaykge1xuICAgIHRoaXNba1NpbmtzXS5kZWxldGUoc2luayk7XG4gIH1cbiAgYXNSZWFkb25seSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnZhciBTaWduYWwgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0U2lnbmFsIHtcbiAgI3ZhbHVlO1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgZXF1YWxzKSB7XG4gICAgc3VwZXIoZXF1YWxzKTtcbiAgICB0aGlzLiN2YWx1ZSA9IGZyZWV6ZSh2YWx1ZSk7XG4gIH1cbiAgW1N5bWJvbC5kaXNwb3NlXSgpIHtcbiAgICBzdXBlcltTeW1ib2wuZGlzcG9zZV0oKTtcbiAgICB0aGlzLiN2YWx1ZSA9IFwiKGRpc3Bvc2VkKVwiO1xuICB9XG4gIGdldCgpIHtcbiAgICB0cmFja2VkUmVhZHM/LmFkZCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy4jdmFsdWU7XG4gIH1cbiAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgYmF0Y2goKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBuZXdWYWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUodGhpcy4jdmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmVxdWFscyh0aGlzLiN2YWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgICAgIHRoaXMuI3ZhbHVlID0gZnJlZXplKG5ld1ZhbHVlKTtcbiAgICAgICAgdGhpcy5tYXJrU2lua3NEaXJ0eSgpO1xuICAgICAgICBlbnF1ZXVlVHJpZ2dlcih0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbnZhciBQYXRjaGFibGVTaWduYWwgPSBjbGFzcyBleHRlbmRzIFNpZ25hbCB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcihmcmVlemUoY29tcGFjdE9iamVjdChkYXRhKSkpO1xuICB9XG4gIHNldCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEb24ndCBjYWxsIC5zZXQoKSBkaXJlY3RseSwgdXNlIC5wYXRjaCgpXCIpO1xuICB9XG4gIC8qKlxuICAgKiBQYXRjaGVzIHRoZSBjdXJyZW50IG9iamVjdC5cbiAgICovXG4gIHBhdGNoKHBhdGNoKSB7XG4gICAgc3VwZXIuc2V0KChvbGQpID0+IG1lcmdlKG9sZCwgcGF0Y2gpKTtcbiAgfVxufTtcbnZhciBJTklUSUFMID0gU3ltYm9sKCk7XG52YXIgRGVyaXZlZFNpZ25hbCA9IGNsYXNzIF9EZXJpdmVkU2lnbmFsIGV4dGVuZHMgQWJzdHJhY3RTaWduYWwge1xuICAjcHJldlZhbHVlO1xuICAjZGlydHk7XG4gIC8vIFdoZW4gdHJ1ZSwgdGhlIHZhbHVlIGluICN2YWx1ZSBtYXkgbm90IGJlIHVwLXRvLWRhdGUgYW5kIG5lZWRzIHJlLWNoZWNraW5nXG4gICNzb3VyY2VzO1xuICAjZGVwcztcbiAgI3RyYW5zZm9ybTtcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHN0YXRpYyBmcm9tKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBsYXN0ID0gYXJncy5wb3AoKTtcbiAgICBpZiAodHlwZW9mIGxhc3QgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHJhaXNlKFwiSW52YWxpZCAuZnJvbSgpIGNhbGwsIGxhc3QgYXJndW1lbnQgZXhwZWN0ZWQgdG8gYmUgYSBmdW5jdGlvblwiKTtcbiAgICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zdCBlcXVhbHMgPSBsYXN0O1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gYXJncy5wb3AoKTtcbiAgICAgIHJldHVybiBuZXcgX0Rlcml2ZWRTaWduYWwoYXJncywgdHJhbnNmb3JtLCBlcXVhbHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBsYXN0O1xuICAgICAgcmV0dXJuIG5ldyBfRGVyaXZlZFNpZ25hbChhcmdzLCB0cmFuc2Zvcm0pO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3RvcihkZXBzLCB0cmFuc2Zvcm0sIGVxdWFscykge1xuICAgIHN1cGVyKGVxdWFscyk7XG4gICAgdGhpcy4jZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuI3ByZXZWYWx1ZSA9IElOSVRJQUw7XG4gICAgdGhpcy4jZGVwcyA9IGRlcHM7XG4gICAgdGhpcy4jc291cmNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy4jdHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICB9XG4gIFtTeW1ib2wuZGlzcG9zZV0oKSB7XG4gICAgZm9yIChjb25zdCBzcmMgb2YgdGhpcy4jc291cmNlcykge1xuICAgICAgc3JjLnJlbW92ZVNpbmsodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuI3ByZXZWYWx1ZSA9IFwiKGRpc3Bvc2VkKVwiO1xuICAgIHRoaXMuI3NvdXJjZXMgPSBcIihkaXNwb3NlZClcIjtcbiAgICB0aGlzLiNkZXBzID0gXCIoZGlzcG9zZWQpXCI7XG4gICAgdGhpcy4jdHJhbnNmb3JtID0gXCIoZGlzcG9zZWQpXCI7XG4gIH1cbiAgZ2V0IGlzRGlydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RpcnR5O1xuICB9XG4gICNyZWNvbXB1dGUoKSB7XG4gICAgY29uc3Qgb2xkVHJhY2tlZFJlYWRzID0gdHJhY2tlZFJlYWRzO1xuICAgIGxldCBkZXJpdmVkO1xuICAgIHRyYWNrZWRSZWFkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdHJ5IHtcbiAgICAgIGRlcml2ZWQgPSB0aGlzLiN0cmFuc2Zvcm0oLi4udGhpcy4jZGVwcy5tYXAoKHApID0+IHAuZ2V0KCkpKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY29uc3Qgb2xkU291cmNlcyA9IHRoaXMuI3NvdXJjZXM7XG4gICAgICB0aGlzLiNzb3VyY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGZvciAoY29uc3Qgc2lnIG9mIHRyYWNrZWRSZWFkcykge1xuICAgICAgICB0aGlzLiNzb3VyY2VzLmFkZChzaWcpO1xuICAgICAgICBvbGRTb3VyY2VzLmRlbGV0ZShzaWcpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBvbGRTb3VyY2Ugb2Ygb2xkU291cmNlcykge1xuICAgICAgICBvbGRTb3VyY2UucmVtb3ZlU2luayh0aGlzKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgbmV3U291cmNlIG9mIHRoaXMuI3NvdXJjZXMpIHtcbiAgICAgICAgbmV3U291cmNlLmFkZFNpbmsodGhpcyk7XG4gICAgICB9XG4gICAgICB0cmFja2VkUmVhZHMgPSBvbGRUcmFja2VkUmVhZHM7XG4gICAgfVxuICAgIHRoaXMuI2RpcnR5ID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLmVxdWFscyh0aGlzLiNwcmV2VmFsdWUsIGRlcml2ZWQpKSB7XG4gICAgICB0aGlzLiNwcmV2VmFsdWUgPSBkZXJpdmVkO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBtYXJrRGlydHkoKSB7XG4gICAgaWYgKCF0aGlzLiNkaXJ0eSkge1xuICAgICAgdGhpcy4jZGlydHkgPSB0cnVlO1xuICAgICAgdGhpcy5tYXJrU2lua3NEaXJ0eSgpO1xuICAgIH1cbiAgfVxuICBnZXQoKSB7XG4gICAgaWYgKHRoaXMuI2RpcnR5KSB7XG4gICAgICB0aGlzLiNyZWNvbXB1dGUoKTtcbiAgICB9XG4gICAgdHJhY2tlZFJlYWRzPy5hZGQodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuI3ByZXZWYWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIGJ5IHRoZSBTaWduYWwgc3lzdGVtIGlmIG9uZSBvciBtb3JlIG9mIHRoZSBkZXBlbmRlbnQgc2lnbmFscyBoYXZlXG4gICAqIGNoYW5nZWQuIEluIHRoZSBjYXNlIG9mIGEgRGVyaXZlZFNpZ25hbCwgd2UnbGwgb25seSB3YW50IHRvIHJlLWV2YWx1YXRlXG4gICAqIHRoZSBhY3R1YWwgdmFsdWUgaWYgaXQncyBiZWluZyB3YXRjaGVkLCBvciBhbnkgb2YgdGhlaXIgc2lua3MgYXJlIGJlaW5nXG4gICAqIHdhdGNoZWQgYWN0aXZlbHkuXG4gICAqL1xuICBba1RyaWdnZXJdKCkge1xuICAgIGlmICghdGhpcy5oYXNXYXRjaGVycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVkID0gdGhpcy4jcmVjb21wdXRlKCk7XG4gICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgIHN1cGVyW2tUcmlnZ2VyXSgpO1xuICAgIH1cbiAgfVxufTtcbnZhciBNdXRhYmxlU2lnbmFsID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdFNpZ25hbCB7XG4gICNzdGF0ZTtcbiAgY29uc3RydWN0b3IoaW5pdGlhbFN0YXRlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNzdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgfVxuICBbU3ltYm9sLmRpc3Bvc2VdKCkge1xuICAgIHN1cGVyW1N5bWJvbC5kaXNwb3NlXSgpO1xuICAgIHRoaXMuI3N0YXRlID0gXCIoZGlzcG9zZWQpXCI7XG4gIH1cbiAgZ2V0KCkge1xuICAgIHRyYWNrZWRSZWFkcz8uYWRkKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLiNzdGF0ZTtcbiAgfVxuICAvKipcbiAgICogSW52b2tlcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgYWxsb3dlZCB0byBtdXRhdGUgdGhlIGdpdmVuIHN0YXRlXG4gICAqIHZhbHVlLiBEbyBub3QgY2hhbmdlIHRoZSB2YWx1ZSBvdXRzaWRlIG9mIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogSWYgdGhlIGNhbGxiYWNrIGV4cGxpY2l0bHkgcmV0dXJucyBgZmFsc2VgLCBpdCdzIGFzc3VtZWQgdGhhdCB0aGUgc3RhdGVcbiAgICogd2FzIG5vdCBjaGFuZ2VkLlxuICAgKi9cbiAgbXV0YXRlKGNhbGxiYWNrKSB7XG4gICAgYmF0Y2goKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2sgPyBjYWxsYmFjayh0aGlzLiNzdGF0ZSkgOiB0cnVlO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0ID09PSBcIm9iamVjdFwiICYmIFwidGhlblwiIGluIHJlc3VsdCkge1xuICAgICAgICByYWlzZShcIk11dGFibGVTaWduYWwubXV0YXRlKCkgZG9lcyBub3Qgc3VwcG9ydCBhc3luYyBjYWxsYmFja3NcIik7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLm1hcmtTaW5rc0RpcnR5KCk7XG4gICAgICAgIGVucXVldWVUcmlnZ2VyKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL3N0cmluZ2lmeS50c1xuZnVuY3Rpb24gcmVwbGFjZXIoX2tleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBPYmplY3Qua2V5cyh2YWx1ZSkuc29ydCgpLnJlZHVjZSgoc29ydGVkLCBrZXkpID0+IHtcbiAgICBzb3J0ZWRba2V5XSA9IHZhbHVlW2tleV07XG4gICAgcmV0dXJuIHNvcnRlZDtcbiAgfSwge30pIDogdmFsdWU7XG59XG5mdW5jdGlvbiBzdGFibGVTdHJpbmdpZnkodmFsdWUpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlcik7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlPckxvZyh2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkIG5vdCBzdHJpbmdpZnk6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgY29uc29sZS5lcnJvcih2YWx1ZSk7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5cbi8vIHNyYy9saWIvYmF0Y2gudHNcbnZhciBERUZBVUxUX1NJWkUgPSA1MDtcbnZhciBCYXRjaENhbGwgPSBjbGFzcyB7XG4gIGlucHV0O1xuICByZXNvbHZlO1xuICByZWplY3Q7XG4gIHByb21pc2U7XG4gIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgIGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0IH0gPSBQcm9taXNlX3dpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gIH1cbn07XG52YXIgQmF0Y2ggPSBjbGFzcyB7XG4gICNxdWV1ZSA9IFtdO1xuICAjY2FsbGJhY2s7XG4gICNzaXplO1xuICAjZGVsYXk7XG4gICNkZWxheVRpbWVvdXRJZDtcbiAgZXJyb3IgPSBmYWxzZTtcbiAgY29uc3RydWN0b3IoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICB0aGlzLiNjYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuI3NpemUgPSBvcHRpb25zLnNpemUgPz8gREVGQVVMVF9TSVpFO1xuICAgIHRoaXMuI2RlbGF5ID0gb3B0aW9ucy5kZWxheTtcbiAgfVxuICAjY2xlYXJEZWxheVRpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMuI2RlbGF5VGltZW91dElkICE9PSB2b2lkIDApIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNkZWxheVRpbWVvdXRJZCk7XG4gICAgICB0aGlzLiNkZWxheVRpbWVvdXRJZCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgI3NjaGVkdWxlKCkge1xuICAgIGlmICh0aGlzLiNxdWV1ZS5sZW5ndGggPT09IHRoaXMuI3NpemUpIHtcbiAgICAgIHZvaWQgdGhpcy4jZmx1c2goKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI3F1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhpcy4jY2xlYXJEZWxheVRpbWVvdXQoKTtcbiAgICAgIHRoaXMuI2RlbGF5VGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB2b2lkIHRoaXMuI2ZsdXNoKCksIHRoaXMuI2RlbGF5KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgI2ZsdXNoKCkge1xuICAgIGlmICh0aGlzLiNxdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2FsbHMgPSB0aGlzLiNxdWV1ZS5zcGxpY2UoMCk7XG4gICAgY29uc3QgaW5wdXRzID0gY2FsbHMubWFwKChjYWxsKSA9PiBjYWxsLmlucHV0KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuI2NhbGxiYWNrKGlucHV0cyk7XG4gICAgICB0aGlzLmVycm9yID0gZmFsc2U7XG4gICAgICBjYWxscy5mb3JFYWNoKChjYWxsLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzPy5baW5kZXhdO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzdWx0cykpIHtcbiAgICAgICAgICBjYWxsLnJlamVjdChuZXcgRXJyb3IoXCJDYWxsYmFjayBtdXN0IHJldHVybiBhbiBhcnJheS5cIikpO1xuICAgICAgICB9IGVsc2UgaWYgKGNhbGxzLmxlbmd0aCAhPT0gcmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICBjYWxsLnJlamVjdChcbiAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYENhbGxiYWNrIG11c3QgcmV0dXJuIGFuIGFycmF5IG9mIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgbnVtYmVyIG9mIHByb3ZpZGVkIGl0ZW1zLiBFeHBlY3RlZCAke2NhbGxzLmxlbmd0aH0sIGJ1dCBnb3QgJHtyZXN1bHRzLmxlbmd0aH0uYFxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBjYWxsLnJlamVjdChyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGwucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcjMpIHtcbiAgICAgIHRoaXMuZXJyb3IgPSB0cnVlO1xuICAgICAgY2FsbHMuZm9yRWFjaCgoY2FsbCkgPT4ge1xuICAgICAgICBjYWxsLnJlamVjdChlcnJvcjMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldChpbnB1dCkge1xuICAgIGNvbnN0IGV4aXN0aW5nQ2FsbCA9IHRoaXMuI3F1ZXVlLmZpbmQoXG4gICAgICAoY2FsbDIpID0+IHN0YWJsZVN0cmluZ2lmeShjYWxsMi5pbnB1dCkgPT09IHN0YWJsZVN0cmluZ2lmeShpbnB1dClcbiAgICApO1xuICAgIGlmIChleGlzdGluZ0NhbGwpIHtcbiAgICAgIHJldHVybiBleGlzdGluZ0NhbGwucHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgY2FsbCA9IG5ldyBCYXRjaENhbGwoaW5wdXQpO1xuICAgIHRoaXMuI3F1ZXVlLnB1c2goY2FsbCk7XG4gICAgdGhpcy4jc2NoZWR1bGUoKTtcbiAgICByZXR1cm4gY2FsbC5wcm9taXNlO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuI3F1ZXVlID0gW107XG4gICAgdGhpcy5lcnJvciA9IGZhbHNlO1xuICAgIHRoaXMuI2NsZWFyRGVsYXlUaW1lb3V0KCk7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVCYXRjaFN0b3JlKGJhdGNoMikge1xuICBjb25zdCBzaWduYWwgPSBuZXcgTXV0YWJsZVNpZ25hbCgvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgZnVuY3Rpb24gZ2V0Q2FjaGVLZXkoYXJncykge1xuICAgIHJldHVybiBzdGFibGVTdHJpbmdpZnkoYXJncyk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlKGNhY2hlS2V5LCBzdGF0ZSkge1xuICAgIHNpZ25hbC5tdXRhdGUoKGNhY2hlKSA9PiB7XG4gICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBpbnZhbGlkYXRlKGlucHV0cykge1xuICAgIHNpZ25hbC5tdXRhdGUoKGNhY2hlKSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dHMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgaW5wdXQgb2YgaW5wdXRzKSB7XG4gICAgICAgICAgY2FjaGUuZGVsZXRlKGdldENhY2hlS2V5KGlucHV0KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZW5xdWV1ZShpbnB1dCkge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkoaW5wdXQpO1xuICAgIGNvbnN0IGNhY2hlID0gc2lnbmFsLmdldCgpO1xuICAgIGlmIChjYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB1cGRhdGUoY2FjaGVLZXksIHsgaXNMb2FkaW5nOiB0cnVlIH0pO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYmF0Y2gyLmdldChpbnB1dCk7XG4gICAgICB1cGRhdGUoY2FjaGVLZXksIHsgaXNMb2FkaW5nOiBmYWxzZSwgZGF0YTogcmVzdWx0IH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yMykge1xuICAgICAgdXBkYXRlKGNhY2hlS2V5LCB7XG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvcjNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRJdGVtU3RhdGUoaW5wdXQpIHtcbiAgICBjb25zdCBjYWNoZUtleSA9IGdldENhY2hlS2V5KGlucHV0KTtcbiAgICBjb25zdCBjYWNoZSA9IHNpZ25hbC5nZXQoKTtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgfVxuICBmdW5jdGlvbiBfY2FjaGVLZXlzKCkge1xuICAgIGNvbnN0IGNhY2hlID0gc2lnbmFsLmdldCgpO1xuICAgIHJldHVybiBbLi4uY2FjaGUua2V5cygpXTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN1YnNjcmliZTogc2lnbmFsLnN1YnNjcmliZSxcbiAgICBlbnF1ZXVlLFxuICAgIGdldEl0ZW1TdGF0ZSxcbiAgICBpbnZhbGlkYXRlLFxuICAgIGJhdGNoOiBiYXRjaDIsXG4gICAgX2NhY2hlS2V5c1xuICB9O1xufVxuXG4vLyBzcmMvbGliL2NodW5rLnRzXG5mdW5jdGlvbiBjaHVuayhhcnJheSwgc2l6ZSkge1xuICBjb25zdCBjaHVua3MgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSBhcnJheS5sZW5ndGg7IGkgPCBqOyBpICs9IHNpemUpIHtcbiAgICBjaHVua3MucHVzaChhcnJheS5zbGljZShpLCBpICsgc2l6ZSkpO1xuICB9XG4gIHJldHVybiBjaHVua3M7XG59XG5cbi8vIHNyYy9saWIvbmFub2lkLnRzXG52YXIgbmFub2lkID0gKHQgPSAyMSkgPT4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSh0KSkucmVkdWNlKFxuICAodDIsIGUpID0+IHQyICs9IChlICY9IDYzKSA8IDM2ID8gZS50b1N0cmluZygzNikgOiBlIDwgNjIgPyAoZSAtIDI2KS50b1N0cmluZygzNikudG9VcHBlckNhc2UoKSA6IGUgPCA2MyA/IFwiX1wiIDogXCItXCIsXG4gIFwiXCJcbik7XG5cbi8vIHNyYy9saWIvY3JlYXRlSWRzLnRzXG52YXIgVEhSRUFEX0lEX1BSRUZJWCA9IFwidGhcIjtcbnZhciBDT01NRU5UX0lEX1BSRUZJWCA9IFwiY21cIjtcbnZhciBDT01NRU5UX0FUVEFDSE1FTlRfSURfUFJFRklYID0gXCJhdFwiO1xudmFyIElOQk9YX05PVElGSUNBVElPTl9JRF9QUkVGSVggPSBcImluXCI7XG5mdW5jdGlvbiBjcmVhdGVPcHRpbWlzdGljSWQocHJlZml4KSB7XG4gIHJldHVybiBgJHtwcmVmaXh9XyR7bmFub2lkKCl9YDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRocmVhZElkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKFRIUkVBRF9JRF9QUkVGSVgpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudElkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKENPTU1FTlRfSURfUFJFRklYKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRBdHRhY2htZW50SWQoKSB7XG4gIHJldHVybiBjcmVhdGVPcHRpbWlzdGljSWQoQ09NTUVOVF9BVFRBQ0hNRU5UX0lEX1BSRUZJWCk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbmJveE5vdGlmaWNhdGlvbklkKCkge1xuICByZXR1cm4gY3JlYXRlT3B0aW1pc3RpY0lkKElOQk9YX05PVElGSUNBVElPTl9JRF9QUkVGSVgpO1xufVxuXG4vLyBzcmMvbGliL0RlZmF1bHRNYXAudHNcbnZhciBEZWZhdWx0TWFwID0gY2xhc3MgZXh0ZW5kcyBNYXAge1xuICAjZGVmYXVsdEZuO1xuICAvKipcbiAgICogSWYgdGhlIGRlZmF1bHQgZnVuY3Rpb24gaXMgbm90IHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3RvciwgaXQgaGFzIHRvIGJlXG4gICAqIHByb3ZpZGVkIGluIGVhY2ggLmdldE9yQ3JlYXRlKCkgY2FsbCBpbmRpdmlkdWFsbHkuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0Rm4sIGVudHJpZXMyKSB7XG4gICAgc3VwZXIoZW50cmllczIpO1xuICAgIHRoaXMuI2RlZmF1bHRGbiA9IGRlZmF1bHRGbjtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIGtleSwgb3IgY3JlYXRlcyBpdC5cbiAgICpcbiAgICogRGlmZmVyZW5jZSBmcm9tIG5vcm1hbCBNYXA6IGlmIHRoZSBrZXkgZG9lcyBub3QgZXhpc3QsIGl0IHdpbGwgYmUgY3JlYXRlZFxuICAgKiBvbiB0aGUgZmx5IHVzaW5nIHRoZSBmYWN0b3J5IGZ1bmN0aW9uLCBhbmQgdGhhdCB2YWx1ZSB3aWxsIGdldCByZXR1cm5lZFxuICAgKiBpbnN0ZWFkIG9mIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgZ2V0T3JDcmVhdGUoa2V5LCBkZWZhdWx0Rm4pIHtcbiAgICBpZiAoc3VwZXIuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBzdXBlci5nZXQoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZm4gPSBkZWZhdWx0Rm4gPz8gdGhpcy4jZGVmYXVsdEZuID8/IHJhaXNlKFwiRGVmYXVsdE1hcCB1c2VkIHdpdGhvdXQgYSBmYWN0b3J5IGZ1bmN0aW9uXCIpO1xuICAgICAgY29uc3QgdmFsdWUgPSBmbihrZXkpO1xuICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvbGliL29iamVjdFRvUXVlcnkudHNcbnZhciBpZGVudGlmaWVyUmVnZXggPSAvXlthLXpBLVpfXVthLXpBLVowLTlfXSokLztcbmZ1bmN0aW9uIG9iamVjdFRvUXVlcnkob2JqKSB7XG4gIGxldCBmaWx0ZXJMaXN0ID0gW107XG4gIGNvbnN0IGVudHJpZXMyID0gT2JqZWN0LmVudHJpZXMob2JqKTtcbiAgY29uc3Qga2V5VmFsdWVQYWlycyA9IFtdO1xuICBjb25zdCBrZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yID0gW107XG4gIGNvbnN0IGluZGV4ZWRLZXlzID0gW107XG4gIGVudHJpZXMyLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICghaWRlbnRpZmllclJlZ2V4LnRlc3Qoa2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IG11c3Qgb25seSBjb250YWluIGxldHRlcnMsIG51bWJlcnMsIF9cIik7XG4gICAgfVxuICAgIGlmIChpc1NpbXBsZVZhbHVlKHZhbHVlKSkge1xuICAgICAga2V5VmFsdWVQYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgaWYgKGlzU3RhcnRzV2l0aE9wZXJhdG9yKHZhbHVlKSkge1xuICAgICAgICBrZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4ZWRLZXlzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBmaWx0ZXJMaXN0ID0gW1xuICAgIC4uLmdldEZpbHRlcnNGcm9tS2V5VmFsdWVQYWlycyhrZXlWYWx1ZVBhaXJzKSxcbiAgICAuLi5nZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3Ioa2V5VmFsdWVQYWlyc1dpdGhPcGVyYXRvcilcbiAgXTtcbiAgaW5kZXhlZEtleXMuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgbmVzdGVkRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHZhbHVlKTtcbiAgICBjb25zdCBuS2V5VmFsdWVQYWlycyA9IFtdO1xuICAgIGNvbnN0IG5LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yID0gW107XG4gICAgbmVzdGVkRW50cmllcy5mb3JFYWNoKChbbmVzdGVkS2V5LCBuZXN0ZWRWYWx1ZV0pID0+IHtcbiAgICAgIGlmIChpc1N0cmluZ0VtcHR5KG5lc3RlZEtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NpbXBsZVZhbHVlKG5lc3RlZFZhbHVlKSkge1xuICAgICAgICBuS2V5VmFsdWVQYWlycy5wdXNoKFtmb3JtYXRGaWx0ZXJLZXkoa2V5LCBuZXN0ZWRLZXkpLCBuZXN0ZWRWYWx1ZV0pO1xuICAgICAgfSBlbHNlIGlmIChpc1N0YXJ0c1dpdGhPcGVyYXRvcihuZXN0ZWRWYWx1ZSkpIHtcbiAgICAgICAgbktleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IucHVzaChbXG4gICAgICAgICAgZm9ybWF0RmlsdGVyS2V5KGtleSwgbmVzdGVkS2V5KSxcbiAgICAgICAgICBuZXN0ZWRWYWx1ZVxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmaWx0ZXJMaXN0ID0gW1xuICAgICAgLi4uZmlsdGVyTGlzdCxcbiAgICAgIC4uLmdldEZpbHRlcnNGcm9tS2V5VmFsdWVQYWlycyhuS2V5VmFsdWVQYWlycyksXG4gICAgICAuLi5nZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IobktleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IpXG4gICAgXTtcbiAgfSk7XG4gIHJldHVybiBmaWx0ZXJMaXN0Lm1hcCgoeyBrZXksIG9wZXJhdG9yLCB2YWx1ZSB9KSA9PiBgJHtrZXl9JHtvcGVyYXRvcn0ke3F1b3RlKHZhbHVlKX1gKS5qb2luKFwiIFwiKTtcbn1cbnZhciBnZXRGaWx0ZXJzRnJvbUtleVZhbHVlUGFpcnMgPSAoa2V5VmFsdWVQYWlycykgPT4ge1xuICBjb25zdCBmaWx0ZXJzID0gW107XG4gIGtleVZhbHVlUGFpcnMuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgZmlsdGVycy5wdXNoKHtcbiAgICAgIGtleSxcbiAgICAgIG9wZXJhdG9yOiBcIjpcIixcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZmlsdGVycztcbn07XG52YXIgZ2V0RmlsdGVyc0Zyb21LZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yID0gKGtleVZhbHVlUGFpcnNXaXRoT3BlcmF0b3IpID0+IHtcbiAgY29uc3QgZmlsdGVycyA9IFtdO1xuICBrZXlWYWx1ZVBhaXJzV2l0aE9wZXJhdG9yLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmIChcInN0YXJ0c1dpdGhcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuc3RhcnRzV2l0aCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZmlsdGVycy5wdXNoKHtcbiAgICAgICAga2V5LFxuICAgICAgICBvcGVyYXRvcjogXCJeXCIsXG4gICAgICAgIHZhbHVlOiB2YWx1ZS5zdGFydHNXaXRoXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZmlsdGVycztcbn07XG52YXIgaXNTaW1wbGVWYWx1ZSA9ICh2YWx1ZSkgPT4ge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiIHx8IHZhbHVlID09PSBudWxsO1xufTtcbnZhciBmb3JtYXRGaWx0ZXJLZXkgPSAoa2V5LCBuZXN0ZWRLZXkpID0+IHtcbiAgaWYgKG5lc3RlZEtleSkge1xuICAgIHJldHVybiBgJHtrZXl9WyR7cXVvdGUobmVzdGVkS2V5KX1dYDtcbiAgfVxuICByZXR1cm4ga2V5O1xufTtcbnZhciBpc1N0cmluZ0VtcHR5ID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiAhdmFsdWUgfHwgdmFsdWUudG9TdHJpbmcoKS50cmltKCkgPT09IFwiXCI7XG59O1xuZnVuY3Rpb24gcXVvdGUoaW5wdXQpIHtcbiAgY29uc3QgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAocmVzdWx0LmluY2x1ZGVzKFwiJ1wiKSkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGAnJHtyZXN1bHQuc2xpY2UoMSwgLTEpLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKX0nYDtcbn1cblxuLy8gc3JjL2xpYi91cmwudHNcbmZ1bmN0aW9uIHRvVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykge1xuICBjb25zdCByZXN1bHQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFtcykpIHtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0LnNldChrZXksIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdXJsam9pbihiYXNlVXJsLCBwYXRoLCBwYXJhbXMpIHtcbiAgY29uc3QgdXJsMiA9IG5ldyBVUkwocGF0aCwgYmFzZVVybCk7XG4gIGlmIChwYXJhbXMgIT09IHZvaWQgMCkge1xuICAgIHVybDIuc2VhcmNoID0gKHBhcmFtcyBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcyA/IHBhcmFtcyA6IHRvVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIHVybDIudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIHVybChzdHJpbmdzLCAuLi52YWx1ZXMyKSB7XG4gIHJldHVybiBzdHJpbmdzLnJlZHVjZShcbiAgICAocmVzdWx0LCBzdHIsIGkpID0+IHJlc3VsdCArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZXMyW2kgLSAxXSA/PyBcIlwiKSArIHN0clxuICApO1xufVxuXG4vLyBzcmMvYXBpLWNsaWVudC50c1xuZnVuY3Rpb24gY3JlYXRlQXBpQ2xpZW50KHtcbiAgYmFzZVVybCxcbiAgYXV0aE1hbmFnZXIsXG4gIGZldGNoUG9seWZpbGxcbn0pIHtcbiAgY29uc3QgaHR0cENsaWVudCA9IG5ldyBIdHRwQ2xpZW50KGJhc2VVcmwsIGZldGNoUG9seWZpbGwpO1xuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWRzU2luY2Uob3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RocmVhZHMvZGVsdGFgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgc2luY2U6IG9wdGlvbnMuc2luY2UudG9JU09TdHJpbmcoKVxuICAgICAgfSxcbiAgICAgIHsgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCB9XG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgdGhyZWFkczoge1xuICAgICAgICB1cGRhdGVkOiByZXN1bHQuZGF0YS5tYXAoY29udmVydFRvVGhyZWFkRGF0YSksXG4gICAgICAgIGRlbGV0ZWQ6IHJlc3VsdC5kZWxldGVkVGhyZWFkcy5tYXAoY29udmVydFRvVGhyZWFkRGVsZXRlSW5mbylcbiAgICAgIH0sXG4gICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IHtcbiAgICAgICAgdXBkYXRlZDogcmVzdWx0LmluYm94Tm90aWZpY2F0aW9ucy5tYXAoY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhKSxcbiAgICAgICAgZGVsZXRlZDogcmVzdWx0LmRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICAgIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGVsZXRlSW5mb1xuICAgICAgICApXG4gICAgICB9LFxuICAgICAgcmVxdWVzdGVkQXQ6IG5ldyBEYXRlKHJlc3VsdC5tZXRhLnJlcXVlc3RlZEF0KSxcbiAgICAgIHBlcm1pc3Npb25IaW50czogcmVzdWx0Lm1ldGEucGVybWlzc2lvbkhpbnRzXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWRzKG9wdGlvbnMpIHtcbiAgICBsZXQgcXVlcnk7XG4gICAgaWYgKG9wdGlvbnMucXVlcnkpIHtcbiAgICAgIHF1ZXJ5ID0gb2JqZWN0VG9RdWVyeShvcHRpb25zLnF1ZXJ5KTtcbiAgICB9XG4gICAgY29uc3QgUEFHRV9TSVpFID0gNTA7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0KFxuICAgICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGhyZWFkc2AsXG4gICAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgICAgfSksXG4gICAgICAgIHtcbiAgICAgICAgICBjdXJzb3I6IG9wdGlvbnMuY3Vyc29yLFxuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIGxpbWl0OiBQQUdFX1NJWkVcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRocmVhZHM6IHJlc3VsdC5kYXRhLm1hcChjb252ZXJ0VG9UaHJlYWREYXRhKSxcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiByZXN1bHQuaW5ib3hOb3RpZmljYXRpb25zLm1hcChcbiAgICAgICAgICBjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGFcbiAgICAgICAgKSxcbiAgICAgICAgbmV4dEN1cnNvcjogcmVzdWx0Lm1ldGEubmV4dEN1cnNvcixcbiAgICAgICAgcmVxdWVzdGVkQXQ6IG5ldyBEYXRlKHJlc3VsdC5tZXRhLnJlcXVlc3RlZEF0KSxcbiAgICAgICAgcGVybWlzc2lvbkhpbnRzOiByZXN1bHQubWV0YS5wZXJtaXNzaW9uSGludHNcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgSHR0cEVycm9yICYmIGVyci5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRocmVhZHM6IFtdLFxuICAgICAgICAgIGluYm94Tm90aWZpY2F0aW9uczogW10sXG4gICAgICAgICAgbmV4dEN1cnNvcjogbnVsbCxcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIEhBQ0tcbiAgICAgICAgICAvLyByZXF1ZXN0ZWRBdCBuZWVkcyB0byBiZSBhICpzZXJ2ZXIqIHRpbWVzdGFtcCBoZXJlLiBIb3dldmVyLCBvblxuICAgICAgICAgIC8vIHRoaXMgNDA0IGVycm9yIHJlc3BvbnNlLCB0aGVyZSBpcyBubyBzdWNoIHRpbWVzdGFtcC4gU28gb3V0IG9mXG4gICAgICAgICAgLy8gcHVyZSBuZWNlc3NpdHkgd2UnbGwgZmFsbCBiYWNrIHRvIGEgbG9jYWwgdGltZXN0YW1wIGluc3RlYWQgKGFuZFxuICAgICAgICAgIC8vIGFsbG93IGZvciBhIHBvc3NpYmxlIDYgaG91ciBjbG9jayBkaWZmZXJlbmNlIGJldHdlZW4gY2xpZW50IGFuZFxuICAgICAgICAgIC8vIHNlcnZlcikuXG4gICAgICAgICAgLy9cbiAgICAgICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDYgKiA2MCAqIDYwICogMWUzKSxcbiAgICAgICAgICBwZXJtaXNzaW9uSGludHM6IHt9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRocmVhZChvcHRpb25zKSB7XG4gICAgY29uc3QgY29tbWVudElkID0gb3B0aW9ucy5jb21tZW50SWQgPz8gY3JlYXRlQ29tbWVudElkKCk7XG4gICAgY29uc3QgdGhyZWFkSWQgPSBvcHRpb25zLnRocmVhZElkID8/IGNyZWF0ZVRocmVhZElkKCk7XG4gICAgY29uc3QgdGhyZWFkID0gYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RocmVhZHNgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IHRocmVhZElkLFxuICAgICAgICBjb21tZW50OiB7XG4gICAgICAgICAgaWQ6IGNvbW1lbnRJZCxcbiAgICAgICAgICBib2R5OiBvcHRpb25zLmJvZHksXG4gICAgICAgICAgYXR0YWNobWVudElkczogb3B0aW9ucy5hdHRhY2htZW50SWRzXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhOiBvcHRpb25zLm1ldGFkYXRhXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY29udmVydFRvVGhyZWFkRGF0YSh0aHJlYWQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVRocmVhZChvcHRpb25zKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5kZWxldGUoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGhyZWFkcy8ke29wdGlvbnMudGhyZWFkSWR9YCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFRocmVhZChvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBodHRwQ2xpZW50LnJhd0dldChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90aHJlYWQtd2l0aC1ub3RpZmljYXRpb24vJHtvcHRpb25zLnRocmVhZElkfWAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pXG4gICAgKTtcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aHJlYWQ6IGNvbnZlcnRUb1RocmVhZERhdGEoanNvbi50aHJlYWQpLFxuICAgICAgICBpbmJveE5vdGlmaWNhdGlvbjoganNvbi5pbmJveE5vdGlmaWNhdGlvbiA/IGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YShqc29uLmluYm94Tm90aWZpY2F0aW9uKSA6IHZvaWQgMFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aHJlYWQ6IHZvaWQgMCxcbiAgICAgICAgaW5ib3hOb3RpZmljYXRpb246IHZvaWQgMFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGdldHRpbmcgdGhyZWFkICR7b3B0aW9ucy50aHJlYWRJZH0uYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZWRpdFRocmVhZE1ldGFkYXRhKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RocmVhZHMvJHtvcHRpb25zLnRocmVhZElkfS9tZXRhZGF0YWAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pLFxuICAgICAgb3B0aW9ucy5tZXRhZGF0YVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ29tbWVudChvcHRpb25zKSB7XG4gICAgY29uc3QgY29tbWVudElkID0gb3B0aW9ucy5jb21tZW50SWQgPz8gY3JlYXRlQ29tbWVudElkKCk7XG4gICAgY29uc3QgY29tbWVudCA9IGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90aHJlYWRzLyR7b3B0aW9ucy50aHJlYWRJZH0vY29tbWVudHNgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IGNvbW1lbnRJZCxcbiAgICAgICAgYm9keTogb3B0aW9ucy5ib2R5LFxuICAgICAgICBhdHRhY2htZW50SWRzOiBvcHRpb25zLmF0dGFjaG1lbnRJZHNcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50RGF0YShjb21tZW50KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBlZGl0Q29tbWVudChvcHRpb25zKSB7XG4gICAgY29uc3QgY29tbWVudCA9IGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90aHJlYWRzLyR7b3B0aW9ucy50aHJlYWRJZH0vY29tbWVudHMvJHtvcHRpb25zLmNvbW1lbnRJZH1gLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgYm9keTogb3B0aW9ucy5ib2R5LFxuICAgICAgICBhdHRhY2htZW50SWRzOiBvcHRpb25zLmF0dGFjaG1lbnRJZHNcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50RGF0YShjb21tZW50KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBkZWxldGVDb21tZW50KG9wdGlvbnMpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50LmRlbGV0ZShcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90aHJlYWRzLyR7b3B0aW9ucy50aHJlYWRJZH0vY29tbWVudHMvJHtvcHRpb25zLmNvbW1lbnRJZH1gLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gYWRkUmVhY3Rpb24ob3B0aW9ucykge1xuICAgIGNvbnN0IHJlYWN0aW9uID0gYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RocmVhZHMvJHtvcHRpb25zLnRocmVhZElkfS9jb21tZW50cy8ke29wdGlvbnMuY29tbWVudElkfS9yZWFjdGlvbnNgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIHsgZW1vamk6IG9wdGlvbnMuZW1vamkgfVxuICAgICk7XG4gICAgcmV0dXJuIGNvbnZlcnRUb0NvbW1lbnRVc2VyUmVhY3Rpb24ocmVhY3Rpb24pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlbW92ZVJlYWN0aW9uKG9wdGlvbnMpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50LmRlbGV0ZShcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90aHJlYWRzLyR7b3B0aW9ucy50aHJlYWRJZH0vY29tbWVudHMvJHtvcHRpb25zLmNvbW1lbnRJZH0vcmVhY3Rpb25zLyR7b3B0aW9ucy5lbW9qaX1gLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya1RocmVhZEFzUmVzb2x2ZWQob3B0aW9ucykge1xuICAgIGF3YWl0IGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90aHJlYWRzLyR7b3B0aW9ucy50aHJlYWRJZH0vbWFyay1hcy1yZXNvbHZlZGAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrVGhyZWFkQXNVbnJlc29sdmVkKG9wdGlvbnMpIHtcbiAgICBhd2FpdCBodHRwQ2xpZW50LnBvc3QoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdGhyZWFkcy8ke29wdGlvbnMudGhyZWFkSWR9L21hcmstYXMtdW5yZXNvbHZlZGAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiB1cGxvYWRBdHRhY2htZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCByb29tSWQgPSBvcHRpb25zLnJvb21JZDtcbiAgICBjb25zdCBhYm9ydFNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsO1xuICAgIGNvbnN0IGF0dGFjaG1lbnQgPSBvcHRpb25zLmF0dGFjaG1lbnQ7XG4gICAgY29uc3QgYWJvcnRFcnJvciA9IGFib3J0U2lnbmFsID8gbmV3IERPTUV4Y2VwdGlvbihcbiAgICAgIGBVcGxvYWQgb2YgYXR0YWNobWVudCAke29wdGlvbnMuYXR0YWNobWVudC5pZH0gd2FzIGFib3J0ZWQuYCxcbiAgICAgIFwiQWJvcnRFcnJvclwiXG4gICAgKSA6IHZvaWQgMDtcbiAgICBpZiAoYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgIHRocm93IGFib3J0RXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZVJldHJ5RXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICBpZiAoYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgdGhyb3cgYWJvcnRFcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBIdHRwRXJyb3IgJiYgZXJyLnN0YXR1cyA9PT0gNDEzKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IEFUVEFDSE1FTlRfUEFSVF9TSVpFID0gNSAqIDEwMjQgKiAxMDI0O1xuICAgIGNvbnN0IFJFVFJZX0FUVEVNUFRTID0gMTA7XG4gICAgY29uc3QgUkVUUllfREVMQVlTID0gW1xuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzLFxuICAgICAgMmUzXG4gICAgXTtcbiAgICBmdW5jdGlvbiBzcGxpdEZpbGVJbnRvUGFydHMoZmlsZSkge1xuICAgICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICB3aGlsZSAoc3RhcnQgPCBmaWxlLnNpemUpIHtcbiAgICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4oc3RhcnQgKyBBVFRBQ0hNRU5UX1BBUlRfU0laRSwgZmlsZS5zaXplKTtcbiAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgcGFydE51bWJlcjogcGFydHMubGVuZ3RoICsgMSxcbiAgICAgICAgICBwYXJ0OiBmaWxlLnNsaWNlKHN0YXJ0LCBlbmQpXG4gICAgICAgIH0pO1xuICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9XG4gICAgaWYgKGF0dGFjaG1lbnQuc2l6ZSA8PSBBVFRBQ0hNRU5UX1BBUlRfU0laRSkge1xuICAgICAgcmV0dXJuIGF1dG9SZXRyeShcbiAgICAgICAgYXN5bmMgKCkgPT4gaHR0cENsaWVudC5wdXRCbG9iKFxuICAgICAgICAgIHVybGAvdjIvYy9yb29tcy8ke3Jvb21JZH0vYXR0YWNobWVudHMvJHthdHRhY2htZW50LmlkfS91cGxvYWQvJHtlbmNvZGVVUklDb21wb25lbnQoYXR0YWNobWVudC5uYW1lKX1gLFxuICAgICAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgICAgICByb29tSWRcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBhdHRhY2htZW50LmZpbGUsXG4gICAgICAgICAgeyBmaWxlU2l6ZTogYXR0YWNobWVudC5zaXplIH0sXG4gICAgICAgICAgeyBzaWduYWw6IGFib3J0U2lnbmFsIH1cbiAgICAgICAgKSxcbiAgICAgICAgUkVUUllfQVRURU1QVFMsXG4gICAgICAgIFJFVFJZX0RFTEFZUyxcbiAgICAgICAgaGFuZGxlUmV0cnlFcnJvclxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHVwbG9hZElkO1xuICAgICAgY29uc3QgdXBsb2FkZWRQYXJ0cyA9IFtdO1xuICAgICAgY29uc3QgY3JlYXRlTXVsdGlQYXJ0VXBsb2FkID0gYXdhaXQgYXV0b1JldHJ5KFxuICAgICAgICBhc3luYyAoKSA9PiBodHRwQ2xpZW50LnBvc3QoXG4gICAgICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7cm9vbUlkfS9hdHRhY2htZW50cy8ke2F0dGFjaG1lbnQuaWR9L211bHRpcGFydC8ke2VuY29kZVVSSUNvbXBvbmVudChhdHRhY2htZW50Lm5hbWUpfWAsXG4gICAgICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgICAgIHJvb21JZFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICB7IHNpZ25hbDogYWJvcnRTaWduYWwgfSxcbiAgICAgICAgICB7IGZpbGVTaXplOiBhdHRhY2htZW50LnNpemUgfVxuICAgICAgICApLFxuICAgICAgICBSRVRSWV9BVFRFTVBUUyxcbiAgICAgICAgUkVUUllfREVMQVlTLFxuICAgICAgICBoYW5kbGVSZXRyeUVycm9yXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdXBsb2FkSWQgPSBjcmVhdGVNdWx0aVBhcnRVcGxvYWQudXBsb2FkSWQ7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gc3BsaXRGaWxlSW50b1BhcnRzKGF0dGFjaG1lbnQuZmlsZSk7XG4gICAgICAgIGlmIChhYm9ydFNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICAgIHRocm93IGFib3J0RXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmF0Y2hlcyA9IGNodW5rKHBhcnRzLCA1KTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0czIgb2YgYmF0Y2hlcykge1xuICAgICAgICAgIGNvbnN0IHVwbG9hZGVkUGFydHNQcm9taXNlcyA9IFtdO1xuICAgICAgICAgIGZvciAoY29uc3QgeyBwYXJ0LCBwYXJ0TnVtYmVyIH0gb2YgcGFydHMyKSB7XG4gICAgICAgICAgICB1cGxvYWRlZFBhcnRzUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgYXV0b1JldHJ5KFxuICAgICAgICAgICAgICAgIGFzeW5jICgpID0+IGh0dHBDbGllbnQucHV0QmxvYihcbiAgICAgICAgICAgICAgICAgIHVybGAvdjIvYy9yb29tcy8ke3Jvb21JZH0vYXR0YWNobWVudHMvJHthdHRhY2htZW50LmlkfS9tdWx0aXBhcnQvJHtjcmVhdGVNdWx0aVBhcnRVcGxvYWQudXBsb2FkSWR9LyR7U3RyaW5nKHBhcnROdW1iZXIpfWAsXG4gICAgICAgICAgICAgICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgICAgICAgICAgICAgIHJvb21JZFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgeyBzaWduYWw6IGFib3J0U2lnbmFsIH1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIFJFVFJZX0FUVEVNUFRTLFxuICAgICAgICAgICAgICAgIFJFVFJZX0RFTEFZUyxcbiAgICAgICAgICAgICAgICBoYW5kbGVSZXRyeUVycm9yXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwbG9hZGVkUGFydHMucHVzaCguLi5hd2FpdCBQcm9taXNlLmFsbCh1cGxvYWRlZFBhcnRzUHJvbWlzZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICB0aHJvdyBhYm9ydEVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvcnRlZFVwbG9hZGVkUGFydHMgPSB1cGxvYWRlZFBhcnRzLnNvcnQoXG4gICAgICAgICAgKGEsIGIpID0+IGEucGFydE51bWJlciAtIGIucGFydE51bWJlclxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gaHR0cENsaWVudC5wb3N0KFxuICAgICAgICAgIHVybGAvdjIvYy9yb29tcy8ke3Jvb21JZH0vYXR0YWNobWVudHMvJHthdHRhY2htZW50LmlkfS9tdWx0aXBhcnQvJHt1cGxvYWRJZH0vY29tcGxldGVgLFxuICAgICAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgICAgICByb29tSWRcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7IHBhcnRzOiBzb3J0ZWRVcGxvYWRlZFBhcnRzIH0sXG4gICAgICAgICAgeyBzaWduYWw6IGFib3J0U2lnbmFsIH1cbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yMykge1xuICAgICAgICBpZiAodXBsb2FkSWQgJiYgZXJyb3IzPy5uYW1lICYmIChlcnJvcjMubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIgfHwgZXJyb3IzLm5hbWUgPT09IFwiVGltZW91dEVycm9yXCIpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGh0dHBDbGllbnQucmF3RGVsZXRlKFxuICAgICAgICAgICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtyb29tSWR9L2F0dGFjaG1lbnRzLyR7YXR0YWNobWVudC5pZH0vbXVsdGlwYXJ0LyR7dXBsb2FkSWR9YCxcbiAgICAgICAgICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgICAgICAgICAgcm9vbUlkXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yNCkge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGF0dGFjaG1lbnRVcmxzQmF0Y2hTdG9yZXNCeVJvb20gPSBuZXcgRGVmYXVsdE1hcCgocm9vbUlkKSA9PiB7XG4gICAgY29uc3QgYmF0Y2gyID0gbmV3IEJhdGNoKFxuICAgICAgYXN5bmMgKGJhdGNoZWRBdHRhY2htZW50SWRzKSA9PiB7XG4gICAgICAgIGNvbnN0IGF0dGFjaG1lbnRJZHMgPSBiYXRjaGVkQXR0YWNobWVudElkcy5mbGF0KCk7XG4gICAgICAgIGNvbnN0IHsgdXJscyB9ID0gYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgICAgIHVybGAvdjIvYy9yb29tcy8ke3Jvb21JZH0vYXR0YWNobWVudHMvcHJlc2lnbmVkLXVybHNgLFxuICAgICAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgICAgICByb29tSWRcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7IGF0dGFjaG1lbnRJZHMgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdXJscy5tYXAoXG4gICAgICAgICAgKHVybDIpID0+IHVybDIgPz8gbmV3IEVycm9yKFwiVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGdldHRpbmcgdGhpcyBhdHRhY2htZW50J3MgVVJMXCIpXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgeyBkZWxheTogNTAgfVxuICAgICk7XG4gICAgcmV0dXJuIGNyZWF0ZUJhdGNoU3RvcmUoYmF0Y2gyKTtcbiAgfSk7XG4gIGZ1bmN0aW9uIGdldE9yQ3JlYXRlQXR0YWNobWVudFVybHNTdG9yZShyb29tSWQpIHtcbiAgICByZXR1cm4gYXR0YWNobWVudFVybHNCYXRjaFN0b3Jlc0J5Um9vbS5nZXRPckNyZWF0ZShyb29tSWQpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEF0dGFjaG1lbnRVcmwob3B0aW9ucykge1xuICAgIGNvbnN0IGJhdGNoMiA9IGdldE9yQ3JlYXRlQXR0YWNobWVudFVybHNTdG9yZShvcHRpb25zLnJvb21JZCkuYmF0Y2g7XG4gICAgcmV0dXJuIGJhdGNoMi5nZXQob3B0aW9ucy5hdHRhY2htZW50SWQpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldE5vdGlmaWNhdGlvblNldHRpbmdzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5nZXQoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vbm90aWZpY2F0aW9uLXNldHRpbmdzYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICB2b2lkIDAsXG4gICAgICB7XG4gICAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWxcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5wb3N0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L25vdGlmaWNhdGlvbi1zZXR0aW5nc2AsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pLFxuICAgICAgb3B0aW9ucy5zZXR0aW5nc1xuICAgICk7XG4gIH1cbiAgY29uc3QgbWFya0FzUmVhZEJhdGNoZXNCeVJvb20gPSBuZXcgRGVmYXVsdE1hcChcbiAgICAocm9vbUlkKSA9PiBuZXcgQmF0Y2goXG4gICAgICBhc3luYyAoYmF0Y2hlZEluYm94Tm90aWZpY2F0aW9uSWRzKSA9PiB7XG4gICAgICAgIGNvbnN0IGluYm94Tm90aWZpY2F0aW9uSWRzID0gYmF0Y2hlZEluYm94Tm90aWZpY2F0aW9uSWRzLmZsYXQoKTtcbiAgICAgICAgYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgICAgIHVybGAvdjIvYy9yb29tcy8ke3Jvb21JZH0vaW5ib3gtbm90aWZpY2F0aW9ucy9yZWFkYCxcbiAgICAgICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoe1xuICAgICAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICAgICAgcm9vbUlkXG4gICAgICAgICAgfSksXG4gICAgICAgICAgeyBpbmJveE5vdGlmaWNhdGlvbklkcyB9XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBpbmJveE5vdGlmaWNhdGlvbklkcztcbiAgICAgIH0sXG4gICAgICB7IGRlbGF5OiA1MCB9XG4gICAgKVxuICApO1xuICBhc3luYyBmdW5jdGlvbiBtYXJrUm9vbUluYm94Tm90aWZpY2F0aW9uQXNSZWFkKG9wdGlvbnMpIHtcbiAgICBjb25zdCBiYXRjaDIgPSBtYXJrQXNSZWFkQmF0Y2hlc0J5Um9vbS5nZXRPckNyZWF0ZShvcHRpb25zLnJvb21JZCk7XG4gICAgcmV0dXJuIGJhdGNoMi5nZXQob3B0aW9ucy5pbmJveE5vdGlmaWNhdGlvbklkKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVUZXh0TWVudGlvbihvcHRpb25zKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5yYXdQb3N0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RleHQtbWVudGlvbnNgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgdXNlcklkOiBvcHRpb25zLnVzZXJJZCxcbiAgICAgICAgbWVudGlvbklkOiBvcHRpb25zLm1lbnRpb25JZFxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlVGV4dE1lbnRpb24ob3B0aW9ucykge1xuICAgIGF3YWl0IGh0dHBDbGllbnQucmF3RGVsZXRlKFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3RleHQtbWVudGlvbnMvJHtvcHRpb25zLm1lbnRpb25JZH1gLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGV4dFZlcnNpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBodHRwQ2xpZW50LnJhd0dldChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS95LXZlcnNpb24vJHtvcHRpb25zLnZlcnNpb25JZH1gLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVGV4dFZlcnNpb24ob3B0aW9ucykge1xuICAgIGF3YWl0IGh0dHBDbGllbnQucmF3UG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS92ZXJzaW9uYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHJlcG9ydFRleHRFZGl0b3Iob3B0aW9ucykge1xuICAgIGF3YWl0IGh0dHBDbGllbnQucmF3UG9zdChcbiAgICAgIHVybGAvdjIvYy9yb29tcy8ke29wdGlvbnMucm9vbUlkfS90ZXh0LW1ldGFkYXRhYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSksXG4gICAgICB7XG4gICAgICAgIHR5cGU6IG9wdGlvbnMudHlwZSxcbiAgICAgICAgcm9vdEtleTogb3B0aW9ucy5yb290S2V5XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBleGVjdXRlQ29udGV4dHVhbFByb21wdChvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L2FpL2NvbnRleHR1YWwtcHJvbXB0YCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcInJvb206cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgcHJvbXB0OiBvcHRpb25zLnByb21wdCxcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIGJlZm9yZVNlbGVjdGlvbjogb3B0aW9ucy5jb250ZXh0LmJlZm9yZVNlbGVjdGlvbixcbiAgICAgICAgICBzZWxlY3Rpb246IG9wdGlvbnMuY29udGV4dC5zZWxlY3Rpb24sXG4gICAgICAgICAgYWZ0ZXJTZWxlY3Rpb246IG9wdGlvbnMuY29udGV4dC5hZnRlclNlbGVjdGlvblxuICAgICAgICB9LFxuICAgICAgICBwcmV2aW91czogb3B0aW9ucy5wcmV2aW91c1xuICAgICAgfSxcbiAgICAgIHsgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCB9XG4gICAgKTtcbiAgICBpZiAoIXJlc3VsdCB8fCByZXN1bHQuY29udGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNvbnRlbnQgcmV0dXJuZWQgZnJvbSBzZXJ2ZXJcIik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuY29udGVudFswXS50ZXh0O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxpc3RUZXh0VmVyc2lvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGh0dHBDbGllbnQuZ2V0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3ZlcnNpb25zYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIixcbiAgICAgICAgcm9vbUlkOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uczogcmVzdWx0LnZlcnNpb25zLm1hcCgoeyBjcmVhdGVkQXQsIC4uLnZlcnNpb24gfSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoY3JlYXRlZEF0KSxcbiAgICAgICAgICAuLi52ZXJzaW9uXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShyZXN1bHQubWV0YS5yZXF1ZXN0ZWRBdClcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxpc3RUZXh0VmVyc2lvbnNTaW5jZShvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaHR0cENsaWVudC5nZXQoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vdmVyc2lvbnMvZGVsdGFgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIHsgc2luY2U6IG9wdGlvbnMuc2luY2UudG9JU09TdHJpbmcoKSB9LFxuICAgICAgeyBzaWduYWw6IG9wdGlvbnMuc2lnbmFsIH1cbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uczogcmVzdWx0LnZlcnNpb25zLm1hcCgoeyBjcmVhdGVkQXQsIC4uLnZlcnNpb24gfSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoY3JlYXRlZEF0KSxcbiAgICAgICAgICAuLi52ZXJzaW9uXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShyZXN1bHQubWV0YS5yZXF1ZXN0ZWRBdClcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHN0cmVhbVN0b3JhZ2Uob3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGh0dHBDbGllbnQucmF3R2V0KFxuICAgICAgdXJsYC92Mi9jL3Jvb21zLyR7b3B0aW9ucy5yb29tSWR9L3N0b3JhZ2VgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHtcbiAgICAgICAgcmVxdWVzdGVkU2NvcGU6IFwicm9vbTpyZWFkXCIsXG4gICAgICAgIHJvb21JZDogb3B0aW9ucy5yb29tSWRcbiAgICAgIH0pXG4gICAgKTtcbiAgICByZXR1cm4gYXdhaXQgcmVzdWx0Lmpzb24oKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBzZW5kTWVzc2FnZXMob3B0aW9ucykge1xuICAgIHJldHVybiBodHRwQ2xpZW50LnJhd1Bvc3QoXG4gICAgICB1cmxgL3YyL2Mvcm9vbXMvJHtvcHRpb25zLnJvb21JZH0vc2VuZC1tZXNzYWdlYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7XG4gICAgICAgIHJlcXVlc3RlZFNjb3BlOiBcInJvb206cmVhZFwiLFxuICAgICAgICByb29tSWQ6IG9wdGlvbnMucm9vbUlkXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgbm9uY2U6IG9wdGlvbnMubm9uY2UsXG4gICAgICAgIG1lc3NhZ2VzOiBvcHRpb25zLm1lc3NhZ2VzXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRJbmJveE5vdGlmaWNhdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IFBBR0VfU0laRSA9IDUwO1xuICAgIGNvbnN0IGpzb24gPSBhd2FpdCBodHRwQ2xpZW50LmdldChcbiAgICAgIHVybGAvdjIvYy9pbmJveC1ub3RpZmljYXRpb25zYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7IHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIiB9KSxcbiAgICAgIHtcbiAgICAgICAgY3Vyc29yOiBvcHRpb25zPy5jdXJzb3IsXG4gICAgICAgIGxpbWl0OiBQQUdFX1NJWkVcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IGpzb24uaW5ib3hOb3RpZmljYXRpb25zLm1hcChcbiAgICAgICAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhXG4gICAgICApLFxuICAgICAgdGhyZWFkczoganNvbi50aHJlYWRzLm1hcChjb252ZXJ0VG9UaHJlYWREYXRhKSxcbiAgICAgIG5leHRDdXJzb3I6IGpzb24ubWV0YS5uZXh0Q3Vyc29yLFxuICAgICAgcmVxdWVzdGVkQXQ6IG5ldyBEYXRlKGpzb24ubWV0YS5yZXF1ZXN0ZWRBdClcbiAgICB9O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldEluYm94Tm90aWZpY2F0aW9uc1NpbmNlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgaHR0cENsaWVudC5nZXQoXG4gICAgICB1cmxgL3YyL2MvaW5ib3gtbm90aWZpY2F0aW9ucy9kZWx0YWAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSksXG4gICAgICB7IHNpbmNlOiBvcHRpb25zLnNpbmNlLnRvSVNPU3RyaW5nKCkgfSxcbiAgICAgIHsgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCB9XG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiB7XG4gICAgICAgIHVwZGF0ZWQ6IGpzb24uaW5ib3hOb3RpZmljYXRpb25zLm1hcChjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEpLFxuICAgICAgICBkZWxldGVkOiBqc29uLmRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICAgIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGVsZXRlSW5mb1xuICAgICAgICApXG4gICAgICB9LFxuICAgICAgdGhyZWFkczoge1xuICAgICAgICB1cGRhdGVkOiBqc29uLnRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERhdGEpLFxuICAgICAgICBkZWxldGVkOiBqc29uLmRlbGV0ZWRUaHJlYWRzLm1hcChjb252ZXJ0VG9UaHJlYWREZWxldGVJbmZvKVxuICAgICAgfSxcbiAgICAgIHJlcXVlc3RlZEF0OiBuZXcgRGF0ZShqc29uLm1ldGEucmVxdWVzdGVkQXQpXG4gICAgfTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRVbnJlYWRJbmJveE5vdGlmaWNhdGlvbnNDb3VudCgpIHtcbiAgICBjb25zdCB7IGNvdW50IH0gPSBhd2FpdCBodHRwQ2xpZW50LmdldChcbiAgICAgIHVybGAvdjIvYy9pbmJveC1ub3RpZmljYXRpb25zL2NvdW50YCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7IHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIiB9KVxuICAgICk7XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQoKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgdXJsYC92Mi9jL2luYm94LW5vdGlmaWNhdGlvbnMvcmVhZGAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSksXG4gICAgICB7XG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uSWRzOiBcImFsbFwiXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBtYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWRzKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5wb3N0KFxuICAgICAgdXJsYC92Mi9jL2luYm94LW5vdGlmaWNhdGlvbnMvcmVhZGAsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSksXG4gICAgICB7XG4gICAgICAgIGluYm94Tm90aWZpY2F0aW9uSWRzXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBjb25zdCBiYXRjaGVkTWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZCA9IG5ldyBCYXRjaChcbiAgICBhc3luYyAoYmF0Y2hlZEluYm94Tm90aWZpY2F0aW9uSWRzKSA9PiB7XG4gICAgICBjb25zdCBpbmJveE5vdGlmaWNhdGlvbklkcyA9IGJhdGNoZWRJbmJveE5vdGlmaWNhdGlvbklkcy5mbGF0KCk7XG4gICAgICBhd2FpdCBtYXJrSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWRzKTtcbiAgICAgIHJldHVybiBpbmJveE5vdGlmaWNhdGlvbklkcztcbiAgICB9LFxuICAgIHsgZGVsYXk6IDUwIH1cbiAgKTtcbiAgYXN5bmMgZnVuY3Rpb24gbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkKGluYm94Tm90aWZpY2F0aW9uSWQpIHtcbiAgICBhd2FpdCBiYXRjaGVkTWFya0luYm94Tm90aWZpY2F0aW9uc0FzUmVhZC5nZXQoaW5ib3hOb3RpZmljYXRpb25JZCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQWxsSW5ib3hOb3RpZmljYXRpb25zKCkge1xuICAgIGF3YWl0IGh0dHBDbGllbnQuZGVsZXRlKFxuICAgICAgdXJsYC92Mi9jL2luYm94LW5vdGlmaWNhdGlvbnNgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHsgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiIH0pXG4gICAgKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBkZWxldGVJbmJveE5vdGlmaWNhdGlvbihpbmJveE5vdGlmaWNhdGlvbklkKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5kZWxldGUoXG4gICAgICB1cmxgL3YyL2MvaW5ib3gtbm90aWZpY2F0aW9ucy8ke2luYm94Tm90aWZpY2F0aW9uSWR9YCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7IHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIiB9KVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VXNlck5vdGlmaWNhdGlvblNldHRpbmdzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5nZXQoXG4gICAgICB1cmxgL3YyL2Mvbm90aWZpY2F0aW9uLXNldHRpbmdzYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7IHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIiB9KSxcbiAgICAgIHZvaWQgMCxcbiAgICAgIHsgc2lnbmFsOiBvcHRpb25zPy5zaWduYWwgfVxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gdXBkYXRlVXNlck5vdGlmaWNhdGlvblNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQucG9zdChcbiAgICAgIHVybGAvdjIvYy9ub3RpZmljYXRpb24tc2V0dGluZ3NgLFxuICAgICAgYXdhaXQgYXV0aE1hbmFnZXIuZ2V0QXV0aFZhbHVlKHsgcmVxdWVzdGVkU2NvcGU6IFwiY29tbWVudHM6cmVhZFwiIH0pLFxuICAgICAgc2V0dGluZ3NcbiAgICApO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGdldFVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbChvcHRpb25zKSB7XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGlmIChvcHRpb25zPy5xdWVyeSkge1xuICAgICAgcXVlcnkgPSBvYmplY3RUb1F1ZXJ5KG9wdGlvbnMucXVlcnkpO1xuICAgIH1cbiAgICBjb25zdCBQQUdFX1NJWkUgPSA1MDtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgaHR0cENsaWVudC5nZXQoXG4gICAgICB1cmxgL3YyL2MvdGhyZWFkc2AsXG4gICAgICBhd2FpdCBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJjb21tZW50czpyZWFkXCIgfSksXG4gICAgICB7XG4gICAgICAgIGN1cnNvcjogb3B0aW9ucz8uY3Vyc29yLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgbGltaXQ6IFBBR0VfU0laRVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRocmVhZHM6IGpzb24udGhyZWFkcy5tYXAoY29udmVydFRvVGhyZWFkRGF0YSksXG4gICAgICBpbmJveE5vdGlmaWNhdGlvbnM6IGpzb24uaW5ib3hOb3RpZmljYXRpb25zLm1hcChcbiAgICAgICAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhXG4gICAgICApLFxuICAgICAgbmV4dEN1cnNvcjoganNvbi5tZXRhLm5leHRDdXJzb3IsXG4gICAgICByZXF1ZXN0ZWRBdDogbmV3IERhdGUoanNvbi5tZXRhLnJlcXVlc3RlZEF0KSxcbiAgICAgIHBlcm1pc3Npb25IaW50czoganNvbi5tZXRhLnBlcm1pc3Npb25IaW50c1xuICAgIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VXNlclRocmVhZHNTaW5jZV9leHBlcmltZW50YWwob3B0aW9ucykge1xuICAgIGNvbnN0IGpzb24gPSBhd2FpdCBodHRwQ2xpZW50LmdldChcbiAgICAgIHVybGAvdjIvYy90aHJlYWRzL2RlbHRhYCxcbiAgICAgIGF3YWl0IGF1dGhNYW5hZ2VyLmdldEF1dGhWYWx1ZSh7IHJlcXVlc3RlZFNjb3BlOiBcImNvbW1lbnRzOnJlYWRcIiB9KSxcbiAgICAgIHsgc2luY2U6IG9wdGlvbnMuc2luY2UudG9JU09TdHJpbmcoKSB9LFxuICAgICAgeyBzaWduYWw6IG9wdGlvbnMuc2lnbmFsIH1cbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICB0aHJlYWRzOiB7XG4gICAgICAgIHVwZGF0ZWQ6IGpzb24udGhyZWFkcy5tYXAoY29udmVydFRvVGhyZWFkRGF0YSksXG4gICAgICAgIGRlbGV0ZWQ6IGpzb24uZGVsZXRlZFRocmVhZHMubWFwKGNvbnZlcnRUb1RocmVhZERlbGV0ZUluZm8pXG4gICAgICB9LFxuICAgICAgaW5ib3hOb3RpZmljYXRpb25zOiB7XG4gICAgICAgIHVwZGF0ZWQ6IGpzb24uaW5ib3hOb3RpZmljYXRpb25zLm1hcChjb252ZXJ0VG9JbmJveE5vdGlmaWNhdGlvbkRhdGEpLFxuICAgICAgICBkZWxldGVkOiBqc29uLmRlbGV0ZWRJbmJveE5vdGlmaWNhdGlvbnMubWFwKFxuICAgICAgICAgIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGVsZXRlSW5mb1xuICAgICAgICApXG4gICAgICB9LFxuICAgICAgcmVxdWVzdGVkQXQ6IG5ldyBEYXRlKGpzb24ubWV0YS5yZXF1ZXN0ZWRBdCksXG4gICAgICBwZXJtaXNzaW9uSGludHM6IGpzb24ubWV0YS5wZXJtaXNzaW9uSGludHNcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgLy8gUm9vbSB0aHJlYWRzXG4gICAgZ2V0VGhyZWFkcyxcbiAgICBnZXRUaHJlYWRzU2luY2UsXG4gICAgY3JlYXRlVGhyZWFkLFxuICAgIGdldFRocmVhZCxcbiAgICBkZWxldGVUaHJlYWQsXG4gICAgZWRpdFRocmVhZE1ldGFkYXRhLFxuICAgIGNyZWF0ZUNvbW1lbnQsXG4gICAgZWRpdENvbW1lbnQsXG4gICAgZGVsZXRlQ29tbWVudCxcbiAgICBhZGRSZWFjdGlvbixcbiAgICByZW1vdmVSZWFjdGlvbixcbiAgICBtYXJrVGhyZWFkQXNSZXNvbHZlZCxcbiAgICBtYXJrVGhyZWFkQXNVbnJlc29sdmVkLFxuICAgIG1hcmtSb29tSW5ib3hOb3RpZmljYXRpb25Bc1JlYWQsXG4gICAgLy8gUm9vbSBub3RpZmljYXRpb25zXG4gICAgZ2V0Tm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgdXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgLy8gUm9vbSB0ZXh0IGVkaXRvclxuICAgIGNyZWF0ZVRleHRNZW50aW9uLFxuICAgIGRlbGV0ZVRleHRNZW50aW9uLFxuICAgIGdldFRleHRWZXJzaW9uLFxuICAgIGNyZWF0ZVRleHRWZXJzaW9uLFxuICAgIHJlcG9ydFRleHRFZGl0b3IsXG4gICAgbGlzdFRleHRWZXJzaW9ucyxcbiAgICBsaXN0VGV4dFZlcnNpb25zU2luY2UsXG4gICAgLy8gUm9vbSBhdHRhY2htZW50c1xuICAgIGdldEF0dGFjaG1lbnRVcmwsXG4gICAgdXBsb2FkQXR0YWNobWVudCxcbiAgICBnZXRPckNyZWF0ZUF0dGFjaG1lbnRVcmxzU3RvcmUsXG4gICAgLy8gUm9vbSBzdG9yYWdlXG4gICAgc3RyZWFtU3RvcmFnZSxcbiAgICBzZW5kTWVzc2FnZXMsXG4gICAgLy8gTm90aWZpY2F0aW9uXG4gICAgZ2V0SW5ib3hOb3RpZmljYXRpb25zLFxuICAgIGdldEluYm94Tm90aWZpY2F0aW9uc1NpbmNlLFxuICAgIGdldFVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50LFxuICAgIG1hcmtBbGxJbmJveE5vdGlmaWNhdGlvbnNBc1JlYWQsXG4gICAgbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkLFxuICAgIGRlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9ucyxcbiAgICBkZWxldGVJbmJveE5vdGlmaWNhdGlvbixcbiAgICBnZXRVc2VyTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgdXBkYXRlVXNlck5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgIC8vIFVzZXIgdGhyZWFkc1xuICAgIGdldFVzZXJUaHJlYWRzX2V4cGVyaW1lbnRhbCxcbiAgICBnZXRVc2VyVGhyZWFkc1NpbmNlX2V4cGVyaW1lbnRhbCxcbiAgICAvLyBBSVxuICAgIGV4ZWN1dGVDb250ZXh0dWFsUHJvbXB0XG4gIH07XG59XG5mdW5jdGlvbiBnZXRCZWFyZXJUb2tlbkZyb21BdXRoVmFsdWUoYXV0aFZhbHVlKSB7XG4gIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJwdWJsaWNcIikge1xuICAgIHJldHVybiBhdXRoVmFsdWUucHVibGljQXBpS2V5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhdXRoVmFsdWUudG9rZW4ucmF3O1xuICB9XG59XG52YXIgSHR0cENsaWVudCA9IGNsYXNzIHtcbiAgI2Jhc2VVcmw7XG4gICNmZXRjaFBvbHlmaWxsO1xuICBjb25zdHJ1Y3RvcihiYXNlVXJsLCBmZXRjaFBvbHlmaWxsKSB7XG4gICAgdGhpcy4jYmFzZVVybCA9IGJhc2VVcmw7XG4gICAgdGhpcy4jZmV0Y2hQb2x5ZmlsbCA9IGZldGNoUG9seWZpbGw7XG4gIH1cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFB1YmxpYyBtZXRob2RzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogQ29uc3RydWN0cyBhbmQgbWFrZXMgdGhlIEhUVFAgcmVxdWVzdCwgYnV0IGRvZXMgbm90IGhhbmRsZSB0aGUgcmVzcG9uc2UuXG4gICAqXG4gICAqIFRoaXMgaXMgd2hhdCAucmF3RmV0Y2goKSBkb2VzOiAgICDwn5GIIFRoaXMgbWV0aG9kIVxuICAgKiAgIDEuIFNldCBDb250ZW50LVR5cGUgaGVhZGVyXG4gICAqICAgMi4gU2V0IEF1dGhvcml6YXRpb24gaGVhZGVyXG4gICAqICAgMy4gQ2FsbCB0aGUgY2FsbGJhY2sgdG8gb2J0YWluIHRoZSBgYXV0aFZhbHVlYCB0byB1c2UgaW4gdGhlIEF1dGhvcml6YXRpb24gaGVhZGVyXG4gICAqXG4gICAqIFRoaXMgaXMgd2hhdCAuZmV0Y2goKSBkb2VzIE9OIFRPUCBvZiB0aGF0OlxuICAgKiAgIDQuIFBhcnNlIHJlc3BvbnNlIGJvZHkgYXMgSnNvblxuICAgKiAgIDUuIC4uLmJ1dCBzaWxlbnRseSByZXR1cm4gYHt9YCBpZiB0aGF0IHBhcnNpbmcgZmFpbHNcbiAgICogICA2LiBUaHJvdyBIdHRwRXJyb3IgaWYgcmVzcG9uc2UgaXMgYW4gZXJyb3JcbiAgICovXG4gIGFzeW5jICNyYXdGZXRjaChlbmRwb2ludCwgYXV0aFZhbHVlLCBvcHRpb25zLCBwYXJhbXMpIHtcbiAgICBpZiAoIWVuZHBvaW50LnN0YXJ0c1dpdGgoXCIvdjIvYy9cIikpIHtcbiAgICAgIHJhaXNlKFwiVGhpcyBjbGllbnQgY2FuIG9ubHkgYmUgdXNlZCB0byBtYWtlIC92Mi9jLyogcmVxdWVzdHNcIik7XG4gICAgfVxuICAgIGNvbnN0IHVybDIgPSB1cmxqb2luKHRoaXMuI2Jhc2VVcmwsIGVuZHBvaW50LCBwYXJhbXMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLiNmZXRjaFBvbHlmaWxsKHVybDIsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC8vIFRoZXNlIGhlYWRlcnMgYXJlIGRlZmF1bHQsIGJ1dCBjYW4gYmUgb3ZlcnJpZGVuIGJ5IGN1c3RvbSBoZWFkZXJzXG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgICAvLyBQb3NzaWJsZSBoZWFkZXIgb3ZlcnJpZGVzXG4gICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgIC8vIENhbm5vdCBiZSBvdmVycmlkZW4gYnkgY3VzdG9tIGhlYWRlcnNcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2dldEJlYXJlclRva2VuRnJvbUF1dGhWYWx1ZShhdXRoVmFsdWUpfWAsXG4gICAgICAgIFwiWC1MQi1DbGllbnRcIjogUEtHX1ZFUlNJT04gfHwgXCJkZXZcIlxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzLCBtYWtlcyB0aGUgSFRUUCByZXF1ZXN0LCBhbmQgaGFuZGxlcyB0aGUgcmVzcG9uc2UgYnkgcGFyc2luZ1xuICAgKiBKU09OIGFuZC9vciB0aHJvd2luZyBhbiBIdHRwRXJyb3IgaWYgaXQgZmFpbGVkLlxuICAgKlxuICAgKiBUaGlzIGlzIHdoYXQgLnJhd0ZldGNoKCkgZG9lczpcbiAgICogICAxLiBTZXQgQ29udGVudC1UeXBlIGhlYWRlclxuICAgKiAgIDIuIFNldCBBdXRob3JpemF0aW9uIGhlYWRlclxuICAgKiAgIDMuIENhbGwgdGhlIGNhbGxiYWNrIHRvIG9idGFpbiB0aGUgYGF1dGhWYWx1ZWAgdG8gdXNlIGluIHRoZSBBdXRob3JpemF0aW9uIGhlYWRlclxuICAgKlxuICAgKiBUaGlzIGlzIHdoYXQgLmZldGNoKCkgZG9lcyBPTiBUT1Agb2YgdGhhdDogICDwn5GIIFRoaXMgbWV0aG9kIVxuICAgKiAgIDQuIFBhcnNlIHJlc3BvbnNlIGJvZHkgYXMgSnNvblxuICAgKiAgIDUuIC4uLmJ1dCBzaWxlbnRseSByZXR1cm4gYHt9YCBpZiB0aGF0IHBhcnNpbmcgZmFpbHMgKPCfpJQpXG4gICAqICAgNi4gVGhyb3cgSHR0cEVycm9yIGlmIHJlc3BvbnNlIGlzIGFuIGVycm9yXG4gICAqL1xuICBhc3luYyAjZmV0Y2goZW5kcG9pbnQsIGF1dGhWYWx1ZSwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLiNyYXdGZXRjaChlbmRwb2ludCwgYXV0aFZhbHVlLCBvcHRpb25zLCBwYXJhbXMpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IGF3YWl0IEh0dHBFcnJvci5mcm9tUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH1cbiAgICBsZXQgYm9keTtcbiAgICB0cnkge1xuICAgICAgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGJvZHkgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2VzIGEgR0VUIHJlcXVlc3QgYW5kIHJldHVybnMgdGhlIHJhdyByZXNwb25zZS5cbiAgICogV29uJ3QgdGhyb3cgaWYgdGhlIHJlcG9uc2UgaXMgYSBub24tMnh4LlxuICAgKiBAZGVwcmVjYXRlZCBJZGVhbGx5LCB1c2UgLmdldCgpIGluc3RlYWQuXG4gICAqL1xuICBhc3luYyByYXdHZXQoZW5kcG9pbnQsIGF1dGhWYWx1ZSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuI3Jhd0ZldGNoKGVuZHBvaW50LCBhdXRoVmFsdWUsIG9wdGlvbnMsIHBhcmFtcyk7XG4gIH1cbiAgLyoqXG4gICAqIE1ha2VzIGEgUE9TVCByZXF1ZXN0IGFuZCByZXR1cm5zIHRoZSByYXcgcmVzcG9uc2UuXG4gICAqIFdvbid0IHRocm93IGlmIHRoZSByZXBvbnNlIGlzIGEgbm9uLTJ4eC5cbiAgICogQGRlcHJlY2F0ZWQgSWRlYWxseSwgdXNlIC5wb3N0KCkgaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIHJhd1Bvc3QoZW5kcG9pbnQsIGF1dGhWYWx1ZSwgYm9keSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLiNyYXdGZXRjaChlbmRwb2ludCwgYXV0aFZhbHVlLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogc3RyaW5naWZ5T3JMb2coYm9keSlcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgYSBERUxFVEUgcmVxdWVzdCBhbmQgcmV0dXJucyB0aGUgcmF3IHJlc3BvbnNlLlxuICAgKiBXb24ndCB0aHJvdyBpZiB0aGUgcmVwb25zZSBpcyBhIG5vbi0yeHguXG4gICAqIEBkZXByZWNhdGVkIElkZWFsbHksIHVzZSAuZGVsZXRlKCkgaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIHJhd0RlbGV0ZShlbmRwb2ludCwgYXV0aFZhbHVlKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuI3Jhd0ZldGNoKGVuZHBvaW50LCBhdXRoVmFsdWUsIHsgbWV0aG9kOiBcIkRFTEVURVwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyBhIEdFVCByZXF1ZXN0LCBhbmQgcmV0dXJuIHRoZSBKU09OIHJlc3BvbnNlLlxuICAgKiBXaWxsIHRocm93IGlmIHRoZSByZXBvbnNlIGlzIGEgbm9uLTJ4eC5cbiAgICovXG4gIGFzeW5jIGdldChlbmRwb2ludCwgYXV0aFZhbHVlLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy4jZmV0Y2goZW5kcG9pbnQsIGF1dGhWYWx1ZSwgb3B0aW9ucywgcGFyYW1zKTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgYSBQT1NUIHJlcXVlc3QsIGFuZCByZXR1cm4gdGhlIEpTT04gcmVzcG9uc2UuXG4gICAqIFdpbGwgdGhyb3cgaWYgdGhlIHJlcG9uc2UgaXMgYSBub24tMnh4LlxuICAgKi9cbiAgYXN5bmMgcG9zdChlbmRwb2ludCwgYXV0aFZhbHVlLCBib2R5LCBvcHRpb25zLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy4jZmV0Y2goXG4gICAgICBlbmRwb2ludCxcbiAgICAgIGF1dGhWYWx1ZSxcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogc3RyaW5naWZ5T3JMb2coYm9keSlcbiAgICAgIH0sXG4gICAgICBwYXJhbXNcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyBhIERFTEVURSByZXF1ZXN0LCBhbmQgcmV0dXJuIHRoZSBKU09OIHJlc3BvbnNlLlxuICAgKiBXaWxsIHRocm93IGlmIHRoZSByZXBvbnNlIGlzIGEgbm9uLTJ4eC5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZShlbmRwb2ludCwgYXV0aFZhbHVlKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuI2ZldGNoKGVuZHBvaW50LCBhdXRoVmFsdWUsIHsgbWV0aG9kOiBcIkRFTEVURVwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyBhIFBVVCByZXF1ZXN0IGZvciBhIEJsb2IgYm9keSwgYW5kIHJldHVybiB0aGUgSlNPTiByZXNwb25zZS5cbiAgICogV2lsbCB0aHJvdyBpZiB0aGUgcmVwb25zZSBpcyBhIG5vbi0yeHguXG4gICAqL1xuICBhc3luYyBwdXRCbG9iKGVuZHBvaW50LCBhdXRoVmFsdWUsIGJsb2IsIHBhcmFtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLiNmZXRjaChcbiAgICAgIGVuZHBvaW50LFxuICAgICAgYXV0aFZhbHVlLFxuICAgICAge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IGJsb2JcbiAgICAgIH0sXG4gICAgICBwYXJhbXNcbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL2Fzc2VydC50c1xuZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3ZhbHVlLCBlcnJtc2cpIHtcbiAgdGhyb3cgbmV3IEVycm9yKGVycm1zZyk7XG59XG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBlcnJtc2cpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoZXJybXNnKTtcbiAgICAgIGVyci5uYW1lID0gXCJBc3NlcnRpb24gZmFpbHVyZVwiO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbm4odmFsdWUsIGVycm1zZyA9IFwiRXhwZWN0ZWQgdmFsdWUgdG8gYmUgbm9uLW51bGxhYmxlXCIpIHtcbiAgYXNzZXJ0KHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAsIGVycm1zZyk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gc3JjL2xpYi9mc20udHNcbmZ1bmN0aW9uIGRpc3RhbmNlKHN0YXRlMSwgc3RhdGUyKSB7XG4gIGlmIChzdGF0ZTEgPT09IHN0YXRlMikge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgY29uc3QgY2h1bmtzMSA9IHN0YXRlMS5zcGxpdChcIi5cIik7XG4gIGNvbnN0IGNodW5rczIgPSBzdGF0ZTIuc3BsaXQoXCIuXCIpO1xuICBjb25zdCBtaW5MZW4gPSBNYXRoLm1pbihjaHVua3MxLmxlbmd0aCwgY2h1bmtzMi5sZW5ndGgpO1xuICBsZXQgc2hhcmVkID0gMDtcbiAgZm9yICg7IHNoYXJlZCA8IG1pbkxlbjsgc2hhcmVkKyspIHtcbiAgICBpZiAoY2h1bmtzMVtzaGFyZWRdICE9PSBjaHVua3MyW3NoYXJlZF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb25zdCB1cCA9IGNodW5rczEubGVuZ3RoIC0gc2hhcmVkO1xuICBjb25zdCBkb3duID0gY2h1bmtzMi5sZW5ndGggLSBzaGFyZWQ7XG4gIHJldHVybiBbdXAsIGRvd25dO1xufVxuZnVuY3Rpb24gcGF0dGVybnModGFyZ2V0U3RhdGUsIGxldmVscykge1xuICBjb25zdCBwYXJ0cyA9IHRhcmdldFN0YXRlLnNwbGl0KFwiLlwiKTtcbiAgaWYgKGxldmVscyA8IDEgfHwgbGV2ZWxzID4gcGFydHMubGVuZ3RoICsgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIGxldmVsc1wiKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaWYgKGxldmVscyA+IHBhcnRzLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wdXNoKFwiKlwiKTtcbiAgfVxuICBmb3IgKGxldCBpID0gcGFydHMubGVuZ3RoIC0gbGV2ZWxzICsgMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2xpY2UgPSBwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICBpZiAoc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnB1c2goc2xpY2Uuam9pbihcIi5cIikgKyBcIi4qXCIpO1xuICAgIH1cbiAgfVxuICByZXN1bHQucHVzaCh0YXJnZXRTdGF0ZSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgU2FmZUNvbnRleHQgPSBjbGFzcyB7XG4gICNjdXJyO1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsQ29udGV4dCkge1xuICAgIHRoaXMuI2N1cnIgPSBpbml0aWFsQ29udGV4dDtcbiAgfVxuICBnZXQgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycjtcbiAgfVxuICAvKipcbiAgICogQ2FsbCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHBhdGNoaW5nIG9mIHRoZSBjb250ZXh0LCBieVxuICAgKiBjYWxsaW5nIGBjb250ZXh0LnBhdGNoKClgLiBQYXRjaGluZyBpcyBvbmx5IGFsbG93ZWQgZm9yIHRoZSBkdXJhdGlvblxuICAgKiBvZiB0aGlzIHdpbmRvdy5cbiAgICovXG4gIGFsbG93UGF0Y2hpbmcoY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBsZXQgYWxsb3dlZCA9IHRydWU7XG4gICAgY29uc3QgcGF0Y2hhYmxlQ29udGV4dCA9IHtcbiAgICAgIC4uLnRoaXMuI2N1cnIsXG4gICAgICBwYXRjaChwYXRjaCkge1xuICAgICAgICBpZiAoYWxsb3dlZCkge1xuICAgICAgICAgIHNlbGYuI2N1cnIgPSBPYmplY3QuYXNzaWduKHt9LCBzZWxmLiNjdXJyLCBwYXRjaCk7XG4gICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIE9iamVjdC5lbnRyaWVzKHBhdGNoKSkge1xuICAgICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gcGFpcjtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IFwicGF0Y2hcIikge1xuICAgICAgICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vIGxvbmdlciBwYXRjaCBzdGFsZSBjb250ZXh0XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjYWxsYmFjayhwYXRjaGFibGVDb250ZXh0KTtcbiAgICBhbGxvd2VkID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9XG59O1xudmFyIG5leHRJZCA9IDE7XG52YXIgRlNNID0gY2xhc3Mge1xuICBpZDtcbiAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBzdGF0ZSBtYWNoaW5lIGlzIHN0aWxsIGJlaW5nIGNvbmZpZ3VyZWQsIGhhc1xuICAvLyBzdGFydGVkLCBvciBoYXMgdGVybWluYXRlZFxuICAjcnVubmluZ1N0YXRlO1xuICAjY3VycmVudENvbnRleHQ7XG4gICNzdGF0ZXM7XG4gICNjdXJyZW50U3RhdGVPck51bGw7XG4gICNhbGxvd2VkVHJhbnNpdGlvbnM7XG4gICNldmVudEh1YjtcbiAgZXZlbnRzO1xuICAvL1xuICAvLyBUaGUgY2xlYW51cCBzdGFjayBpcyBhIHN0YWNrIG9mIChvcHRpb25hbCkgY2FsbGJhY2sgZnVuY3Rpb25zIHRoYXQgd2lsbFxuICAvLyBiZSBydW4gd2hlbiBleGl0aW5nIHRoZSBjdXJyZW50IHN0YXRlLiBJZiBhIHN0YXRlIChvciBzdGF0ZSBncm91cCkgZG9lc1xuICAvLyBub3QgaGF2ZSBhbiBleGl0IGhhbmRsZXIsIHRoZW4gdGhlIGVudHJ5IGZvciB0aGF0IGxldmVsIG1heSBiZVxuICAvLyBgdW5kZWZpbmVkYCwgYnV0IHRoZXJlIHdpbGwgYmUgYW4gZXhwbGljaXQgZW50cnkgaW4gdGhlIHN0YWNrIGZvciBpdC5cbiAgLy9cbiAgLy8gVGhpcyB3aWxsIGFsd2F5cyBiZSB0cnVlOlxuICAvL1xuICAvLyAgIGNsZWFudXBTdGFjay5sZW5ndGggPT0gY3VycmVudFN0YXRlLnNwbGl0KCcuJykubGVuZ3RoICsgMVxuICAvL1xuICAvLyBFYWNoIHN0YWNrIGxldmVsIHJlcHJlc2VudHMgYSBkaWZmZXJlbnQgc3RhdGUgXCJncm91cFwiLlxuICAvL1xuICAvLyBGb3IgZXhhbXBsZSwgaWYgeW91IGFyZSBpbiBhIHN0YXRlIG5hbWVkIGBmb28uYmFyLnF1eGAsIHRoZW4gdGhlIHN0YWNrXG4gIC8vIHdpbGwgY29udGFpbiB0aGUgZXhpdCBoYW5kbGVyIGZvciBgZm9vLmJhci5xdXhgIChhdCB0aGUgdG9wKSwgdGhlblxuICAvLyBgZm9vLmJhci4qYCwgdGhlbiBgZm9vLipgLCBhbmQgZmluYWxseSwgYCpgLlxuICAvL1xuICAjY2xlYW51cFN0YWNrO1xuICAjZW50ZXJGbnM7XG4gIC8vIFVzZWQgdG8gcHJvdmlkZSBiZXR0ZXIgZXJyb3IgbWVzc2FnZXNcbiAgI2tub3duRXZlbnRUeXBlcztcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluaXRpYWwgc3RhdGUsIHdoaWNoIGlzIGRlZmluZWQgYnkgdGhlIGZpcnN0IGNhbGwgbWFkZSB0b1xuICAgKiAuYWRkU3RhdGUoKS5cbiAgICovXG4gIGdldCAjaW5pdGlhbFN0YXRlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI3N0YXRlcy52YWx1ZXMoKVtTeW1ib2wuaXRlcmF0b3JdKCkubmV4dCgpO1xuICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3RhdGVzIGRlZmluZWQgeWV0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgfVxuICBnZXQgY3VycmVudFN0YXRlKCkge1xuICAgIGlmICh0aGlzLiNjdXJyZW50U3RhdGVPck51bGwgPT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLiNydW5uaW5nU3RhdGUgPT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdGFydGVkIHlldFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgc3RvcHBlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRTdGF0ZU9yTnVsbDtcbiAgfVxuICAvKipcbiAgICogU3RhcnRzIHRoZSBtYWNoaW5lIGJ5IGVudGVyaW5nIHRoZSBpbml0aWFsIHN0YXRlLlxuICAgKi9cbiAgc3RhcnQoKSB7XG4gICAgaWYgKHRoaXMuI3J1bm5pbmdTdGF0ZSAhPT0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXRlIG1hY2hpbmUgaGFzIGFscmVhZHkgc3RhcnRlZFwiKTtcbiAgICB9XG4gICAgdGhpcy4jcnVubmluZ1N0YXRlID0gMSAvKiBTVEFSVEVEICovO1xuICAgIHRoaXMuI2N1cnJlbnRTdGF0ZU9yTnVsbCA9IHRoaXMuI2luaXRpYWxTdGF0ZTtcbiAgICB0aGlzLiNlbnRlcihudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU3RvcHMgdGhlIHN0YXRlIG1hY2hpbmUuIFN0b3BwaW5nIHRoZSBzdGF0ZSBtYWNoaW5lIHdpbGwgY2FsbCBleGl0XG4gICAqIGhhbmRsZXJzIGZvciB0aGUgY3VycmVudCBzdGF0ZSwgYnV0IG5vdCBlbnRlciBhIG5ldyBzdGF0ZS5cbiAgICovXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuI3J1bm5pbmdTdGF0ZSAhPT0gMSAvKiBTVEFSVEVEICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3RvcCBhIHN0YXRlIG1hY2hpbmUgdGhhdCBoYXNuJ3Qgc3RhcnRlZCB5ZXRcIik7XG4gICAgfVxuICAgIHRoaXMuI2V4aXQobnVsbCk7XG4gICAgdGhpcy4jcnVubmluZ1N0YXRlID0gMiAvKiBTVE9QUEVEICovO1xuICAgIHRoaXMuI2N1cnJlbnRTdGF0ZU9yTnVsbCA9IG51bGw7XG4gIH1cbiAgY29uc3RydWN0b3IoaW5pdGlhbENvbnRleHQpIHtcbiAgICB0aGlzLmlkID0gbmV4dElkKys7XG4gICAgdGhpcy4jcnVubmluZ1N0YXRlID0gMCAvKiBOT1RfU1RBUlRFRF9ZRVQgKi87XG4gICAgdGhpcy4jY3VycmVudFN0YXRlT3JOdWxsID0gbnVsbDtcbiAgICB0aGlzLiNzdGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuI2VudGVyRm5zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLiNjbGVhbnVwU3RhY2sgPSBbXTtcbiAgICB0aGlzLiNrbm93bkV2ZW50VHlwZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuI2FsbG93ZWRUcmFuc2l0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy4jY3VycmVudENvbnRleHQgPSBuZXcgU2FmZUNvbnRleHQoaW5pdGlhbENvbnRleHQpO1xuICAgIHRoaXMuI2V2ZW50SHViID0ge1xuICAgICAgZGlkUmVjZWl2ZUV2ZW50OiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAgIHdpbGxUcmFuc2l0aW9uOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAgIGRpZElnbm9yZUV2ZW50OiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAgIHdpbGxFeGl0U3RhdGU6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgICAgZGlkRW50ZXJTdGF0ZTogbWFrZUV2ZW50U291cmNlKClcbiAgICB9O1xuICAgIHRoaXMuZXZlbnRzID0ge1xuICAgICAgZGlkUmVjZWl2ZUV2ZW50OiB0aGlzLiNldmVudEh1Yi5kaWRSZWNlaXZlRXZlbnQub2JzZXJ2YWJsZSxcbiAgICAgIHdpbGxUcmFuc2l0aW9uOiB0aGlzLiNldmVudEh1Yi53aWxsVHJhbnNpdGlvbi5vYnNlcnZhYmxlLFxuICAgICAgZGlkSWdub3JlRXZlbnQ6IHRoaXMuI2V2ZW50SHViLmRpZElnbm9yZUV2ZW50Lm9ic2VydmFibGUsXG4gICAgICB3aWxsRXhpdFN0YXRlOiB0aGlzLiNldmVudEh1Yi53aWxsRXhpdFN0YXRlLm9ic2VydmFibGUsXG4gICAgICBkaWRFbnRlclN0YXRlOiB0aGlzLiNldmVudEh1Yi5kaWRFbnRlclN0YXRlLm9ic2VydmFibGVcbiAgICB9O1xuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiNjdXJyZW50Q29udGV4dC5jdXJyZW50O1xuICB9XG4gIC8qKlxuICAgKiBEZWZpbmUgYW4gZXhwbGljaXQgZmluaXRlIHN0YXRlIGluIHRoZSBzdGF0ZSBtYWNoaW5lLlxuICAgKi9cbiAgYWRkU3RhdGUoc3RhdGUpIHtcbiAgICBpZiAodGhpcy4jcnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH1cbiAgICB0aGlzLiNzdGF0ZXMuYWRkKHN0YXRlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvbkVudGVyKG5hbWVPclBhdHRlcm4sIGVudGVyRm4pIHtcbiAgICBpZiAodGhpcy4jcnVubmluZ1N0YXRlICE9PSAwIC8qIE5PVF9TVEFSVEVEX1lFVCAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBzdGFydGVkXCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jZW50ZXJGbnMuaGFzKG5hbWVPclBhdHRlcm4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIC8vIFRPRE8gV2UgX2N1cnJlbnRseV8gZG9uJ3Qgc3VwcG9ydCBtdWx0aXBsZSAub25FbnRlcnMoKSBmb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gc3RhdGUsIGJ1dCB0aGlzIGlzIG5vdCBhIGZ1bmRhbWVudGFsIGxpbWl0YXRpb24uIEp1c3Qgbm90XG4gICAgICAgIC8vIGltcGxlbWVudGVkIHlldC4gSWYgd2Ugd2FudGVkIHRvLCB3ZSBjb3VsZCBtYWtlIHRoaXMgYW4gYXJyYXkuXG4gICAgICAgIGBlbnRlci9leGl0IGZ1bmN0aW9uIGZvciAke25hbWVPclBhdHRlcm59IGFscmVhZHkgZXhpc3RzYFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy4jZW50ZXJGbnMuc2V0KG5hbWVPclBhdHRlcm4sIGVudGVyRm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgcHJvbWlzZS1iYXNlZCBzdGF0ZS4gV2hlbiB0aGUgc3RhdGUgaXMgZW50ZXJlZCwgdGhlIHByb21pc2UgaXNcbiAgICogY3JlYXRlZC4gV2hlbiB0aGUgcHJvbWlzZSByZXNvbHZlcywgdGhlIG1hY2hpbmUgd2lsbCB0cmFuc2l0aW9uIHRvIHRoZVxuICAgKiBwcm92aWRlZCBgb25PS2AgdGFyZ2V0IHN0YXRlLiBXaGVuIHRoZSBwcm9taXNlIHJlamVjdHMsIHRoZSBtYWNoaW5lIHdpbGxcbiAgICogdHJhbnNpdGlvbiB0byB0aGUgYG9uRXJyb3JgIHRhcmdldCBzdGF0ZS5cbiAgICpcbiAgICogT3B0aW9uYWxseSwgYSBgbWF4VGltZW91dGAgY2FuIGJlIHNldC4gSWYgdGhlIHRpbWVvdXQgaGFwcGVucyBiZWZvcmUgdGhlXG4gICAqIHByb21pc2UgaXMgc2V0dGxlZCwgdGhlbiB0aGUgbWFjaGluZSB3aWxsIGFsc28gdHJhbnNpdGlvbiB0byB0aGUgYG9uRXJyb3JgXG4gICAqIHRhcmdldCBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlT3JQYXR0ZXJuICBUaGUgc3RhdGUgbmFtZSwgb3Igc3RhdGUgZ3JvdXAgcGF0dGVybiBuYW1lLlxuICAgKiBAcGFyYW0gcHJvbWlzZUZuICAgICAgIFRoZSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gdGhlIHN0YXRlIGlzIGVudGVyZWQuXG4gICAqIEBwYXJhbSBvbk9LICAgICAgICAgICAgVGhlIHN0YXRlIHRvIHRyYW5zaXRpb24gdG8gd2hlbiB0aGUgcHJvbWlzZSByZXNvbHZlcy5cbiAgICogQHBhcmFtIG9uRXJyb3IgICAgICAgICBUaGUgc3RhdGUgdG8gdHJhbnNpdGlvbiB0byB3aGVuIHRoZSBwcm9taXNlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0cywgb3Igd2hlbiB0aGUgdGltZW91dCBoYXBwZW5zIGJlZm9yZSB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlIGhhcyBiZWVuIHNldHRsZWQuXG4gICAqIEBwYXJhbSBtYXhUaW1lb3V0ICAgICAgT3B0aW9uYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMuXG4gICAqXG4gICAqIFdoZW4gdGhlIHByb21pc2UgY2FsbGJhY2sgZnVuY3Rpb24gaXMgaW52b2tlZCwgaXQncyBwcm92aWRlZCB3aXRoIGFuXG4gICAqIEFib3J0U2lnbmFsICgybmQgYXJndW1lbnQpLlxuICAgKiBJZiBhIHN0YXRlIHRyYW5zaXRpb24gaGFwcGVucyB3aGlsZSB0aGUgcHJvbWlzZSBpcyBwZW5kaW5nIChmb3IgZXhhbXBsZSxcbiAgICogYW4gZXZlbnQsIG9yIGEgdGltZW91dCBoYXBwZW5zKSwgdGhlbiBhbiBhYm9ydCBzaWduYWwgd2lsbCBiZSB1c2VkIHRvXG4gICAqIGluZGljYXRlIHRoaXMuIEltcGxlbWVudGVycyBjYW4gdXNlIHRoaXMgYWJvcnQgc2lnbmFsIHRvIHRlcm1pbmF0ZSB0aGVcbiAgICogaW4tZmxpZ2h0IHByb21pc2UsIG9yIGlnbm9yZSBpdHMgcmVzdWx0cywgZXRjLlxuICAgKi9cbiAgb25FbnRlckFzeW5jKG5hbWVPclBhdHRlcm4sIHByb21pc2VGbiwgb25PSywgb25FcnJvciwgbWF4VGltZW91dCkge1xuICAgIHJldHVybiB0aGlzLm9uRW50ZXIobmFtZU9yUGF0dGVybiwgKCkgPT4ge1xuICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IG1heFRpbWVvdXQgPyBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgcmVhc29uID0gbmV3IEVycm9yKFwiVGltZWQgb3V0XCIpO1xuICAgICAgICB0aGlzLiN0cmFuc2l0aW9uKHsgdHlwZTogXCJBU1lOQ19FUlJPUlwiLCByZWFzb24gfSwgb25FcnJvcik7XG4gICAgICB9LCBtYXhUaW1lb3V0KSA6IHZvaWQgMDtcbiAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICB2b2lkIHByb21pc2VGbih0aGlzLiNjdXJyZW50Q29udGV4dC5jdXJyZW50LCBzaWduYWwpLnRoZW4oXG4gICAgICAgIC8vIE9uIE9LXG4gICAgICAgIChkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKCFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiN0cmFuc2l0aW9uKHsgdHlwZTogXCJBU1lOQ19PS1wiLCBkYXRhIH0sIG9uT0spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gT24gRXJyb3JcbiAgICAgICAgKHJlYXNvbikgPT4ge1xuICAgICAgICAgIGlmICghc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4jdHJhbnNpdGlvbih7IHR5cGU6IFwiQVNZTkNfRVJST1JcIiwgcmVhc29uIH0sIG9uRXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICAjZ2V0U3RhdGVzTWF0Y2hpbmcobmFtZU9yUGF0dGVybikge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICBpZiAobmFtZU9yUGF0dGVybiA9PT0gXCIqXCIpIHtcbiAgICAgIGZvciAoY29uc3Qgc3RhdGUgb2YgdGhpcy4jc3RhdGVzKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaChzdGF0ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuYW1lT3JQYXR0ZXJuLmVuZHNXaXRoKFwiLipcIikpIHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IG5hbWVPclBhdHRlcm4uc2xpY2UoMCwgLTEpO1xuICAgICAgZm9yIChjb25zdCBzdGF0ZSBvZiB0aGlzLiNzdGF0ZXMpIHtcbiAgICAgICAgaWYgKHN0YXRlLnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmFtZSA9IG5hbWVPclBhdHRlcm47XG4gICAgICBpZiAodGhpcy4jc3RhdGVzLmhhcyhuYW1lKSkge1xuICAgICAgICBtYXRjaGVzLnB1c2gobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzdGF0ZXMgbWF0Y2ggJHtKU09OLnN0cmluZ2lmeShuYW1lT3JQYXR0ZXJuKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cbiAgLyoqXG4gICAqIERlZmluZSBhbGwgYWxsb3dlZCBvdXRnb2luZyB0cmFuc2l0aW9ucyBmb3IgYSBzdGF0ZS5cbiAgICpcbiAgICogVGhlIHRhcmdldHMgZm9yIGVhY2ggZXZlbnQgY2FuIGJlIGRlZmluZWQgYXMgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRoZVxuICAgKiBuZXh0IHN0YXRlIHRvIHRyYW5zaXRpb24gdG8uIFRoZXNlIGZ1bmN0aW9ucyBjYW4gbG9vayBhdCB0aGUgYGV2ZW50YCBvclxuICAgKiBgY29udGV4dGAgcGFyYW1zIHRvIGNvbmRpdGlvbmFsbHkgZGVjaWRlIHdoaWNoIG5leHQgc3RhdGUgdG8gdHJhbnNpdGlvblxuICAgKiB0by5cbiAgICpcbiAgICogSWYgeW91IHNldCBpdCB0byBgbnVsbGAsIHRoZW4gdGhlIHRyYW5zaXRpb24gd2lsbCBiZSBleHBsaWNpdGx5IGZvcmJpZGRlblxuICAgKiBhbmQgdGhyb3cgYW4gZXJyb3IuIElmIHlvdSBkb24ndCBkZWZpbmUgYSB0YXJnZXQgZm9yIGEgdHJhbnNpdGlvbiwgdGhlblxuICAgKiBzdWNoIGV2ZW50cyB3aWxsIGdldCBpZ25vcmVkLlxuICAgKi9cbiAgYWRkVHJhbnNpdGlvbnMobmFtZU9yUGF0dGVybiwgbWFwcGluZykge1xuICAgIGlmICh0aGlzLiNydW5uaW5nU3RhdGUgIT09IDAgLyogTk9UX1NUQVJURURfWUVUICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc3JjU3RhdGUgb2YgdGhpcy4jZ2V0U3RhdGVzTWF0Y2hpbmcobmFtZU9yUGF0dGVybikpIHtcbiAgICAgIGxldCBtYXAgPSB0aGlzLiNhbGxvd2VkVHJhbnNpdGlvbnMuZ2V0KHNyY1N0YXRlKTtcbiAgICAgIGlmIChtYXAgPT09IHZvaWQgMCkge1xuICAgICAgICBtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNhbGxvd2VkVHJhbnNpdGlvbnMuc2V0KHNyY1N0YXRlLCBtYXApO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBbdHlwZSwgdGFyZ2V0X10gb2YgT2JqZWN0LmVudHJpZXMobWFwcGluZykpIHtcbiAgICAgICAgaWYgKG1hcC5oYXModHlwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVHJ5aW5nIHRvIHNldCB0cmFuc2l0aW9uIFwiJHt0eXBlfVwiIG9uIFwiJHtzcmNTdGF0ZX1cIiAodmlhIFwiJHtuYW1lT3JQYXR0ZXJufVwiKSwgYnV0IGEgdHJhbnNpdGlvbiBhbHJlYWR5IGV4aXN0cyB0aGVyZS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRfO1xuICAgICAgICB0aGlzLiNrbm93bkV2ZW50VHlwZXMuYWRkKHR5cGUpO1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRGbiA9IHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIiA/IHRhcmdldCA6ICgpID0+IHRhcmdldDtcbiAgICAgICAgICBtYXAuc2V0KHR5cGUsIHRhcmdldEZuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogTGlrZSBgLmFkZFRyYW5zaXRpb24oKWAsIGJ1dCB0YWtlcyBhbiAoYW5vbnltb3VzKSB0cmFuc2l0aW9uIHdoZW5ldmVyIHRoZVxuICAgKiB0aW1lciBmaXJlcy5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlT3JQYXR0ZXJuICBUaGUgc3RhdGUgbmFtZSwgb3Igc3RhdGUgZ3JvdXAgcGF0dGVybiBuYW1lLlxuICAgKiBAcGFyYW0gYWZ0ZXIgICAgICAgICAgIE51bWJlciBvZiBtaWxsaXNlY29uZHMgYWZ0ZXIgd2hpY2ggdG8gdGFrZSB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLiBJZiBpbiB0aGUgbWVhbiB0aW1lLCBhbm90aGVyIHRyYW5zaXRpb25cbiAgICogICAgICAgICAgICAgICAgICAgICAgICBpcyB0YWtlbiwgdGhlIHRpbWVyIHdpbGwgZ2V0IGNhbmNlbGxlZC5cbiAgICogQHBhcmFtIHRhcmdldCAgICAgICAgICBUaGUgdGFyZ2V0IHN0YXRlIHRvIGdvIHRvLlxuICAgKi9cbiAgYWRkVGltZWRUcmFuc2l0aW9uKHN0YXRlT3JQYXR0ZXJuLCBhZnRlcjIsIHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLm9uRW50ZXIoc3RhdGVPclBhdHRlcm4sICgpID0+IHtcbiAgICAgIGNvbnN0IG1zID0gdHlwZW9mIGFmdGVyMiA9PT0gXCJmdW5jdGlvblwiID8gYWZ0ZXIyKHRoaXMuI2N1cnJlbnRDb250ZXh0LmN1cnJlbnQpIDogYWZ0ZXIyO1xuICAgICAgY29uc3QgdGltZW91dElEID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuI3RyYW5zaXRpb24oeyB0eXBlOiBcIlRJTUVSXCIgfSwgdGFyZ2V0KTtcbiAgICAgIH0sIG1zKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICAjZ2V0VGFyZ2V0Rm4oZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsbG93ZWRUcmFuc2l0aW9ucy5nZXQodGhpcy5jdXJyZW50U3RhdGUpPy5nZXQoZXZlbnROYW1lKTtcbiAgfVxuICAvKipcbiAgICogRXhpdHMgdGhlIGN1cnJlbnQgc3RhdGUsIGFuZCBleGVjdXRlcyBhbnkgbmVjZXNzYXJ5IGNsZWFudXAgZnVuY3Rpb25zLlxuICAgKiBDYWxsIHRoaXMgYmVmb3JlIGNoYW5naW5nIHRoZSBjdXJyZW50IHN0YXRlIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0gbGV2ZWxzIERlZmluZXMgaG93IG1hbnkgXCJsZXZlbHNcIiBvZiBuZXN0aW5nIHdpbGwgYmVcbiAgICogZXhpdGVkLiBGb3IgZXhhbXBsZSwgaWYgeW91IHRyYW5zaXRpb24gZnJvbSBgZm9vLmJhci5xdXhgIHRvXG4gICAqIGBmb28uYmFyLmJhemAsIHRoZW4gdGhlIGxldmVsIGlzIDEuIEJ1dCBpZiB5b3UgdHJhbnNpdGlvbiBmcm9tXG4gICAqIGBmb28uYmFyLnF1eGAgdG8gYGJsYS5ibGFgLCB0aGVuIHRoZSBsZXZlbCBpcyAzLlxuICAgKiBJZiBgbnVsbGAsIGl0IHdpbGwgZXhpdCBhbGwgbGV2ZWxzLlxuICAgKi9cbiAgI2V4aXQobGV2ZWxzKSB7XG4gICAgdGhpcy4jZXZlbnRIdWIud2lsbEV4aXRTdGF0ZS5ub3RpZnkodGhpcy5jdXJyZW50U3RhdGUpO1xuICAgIHRoaXMuI2N1cnJlbnRDb250ZXh0LmFsbG93UGF0Y2hpbmcoKHBhdGNoYWJsZUNvbnRleHQpID0+IHtcbiAgICAgIGxldmVscyA9IGxldmVscyA/PyB0aGlzLiNjbGVhbnVwU3RhY2subGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbHM7IGkrKykge1xuICAgICAgICB0aGlzLiNjbGVhbnVwU3RhY2sucG9wKCk/LihwYXRjaGFibGVDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW50ZXJzIHRoZSBjdXJyZW50IHN0YXRlLCBhbmQgZXhlY3V0ZXMgYW55IG5lY2Vzc2FyeSBvbkVudGVyIGhhbmRsZXJzLlxuICAgKiBDYWxsIHRoaXMgZGlyZWN0bHkgX2FmdGVyXyBzZXR0aW5nIHRoZSBjdXJyZW50IHN0YXRlIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgKi9cbiAgI2VudGVyKGxldmVscykge1xuICAgIGNvbnN0IGVudGVyUGF0dGVybnMgPSBwYXR0ZXJucyhcbiAgICAgIHRoaXMuY3VycmVudFN0YXRlLFxuICAgICAgbGV2ZWxzID8/IHRoaXMuY3VycmVudFN0YXRlLnNwbGl0KFwiLlwiKS5sZW5ndGggKyAxXG4gICAgKTtcbiAgICB0aGlzLiNjdXJyZW50Q29udGV4dC5hbGxvd1BhdGNoaW5nKChwYXRjaGFibGVDb250ZXh0KSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgZW50ZXJQYXR0ZXJucykge1xuICAgICAgICBjb25zdCBlbnRlckZuID0gdGhpcy4jZW50ZXJGbnMuZ2V0KHBhdHRlcm4pO1xuICAgICAgICBjb25zdCBjbGVhbnVwRm4gPSBlbnRlckZuPy4ocGF0Y2hhYmxlQ29udGV4dCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYW51cEZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLiNjbGVhbnVwU3RhY2sucHVzaChjbGVhbnVwRm4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuI2NsZWFudXBTdGFjay5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy4jZXZlbnRIdWIuZGlkRW50ZXJTdGF0ZS5ub3RpZnkodGhpcy5jdXJyZW50U3RhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhbiBldmVudCB0byB0aGUgbWFjaGluZSwgd2hpY2ggbWF5IGNhdXNlIGFuIGludGVybmFsIHN0YXRlXG4gICAqIHRyYW5zaXRpb24gdG8gaGFwcGVuLiBXaGVuIHRoYXQgaGFwcGVucywgd2lsbCB0cmlnZ2VyIHNpZGUgZWZmZWN0cy5cbiAgICovXG4gIHNlbmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2tub3duRXZlbnRUeXBlcy5oYXMoZXZlbnQudHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBldmVudCAke0pTT04uc3RyaW5naWZ5KGV2ZW50LnR5cGUpfWApO1xuICAgIH1cbiAgICBpZiAodGhpcy4jcnVubmluZ1N0YXRlID09PSAyIC8qIFNUT1BQRUQgKi8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0Rm4gPSB0aGlzLiNnZXRUYXJnZXRGbihldmVudC50eXBlKTtcbiAgICBpZiAodGFyZ2V0Rm4gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuI3RyYW5zaXRpb24oZXZlbnQsIHRhcmdldEZuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZXZlbnRIdWIuZGlkSWdub3JlRXZlbnQubm90aWZ5KGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgI3RyYW5zaXRpb24oZXZlbnQsIHRhcmdldCkge1xuICAgIHRoaXMuI2V2ZW50SHViLmRpZFJlY2VpdmVFdmVudC5ub3RpZnkoZXZlbnQpO1xuICAgIGNvbnN0IG9sZFN0YXRlID0gdGhpcy5jdXJyZW50U3RhdGU7XG4gICAgY29uc3QgdGFyZ2V0Rm4gPSB0eXBlb2YgdGFyZ2V0ID09PSBcImZ1bmN0aW9uXCIgPyB0YXJnZXQgOiAoKSA9PiB0YXJnZXQ7XG4gICAgY29uc3QgbmV4dFRhcmdldCA9IHRhcmdldEZuKGV2ZW50LCB0aGlzLiNjdXJyZW50Q29udGV4dC5jdXJyZW50KTtcbiAgICBsZXQgbmV4dFN0YXRlO1xuICAgIGxldCBlZmZlY3RzID0gdm9pZCAwO1xuICAgIGlmIChuZXh0VGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICB0aGlzLiNldmVudEh1Yi5kaWRJZ25vcmVFdmVudC5ub3RpZnkoZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5leHRUYXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHRUYXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5leHRUYXJnZXQudGFyZ2V0O1xuICAgICAgZWZmZWN0cyA9IEFycmF5LmlzQXJyYXkobmV4dFRhcmdldC5lZmZlY3QpID8gbmV4dFRhcmdldC5lZmZlY3QgOiBbbmV4dFRhcmdldC5lZmZlY3RdO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI3N0YXRlcy5oYXMobmV4dFN0YXRlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG5leHQgc3RhdGUgbmFtZTogJHtKU09OLnN0cmluZ2lmeShuZXh0U3RhdGUpfWApO1xuICAgIH1cbiAgICB0aGlzLiNldmVudEh1Yi53aWxsVHJhbnNpdGlvbi5ub3RpZnkoeyBmcm9tOiBvbGRTdGF0ZSwgdG86IG5leHRTdGF0ZSB9KTtcbiAgICBjb25zdCBbdXAsIGRvd25dID0gZGlzdGFuY2UodGhpcy5jdXJyZW50U3RhdGUsIG5leHRTdGF0ZSk7XG4gICAgaWYgKHVwID4gMCkge1xuICAgICAgdGhpcy4jZXhpdCh1cCk7XG4gICAgfVxuICAgIHRoaXMuI2N1cnJlbnRTdGF0ZU9yTnVsbCA9IG5leHRTdGF0ZTtcbiAgICBpZiAoZWZmZWN0cyAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBlZmZlY3RzVG9SdW4gPSBlZmZlY3RzO1xuICAgICAgdGhpcy4jY3VycmVudENvbnRleHQuYWxsb3dQYXRjaGluZygocGF0Y2hhYmxlQ29udGV4dCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiBlZmZlY3RzVG9SdW4pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBlZmZlY3QocGF0Y2hhYmxlQ29udGV4dCwgZXZlbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRjaGFibGVDb250ZXh0LnBhdGNoKGVmZmVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGRvd24gPiAwKSB7XG4gICAgICB0aGlzLiNlbnRlcihkb3duKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9wcm90b2NvbC9TZXJ2ZXJNc2cudHNcbnZhciBTZXJ2ZXJNc2dDb2RlID0gLyogQF9fUFVSRV9fICovICgoU2VydmVyTXNnQ29kZTIpID0+IHtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVUERBVEVfUFJFU0VOQ0VcIl0gPSAxMDBdID0gXCJVUERBVEVfUFJFU0VOQ0VcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVU0VSX0pPSU5FRFwiXSA9IDEwMV0gPSBcIlVTRVJfSk9JTkVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVNFUl9MRUZUXCJdID0gMTAyXSA9IFwiVVNFUl9MRUZUXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiQlJPQURDQVNURURfRVZFTlRcIl0gPSAxMDNdID0gXCJCUk9BRENBU1RFRF9FVkVOVFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlJPT01fU1RBVEVcIl0gPSAxMDRdID0gXCJST09NX1NUQVRFXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiSU5JVElBTF9TVE9SQUdFX1NUQVRFXCJdID0gMjAwXSA9IFwiSU5JVElBTF9TVE9SQUdFX1NUQVRFXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVVBEQVRFX1NUT1JBR0VcIl0gPSAyMDFdID0gXCJVUERBVEVfU1RPUkFHRVwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlJFSkVDVF9TVE9SQUdFX09QXCJdID0gMjk5XSA9IFwiUkVKRUNUX1NUT1JBR0VfT1BcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJVUERBVEVfWURPQ1wiXSA9IDMwMF0gPSBcIlVQREFURV9ZRE9DXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVEhSRUFEX0NSRUFURURcIl0gPSA0MDBdID0gXCJUSFJFQURfQ1JFQVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIlRIUkVBRF9ERUxFVEVEXCJdID0gNDA3XSA9IFwiVEhSRUFEX0RFTEVURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJUSFJFQURfTUVUQURBVEFfVVBEQVRFRFwiXSA9IDQwMV0gPSBcIlRIUkVBRF9NRVRBREFUQV9VUERBVEVEXCI7XG4gIFNlcnZlck1zZ0NvZGUyW1NlcnZlck1zZ0NvZGUyW1wiVEhSRUFEX1VQREFURURcIl0gPSA0MDhdID0gXCJUSFJFQURfVVBEQVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfQ1JFQVRFRFwiXSA9IDQwMl0gPSBcIkNPTU1FTlRfQ1JFQVRFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfRURJVEVEXCJdID0gNDAzXSA9IFwiQ09NTUVOVF9FRElURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX0RFTEVURURcIl0gPSA0MDRdID0gXCJDT01NRU5UX0RFTEVURURcIjtcbiAgU2VydmVyTXNnQ29kZTJbU2VydmVyTXNnQ29kZTJbXCJDT01NRU5UX1JFQUNUSU9OX0FEREVEXCJdID0gNDA1XSA9IFwiQ09NTUVOVF9SRUFDVElPTl9BRERFRFwiO1xuICBTZXJ2ZXJNc2dDb2RlMltTZXJ2ZXJNc2dDb2RlMltcIkNPTU1FTlRfUkVBQ1RJT05fUkVNT1ZFRFwiXSA9IDQwNl0gPSBcIkNPTU1FTlRfUkVBQ1RJT05fUkVNT1ZFRFwiO1xuICByZXR1cm4gU2VydmVyTXNnQ29kZTI7XG59KShTZXJ2ZXJNc2dDb2RlIHx8IHt9KTtcblxuLy8gc3JjL3R5cGVzL0lXZWJTb2NrZXQudHNcbnZhciBXZWJzb2NrZXRDbG9zZUNvZGVzID0gLyogQF9fUFVSRV9fICovICgoV2Vic29ja2V0Q2xvc2VDb2RlczIpID0+IHtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJDTE9TRV9OT1JNQUxcIl0gPSAxZTNdID0gXCJDTE9TRV9OT1JNQUxcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJDTE9TRV9BQk5PUk1BTFwiXSA9IDEwMDZdID0gXCJDTE9TRV9BQk5PUk1BTFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIlVORVhQRUNURURfQ09ORElUSU9OXCJdID0gMTAxMV0gPSBcIlVORVhQRUNURURfQ09ORElUSU9OXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiVFJZX0FHQUlOX0xBVEVSXCJdID0gMTAxM10gPSBcIlRSWV9BR0FJTl9MQVRFUlwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIklOVkFMSURfTUVTU0FHRV9GT1JNQVRcIl0gPSA0ZTNdID0gXCJJTlZBTElEX01FU1NBR0VfRk9STUFUXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTk9UX0FMTE9XRURcIl0gPSA0MDAxXSA9IFwiTk9UX0FMTE9XRURcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9TRUNPTkRTXCJdID0gNDAwMl0gPSBcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX1NFQ09ORFNcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNcIl0gPSA0MDAzXSA9IFwiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfREFZX1BFUl9BUFBcIl0gPSA0MDA0XSA9IFwiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfREFZX1BFUl9BUFBcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNfUEVSX1JPT01cIl0gPSA0MDA1XSA9IFwiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TX1BFUl9ST09NXCI7XG4gIFdlYnNvY2tldENsb3NlQ29kZXMyW1dlYnNvY2tldENsb3NlQ29kZXMyW1wiUk9PTV9JRF9VUERBVEVEXCJdID0gNDAwNl0gPSBcIlJPT01fSURfVVBEQVRFRFwiO1xuICBXZWJzb2NrZXRDbG9zZUNvZGVzMltXZWJzb2NrZXRDbG9zZUNvZGVzMltcIktJQ0tFRFwiXSA9IDQxMDBdID0gXCJLSUNLRURcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJUT0tFTl9FWFBJUkVEXCJdID0gNDEwOV0gPSBcIlRPS0VOX0VYUElSRURcIjtcbiAgV2Vic29ja2V0Q2xvc2VDb2RlczJbV2Vic29ja2V0Q2xvc2VDb2RlczJbXCJDTE9TRV9XSVRIT1VUX1JFVFJZXCJdID0gNDk5OV0gPSBcIkNMT1NFX1dJVEhPVVRfUkVUUllcIjtcbiAgcmV0dXJuIFdlYnNvY2tldENsb3NlQ29kZXMyO1xufSkoV2Vic29ja2V0Q2xvc2VDb2RlcyB8fCB7fSk7XG5mdW5jdGlvbiBzaG91bGREaXNjb25uZWN0KGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDQ5OTkgLyogQ0xPU0VfV0lUSE9VVF9SRVRSWSAqLyB8fCBjb2RlID49IDRlMyAmJiBjb2RlIDwgNDEwMDtcbn1cbmZ1bmN0aW9uIHNob3VsZFJlYXV0aChjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDQxMDAgJiYgY29kZSA8IDQyMDA7XG59XG5mdW5jdGlvbiBzaG91bGRSZXRyeVdpdGhvdXRSZWF1dGgoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gMTAxMyAvKiBUUllfQUdBSU5fTEFURVIgKi8gfHwgY29kZSA+PSA0MjAwICYmIGNvZGUgPCA0MzAwO1xufVxuXG4vLyBzcmMvY29ubmVjdGlvbi50c1xuZnVuY3Rpb24gaXNJZGxlKHN0YXR1cykge1xuICByZXR1cm4gc3RhdHVzID09PSBcImluaXRpYWxcIiB8fCBzdGF0dXMgPT09IFwiZGlzY29ubmVjdGVkXCI7XG59XG5mdW5jdGlvbiB0b05ld0Nvbm5lY3Rpb25TdGF0dXMobWFjaGluZSkge1xuICBjb25zdCBzdGF0ZSA9IG1hY2hpbmUuY3VycmVudFN0YXRlO1xuICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgY2FzZSBcIkBvay5jb25uZWN0ZWRcIjpcbiAgICBjYXNlIFwiQG9rLmF3YWl0aW5nLXBvbmdcIjpcbiAgICAgIHJldHVybiBcImNvbm5lY3RlZFwiO1xuICAgIGNhc2UgXCJAaWRsZS5pbml0aWFsXCI6XG4gICAgICByZXR1cm4gXCJpbml0aWFsXCI7XG4gICAgY2FzZSBcIkBhdXRoLmJ1c3lcIjpcbiAgICBjYXNlIFwiQGF1dGguYmFja29mZlwiOlxuICAgIGNhc2UgXCJAY29ubmVjdGluZy5idXN5XCI6XG4gICAgY2FzZSBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIjpcbiAgICBjYXNlIFwiQGlkbGUuem9tYmllXCI6XG4gICAgICByZXR1cm4gbWFjaGluZS5jb250ZXh0LnN1Y2Nlc3NDb3VudCA+IDAgPyBcInJlY29ubmVjdGluZ1wiIDogXCJjb25uZWN0aW5nXCI7XG4gICAgY2FzZSBcIkBpZGxlLmZhaWxlZFwiOlxuICAgICAgcmV0dXJuIFwiZGlzY29ubmVjdGVkXCI7XG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHN0YXRlLCBcIlVua25vd24gc3RhdGVcIik7XG4gIH1cbn1cbnZhciBCQUNLT0ZGX0RFTEFZUyA9IFsyNTAsIDUwMCwgMWUzLCAyZTMsIDRlMywgOGUzLCAxZTRdO1xudmFyIFJFU0VUX0RFTEFZID0gQkFDS09GRl9ERUxBWVNbMF0gLSAxO1xudmFyIEJBQ0tPRkZfREVMQVlTX1NMT1cgPSBbMmUzLCAzZTQsIDZlNCwgM2U1XTtcbnZhciBIRUFSVEJFQVRfSU5URVJWQUwgPSAzZTQ7XG52YXIgUE9OR19USU1FT1VUID0gMmUzO1xudmFyIEFVVEhfVElNRU9VVCA9IDFlNDtcbnZhciBTT0NLRVRfQ09OTkVDVF9USU1FT1VUID0gMWU0O1xudmFyIFN0b3BSZXRyeWluZyA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihyZWFzb24pO1xuICB9XG59O1xuZnVuY3Rpb24gbmV4dEJhY2tvZmZEZWxheShjdXJyZW50RGVsYXksIGRlbGF5cykge1xuICByZXR1cm4gZGVsYXlzLmZpbmQoKGRlbGF5KSA9PiBkZWxheSA+IGN1cnJlbnREZWxheSkgPz8gZGVsYXlzW2RlbGF5cy5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGluY3JlYXNlQmFja29mZkRlbGF5KGNvbnRleHQpIHtcbiAgY29udGV4dC5wYXRjaCh7XG4gICAgYmFja29mZkRlbGF5OiBuZXh0QmFja29mZkRlbGF5KGNvbnRleHQuYmFja29mZkRlbGF5LCBCQUNLT0ZGX0RFTEFZUylcbiAgfSk7XG59XG5mdW5jdGlvbiBpbmNyZWFzZUJhY2tvZmZEZWxheUFnZ3Jlc3NpdmVseShjb250ZXh0KSB7XG4gIGNvbnRleHQucGF0Y2goe1xuICAgIGJhY2tvZmZEZWxheTogbmV4dEJhY2tvZmZEZWxheShjb250ZXh0LmJhY2tvZmZEZWxheSwgQkFDS09GRl9ERUxBWVNfU0xPVylcbiAgfSk7XG59XG5mdW5jdGlvbiByZXNldFN1Y2Nlc3NDb3VudChjb250ZXh0KSB7XG4gIGNvbnRleHQucGF0Y2goeyBzdWNjZXNzQ291bnQ6IDAgfSk7XG59XG5mdW5jdGlvbiBsb2cobGV2ZWwsIG1lc3NhZ2UpIHtcbiAgY29uc3QgbG9nZ2VyID0gbGV2ZWwgPT09IDIgLyogRVJST1IgKi8gPyBlcnJvcjIgOiBsZXZlbCA9PT0gMSAvKiBXQVJOICovID8gd2FybiA6IChcbiAgICAvKiBibGFjayBob2xlICovXG4gICAgKCkgPT4ge1xuICAgIH1cbiAgKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsb2dnZXIobWVzc2FnZSk7XG4gIH07XG59XG5mdW5jdGlvbiBsb2dQcmVtYXR1cmVFcnJvck9yQ2xvc2VFdmVudChlKSB7XG4gIGNvbnN0IGNvbm4gPSBcIkNvbm5lY3Rpb24gdG8gTGl2ZWJsb2NrcyB3ZWJzb2NrZXQgc2VydmVyXCI7XG4gIHJldHVybiAoY3R4KSA9PiB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgd2FybihgJHtjb25ufSBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQuICR7U3RyaW5nKGUpfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFxuICAgICAgICBpc0Nsb3NlRXZlbnQoZSkgPyBgJHtjb25ufSBjbG9zZWQgcHJlbWF0dXJlbHkgKGNvZGU6ICR7ZS5jb2RlfSkuIFJldHJ5aW5nIGluICR7Y3R4LmJhY2tvZmZEZWxheX1tcy5gIDogYCR7Y29ubn0gY291bGQgbm90IGJlIGVzdGFibGlzaGVkLmBcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbG9nQ2xvc2VFdmVudChldmVudCkge1xuICBjb25zdCBkZXRhaWxzID0gW2Bjb2RlOiAke2V2ZW50LmNvZGV9YF07XG4gIGlmIChldmVudC5yZWFzb24pIHtcbiAgICBkZXRhaWxzLnB1c2goYHJlYXNvbjogJHtldmVudC5yZWFzb259YCk7XG4gIH1cbiAgcmV0dXJuIChjdHgpID0+IHtcbiAgICB3YXJuKFxuICAgICAgYENvbm5lY3Rpb24gdG8gTGl2ZWJsb2NrcyB3ZWJzb2NrZXQgc2VydmVyIGNsb3NlZCAoJHtkZXRhaWxzLmpvaW4oXCIsIFwiKX0pLiBSZXRyeWluZyBpbiAke2N0eC5iYWNrb2ZmRGVsYXl9bXMuYFxuICAgICk7XG4gIH07XG59XG52YXIgbG9nUGVybWFuZW50Q2xvc2UgPSBsb2coXG4gIDEgLyogV0FSTiAqLyxcbiAgXCJDb25uZWN0aW9uIHRvIFdlYlNvY2tldCBjbG9zZWQgcGVybWFuZW50bHkuIFdvbid0IHJldHJ5LlwiXG4pO1xuZnVuY3Rpb24gaXNDbG9zZUV2ZW50KGVycm9yMykge1xuICByZXR1cm4gIShlcnJvcjMgaW5zdGFuY2VvZiBFcnJvcikgJiYgZXJyb3IzLnR5cGUgPT09IFwiY2xvc2VcIjtcbn1cbmZ1bmN0aW9uIGVuYWJsZVRyYWNpbmcobWFjaGluZSkge1xuICBjb25zdCBzdGFydCA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICBmdW5jdGlvbiBsb2cyKC4uLmFyZ3MpIHtcbiAgICB3YXJuKFxuICAgICAgYCR7KCgoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0KSAvIDFlMykudG9GaXhlZCgyKX0gW0ZTTSAjJHttYWNoaW5lLmlkfV1gLFxuICAgICAgLi4uYXJnc1xuICAgICk7XG4gIH1cbiAgY29uc3QgdW5zdWJzID0gW1xuICAgIG1hY2hpbmUuZXZlbnRzLmRpZFJlY2VpdmVFdmVudC5zdWJzY3JpYmUoKGUpID0+IGxvZzIoYEV2ZW50ICR7ZS50eXBlfWApKSxcbiAgICBtYWNoaW5lLmV2ZW50cy53aWxsVHJhbnNpdGlvbi5zdWJzY3JpYmUoXG4gICAgICAoeyBmcm9tLCB0byB9KSA9PiBsb2cyKFwiVHJhbnNpdGlvbmluZ1wiLCBmcm9tLCBcIlxcdTIxOTJcIiwgdG8pXG4gICAgKSxcbiAgICBtYWNoaW5lLmV2ZW50cy5kaWRJZ25vcmVFdmVudC5zdWJzY3JpYmUoXG4gICAgICAoZSkgPT4gbG9nMihcIklnbm9yZWQgZXZlbnRcIiwgZS50eXBlLCBlLCBcIihjdXJyZW50IHN0YXRlIHdvbid0IGhhbmRsZSBpdClcIilcbiAgICApXG4gICAgLy8gbWFjaGluZS5ldmVudHMud2lsbEV4aXRTdGF0ZS5zdWJzY3JpYmUoKHMpID0+IGxvZyhcIkV4aXRpbmcgc3RhdGVcIiwgcykpLFxuICAgIC8vIG1hY2hpbmUuZXZlbnRzLmRpZEVudGVyU3RhdGUuc3Vic2NyaWJlKChzKSA9PiBsb2coXCJFbnRlcmluZyBzdGF0ZVwiLCBzKSksXG4gIF07XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZm9yIChjb25zdCB1bnN1YiBvZiB1bnN1YnMpIHtcbiAgICAgIHVuc3ViKCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZGVmaW5lQ29ubmVjdGl2aXR5RXZlbnRzKG1hY2hpbmUpIHtcbiAgY29uc3Qgc3RhdHVzRGlkQ2hhbmdlID0gbWFrZUV2ZW50U291cmNlKCk7XG4gIGNvbnN0IGRpZENvbm5lY3QgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgY29uc3QgZGlkRGlzY29ubmVjdCA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBsZXQgbGFzdFN0YXR1cyA9IG51bGw7XG4gIGNvbnN0IHVuc3Vic2NyaWJlID0gbWFjaGluZS5ldmVudHMuZGlkRW50ZXJTdGF0ZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJTdGF0dXMgPSB0b05ld0Nvbm5lY3Rpb25TdGF0dXMobWFjaGluZSk7XG4gICAgaWYgKGN1cnJTdGF0dXMgIT09IGxhc3RTdGF0dXMpIHtcbiAgICAgIHN0YXR1c0RpZENoYW5nZS5ub3RpZnkoY3VyclN0YXR1cyk7XG4gICAgfVxuICAgIGlmIChsYXN0U3RhdHVzID09PSBcImNvbm5lY3RlZFwiICYmIGN1cnJTdGF0dXMgIT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIGRpZERpc2Nvbm5lY3Qubm90aWZ5KCk7XG4gICAgfSBlbHNlIGlmIChsYXN0U3RhdHVzICE9PSBcImNvbm5lY3RlZFwiICYmIGN1cnJTdGF0dXMgPT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgIGRpZENvbm5lY3Qubm90aWZ5KCk7XG4gICAgfVxuICAgIGxhc3RTdGF0dXMgPSBjdXJyU3RhdHVzO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXNEaWRDaGFuZ2U6IHN0YXR1c0RpZENoYW5nZS5vYnNlcnZhYmxlLFxuICAgIGRpZENvbm5lY3Q6IGRpZENvbm5lY3Qub2JzZXJ2YWJsZSxcbiAgICBkaWREaXNjb25uZWN0OiBkaWREaXNjb25uZWN0Lm9ic2VydmFibGUsXG4gICAgdW5zdWJzY3JpYmVcbiAgfTtcbn1cbnZhciBhc3NpZ24gPSAocGF0Y2gpID0+IChjdHgpID0+IGN0eC5wYXRjaChwYXRjaCk7XG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uU3RhdGVNYWNoaW5lKGRlbGVnYXRlcywgb3B0aW9ucykge1xuICBjb25zdCBvbk1lc3NhZ2UgPSBtYWtlQnVmZmVyYWJsZUV2ZW50U291cmNlKCk7XG4gIG9uTWVzc2FnZS5wYXVzZSgpO1xuICBjb25zdCBvbkNvbm5lY3Rpb25FcnJvciA9IG1ha2VFdmVudFNvdXJjZSgpO1xuICBmdW5jdGlvbiBmaXJlRXJyb3JFdmVudChtZXNzYWdlLCBjb2RlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG9uQ29ubmVjdGlvbkVycm9yLm5vdGlmeSh7IG1lc3NhZ2UsIGNvZGUgfSk7XG4gICAgfTtcbiAgfVxuICBjb25zdCBpbml0aWFsQ29udGV4dCA9IHtcbiAgICBzdWNjZXNzQ291bnQ6IDAsXG4gICAgYXV0aFZhbHVlOiBudWxsLFxuICAgIHNvY2tldDogbnVsbCxcbiAgICBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZXG4gIH07XG4gIGNvbnN0IG1hY2hpbmUgPSBuZXcgRlNNKGluaXRpYWxDb250ZXh0KS5hZGRTdGF0ZShcIkBpZGxlLmluaXRpYWxcIikuYWRkU3RhdGUoXCJAaWRsZS5mYWlsZWRcIikuYWRkU3RhdGUoXCJAaWRsZS56b21iaWVcIikuYWRkU3RhdGUoXCJAYXV0aC5idXN5XCIpLmFkZFN0YXRlKFwiQGF1dGguYmFja29mZlwiKS5hZGRTdGF0ZShcIkBjb25uZWN0aW5nLmJ1c3lcIikuYWRkU3RhdGUoXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIpLmFkZFN0YXRlKFwiQG9rLmNvbm5lY3RlZFwiKS5hZGRTdGF0ZShcIkBvay5hd2FpdGluZy1wb25nXCIpO1xuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiKlwiLCB7XG4gICAgUkVDT05ORUNUOiB7XG4gICAgICB0YXJnZXQ6IFwiQGF1dGguYmFja29mZlwiLFxuICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIHJlc2V0U3VjY2Vzc0NvdW50XVxuICAgIH0sXG4gICAgRElTQ09OTkVDVDogXCJAaWRsZS5pbml0aWFsXCJcbiAgfSk7XG4gIG1hY2hpbmUub25FbnRlcihcIkBpZGxlLipcIiwgcmVzZXRTdWNjZXNzQ291bnQpLmFkZFRyYW5zaXRpb25zKFwiQGlkbGUuKlwiLCB7XG4gICAgQ09OTkVDVDogKF8sIGN0eCkgPT4gKFxuICAgICAgLy8gSWYgd2Ugc3RpbGwgaGF2ZSBhIGtub3duIGF1dGhWYWx1ZSwgdHJ5IHRvIHJlY29ubmVjdCB0byB0aGUgc29ja2V0IGRpcmVjdGx5LFxuICAgICAgLy8gb3RoZXJ3aXNlLCB0cnkgdG8gb2J0YWluIGEgbmV3IGF1dGhWYWx1ZVxuICAgICAgY3R4LmF1dGhWYWx1ZSAhPT0gbnVsbCA/IFwiQGNvbm5lY3RpbmcuYnVzeVwiIDogXCJAYXV0aC5idXN5XCJcbiAgICApXG4gIH0pO1xuICBtYWNoaW5lLmFkZFRyYW5zaXRpb25zKFwiQGF1dGguYmFja29mZlwiLCB7XG4gICAgTkFWSUdBVE9SX09OTElORToge1xuICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJ1c3lcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHsgYmFja29mZkRlbGF5OiBSRVNFVF9ERUxBWSB9KVxuICAgIH1cbiAgfSkuYWRkVGltZWRUcmFuc2l0aW9uKFxuICAgIFwiQGF1dGguYmFja29mZlwiLFxuICAgIChjdHgpID0+IGN0eC5iYWNrb2ZmRGVsYXksXG4gICAgXCJAYXV0aC5idXN5XCJcbiAgKS5vbkVudGVyQXN5bmMoXG4gICAgXCJAYXV0aC5idXN5XCIsXG4gICAgKCkgPT4gd2l0aFRpbWVvdXQoXG4gICAgICBkZWxlZ2F0ZXMuYXV0aGVudGljYXRlKCksXG4gICAgICBBVVRIX1RJTUVPVVQsXG4gICAgICBcIlRpbWVkIG91dCBkdXJpbmcgYXV0aFwiXG4gICAgKSxcbiAgICAvLyBPbiBzdWNjZXNzZnVsIGF1dGhlbnRpY2F0aW9uXG4gICAgKG9rRXZlbnQpID0+ICh7XG4gICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgICAgZWZmZWN0OiBhc3NpZ24oe1xuICAgICAgICBhdXRoVmFsdWU6IG9rRXZlbnQuZGF0YVxuICAgICAgfSlcbiAgICB9KSxcbiAgICAvLyBBdXRoIGZhaWxlZFxuICAgIChmYWlsZWRFdmVudCkgPT4ge1xuICAgICAgaWYgKGZhaWxlZEV2ZW50LnJlYXNvbiBpbnN0YW5jZW9mIFN0b3BSZXRyeWluZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgIGxvZygyIC8qIEVSUk9SICovLCBmYWlsZWRFdmVudC5yZWFzb24ubWVzc2FnZSksXG4gICAgICAgICAgICBmaXJlRXJyb3JFdmVudChmYWlsZWRFdmVudC5yZWFzb24ubWVzc2FnZSwgLTEpXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgaW5jcmVhc2VCYWNrb2ZmRGVsYXksXG4gICAgICAgICAgbG9nKFxuICAgICAgICAgICAgMiAvKiBFUlJPUiAqLyxcbiAgICAgICAgICAgIGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7ZmFpbGVkRXZlbnQucmVhc29uIGluc3RhbmNlb2YgRXJyb3IgPyBmYWlsZWRFdmVudC5yZWFzb24ubWVzc2FnZSA6IFN0cmluZyhmYWlsZWRFdmVudC5yZWFzb24pfWBcbiAgICAgICAgICApXG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgfVxuICApO1xuICBjb25zdCBvblNvY2tldEVycm9yID0gKGV2ZW50KSA9PiBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIkVYUExJQ0lUX1NPQ0tFVF9FUlJPUlwiLCBldmVudCB9KTtcbiAgY29uc3Qgb25Tb2NrZXRDbG9zZSA9IChldmVudCkgPT4gbWFjaGluZS5zZW5kKHsgdHlwZTogXCJFWFBMSUNJVF9TT0NLRVRfQ0xPU0VcIiwgZXZlbnQgfSk7XG4gIGNvbnN0IG9uU29ja2V0TWVzc2FnZSA9IChldmVudCkgPT4gZXZlbnQuZGF0YSA9PT0gXCJwb25nXCIgPyBtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIlBPTkdcIiB9KSA6IG9uTWVzc2FnZS5ub3RpZnkoZXZlbnQpO1xuICBmdW5jdGlvbiB0ZWFyZG93blNvY2tldChzb2NrZXQpIHtcbiAgICBpZiAoc29ja2V0KSB7XG4gICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uU29ja2V0RXJyb3IpO1xuICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCBvblNvY2tldENsb3NlKTtcbiAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvblNvY2tldE1lc3NhZ2UpO1xuICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgfVxuICB9XG4gIG1hY2hpbmUuYWRkVHJhbnNpdGlvbnMoXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsIHtcbiAgICBOQVZJR0FUT1JfT05MSU5FOiB7XG4gICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYnVzeVwiLFxuICAgICAgZWZmZWN0OiBhc3NpZ24oeyBiYWNrb2ZmRGVsYXk6IFJFU0VUX0RFTEFZIH0pXG4gICAgfVxuICB9KS5hZGRUaW1lZFRyYW5zaXRpb24oXG4gICAgXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgKGN0eCkgPT4gY3R4LmJhY2tvZmZEZWxheSxcbiAgICBcIkBjb25uZWN0aW5nLmJ1c3lcIlxuICApLm9uRW50ZXJBc3luYyhcbiAgICBcIkBjb25uZWN0aW5nLmJ1c3lcIixcbiAgICAvL1xuICAgIC8vIFVzZSB0aGUgXCJjcmVhdGVTb2NrZXRcIiBkZWxlZ2F0ZSBmdW5jdGlvbiAocHJvdmlkZWQgdG8gdGhlXG4gICAgLy8gTWFuYWdlZFNvY2tldCkgdG8gY3JlYXRlIHRoZSBhY3R1YWwgV2ViU29ja2V0IGNvbm5lY3Rpb24gaW5zdGFuY2UuXG4gICAgLy8gVGhlbiwgc2V0IHVwIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGxpc3RlbmVycywgYW5kIHdhaXQgZm9yIHRoZVxuICAgIC8vIFwib3BlblwiIGV2ZW50IHRvIG9jY3VyLlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGUgXCJvcGVuXCIgZXZlbnQgaGFwcGVucywgd2UncmUgcmVhZHkgdG8gdHJhbnNpdGlvbiB0byB0aGVcbiAgICAvLyBPSyBzdGF0ZS4gVGhpcyBpcyBkb25lIGJ5IHJlc29sdmluZyB0aGUgUHJvbWlzZS5cbiAgICAvL1xuICAgIGFzeW5jIChjdHgsIHNpZ25hbCkgPT4ge1xuICAgICAgbGV0IGNhcHR1cmVkUHJlbWF0dXJlRXZlbnQgPSBudWxsO1xuICAgICAgbGV0IHVuY29uZmlybWVkU29ja2V0ID0gbnVsbDtcbiAgICAgIGNvbnN0IGNvbm5lY3QkID0gbmV3IFByb21pc2UoXG4gICAgICAgIChyZXNvbHZlLCByZWopID0+IHtcbiAgICAgICAgICBpZiAoY3R4LmF1dGhWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXV0aCBhdXRoVmFsdWVcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNvY2tldCA9IGRlbGVnYXRlcy5jcmVhdGVTb2NrZXQoY3R4LmF1dGhWYWx1ZSk7XG4gICAgICAgICAgdW5jb25maXJtZWRTb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgICAgZnVuY3Rpb24gcmVqZWN0KGV2ZW50KSB7XG4gICAgICAgICAgICBjYXB0dXJlZFByZW1hdHVyZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25Tb2NrZXRNZXNzYWdlKTtcbiAgICAgICAgICAgIHJlaihldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IFthY3RvciQsIGRpZFJlY2VpdmVBY3Rvcl0gPSBjb250cm9sbGVkUHJvbWlzZSgpO1xuICAgICAgICAgIGlmICghb3B0aW9ucy53YWl0Rm9yQWN0b3JJZCkge1xuICAgICAgICAgICAgZGlkUmVjZWl2ZUFjdG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHdhaXRGb3JBY3RvcklkKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJNc2cgPSB0cnlQYXJzZUpzb24oZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICBpZiAoc2VydmVyTXNnPy50eXBlID09PSAxMDQgLyogUk9PTV9TVEFURSAqLykge1xuICAgICAgICAgICAgICBkaWRSZWNlaXZlQWN0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uU29ja2V0TWVzc2FnZSk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMud2FpdEZvckFjdG9ySWQpIHtcbiAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB3YWl0Rm9yQWN0b3JJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIHJlamVjdCk7XG4gICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsICgpID0+IHtcbiAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Tb2NrZXRFcnJvcik7XG4gICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIG9uU29ja2V0Q2xvc2UpO1xuICAgICAgICAgICAgY29uc3QgdW5zdWIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCByZWplY3QpO1xuICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgd2FpdEZvckFjdG9ySWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZvaWQgYWN0b3IkLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICByZXNvbHZlKFtzb2NrZXQsIHVuc3ViXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiB3aXRoVGltZW91dChcbiAgICAgICAgY29ubmVjdCQsXG4gICAgICAgIFNPQ0tFVF9DT05ORUNUX1RJTUVPVVQsXG4gICAgICAgIFwiVGltZWQgb3V0IGR1cmluZyB3ZWJzb2NrZXQgY29ubmVjdGlvblwiXG4gICAgICApLnRoZW4oXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFBhcnQgMzpcbiAgICAgICAgLy8gQnkgbm93LCBvdXIgXCJvcGVuXCIgZXZlbnQgaGFzIGZpcmVkLCBhbmQgdGhlIHByb21pc2UgaGFzIGJlZW5cbiAgICAgICAgLy8gcmVzb2x2ZWQuIFR3byBwb3NzaWJsZSBzY2VuYXJpb3M6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIDEuIFRoZSBoYXBweSBwYXRoLiBNb3N0IGxpa2VseS5cbiAgICAgICAgLy8gMi4gVWgtb2guIEEgcHJlbWF0dXJlIGNsb3NlL2Vycm9yIGV2ZW50IGhhcyBiZWVuIG9ic2VydmVkLiBMZXQnc1xuICAgICAgICAvLyAgICByZWplY3QgdGhlIHByb21pc2UgYWZ0ZXIgYWxsLlxuICAgICAgICAvL1xuICAgICAgICAvLyBBbnkgY2xvc2UvZXJyb3IgZXZlbnQgdGhhdCB3aWxsIGdldCBzY2hlZHVsZWQgYWZ0ZXIgdGhpcyBwb2ludFxuICAgICAgICAvLyBvbndhcmRzLCB3aWxsIGJlIGNhdWdodCBpbiB0aGUgT0sgc3RhdGUsIGFuZCBkZWFsdCB3aXRoXG4gICAgICAgIC8vIGFjY29yZGluZ2x5LlxuICAgICAgICAvL1xuICAgICAgICAoW3NvY2tldCwgdW5zdWJdKSA9PiB7XG4gICAgICAgICAgdW5zdWIoKTtcbiAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFib3J0ZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYXB0dXJlZFByZW1hdHVyZUV2ZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBjYXB0dXJlZFByZW1hdHVyZUV2ZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc29ja2V0O1xuICAgICAgICB9XG4gICAgICApLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIHRlYXJkb3duU29ja2V0KHVuY29uZmlybWVkU29ja2V0KTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gT25seSB0cmFuc2l0aW9uIHRvIE9LIHN0YXRlIGFmdGVyIGEgc3VjY2Vzc2Z1bGx5IG9wZW5lZCBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAgIChva0V2ZW50KSA9PiAoe1xuICAgICAgdGFyZ2V0OiBcIkBvay5jb25uZWN0ZWRcIixcbiAgICAgIGVmZmVjdDogYXNzaWduKHtcbiAgICAgICAgc29ja2V0OiBva0V2ZW50LmRhdGEsXG4gICAgICAgIGJhY2tvZmZEZWxheTogUkVTRVRfREVMQVlcbiAgICAgIH0pXG4gICAgfSksXG4gICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGNhbm5vdCBiZSBlc3RhYmxpc2hlZFxuICAgIChmYWlsdXJlKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSBmYWlsdXJlLnJlYXNvbjtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBTdG9wUmV0cnlpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXJnZXQ6IFwiQGlkbGUuZmFpbGVkXCIsXG4gICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICBsb2coMiAvKiBFUlJPUiAqLywgZXJyLm1lc3NhZ2UpLFxuICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZXJyLm1lc3NhZ2UsIC0xKVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Nsb3NlRXZlbnQoZXJyKSkge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IDQxMDkgLyogVE9LRU5fRVhQSVJFRCAqLykge1xuICAgICAgICAgIHJldHVybiBcIkBhdXRoLmJ1c3lcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkUmV0cnlXaXRob3V0UmVhdXRoKGVyci5jb2RlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICAgIGluY3JlYXNlQmFja29mZkRlbGF5QWdncmVzc2l2ZWx5LFxuICAgICAgICAgICAgICBsb2dQcmVtYXR1cmVFcnJvck9yQ2xvc2VFdmVudChlcnIpXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkRGlzY29ubmVjdChlcnIuY29kZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFyZ2V0OiBcIkBpZGxlLmZhaWxlZFwiLFxuICAgICAgICAgICAgZWZmZWN0OiBbXG4gICAgICAgICAgICAgIGxvZygyIC8qIEVSUk9SICovLCBlcnIucmVhc29uKSxcbiAgICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZXJyLnJlYXNvbiwgZXJyLmNvZGUpXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBcIkBhdXRoLmJhY2tvZmZcIixcbiAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIGxvZ1ByZW1hdHVyZUVycm9yT3JDbG9zZUV2ZW50KGVycildXG4gICAgICB9O1xuICAgIH1cbiAgKTtcbiAgY29uc3Qgc2VuZEhlYXJ0YmVhdCA9IHtcbiAgICB0YXJnZXQ6IFwiQG9rLmF3YWl0aW5nLXBvbmdcIixcbiAgICBlZmZlY3Q6IChjdHgpID0+IHtcbiAgICAgIGN0eC5zb2NrZXQ/LnNlbmQoXCJwaW5nXCIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbWF5YmVIZWFydGJlYXQgPSAoKSA9PiB7XG4gICAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gICAgY29uc3QgY2FuWm9tYmllID0gZG9jPy52aXNpYmlsaXR5U3RhdGUgPT09IFwiaGlkZGVuXCIgJiYgZGVsZWdhdGVzLmNhblpvbWJpZSgpO1xuICAgIHJldHVybiBjYW5ab21iaWUgPyBcIkBpZGxlLnpvbWJpZVwiIDogc2VuZEhlYXJ0YmVhdDtcbiAgfTtcbiAgbWFjaGluZS5hZGRUaW1lZFRyYW5zaXRpb24oXCJAb2suY29ubmVjdGVkXCIsIEhFQVJUQkVBVF9JTlRFUlZBTCwgbWF5YmVIZWFydGJlYXQpLmFkZFRyYW5zaXRpb25zKFwiQG9rLmNvbm5lY3RlZFwiLCB7XG4gICAgTkFWSUdBVE9SX09GRkxJTkU6IG1heWJlSGVhcnRiZWF0LFxuICAgIC8vIERvbid0IHRha2UgdGhlIGJyb3dzZXIncyB3b3JkIGZvciBpdCB3aGVuIGl0IHNheXMgaXQncyBvZmZsaW5lLiBEbyBhIHBpbmcvcG9uZyB0byBtYWtlIHN1cmUuXG4gICAgV0lORE9XX0dPVF9GT0NVUzogc2VuZEhlYXJ0YmVhdFxuICB9KTtcbiAgbWFjaGluZS5hZGRUcmFuc2l0aW9ucyhcIkBpZGxlLnpvbWJpZVwiLCB7XG4gICAgV0lORE9XX0dPVF9GT0NVUzogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCJcbiAgICAvLyBXaGVuIGluIHpvbWJpZSBzdGF0ZSwgdGhlIGNsaWVudCB3aWxsIHRyeSB0byB3YWtlIHVwIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgd2luZG93IHJlZ2FpbnMgZm9jdXNcbiAgfSk7XG4gIG1hY2hpbmUub25FbnRlcihcIkBvay4qXCIsIChjdHgpID0+IHtcbiAgICBjdHgucGF0Y2goeyBzdWNjZXNzQ291bnQ6IGN0eC5zdWNjZXNzQ291bnQgKyAxIH0pO1xuICAgIGNvbnN0IHRpbWVySUQgPSBzZXRUaW1lb3V0KFxuICAgICAgLy8gT24gdGhlIG5leHQgdGljaywgc3RhcnQgZGVsaXZlcmluZyBhbGwgbWVzc2FnZXMgdGhhdCBoYXZlIGFscmVhZHlcbiAgICAgIC8vIGJlZW4gcmVjZWl2ZWQsIGFuZCBjb250aW51ZSBzeW5jaHJvbm91cyBkZWxpdmVyeSBvZiBhbGwgZnV0dXJlXG4gICAgICAvLyBpbmNvbWluZyBtZXNzYWdlcy5cbiAgICAgIG9uTWVzc2FnZS51bnBhdXNlLFxuICAgICAgMFxuICAgICk7XG4gICAgcmV0dXJuIChjdHgyKSA9PiB7XG4gICAgICB0ZWFyZG93blNvY2tldChjdHgyLnNvY2tldCk7XG4gICAgICBjdHgyLnBhdGNoKHsgc29ja2V0OiBudWxsIH0pO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySUQpO1xuICAgICAgb25NZXNzYWdlLnBhdXNlKCk7XG4gICAgfTtcbiAgfSkuYWRkVHJhbnNpdGlvbnMoXCJAb2suYXdhaXRpbmctcG9uZ1wiLCB7IFBPTkc6IFwiQG9rLmNvbm5lY3RlZFwiIH0pLmFkZFRpbWVkVHJhbnNpdGlvbihcIkBvay5hd2FpdGluZy1wb25nXCIsIFBPTkdfVElNRU9VVCwge1xuICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5idXN5XCIsXG4gICAgLy8gTG9nIGltcGxpY2l0IGNvbm5lY3Rpb24gbG9zcyBhbmQgZHJvcCB0aGUgY3VycmVudCBvcGVuIHNvY2tldFxuICAgIGVmZmVjdDogbG9nKFxuICAgICAgMSAvKiBXQVJOICovLFxuICAgICAgXCJSZWNlaXZlZCBubyBwb25nIGZyb20gc2VydmVyLCBhc3N1bWUgaW1wbGljaXQgY29ubmVjdGlvbiBsb3NzLlwiXG4gICAgKVxuICB9KS5hZGRUcmFuc2l0aW9ucyhcIkBvay4qXCIsIHtcbiAgICAvLyBXaGVuIGEgc29ja2V0IHJlY2VpdmVzIGFuIGVycm9yLCB0aGlzIGNhbiBjYXVzZSB0aGUgY2xvc2luZyBvZiB0aGVcbiAgICAvLyBzb2NrZXQsIG9yIG5vdC4gU28gYWx3YXlzIGNoZWNrIHRvIHNlZSBpZiB0aGUgc29ja2V0IGlzIHN0aWxsIE9QRU4gb3JcbiAgICAvLyBub3QuIFdoZW4gc3RpbGwgT1BFTiwgZG9uJ3QgdHJhbnNpdGlvbi5cbiAgICBFWFBMSUNJVF9TT0NLRVRfRVJST1I6IChfLCBjb250ZXh0KSA9PiB7XG4gICAgICBpZiAoY29udGV4dC5zb2NrZXQ/LnJlYWR5U3RhdGUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IFwiQGNvbm5lY3RpbmcuYmFja29mZlwiLFxuICAgICAgICBlZmZlY3Q6IGluY3JlYXNlQmFja29mZkRlbGF5XG4gICAgICB9O1xuICAgIH0sXG4gICAgRVhQTElDSVRfU09DS0VUX0NMT1NFOiAoZSkgPT4ge1xuICAgICAgaWYgKHNob3VsZERpc2Nvbm5lY3QoZS5ldmVudC5jb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhcmdldDogXCJAaWRsZS5mYWlsZWRcIixcbiAgICAgICAgICBlZmZlY3Q6IFtcbiAgICAgICAgICAgIGxvZ1Blcm1hbmVudENsb3NlLFxuICAgICAgICAgICAgZmlyZUVycm9yRXZlbnQoZS5ldmVudC5yZWFzb24sIGUuZXZlbnQuY29kZSlcbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmVhdXRoKGUuZXZlbnQuY29kZSkpIHtcbiAgICAgICAgaWYgKGUuZXZlbnQuY29kZSA9PT0gNDEwOSAvKiBUT0tFTl9FWFBJUkVEICovKSB7XG4gICAgICAgICAgcmV0dXJuIFwiQGF1dGguYnVzeVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiQGF1dGguYmFja29mZlwiLFxuICAgICAgICAgICAgZWZmZWN0OiBbaW5jcmVhc2VCYWNrb2ZmRGVsYXksIGxvZ0Nsb3NlRXZlbnQoZS5ldmVudCldXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFJldHJ5V2l0aG91dFJlYXV0aChlLmV2ZW50LmNvZGUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFyZ2V0OiBcIkBjb25uZWN0aW5nLmJhY2tvZmZcIixcbiAgICAgICAgICBlZmZlY3Q6IFtpbmNyZWFzZUJhY2tvZmZEZWxheUFnZ3Jlc3NpdmVseSwgbG9nQ2xvc2VFdmVudChlLmV2ZW50KV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogXCJAY29ubmVjdGluZy5iYWNrb2ZmXCIsXG4gICAgICAgIGVmZmVjdDogW2luY3JlYXNlQmFja29mZkRlbGF5LCBsb2dDbG9zZUV2ZW50KGUuZXZlbnQpXVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gICAgY29uc3Qgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHZvaWQgMDtcbiAgICBjb25zdCByb290ID0gd2luID8/IGRvYztcbiAgICBtYWNoaW5lLm9uRW50ZXIoXCIqXCIsIChjdHgpID0+IHtcbiAgICAgIGZ1bmN0aW9uIG9uTmV0d29ya09mZmxpbmUoKSB7XG4gICAgICAgIG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiTkFWSUdBVE9SX09GRkxJTkVcIiB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG9uTmV0d29ya0JhY2tPbmxpbmUoKSB7XG4gICAgICAgIG1hY2hpbmUuc2VuZCh7IHR5cGU6IFwiTkFWSUdBVE9SX09OTElORVwiIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gb25WaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgICAgICBpZiAoZG9jPy52aXNpYmlsaXR5U3RhdGUgPT09IFwidmlzaWJsZVwiKSB7XG4gICAgICAgICAgbWFjaGluZS5zZW5kKHsgdHlwZTogXCJXSU5ET1dfR09UX0ZPQ1VTXCIgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdpbj8uYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBvbk5ldHdvcmtCYWNrT25saW5lKTtcbiAgICAgIHdpbj8uYWRkRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgb25OZXR3b3JrT2ZmbGluZSk7XG4gICAgICByb290Py5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcm9vdD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICAgICAgd2luPy5yZW1vdmVFdmVudExpc3RlbmVyKFwib25saW5lXCIsIG9uTmV0d29ya0JhY2tPbmxpbmUpO1xuICAgICAgICB3aW4/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIG9uTmV0d29ya09mZmxpbmUpO1xuICAgICAgICB0ZWFyZG93blNvY2tldChjdHguc29ja2V0KTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgY2xlYW51cHMgPSBbXTtcbiAgY29uc3QgeyBzdGF0dXNEaWRDaGFuZ2UsIGRpZENvbm5lY3QsIGRpZERpc2Nvbm5lY3QsIHVuc3Vic2NyaWJlIH0gPSBkZWZpbmVDb25uZWN0aXZpdHlFdmVudHMobWFjaGluZSk7XG4gIGNsZWFudXBzLnB1c2godW5zdWJzY3JpYmUpO1xuICBpZiAob3B0aW9ucy5lbmFibGVEZWJ1Z0xvZ2dpbmcpIHtcbiAgICBjbGVhbnVwcy5wdXNoKGVuYWJsZVRyYWNpbmcobWFjaGluZSkpO1xuICB9XG4gIG1hY2hpbmUuc3RhcnQoKTtcbiAgcmV0dXJuIHtcbiAgICBtYWNoaW5lLFxuICAgIGNsZWFudXBzLFxuICAgIC8vIE9ic2VydmFibGUgZXZlbnRzIHRoYXQgd2lsbCBiZSBlbWl0dGVkIGJ5IHRoaXMgbWFjaGluZVxuICAgIGV2ZW50czoge1xuICAgICAgc3RhdHVzRGlkQ2hhbmdlLFxuICAgICAgZGlkQ29ubmVjdCxcbiAgICAgIGRpZERpc2Nvbm5lY3QsXG4gICAgICBvbk1lc3NhZ2U6IG9uTWVzc2FnZS5vYnNlcnZhYmxlLFxuICAgICAgb25Db25uZWN0aW9uRXJyb3I6IG9uQ29ubmVjdGlvbkVycm9yLm9ic2VydmFibGVcbiAgICB9XG4gIH07XG59XG52YXIgTWFuYWdlZFNvY2tldCA9IGNsYXNzIHtcbiAgI21hY2hpbmU7XG4gICNjbGVhbnVwcztcbiAgZXZlbnRzO1xuICBjb25zdHJ1Y3RvcihkZWxlZ2F0ZXMsIGVuYWJsZURlYnVnTG9nZ2luZyA9IGZhbHNlLCB3YWl0Rm9yQWN0b3JJZCA9IHRydWUpIHtcbiAgICBjb25zdCB7IG1hY2hpbmUsIGV2ZW50cywgY2xlYW51cHMgfSA9IGNyZWF0ZUNvbm5lY3Rpb25TdGF0ZU1hY2hpbmUoXG4gICAgICBkZWxlZ2F0ZXMsXG4gICAgICB7IHdhaXRGb3JBY3RvcklkLCBlbmFibGVEZWJ1Z0xvZ2dpbmcgfVxuICAgICk7XG4gICAgdGhpcy4jbWFjaGluZSA9IG1hY2hpbmU7XG4gICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgdGhpcy4jY2xlYW51cHMgPSBjbGVhbnVwcztcbiAgfVxuICBnZXRTdGF0dXMoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0b05ld0Nvbm5lY3Rpb25TdGF0dXModGhpcy4jbWFjaGluZSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gXCJpbml0aWFsXCI7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGF1dGggYXV0aFZhbHVlLlxuICAgKi9cbiAgZ2V0IGF1dGhWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jbWFjaGluZS5jb250ZXh0LmF1dGhWYWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCB0aGlzIG1ldGhvZCB0byB0cnkgdG8gY29ubmVjdCB0byBhIFdlYlNvY2tldC4gVGhpcyBvbmx5IGhhcyBhbiBlZmZlY3RcbiAgICogaWYgdGhlIG1hY2hpbmUgaXMgaWRsZSBhdCB0aGUgbW9tZW50LCBvdGhlcndpc2UgdGhpcyBpcyBhIG5vLW9wLlxuICAgKi9cbiAgY29ubmVjdCgpIHtcbiAgICB0aGlzLiNtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIkNPTk5FQ1RcIiB9KTtcbiAgfVxuICAvKipcbiAgICogSWYgaWRsZSwgd2lsbCB0cnkgdG8gY29ubmVjdC4gT3RoZXJ3aXNlLCBpdCB3aWxsIGF0dGVtcHQgdG8gcmVjb25uZWN0IHRvXG4gICAqIHRoZSBzb2NrZXQsIHBvdGVudGlhbGx5IG9idGFpbmluZyBhIG5ldyBhdXRoVmFsdWUgZmlyc3QsIGlmIG5lZWRlZC5cbiAgICovXG4gIHJlY29ubmVjdCgpIHtcbiAgICB0aGlzLiNtYWNoaW5lLnNlbmQoeyB0eXBlOiBcIlJFQ09OTkVDVFwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgbWV0aG9kIHRvIGRpc2Nvbm5lY3QgZnJvbSB0aGUgY3VycmVudCBXZWJTb2NrZXQuIElzIGdvaW5nIHRvIGJlXG4gICAqIGEgbm8tb3AgaWYgdGhlcmUgaXMgbm8gYWN0aXZlIGNvbm5lY3Rpb24uXG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMuI21hY2hpbmUuc2VuZCh7IHR5cGU6IFwiRElTQ09OTkVDVFwiIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgdG8gc3RvcCB0aGUgbWFjaGluZSBhbmQgcnVuIG5lY2Vzc2FyeSBjbGVhbnVwIGZ1bmN0aW9ucy4gQWZ0ZXJcbiAgICogY2FsbGluZyBkZXN0cm95KCksIHlvdSBjYW4gbm8gbG9uZ2VyIHVzZSB0aGlzIGluc3RhbmNlLiBDYWxsIHRoaXMgYmVmb3JlXG4gICAqIGxldHRpbmcgdGhlIGluc3RhbmNlIGdldCBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jbWFjaGluZS5zdG9wKCk7XG4gICAgbGV0IGNsZWFudXA7XG4gICAgd2hpbGUgKGNsZWFudXAgPSB0aGlzLiNjbGVhbnVwcy5wb3AoKSkge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2FmZWx5IHNlbmQgYSBtZXNzYWdlIHRvIHRoZSBjdXJyZW50IFdlYlNvY2tldCBjb25uZWN0aW9uLiBXaWxsIGVtaXQgYSBsb2dcbiAgICogbWVzc2FnZSBpZiB0aGlzIGlzIHNvbWVob3cgaW1wb3NzaWJsZS5cbiAgICovXG4gIHNlbmQoZGF0YSkge1xuICAgIGNvbnN0IHNvY2tldCA9IHRoaXMuI21hY2hpbmUuY29udGV4dD8uc29ja2V0O1xuICAgIGlmIChzb2NrZXQgPT09IG51bGwpIHtcbiAgICAgIHdhcm4oXCJDYW5ub3Qgc2VuZDogbm90IGNvbm5lY3RlZCB5ZXRcIiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChzb2NrZXQucmVhZHlTdGF0ZSAhPT0gMSkge1xuICAgICAgd2FybihcIkNhbm5vdCBzZW5kOiBXZWJTb2NrZXQgbm8gbG9uZ2VyIG9wZW5cIiwgZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvY2tldC5zZW5kKGRhdGEpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTk9URTogVXNlZCBieSB0aGUgRTJFIGFwcCBvbmx5LCB0byBzaW11bGF0ZSBleHBsaWNpdCBldmVudHMuXG4gICAqIE5vdCBpZGVhbCB0byBrZWVwIGV4cG9zZWQgOihcbiAgICovXG4gIF9wcml2YXRlU2VuZE1hY2hpbmVFdmVudChldmVudCkge1xuICAgIHRoaXMuI21hY2hpbmUuc2VuZChldmVudCk7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm90b2NvbC9BdXRoVG9rZW4udHNcbnZhciBQZXJtaXNzaW9uID0gLyogQF9fUFVSRV9fICovICgoUGVybWlzc2lvbjIpID0+IHtcbiAgUGVybWlzc2lvbjJbXCJSZWFkXCJdID0gXCJyb29tOnJlYWRcIjtcbiAgUGVybWlzc2lvbjJbXCJXcml0ZVwiXSA9IFwicm9vbTp3cml0ZVwiO1xuICBQZXJtaXNzaW9uMltcIlByZXNlbmNlV3JpdGVcIl0gPSBcInJvb206cHJlc2VuY2U6d3JpdGVcIjtcbiAgUGVybWlzc2lvbjJbXCJDb21tZW50c1dyaXRlXCJdID0gXCJjb21tZW50czp3cml0ZVwiO1xuICBQZXJtaXNzaW9uMltcIkNvbW1lbnRzUmVhZFwiXSA9IFwiY29tbWVudHM6cmVhZFwiO1xuICByZXR1cm4gUGVybWlzc2lvbjI7XG59KShQZXJtaXNzaW9uIHx8IHt9KTtcbmZ1bmN0aW9uIGNhbldyaXRlU3RvcmFnZShzY29wZXMpIHtcbiAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG59XG5mdW5jdGlvbiBjYW5Db21tZW50KHNjb3Blcykge1xuICByZXR1cm4gc2NvcGVzLmluY2x1ZGVzKFwiY29tbWVudHM6d3JpdGVcIiAvKiBDb21tZW50c1dyaXRlICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJyb29tOndyaXRlXCIgLyogV3JpdGUgKi8pO1xufVxuZnVuY3Rpb24gaXNWYWxpZEF1dGhUb2tlblBheWxvYWQoZGF0YSkge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdChkYXRhKSAmJiAoZGF0YS5rID09PSBcImFjY1wiIC8qIEFDQ0VTU19UT0tFTiAqLyB8fCBkYXRhLmsgPT09IFwiaWRcIiAvKiBJRF9UT0tFTiAqLyB8fCBkYXRhLmsgPT09IFwic2VjLWxlZ2FjeVwiIC8qIFNFQ1JFVF9MRUdBQ1kgKi8pO1xufVxuZnVuY3Rpb24gcGFyc2VBdXRoVG9rZW4ocmF3VG9rZW5TdHJpbmcpIHtcbiAgY29uc3QgdG9rZW5QYXJ0cyA9IHJhd1Rva2VuU3RyaW5nLnNwbGl0KFwiLlwiKTtcbiAgaWYgKHRva2VuUGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXV0aGVudGljYXRpb24gZXJyb3I6IGludmFsaWQgSldUIHRva2VuXCIpO1xuICB9XG4gIGNvbnN0IHBheWxvYWQgPSB0cnlQYXJzZUpzb24oYjY0ZGVjb2RlKHRva2VuUGFydHNbMV0pKTtcbiAgaWYgKCEocGF5bG9hZCAmJiBpc1ZhbGlkQXV0aFRva2VuUGF5bG9hZChwYXlsb2FkKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkF1dGhlbnRpY2F0aW9uIGVycm9yOiBleHBlY3RlZCBhIHZhbGlkIHRva2VuIGJ1dCBkaWQgbm90IGdldCBvbmUuIEhpbnQ6IGlmIHlvdSBhcmUgdXNpbmcgYSBjYWxsYmFjaywgZW5zdXJlIHRoZSByb29tIGlzIHBhc3NlZCB3aGVuIGNyZWF0aW5nIHRoZSB0b2tlbi4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50Q2FsbGJhY2tcIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByYXc6IHJhd1Rva2VuU3RyaW5nLFxuICAgIHBhcnNlZDogcGF5bG9hZFxuICB9O1xufVxuXG4vLyBzcmMvYXV0aC1tYW5hZ2VyLnRzXG5mdW5jdGlvbiBjcmVhdGVBdXRoTWFuYWdlcihhdXRoT3B0aW9ucywgb25BdXRoZW50aWNhdGUpIHtcbiAgY29uc3QgYXV0aGVudGljYXRpb24gPSBwcmVwYXJlQXV0aGVudGljYXRpb24oYXV0aE9wdGlvbnMpO1xuICBjb25zdCBzZWVuVG9rZW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgdG9rZW5zID0gW107XG4gIGNvbnN0IGV4cGlyeVRpbWVzID0gW107XG4gIGNvbnN0IHJlcXVlc3RQcm9taXNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHNlZW5Ub2tlbnMuY2xlYXIoKTtcbiAgICB0b2tlbnMubGVuZ3RoID0gMDtcbiAgICBleHBpcnlUaW1lcy5sZW5ndGggPSAwO1xuICAgIHJlcXVlc3RQcm9taXNlcy5jbGVhcigpO1xuICB9XG4gIGZ1bmN0aW9uIGhhc0NvcnJlc3BvbmRpbmdTY29wZXMocmVxdWVzdGVkU2NvcGUsIHNjb3Blcykge1xuICAgIGlmIChyZXF1ZXN0ZWRTY29wZSA9PT0gXCJjb21tZW50czpyZWFkXCIpIHtcbiAgICAgIHJldHVybiBzY29wZXMuaW5jbHVkZXMoXCJjb21tZW50czpyZWFkXCIgLyogQ29tbWVudHNSZWFkICovKSB8fCBzY29wZXMuaW5jbHVkZXMoXCJjb21tZW50czp3cml0ZVwiIC8qIENvbW1lbnRzV3JpdGUgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206cmVhZFwiIC8qIFJlYWQgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0ZWRTY29wZSA9PT0gXCJyb29tOnJlYWRcIikge1xuICAgICAgcmV0dXJuIHNjb3Blcy5pbmNsdWRlcyhcInJvb206cmVhZFwiIC8qIFJlYWQgKi8pIHx8IHNjb3Blcy5pbmNsdWRlcyhcInJvb206d3JpdGVcIiAvKiBXcml0ZSAqLyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDYWNoZWRUb2tlbihyZXF1ZXN0T3B0aW9ucykge1xuICAgIGNvbnN0IG5vdyA9IE1hdGguY2VpbChEYXRlLm5vdygpIC8gMWUzKTtcbiAgICBmb3IgKGxldCBpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgIGNvbnN0IGV4cGlyZXNBdCA9IGV4cGlyeVRpbWVzW2ldO1xuICAgICAgaWYgKGV4cGlyZXNBdCA8PSBub3cpIHtcbiAgICAgICAgdG9rZW5zLnNwbGljZShpLCAxKTtcbiAgICAgICAgZXhwaXJ5VGltZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi5wYXJzZWQuayA9PT0gXCJpZFwiIC8qIElEX1RPS0VOICovKSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH0gZWxzZSBpZiAodG9rZW4ucGFyc2VkLmsgPT09IFwiYWNjXCIgLyogQUNDRVNTX1RPS0VOICovKSB7XG4gICAgICAgIGlmICghcmVxdWVzdE9wdGlvbnMucm9vbUlkICYmIE9iamVjdC5lbnRyaWVzKHRva2VuLnBhcnNlZC5wZXJtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW3Jlc291cmNlLCBzY29wZXNdIG9mIE9iamVjdC5lbnRyaWVzKHRva2VuLnBhcnNlZC5wZXJtcykpIHtcbiAgICAgICAgICBpZiAoIXJlcXVlc3RPcHRpb25zLnJvb21JZCkge1xuICAgICAgICAgICAgaWYgKHJlc291cmNlLmluY2x1ZGVzKFwiKlwiKSAmJiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKHJlcXVlc3RPcHRpb25zLnJlcXVlc3RlZFNjb3BlLCBzY29wZXMpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc291cmNlLmluY2x1ZGVzKFwiKlwiKSAmJiByZXF1ZXN0T3B0aW9ucy5yb29tSWQuc3RhcnRzV2l0aChyZXNvdXJjZS5yZXBsYWNlKFwiKlwiLCBcIlwiKSkgfHwgcmVxdWVzdE9wdGlvbnMucm9vbUlkID09PSByZXNvdXJjZSAmJiBoYXNDb3JyZXNwb25kaW5nU2NvcGVzKHJlcXVlc3RPcHRpb25zLnJlcXVlc3RlZFNjb3BlLCBzY29wZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFrZUF1dGhSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICBjb25zdCBmZXRjaGVyID0gYXV0aE9wdGlvbnMucG9seWZpbGxzPy5mZXRjaCA/PyAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IHdpbmRvdy5mZXRjaCk7XG4gICAgaWYgKGF1dGhlbnRpY2F0aW9uLnR5cGUgPT09IFwicHJpdmF0ZVwiKSB7XG4gICAgICBpZiAoZmV0Y2hlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgICAgXCJUbyB1c2UgTGl2ZWJsb2NrcyBjbGllbnQgaW4gYSBub24tRE9NIGVudmlyb25tZW50IHdpdGggYSB1cmwgYXMgYXV0aCBlbmRwb2ludCwgeW91IG5lZWQgdG8gcHJvdmlkZSBhIGZldGNoIHBvbHlmaWxsLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQXV0aEVuZHBvaW50KGZldGNoZXIsIGF1dGhlbnRpY2F0aW9uLnVybCwge1xuICAgICAgICByb29tOiBvcHRpb25zLnJvb21JZFxuICAgICAgfSk7XG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUF1dGhUb2tlbihyZXNwb25zZS50b2tlbik7XG4gICAgICBpZiAoc2VlblRva2Vucy5oYXMocGFyc2VkLnJhdykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhcbiAgICAgICAgICBcIlRoZSBzYW1lIExpdmVibG9ja3MgYXV0aCB0b2tlbiB3YXMgaXNzdWVkIGZyb20gdGhlIGJhY2tlbmQgYmVmb3JlLiBDYWNoaW5nIExpdmVibG9ja3MgdG9rZW5zIGlzIG5vdCBzdXBwb3J0ZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG9uQXV0aGVudGljYXRlPy4ocGFyc2VkLnBhcnNlZCk7XG4gICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cbiAgICBpZiAoYXV0aGVudGljYXRpb24udHlwZSA9PT0gXCJjdXN0b21cIikge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhdXRoZW50aWNhdGlvbi5jYWxsYmFjayhvcHRpb25zLnJvb21JZCk7XG4gICAgICBpZiAocmVzcG9uc2UgJiYgdHlwZW9mIHJlc3BvbnNlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UudG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUF1dGhUb2tlbihyZXNwb25zZS50b2tlbik7XG4gICAgICAgICAgb25BdXRoZW50aWNhdGU/LihwYXJzZWQucGFyc2VkKTtcbiAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZS5lcnJvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IGBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6ICR7XCJyZWFzb25cIiBpbiByZXNwb25zZSAmJiB0eXBlb2YgcmVzcG9uc2UucmVhc29uID09PSBcInN0cmluZ1wiID8gcmVzcG9uc2UucmVhc29uIDogXCJGb3JiaWRkZW5cIn1gO1xuICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvciA9PT0gXCJmb3JiaWRkZW5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3BSZXRyeWluZyhyZWFzb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhc29uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1lvdXIgYXV0aGVudGljYXRpb24gY2FsbGJhY2sgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIHRva2VuLCBidXQgaXQgZGlkIG5vdC4gSGludDogdGhlIHJldHVybiB2YWx1ZSBzaG91bGQgbG9vayBsaWtlOiB7IHRva2VuOiBcIi4uLlwiIH0nXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlVuZXhwZWN0ZWQgYXV0aGVudGljYXRpb24gdHlwZS4gTXVzdCBiZSBwcml2YXRlIG9yIGN1c3RvbS5cIlxuICAgICk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0QXV0aFZhbHVlKHJlcXVlc3RPcHRpb25zKSB7XG4gICAgaWYgKGF1dGhlbnRpY2F0aW9uLnR5cGUgPT09IFwicHVibGljXCIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwicHVibGljXCIsIHB1YmxpY0FwaUtleTogYXV0aGVudGljYXRpb24ucHVibGljQXBpS2V5IH07XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlZFRva2VuID0gZ2V0Q2FjaGVkVG9rZW4ocmVxdWVzdE9wdGlvbnMpO1xuICAgIGlmIChjYWNoZWRUb2tlbiAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInNlY3JldFwiLCB0b2tlbjogY2FjaGVkVG9rZW4gfTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRQcm9taXNlO1xuICAgIGlmIChyZXF1ZXN0T3B0aW9ucy5yb29tSWQpIHtcbiAgICAgIGN1cnJlbnRQcm9taXNlID0gcmVxdWVzdFByb21pc2VzLmdldChyZXF1ZXN0T3B0aW9ucy5yb29tSWQpO1xuICAgICAgaWYgKGN1cnJlbnRQcm9taXNlID09PSB2b2lkIDApIHtcbiAgICAgICAgY3VycmVudFByb21pc2UgPSBtYWtlQXV0aFJlcXVlc3QocmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXMuc2V0KHJlcXVlc3RPcHRpb25zLnJvb21JZCwgY3VycmVudFByb21pc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHJlcXVlc3RQcm9taXNlcy5nZXQoXCJsaXZlYmxvY2tzLXVzZXItdG9rZW5cIik7XG4gICAgICBpZiAoY3VycmVudFByb21pc2UgPT09IHZvaWQgMCkge1xuICAgICAgICBjdXJyZW50UHJvbWlzZSA9IG1ha2VBdXRoUmVxdWVzdChyZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIHJlcXVlc3RQcm9taXNlcy5zZXQoXCJsaXZlYmxvY2tzLXVzZXItdG9rZW5cIiwgY3VycmVudFByb21pc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCBjdXJyZW50UHJvbWlzZTtcbiAgICAgIGNvbnN0IEJVRkZFUiA9IDMwO1xuICAgICAgY29uc3QgZXhwaXJlc0F0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKSArICh0b2tlbi5wYXJzZWQuZXhwIC0gdG9rZW4ucGFyc2VkLmlhdCkgLSBCVUZGRVI7XG4gICAgICBzZWVuVG9rZW5zLmFkZCh0b2tlbi5yYXcpO1xuICAgICAgaWYgKHRva2VuLnBhcnNlZC5rICE9PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgZXhwaXJ5VGltZXMucHVzaChleHBpcmVzQXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJzZWNyZXRcIiwgdG9rZW4gfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHJlcXVlc3RPcHRpb25zLnJvb21JZCkge1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXMuZGVsZXRlKHJlcXVlc3RPcHRpb25zLnJvb21JZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0UHJvbWlzZXMuZGVsZXRlKFwibGl2ZWJsb2Nrcy11c2VyLXRva2VuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHJlc2V0LFxuICAgIGdldEF1dGhWYWx1ZVxuICB9O1xufVxuZnVuY3Rpb24gcHJlcGFyZUF1dGhlbnRpY2F0aW9uKGF1dGhPcHRpb25zKSB7XG4gIGNvbnN0IHsgcHVibGljQXBpS2V5LCBhdXRoRW5kcG9pbnQgfSA9IGF1dGhPcHRpb25zO1xuICBpZiAoYXV0aEVuZHBvaW50ICE9PSB2b2lkIDAgJiYgcHVibGljQXBpS2V5ICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIllvdSBjYW5ub3Qgc2ltdWx0YW5lb3VzbHkgdXNlIGBwdWJsaWNBcGlLZXlgIGFuZCBgYXV0aEVuZHBvaW50YCBvcHRpb25zLiBQbGVhc2UgcGljayBvbmUgYW5kIGxlYXZlIHRoZSBvdGhlciBvcHRpb24gdW5zcGVjaWZpZWQuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3MtY2xpZW50I2NyZWF0ZUNsaWVudFwiXG4gICAgKTtcbiAgfVxuICBpZiAodHlwZW9mIHB1YmxpY0FwaUtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChwdWJsaWNBcGlLZXkuc3RhcnRzV2l0aChcInNrX1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkludmFsaWQgYHB1YmxpY0FwaUtleWAgb3B0aW9uLiBUaGUgdmFsdWUgeW91IHBhc3NlZCBpcyBhIHNlY3JldCBrZXksIHdoaWNoIHNob3VsZCBub3QgYmUgdXNlZCBmcm9tIHRoZSBjbGllbnQuIFBsZWFzZSBvbmx5IGV2ZXIgcGFzcyBhIHB1YmxpYyBrZXkgaGVyZS4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50UHVibGljS2V5XCJcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghcHVibGljQXBpS2V5LnN0YXJ0c1dpdGgoXCJwa19cIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJJbnZhbGlkIGtleS4gUGxlYXNlIHVzZSB0aGUgcHVibGljIGtleSBmb3JtYXQ6IHBrXzxwdWJsaWMga2V5Pi4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50UHVibGljS2V5XCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInB1YmxpY1wiLFxuICAgICAgcHVibGljQXBpS2V5XG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIGF1dGhFbmRwb2ludCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInByaXZhdGVcIixcbiAgICAgIHVybDogYXV0aEVuZHBvaW50XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXV0aEVuZHBvaW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjdXN0b21cIixcbiAgICAgIGNhbGxiYWNrOiBhdXRoRW5kcG9pbnRcbiAgICB9O1xuICB9IGVsc2UgaWYgKGF1dGhFbmRwb2ludCAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJUaGUgYGF1dGhFbmRwb2ludGAgb3B0aW9uIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvbi4gRm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL2FwaS1yZWZlcmVuY2UvbGl2ZWJsb2Nrcy1jbGllbnQjY3JlYXRlQ2xpZW50QXV0aEVuZHBvaW50XCJcbiAgICApO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBcIkludmFsaWQgTGl2ZWJsb2NrcyBjbGllbnQgb3B0aW9ucy4gUGxlYXNlIHByb3ZpZGUgZWl0aGVyIGEgYHB1YmxpY0FwaUtleWAgb3IgYGF1dGhFbmRwb2ludGAgb3B0aW9uLiBUaGV5IGNhbm5vdCBib3RoIGJlIGVtcHR5LiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvYXBpLXJlZmVyZW5jZS9saXZlYmxvY2tzLWNsaWVudCNjcmVhdGVDbGllbnRcIlxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBdXRoRW5kcG9pbnQoZmV0Y2gsIGVuZHBvaW50LCBib2R5KSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGVuZHBvaW50LCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH0sXG4gICAgYm9keTogc3RyaW5naWZ5T3JMb2coYm9keSlcbiAgfSk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgY29uc3QgcmVhc29uID0gYCR7KGF3YWl0IHJlcy50ZXh0KCkpLnRyaW0oKSB8fCBcInJlYXNvbiBub3QgcHJvdmlkZWQgaW4gYXV0aCByZXNwb25zZVwifSAoJHtyZXMuc3RhdHVzfSByZXR1cm5lZCBieSBQT1NUICR7ZW5kcG9pbnR9KWA7XG4gICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwMSB8fCByZXMuc3RhdHVzID09PSA0MDMpIHtcbiAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoYFVuYXV0aG9yaXplZDogJHtyZWFzb259YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGF1dGhlbnRpY2F0ZTogJHtyZWFzb259YCk7XG4gICAgfVxuICB9XG4gIGxldCBkYXRhO1xuICB0cnkge1xuICAgIGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICB9IGNhdGNoIChlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHBlY3RlZCBhIEpTT04gcmVzcG9uc2Ugd2hlbiBkb2luZyBhIFBPU1QgcmVxdWVzdCBvbiBcIiR7ZW5kcG9pbnR9XCIuICR7U3RyaW5nKFxuICAgICAgICBlclxuICAgICAgKX1gXG4gICAgKTtcbiAgfVxuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkgfHwgdHlwZW9mIGRhdGEudG9rZW4gIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYSBKU09OIHJlc3BvbnNlIG9mIHRoZSBmb3JtIFxcYHsgdG9rZW46IFwiLi4uXCIgfVxcYCB3aGVuIGRvaW5nIGEgUE9TVCByZXF1ZXN0IG9uIFwiJHtlbmRwb2ludH1cIiwgYnV0IGdvdCAke3N0cmluZ2lmeU9yTG9nKFxuICAgICAgICBkYXRhXG4gICAgICApfWBcbiAgICApO1xuICB9XG4gIGNvbnN0IHsgdG9rZW4gfSA9IGRhdGE7XG4gIHJldHVybiB7IHRva2VuIH07XG59XG5cbi8vIHNyYy9jb25zdGFudHMudHNcbnZhciBERUZBVUxUX0JBU0VfVVJMID0gXCJodHRwczovL2FwaS5saXZlYmxvY2tzLmlvXCI7XG5cbi8vIHNyYy9pbnRlcm5hbC50c1xudmFyIGtJbnRlcm5hbCA9IFN5bWJvbCgpO1xuXG4vLyBzcmMvZGV2dG9vbHMvYnJpZGdlLnRzXG52YXIgX2JyaWRnZUFjdGl2ZSA9IGZhbHNlO1xuZnVuY3Rpb24gYWN0aXZhdGVCcmlkZ2UoYWxsb3dlZCkge1xuICBfYnJpZGdlQWN0aXZlID0gYWxsb3dlZDtcbn1cbmZ1bmN0aW9uIHNlbmRUb1BhbmVsKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZ1bGxNc2cgPSB7XG4gICAgLi4ubWVzc2FnZSxcbiAgICBzb3VyY2U6IFwibGl2ZWJsb2Nrcy1kZXZ0b29scy1jbGllbnRcIlxuICB9O1xuICBpZiAoIShvcHRpb25zPy5mb3JjZSB8fCBfYnJpZGdlQWN0aXZlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cucG9zdE1lc3NhZ2UoZnVsbE1zZywgXCIqXCIpO1xufVxudmFyIGV2ZW50U291cmNlID0gbWFrZUV2ZW50U291cmNlKCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5zb3VyY2UgPT09IHdpbmRvdyAmJiBldmVudC5kYXRhPy5zb3VyY2UgPT09IFwibGl2ZWJsb2Nrcy1kZXZ0b29scy1wYW5lbFwiKSB7XG4gICAgICBldmVudFNvdXJjZS5ub3RpZnkoZXZlbnQuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICB9XG4gIH0pO1xufVxudmFyIG9uTWVzc2FnZUZyb21QYW5lbCA9IGV2ZW50U291cmNlLm9ic2VydmFibGU7XG5cbi8vIHNyYy9kZXZ0b29scy9pbmRleC50c1xudmFyIFZFUlNJT04gPSBQS0dfVkVSU0lPTiB8fCBcImRldlwiO1xudmFyIF9kZXZ0b29sc1NldHVwSGFzUnVuID0gZmFsc2U7XG5mdW5jdGlvbiBzZXR1cERldlRvb2xzKGdldEFsbFJvb21zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoX2RldnRvb2xzU2V0dXBIYXNSdW4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgX2RldnRvb2xzU2V0dXBIYXNSdW4gPSB0cnVlO1xuICBvbk1lc3NhZ2VGcm9tUGFuZWwuc3Vic2NyaWJlKChtc2cpID0+IHtcbiAgICBzd2l0Y2ggKG1zZy5tc2cpIHtcbiAgICAgIC8vIFdoZW4gYSBkZXZ0b29sIHBhbmVsIHNlbmRzIGFuIGV4cGxpY2l0IFwiY29ubmVjdFwiIG1lc3NhZ2UgYmFjayB0byB0aGlzXG4gICAgICAvLyBsaXZlIHJ1bm5pbmcgY2xpZW50IChpbiByZXNwb25zZSB0byB0aGUgXCJ3YWtlLXVwLWRldnRvb2xzXCIgbWVzc2FnZSxcbiAgICAgIC8vIG9yIHdoZW4gdGhlIGRldnRvb2wgcGFuZWwgaXMgb3BlbmVkIGZvciB0aGUgZmlyc3QgdGltZSksIGl0IG1lYW5zIHRoYXQgaXQncyBva2F5IHRvXG4gICAgICAvLyBzdGFydCBlbWl0dGluZyBtZXNzYWdlcy5cbiAgICAgIC8vIEJlZm9yZSB0aGlzIGV4cGxpY2l0IGFja25vd2xlZGdlbWVudCwgYW55IGNhbGwgdG8gc2VuZFRvUGFuZWwoKSB3aWxsXG4gICAgICAvLyBiZSBhIG5vLW9wLlxuICAgICAgY2FzZSBcImNvbm5lY3RcIjoge1xuICAgICAgICBhY3RpdmF0ZUJyaWRnZSh0cnVlKTtcbiAgICAgICAgZm9yIChjb25zdCByb29tSWQgb2YgZ2V0QWxsUm9vbXMoKSkge1xuICAgICAgICAgIHNlbmRUb1BhbmVsKHtcbiAgICAgICAgICAgIG1zZzogXCJyb29tOjphdmFpbGFibGVcIixcbiAgICAgICAgICAgIHJvb21JZCxcbiAgICAgICAgICAgIGNsaWVudFZlcnNpb246IFZFUlNJT05cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBzZW5kVG9QYW5lbCh7IG1zZzogXCJ3YWtlLXVwLWRldnRvb2xzXCIgfSwgeyBmb3JjZTogdHJ1ZSB9KTtcbn1cbnZhciB1bnN1YnNCeVJvb21JZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBzdG9wU3luY1N0cmVhbShyb29tSWQpIHtcbiAgY29uc3QgdW5zdWJzID0gdW5zdWJzQnlSb29tSWQuZ2V0KHJvb21JZCkgPz8gW107XG4gIHVuc3Vic0J5Um9vbUlkLmRlbGV0ZShyb29tSWQpO1xuICBmb3IgKGNvbnN0IHVuc3ViIG9mIHVuc3Vicykge1xuICAgIHVuc3ViKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHN0YXJ0U3luY1N0cmVhbShyb29tKSB7XG4gIHN0b3BTeW5jU3RyZWFtKHJvb20uaWQpO1xuICBmdWxsU3luYyhyb29tKTtcbiAgdW5zdWJzQnlSb29tSWQuc2V0KHJvb20uaWQsIFtcbiAgICAvLyBXaGVuIHRoZSBjb25uZWN0aW9uIHN0YXR1cyBjaGFuZ2VzXG4gICAgcm9vbS5ldmVudHMuc3RhdHVzLnN1YnNjcmliZSgoKSA9PiBwYXJ0aWFsU3luY0Nvbm5lY3Rpb24ocm9vbSkpLFxuICAgIC8vIFdoZW4gc3RvcmFnZSBpbml0aWFsaXplcywgc2VuZCB0aGUgdXBkYXRlXG4gICAgcm9vbS5ldmVudHMuc3RvcmFnZURpZExvYWQuc3Vic2NyaWJlT25jZSgoKSA9PiBwYXJ0aWFsU3luY1N0b3JhZ2Uocm9vbSkpLFxuICAgIC8vIEFueSB0aW1lIHN0b3JhZ2UgdXBkYXRlcywgc2VuZCB0aGUgbmV3IHN0b3JhZ2Ugcm9vdFxuICAgIHJvb20uZXZlbnRzLnN0b3JhZ2VCYXRjaC5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNTdG9yYWdlKHJvb20pKSxcbiAgICAvLyBBbnkgdGltZSBcIm1lXCIgb3IgXCJvdGhlcnNcIiB1cGRhdGVzLCBzZW5kIHRoZSBuZXcgdmFsdWVzIGFjY29yZGluZ2x5XG4gICAgcm9vbS5ldmVudHMuc2VsZi5zdWJzY3JpYmUoKCkgPT4gcGFydGlhbFN5bmNNZShyb29tKSksXG4gICAgcm9vbS5ldmVudHMub3RoZXJzLnN1YnNjcmliZSgoKSA9PiBwYXJ0aWFsU3luY090aGVycyhyb29tKSksXG4gICAgLy8gQW55IHRpbWUgeWRvYyBpcyB1cGRhdGVkLCBmb3J3YXJkIHRoZSB1cGRhdGVcbiAgICByb29tLmV2ZW50cy55ZG9jLnN1YnNjcmliZSgodXBkYXRlKSA9PiBzeW5jWWRvY1VwZGF0ZShyb29tLCB1cGRhdGUpKSxcbiAgICAvLyBBbnkgdGltZSBhIGN1c3RvbSByb29tIGV2ZW50IGlzIHJlY2VpdmVkLCBmb3J3YXJkIGl0XG4gICAgcm9vbS5ldmVudHMuY3VzdG9tRXZlbnQuc3Vic2NyaWJlKFxuICAgICAgKGV2ZW50RGF0YSkgPT4gZm9yd2FyZEV2ZW50KHJvb20sIGV2ZW50RGF0YSlcbiAgICApXG4gIF0pO1xufVxuZnVuY3Rpb24gc3luY1lkb2NVcGRhdGUocm9vbSwgdXBkYXRlKSB7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6c3luYzo6eWRvY1wiLFxuICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICB1cGRhdGVcbiAgfSk7XG59XG52YXIgbG9hZGVkQXQgPSBEYXRlLm5vdygpO1xudmFyIGV2ZW50Q291bnRlciA9IDA7XG5mdW5jdGlvbiBuZXh0RXZlbnRJZCgpIHtcbiAgcmV0dXJuIGBldmVudC0ke2xvYWRlZEF0fS0ke2V2ZW50Q291bnRlcisrfWA7XG59XG5mdW5jdGlvbiBmb3J3YXJkRXZlbnQocm9vbSwgZXZlbnREYXRhKSB7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6ZXZlbnRzOjpjdXN0b20tZXZlbnRcIixcbiAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgZXZlbnQ6IHtcbiAgICAgIHR5cGU6IFwiQ3VzdG9tRXZlbnRcIixcbiAgICAgIGlkOiBuZXh0RXZlbnRJZCgpLFxuICAgICAga2V5OiBcIkV2ZW50XCIsXG4gICAgICBjb25uZWN0aW9uSWQ6IGV2ZW50RGF0YS5jb25uZWN0aW9uSWQsXG4gICAgICBwYXlsb2FkOiBldmVudERhdGEuZXZlbnRcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcGFydGlhbFN5bmNDb25uZWN0aW9uKHJvb20pIHtcbiAgc2VuZFRvUGFuZWwoe1xuICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgcm9vbUlkOiByb29tLmlkLFxuICAgIHN0YXR1czogcm9vbS5nZXRTdGF0dXMoKVxuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jU3RvcmFnZShyb29tKSB7XG4gIGNvbnN0IHJvb3QgPSByb29tLmdldFN0b3JhZ2VTbmFwc2hvdCgpO1xuICBpZiAocm9vdCkge1xuICAgIHNlbmRUb1BhbmVsKHtcbiAgICAgIG1zZzogXCJyb29tOjpzeW5jOjpwYXJ0aWFsXCIsXG4gICAgICByb29tSWQ6IHJvb20uaWQsXG4gICAgICBzdG9yYWdlOiByb290LnRvVHJlZU5vZGUoXCJyb290XCIpLnBheWxvYWRcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGFydGlhbFN5bmNNZShyb29tKSB7XG4gIGNvbnN0IG1lID0gcm9vbVtrSW50ZXJuYWxdLmdldFNlbGZfZm9yRGV2VG9vbHMoKTtcbiAgaWYgKG1lKSB7XG4gICAgc2VuZFRvUGFuZWwoe1xuICAgICAgbXNnOiBcInJvb206OnN5bmM6OnBhcnRpYWxcIixcbiAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgIG1lXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnRpYWxTeW5jT3RoZXJzKHJvb20pIHtcbiAgY29uc3Qgb3RoZXJzID0gcm9vbVtrSW50ZXJuYWxdLmdldE90aGVyc19mb3JEZXZUb29scygpO1xuICBpZiAob3RoZXJzKSB7XG4gICAgc2VuZFRvUGFuZWwoe1xuICAgICAgbXNnOiBcInJvb206OnN5bmM6OnBhcnRpYWxcIixcbiAgICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICAgIG90aGVyc1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBmdWxsU3luYyhyb29tKSB7XG4gIGNvbnN0IHJvb3QgPSByb29tLmdldFN0b3JhZ2VTbmFwc2hvdCgpO1xuICBjb25zdCBtZSA9IHJvb21ba0ludGVybmFsXS5nZXRTZWxmX2ZvckRldlRvb2xzKCk7XG4gIGNvbnN0IG90aGVycyA9IHJvb21ba0ludGVybmFsXS5nZXRPdGhlcnNfZm9yRGV2VG9vbHMoKTtcbiAgcm9vbS5mZXRjaFlEb2MoXCJcIik7XG4gIHNlbmRUb1BhbmVsKHtcbiAgICBtc2c6IFwicm9vbTo6c3luYzo6ZnVsbFwiLFxuICAgIHJvb21JZDogcm9vbS5pZCxcbiAgICBzdGF0dXM6IHJvb20uZ2V0U3RhdHVzKCksXG4gICAgc3RvcmFnZTogcm9vdD8udG9UcmVlTm9kZShcInJvb3RcIikucGF5bG9hZCA/PyBudWxsLFxuICAgIG1lLFxuICAgIG90aGVyc1xuICB9KTtcbn1cbnZhciByb29tQ2hhbm5lbExpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBzdG9wUm9vbUNoYW5uZWxMaXN0ZW5lcihyb29tSWQpIHtcbiAgY29uc3QgbGlzdGVuZXIgPSByb29tQ2hhbm5lbExpc3RlbmVycy5nZXQocm9vbUlkKTtcbiAgcm9vbUNoYW5uZWxMaXN0ZW5lcnMuZGVsZXRlKHJvb21JZCk7XG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGxpc3RlbmVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGxpbmtEZXZUb29scyhyb29tSWQsIHJvb20pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNlbmRUb1BhbmVsKHsgbXNnOiBcInJvb206OmF2YWlsYWJsZVwiLCByb29tSWQsIGNsaWVudFZlcnNpb246IFZFUlNJT04gfSk7XG4gIHN0b3BSb29tQ2hhbm5lbExpc3RlbmVyKHJvb21JZCk7XG4gIHJvb21DaGFubmVsTGlzdGVuZXJzLnNldChcbiAgICByb29tSWQsXG4gICAgLy8gUmV0dXJucyB0aGUgdW5zdWJzY3JpYmUgY2FsbGJhY2ssIHRoYXQgd2Ugc3RvcmUgaW4gdGhlXG4gICAgLy8gcm9vbUNoYW5uZWxMaXN0ZW5lcnMgcmVnaXN0cnlcbiAgICBvbk1lc3NhZ2VGcm9tUGFuZWwuc3Vic2NyaWJlKChtc2cpID0+IHtcbiAgICAgIHN3aXRjaCAobXNnLm1zZykge1xuICAgICAgICAvLyBTZW50IGJ5IHRoZSBkZXZ0b29sIHBhbmVsIHdoZW4gaXQgd2FudHMgdG8gcmVjZWl2ZSB0aGUgc3luYyBzdHJlYW1cbiAgICAgICAgLy8gZm9yIGEgcm9vbVxuICAgICAgICBjYXNlIFwicm9vbTo6c3Vic2NyaWJlXCI6IHtcbiAgICAgICAgICBpZiAobXNnLnJvb21JZCA9PT0gcm9vbUlkKSB7XG4gICAgICAgICAgICBzdGFydFN5bmNTdHJlYW0ocm9vbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJyb29tOjp1bnN1YnNjcmliZVwiOiB7XG4gICAgICAgICAgaWYgKG1zZy5yb29tSWQgPT09IHJvb21JZCkge1xuICAgICAgICAgICAgc3RvcFN5bmNTdHJlYW0ocm9vbUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gdW5saW5rRGV2VG9vbHMocm9vbUlkKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBzdG9wU3luY1N0cmVhbShyb29tSWQpO1xuICBzdG9wUm9vbUNoYW5uZWxMaXN0ZW5lcihyb29tSWQpO1xuICBzZW5kVG9QYW5lbCh7XG4gICAgbXNnOiBcInJvb206OnVuYXZhaWxhYmxlXCIsXG4gICAgcm9vbUlkXG4gIH0pO1xufVxuXG4vLyBzcmMvcHJvdG9jb2wvVXNlck5vdGlmaWNhdGlvblNldHRpbmdzLnRzXG52YXIga1BsYWluID0gU3ltYm9sKFwidXNlci1ub3RpZmljYXRpb24tc2V0dGluZ3MtcGxhaW5cIik7XG5mdW5jdGlvbiBjcmVhdGVVc2VyTm90aWZpY2F0aW9uU2V0dGluZ3MocGxhaW4pIHtcbiAgY29uc3QgY2hhbm5lbHMgPSBbXG4gICAgXCJlbWFpbFwiLFxuICAgIFwic2xhY2tcIixcbiAgICBcInRlYW1zXCIsXG4gICAgXCJ3ZWJQdXNoXCJcbiAgXTtcbiAgY29uc3QgZGVzY3JpcHRvcnMgPSB7XG4gICAgW2tQbGFpbl06IHtcbiAgICAgIHZhbHVlOiBwbGFpbixcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgfVxuICB9O1xuICBmb3IgKGNvbnN0IGNoYW5uZWwgb2YgY2hhbm5lbHMpIHtcbiAgICBkZXNjcmlwdG9yc1tjaGFubmVsXSA9IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAvKipcbiAgICAgICAqIEluIHRoZSBUeXBlU2NyaXB0IHN0YW5kYXJkIGxpYnJhcnkgZGVmaW5pdGlvbnMsIHRoZSBidWlsdC1pbiBpbnRlcmZhY2UgZm9yIGEgcHJvcGVydHkgZGVzY3JpcHRvclxuICAgICAgICogZG9lcyBub3QgaW5jbHVkZSBhIHNwZWNpYWxpemVkIHR5cGUgZm9yIHRoZSDigJx0aGlz4oCdIGNvbnRleHQgaW4gdGhlIGdldHRlciBvciBzZXR0ZXIgZnVuY3Rpb25zLlxuICAgICAgICogQXMgYSByZXN1bHQsIGJvdGggdGhlIOKBoGdldCBhbmQg4oGgc2V0IG1ldGhvZHMgaW1wbGljaXRseSBoYXZlIOKBoHRoaXM6IGFueS5cbiAgICAgICAqIFRoZSByZWFzb24gaXMgdGhhdCBwcm9wZXJ0eSBkZXNjcmlwdG9ycyBpbiBKYXZhU2NyaXB0IGFyZSB1c2VkIGFjcm9zcyB2YXJpb3VzIG9iamVjdHMgd2l0aFxuICAgICAgICogbm8gZW5mb3JjZWQgc2hhcGUgZm9yIOKBoHRoaXMuIEFuZCBzbyB0aGUgc3RhbmRhcmQgbGlicmFyeSBkZWZpbml0aW9ucyBoYXZlIHRvIHJlbWFpbiBhcyBicm9hZCBhcyBwb3NzaWJsZVxuICAgICAgICogdG8gc3VwcG9ydCBhbnkgdmFsaWQgSmF2YVNjcmlwdCB1c2FnZSAoZS5nIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgKS5cbiAgICAgICAqXG4gICAgICAgKiBTbyB3ZSBjYW4gc2FmZWx5IHRlbGxzIHRoYXQgdGhpcyBnZXR0ZXIgaXMgdHlwZWQgYXMgYHRoaXM6IFVzZXJOb3RpZmljYXRpb25TZXR0aW5nc2AgYmVjYXVzZSB3ZSdyZVxuICAgICAgICogY3JlYXRpbmcgYSB3ZWxsIGtub3duIHNoYXBlZCBvYmplY3Qg4oaSIGBVc2VyTm90aWZpY2F0aW9uU2V0dGluZ3NgLlxuICAgICAgICovXG4gICAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpc1trUGxhaW5dW2NoYW5uZWxdO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgZXJyb3IyKFxuICAgICAgICAgICAgYEluIG9yZGVyIHRvIHVzZSB0aGUgJyR7Y2hhbm5lbH0nIGNoYW5uZWwsIHBsZWFzZSBzZXQgdXAgeW91ciBwcm9qZWN0IGZpcnN0LiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2VuYWJsZS1hLW5vdGlmaWNhdGlvbi1jaGFubmVsYFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZShudWxsLCBkZXNjcmlwdG9ycyk7XG59XG5mdW5jdGlvbiBwYXRjaFVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyhleGlzdGluZywgcGF0Y2gpIHtcbiAgY29uc3Qgb3V0Y29taW5nID0gY3JlYXRlVXNlck5vdGlmaWNhdGlvblNldHRpbmdzKHtcbiAgICAuLi5leGlzdGluZ1trUGxhaW5dXG4gIH0pO1xuICBmb3IgKGNvbnN0IGNoYW5uZWwgb2Yga2V5cyhwYXRjaCkpIHtcbiAgICBjb25zdCB1cGRhdGVzID0gcGF0Y2hbY2hhbm5lbF07XG4gICAgaWYgKHVwZGF0ZXMgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3Qga2luZFVwZGF0ZXMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIGVudHJpZXModXBkYXRlcykuZmlsdGVyKChbLCB2YWx1ZV0pID0+IHZhbHVlICE9PSB2b2lkIDApXG4gICAgICApO1xuICAgICAgb3V0Y29taW5nW2tQbGFpbl1bY2hhbm5lbF0gPSB7XG4gICAgICAgIC4uLm91dGNvbWluZ1trUGxhaW5dW2NoYW5uZWxdLFxuICAgICAgICAuLi5raW5kVXBkYXRlc1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dGNvbWluZztcbn1cbmZ1bmN0aW9uIGlzTm90aWZpY2F0aW9uQ2hhbm5lbEVuYWJsZWQoc2V0dGluZ3MpIHtcbiAgcmV0dXJuIHNldHRpbmdzICE9PSBudWxsID8gdmFsdWVzKHNldHRpbmdzKS5ldmVyeSgoZW5hYmxlZCkgPT4gZW5hYmxlZCA9PT0gdHJ1ZSkgOiBmYWxzZTtcbn1cblxuLy8gc3JjL2xpYi9wb3NpdGlvbi50c1xudmFyIE1JTl9DT0RFID0gMzI7XG52YXIgTUFYX0NPREUgPSAxMjY7XG52YXIgTlVNX0RJR0lUUyA9IE1BWF9DT0RFIC0gTUlOX0NPREUgKyAxO1xudmFyIFpFUk8gPSBudGhEaWdpdCgwKTtcbnZhciBPTkUgPSBudGhEaWdpdCgxKTtcbnZhciBaRVJPX05JTkUgPSBaRVJPICsgbnRoRGlnaXQoLTEpO1xuZnVuY3Rpb24gbnRoRGlnaXQobikge1xuICBjb25zdCBjb2RlID0gTUlOX0NPREUgKyAobiA8IDAgPyBOVU1fRElHSVRTICsgbiA6IG4pO1xuICBpZiAoY29kZSA8IE1JTl9DT0RFIHx8IGNvZGUgPiBNQVhfQ09ERSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuIHZhbHVlOiAke259YCk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG59XG5mdW5jdGlvbiBtYWtlUG9zaXRpb24oeCwgeSkge1xuICBpZiAoeCAhPT0gdm9pZCAwICYmIHkgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBiZXR3ZWVuKHgsIHkpO1xuICB9IGVsc2UgaWYgKHggIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBhZnRlcih4KTtcbiAgfSBlbHNlIGlmICh5ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gYmVmb3JlKHkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBPTkU7XG4gIH1cbn1cbmZ1bmN0aW9uIGJlZm9yZShwb3MpIHtcbiAgY29uc3QgbGFzdEluZGV4ID0gcG9zLmxlbmd0aCAtIDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHBvcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlIDw9IE1JTl9DT0RFKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGkgPT09IGxhc3RJbmRleCkge1xuICAgICAgaWYgKGNvZGUgPT09IE1JTl9DT0RFICsgMSkge1xuICAgICAgICByZXR1cm4gcG9zLnN1YnN0cmluZygwLCBpKSArIFpFUk9fTklORTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwb3Muc3Vic3RyaW5nKDAsIGkgKyAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9ORTtcbn1cbmZ1bmN0aW9uIGFmdGVyKHBvcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8PSBwb3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHBvcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID49IE1BWF9DT0RFKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcy5zdWJzdHJpbmcoMCwgaSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUgKyAxKTtcbiAgfVxuICByZXR1cm4gcG9zICsgT05FO1xufVxuZnVuY3Rpb24gYmV0d2VlbihsbywgaGkpIHtcbiAgaWYgKGxvIDwgaGkpIHtcbiAgICByZXR1cm4gX2JldHdlZW4obG8sIGhpKTtcbiAgfSBlbHNlIGlmIChsbyA+IGhpKSB7XG4gICAgcmV0dXJuIF9iZXR3ZWVuKGhpLCBsbyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgdmFsdWUgYmV0d2VlbiB0d28gZXF1YWwgcG9zaXRpb25zXCIpO1xuICB9XG59XG5mdW5jdGlvbiBfYmV0d2VlbihsbywgaGkpIHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgY29uc3QgbG9MZW4gPSBsby5sZW5ndGg7XG4gIGNvbnN0IGhpTGVuID0gaGkubGVuZ3RoO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IGxvQ29kZSA9IGluZGV4IDwgbG9MZW4gPyBsby5jaGFyQ29kZUF0KGluZGV4KSA6IE1JTl9DT0RFO1xuICAgIGNvbnN0IGhpQ29kZSA9IGluZGV4IDwgaGlMZW4gPyBoaS5jaGFyQ29kZUF0KGluZGV4KSA6IE1BWF9DT0RFO1xuICAgIGlmIChsb0NvZGUgPT09IGhpQ29kZSkge1xuICAgICAgaW5kZXgrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaGlDb2RlIC0gbG9Db2RlID09PSAxKSB7XG4gICAgICBjb25zdCBzaXplID0gaW5kZXggKyAxO1xuICAgICAgbGV0IHByZWZpeCA9IGxvLnN1YnN0cmluZygwLCBzaXplKTtcbiAgICAgIGlmIChwcmVmaXgubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgICBwcmVmaXggKz0gWkVSTy5yZXBlYXQoc2l6ZSAtIHByZWZpeC5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3VmZml4ID0gbG8uc3Vic3RyaW5nKHNpemUpO1xuICAgICAgY29uc3QgbmluZXMgPSBcIlwiO1xuICAgICAgcmV0dXJuIHByZWZpeCArIF9iZXR3ZWVuKHN1ZmZpeCwgbmluZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGFrZU4obG8sIGluZGV4KSArIFN0cmluZy5mcm9tQ2hhckNvZGUoaGlDb2RlICsgbG9Db2RlID4+IDEpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdGFrZU4ocG9zLCBuKSB7XG4gIHJldHVybiBuIDwgcG9zLmxlbmd0aCA/IHBvcy5zdWJzdHJpbmcoMCwgbikgOiBwb3MgKyBaRVJPLnJlcGVhdChuIC0gcG9zLmxlbmd0aCk7XG59XG52YXIgTUlOX05PTl9aRVJPX0NPREUgPSBNSU5fQ09ERSArIDE7XG5mdW5jdGlvbiBpc1BvcyhzdHIpIHtcbiAgaWYgKHN0ciA9PT0gXCJcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsYXN0SWR4ID0gc3RyLmxlbmd0aCAtIDE7XG4gIGNvbnN0IGxhc3QgPSBzdHIuY2hhckNvZGVBdChsYXN0SWR4KTtcbiAgaWYgKGxhc3QgPCBNSU5fTk9OX1pFUk9fQ09ERSB8fCBsYXN0ID4gTUFYX0NPREUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0SWR4OyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPCBNSU5fQ09ERSB8fCBjb2RlID4gTUFYX0NPREUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9Qb3Moc3RyKSB7XG4gIGNvbnN0IGNvZGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGNvZGVzLnB1c2goY29kZSA8IE1JTl9DT0RFID8gTUlOX0NPREUgOiBjb2RlID4gTUFYX0NPREUgPyBNQVhfQ09ERSA6IGNvZGUpO1xuICB9XG4gIHdoaWxlIChjb2Rlcy5sZW5ndGggPiAwICYmIGNvZGVzW2NvZGVzLmxlbmd0aCAtIDFdID09PSBNSU5fQ09ERSkge1xuICAgIGNvZGVzLmxlbmd0aC0tO1xuICB9XG4gIHJldHVybiBjb2Rlcy5sZW5ndGggPiAwID8gU3RyaW5nLmZyb21DaGFyQ29kZSguLi5jb2RlcykgOiAoXG4gICAgLy8gRWRnZSBjYXNlOiB0aGUgc3RyIHdhcyBhIDAtb25seSBzdHJpbmcsIHdoaWNoIGlzIGludmFsaWQuIERlZmF1bHQgYmFjayB0byAuMVxuICAgIE9ORVxuICApO1xufVxuZnVuY3Rpb24gYXNQb3Moc3RyKSB7XG4gIHJldHVybiBpc1BvcyhzdHIpID8gc3RyIDogY29udmVydFRvUG9zKHN0cik7XG59XG5cbi8vIHNyYy9wcm90b2NvbC9PcC50c1xudmFyIE9wQ29kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE9wQ29kZTIpID0+IHtcbiAgT3BDb2RlMltPcENvZGUyW1wiSU5JVFwiXSA9IDBdID0gXCJJTklUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIlNFVF9QQVJFTlRfS0VZXCJdID0gMV0gPSBcIlNFVF9QQVJFTlRfS0VZXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9MSVNUXCJdID0gMl0gPSBcIkNSRUFURV9MSVNUXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIlVQREFURV9PQkpFQ1RcIl0gPSAzXSA9IFwiVVBEQVRFX09CSkVDVFwiO1xuICBPcENvZGUyW09wQ29kZTJbXCJDUkVBVEVfT0JKRUNUXCJdID0gNF0gPSBcIkNSRUFURV9PQkpFQ1RcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiREVMRVRFX0NSRFRcIl0gPSA1XSA9IFwiREVMRVRFX0NSRFRcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiREVMRVRFX09CSkVDVF9LRVlcIl0gPSA2XSA9IFwiREVMRVRFX09CSkVDVF9LRVlcIjtcbiAgT3BDb2RlMltPcENvZGUyW1wiQ1JFQVRFX01BUFwiXSA9IDddID0gXCJDUkVBVEVfTUFQXCI7XG4gIE9wQ29kZTJbT3BDb2RlMltcIkNSRUFURV9SRUdJU1RFUlwiXSA9IDhdID0gXCJDUkVBVEVfUkVHSVNURVJcIjtcbiAgcmV0dXJuIE9wQ29kZTI7XG59KShPcENvZGUgfHwge30pO1xuZnVuY3Rpb24gYWNrT3Aob3BJZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sXG4gICAgaWQ6IFwiQUNLXCIsXG4gICAgLy8gKEgpQUNLXG4gICAgb3BJZFxuICB9O1xufVxuZnVuY3Rpb24gaXNBY2tPcChvcCkge1xuICByZXR1cm4gb3AudHlwZSA9PT0gNSAvKiBERUxFVEVfQ1JEVCAqLyAmJiBvcC5pZCA9PT0gXCJBQ0tcIjtcbn1cblxuLy8gc3JjL2NyZHRzL0Fic3RyYWN0Q3JkdC50c1xuZnVuY3Rpb24gY3JlYXRlTWFuYWdlZFBvb2wocm9vbUlkLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBnZXRDdXJyZW50Q29ubmVjdGlvbklkLFxuICAgIG9uRGlzcGF0Y2gsXG4gICAgaXNTdG9yYWdlV3JpdGFibGUgPSAoKSA9PiB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBsZXQgY2xvY2sgPSAwO1xuICBsZXQgb3BDbG9jayA9IDA7XG4gIGNvbnN0IG5vZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgcmV0dXJuIHtcbiAgICByb29tSWQsXG4gICAgbm9kZXMsXG4gICAgZ2V0Tm9kZTogKGlkKSA9PiBub2Rlcy5nZXQoaWQpLFxuICAgIGFkZE5vZGU6IChpZCwgbm9kZSkgPT4gdm9pZCBub2Rlcy5zZXQoaWQsIG5vZGUpLFxuICAgIGRlbGV0ZU5vZGU6IChpZCkgPT4gdm9pZCBub2Rlcy5kZWxldGUoaWQpLFxuICAgIGdlbmVyYXRlSWQ6ICgpID0+IGAke2dldEN1cnJlbnRDb25uZWN0aW9uSWQoKX06JHtjbG9jaysrfWAsXG4gICAgZ2VuZXJhdGVPcElkOiAoKSA9PiBgJHtnZXRDdXJyZW50Q29ubmVjdGlvbklkKCl9OiR7b3BDbG9jaysrfWAsXG4gICAgZGlzcGF0Y2gob3BzLCByZXZlcnNlLCBzdG9yYWdlVXBkYXRlcykge1xuICAgICAgb25EaXNwYXRjaD8uKG9wcywgcmV2ZXJzZSwgc3RvcmFnZVVwZGF0ZXMpO1xuICAgIH0sXG4gICAgYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGU6ICgpID0+IHtcbiAgICAgIGlmICghaXNTdG9yYWdlV3JpdGFibGUoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJDYW5ub3Qgd3JpdGUgdG8gc3RvcmFnZSB3aXRoIGEgcmVhZCBvbmx5IHVzZXIsIHBsZWFzZSBlbnN1cmUgdGhlIHVzZXIgaGFzIHdyaXRlIHBlcm1pc3Npb25zXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjcmR0QXNMaXZlTm9kZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBIYXNQYXJlbnQobm9kZSwga2V5LCBwb3MgPSBhc1BvcyhrZXkpKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHsgdHlwZTogXCJIYXNQYXJlbnRcIiwgbm9kZSwga2V5LCBwb3MgfSk7XG59XG52YXIgTm9QYXJlbnQgPSBPYmplY3QuZnJlZXplKHsgdHlwZTogXCJOb1BhcmVudFwiIH0pO1xuZnVuY3Rpb24gT3JwaGFuZWQob2xkS2V5LCBvbGRQb3MgPSBhc1BvcyhvbGRLZXkpKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHsgdHlwZTogXCJPcnBoYW5lZFwiLCBvbGRLZXksIG9sZFBvcyB9KTtcbn1cbnZhciBBYnN0cmFjdENyZHQgPSBjbGFzcyB7XG4gIC8vICAgICAgICAgICAgICAgICAgXl5eXl5eXl5eXl5eIFRPRE86IE1ha2UgdGhpcyBhbiBpbnRlcmZhY2VcbiAgI3Bvb2w7XG4gICNpZDtcbiAgI3BhcmVudCA9IE5vUGFyZW50O1xuICAvKiogQGludGVybmFsICovXG4gIF9nZXRQYXJlbnRLZXlPclRocm93KCkge1xuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQua2V5O1xuICAgICAgY2FzZSBcIk5vUGFyZW50XCI6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBrZXkgaXMgbWlzc2luZ1wiKTtcbiAgICAgIGNhc2UgXCJPcnBoYW5lZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQub2xkS2V5O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IF9wYXJlbnRQb3MoKSB7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiSGFzUGFyZW50XCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5wb3M7XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyZW50IGtleSBpcyBtaXNzaW5nXCIpO1xuICAgICAgY2FzZSBcIk9ycGhhbmVkXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5vbGRQb3M7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgX3Bvb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Bvb2w7XG4gIH1cbiAgZ2V0IHJvb21JZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9vbCA/IHRoaXMuI3Bvb2wucm9vbUlkIDogbnVsbDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldCBfaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lkO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IHBhcmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcGFyZW50O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IF9wYXJlbnRLZXkoKSB7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiSGFzUGFyZW50XCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5rZXk7XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm9sZEtleTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhc3NlcnROZXZlcih0aGlzLnBhcmVudCwgXCJVbmtub3duIHN0YXRlXCIpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseShvcCwgX2lzTG9jYWwpIHtcbiAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgIGNhc2UgNSAvKiBERUxFVEVfQ1JEVCAqLzoge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5ub2RlLl9kZXRhY2hDaGlsZChjcmR0QXNMaXZlTm9kZSh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NldFBhcmVudExpbmsobmV3UGFyZW50Tm9kZSwgbmV3UGFyZW50S2V5KSB7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiSGFzUGFyZW50XCI6XG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5ub2RlICE9PSBuZXdQYXJlbnROb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBwYXJlbnQ6IG5vZGUgYWxyZWFkeSBoYXMgYSBwYXJlbnRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4jcGFyZW50ID0gSGFzUGFyZW50KG5ld1BhcmVudE5vZGUsIG5ld1BhcmVudEtleSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjpcbiAgICAgIGNhc2UgXCJOb1BhcmVudFwiOiB7XG4gICAgICAgIHRoaXMuI3BhcmVudCA9IEhhc1BhcmVudChuZXdQYXJlbnROb2RlLCBuZXdQYXJlbnRLZXkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIodGhpcy5wYXJlbnQsIFwiVW5rbm93biBzdGF0ZVwiKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoKGlkLCBwb29sKSB7XG4gICAgaWYgKHRoaXMuI2lkIHx8IHRoaXMuI3Bvb2wpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhdHRhY2ggbm9kZTogYWxyZWFkeSBhdHRhY2hlZFwiKTtcbiAgICB9XG4gICAgcG9vbC5hZGROb2RlKGlkLCBjcmR0QXNMaXZlTm9kZSh0aGlzKSk7XG4gICAgdGhpcy4jaWQgPSBpZDtcbiAgICB0aGlzLiNwb29sID0gcG9vbDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2goKSB7XG4gICAgaWYgKHRoaXMuI3Bvb2wgJiYgdGhpcy4jaWQpIHtcbiAgICAgIHRoaXMuI3Bvb2wuZGVsZXRlTm9kZSh0aGlzLiNpZCk7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5wYXJlbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkhhc1BhcmVudFwiOiB7XG4gICAgICAgIHRoaXMuI3BhcmVudCA9IE9ycGhhbmVkKHRoaXMucGFyZW50LmtleSwgdGhpcy5wYXJlbnQucG9zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiTm9QYXJlbnRcIjoge1xuICAgICAgICB0aGlzLiNwYXJlbnQgPSBOb1BhcmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiT3JwaGFuZWRcIjoge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFzc2VydE5ldmVyKHRoaXMucGFyZW50LCBcIlVua25vd24gc3RhdGVcIik7XG4gICAgfVxuICAgIHRoaXMuI3Bvb2wgPSB2b2lkIDA7XG4gIH1cbiAgLyoqIFRoaXMgY2FjaGVzIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgLnRvSW1tdXRhYmxlKCkgY2FsbCBmb3IgdGhpcyBMaXZlIG5vZGUuICovXG4gICNjYWNoZWRJbW11dGFibGU7XG4gICNjYWNoZWRUcmVlTm9kZUtleTtcbiAgLyoqIFRoaXMgY2FjaGVzIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgLnRvVHJlZU5vZGUoKSBjYWxsIGZvciB0aGlzIExpdmUgbm9kZS4gKi9cbiAgI2NhY2hlZFRyZWVOb2RlO1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIENsZWFyIHRoZSBJbW11dGFibGUgY2FjaGUsIHNvIHRoYXQgdGhlIG5leHQgY2FsbCB0byBgLnRvSW1tdXRhYmxlKClgIHdpbGxcbiAgICogcmVjb21wdXRlIHRoZSBlcXVpdmFsZW50IEltbXV0YWJsZSB2YWx1ZSBhZ2Fpbi4gIENhbGwgdGhpcyBhZnRlciBldmVyeVxuICAgKiBtdXRhdGlvbiB0byB0aGUgTGl2ZSBub2RlLlxuICAgKi9cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICBpZiAodGhpcy4jY2FjaGVkSW1tdXRhYmxlICE9PSB2b2lkIDAgfHwgdGhpcy4jY2FjaGVkVHJlZU5vZGUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy4jY2FjaGVkSW1tdXRhYmxlID0gdm9pZCAwO1xuICAgICAgdGhpcy4jY2FjaGVkVHJlZU5vZGUgPSB2b2lkIDA7XG4gICAgICBpZiAodGhpcy5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgICB0aGlzLnBhcmVudC5ub2RlLmludmFsaWRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBSZXR1cm4gYW4gc25hcHNob3Qgb2YgdGhpcyBMaXZlIHRyZWUgZm9yIHVzZSBpbiBEZXZUb29scy5cbiAgICovXG4gIHRvVHJlZU5vZGUoa2V5KSB7XG4gICAgaWYgKHRoaXMuI2NhY2hlZFRyZWVOb2RlID09PSB2b2lkIDAgfHwgdGhpcy4jY2FjaGVkVHJlZU5vZGVLZXkgIT09IGtleSkge1xuICAgICAgdGhpcy4jY2FjaGVkVHJlZU5vZGVLZXkgPSBrZXk7XG4gICAgICB0aGlzLiNjYWNoZWRUcmVlTm9kZSA9IHRoaXMuX3RvVHJlZU5vZGUoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlZFRyZWVOb2RlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gaW1tdXRhYmxlIHNuYXBzaG90IG9mIHRoaXMgTGl2ZSBub2RlIGFuZCBpdHMgY2hpbGRyZW4uXG4gICAqL1xuICB0b0ltbXV0YWJsZSgpIHtcbiAgICBpZiAodGhpcy4jY2FjaGVkSW1tdXRhYmxlID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuI2NhY2hlZEltbXV0YWJsZSA9IHRoaXMuX3RvSW1tdXRhYmxlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNjYWNoZWRJbW11dGFibGU7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm90b2NvbC9TZXJpYWxpemVkQ3JkdC50c1xudmFyIENyZHRUeXBlID0gLyogQF9fUFVSRV9fICovICgoQ3JkdFR5cGUyKSA9PiB7XG4gIENyZHRUeXBlMltDcmR0VHlwZTJbXCJPQkpFQ1RcIl0gPSAwXSA9IFwiT0JKRUNUXCI7XG4gIENyZHRUeXBlMltDcmR0VHlwZTJbXCJMSVNUXCJdID0gMV0gPSBcIkxJU1RcIjtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIk1BUFwiXSA9IDJdID0gXCJNQVBcIjtcbiAgQ3JkdFR5cGUyW0NyZHRUeXBlMltcIlJFR0lTVEVSXCJdID0gM10gPSBcIlJFR0lTVEVSXCI7XG4gIHJldHVybiBDcmR0VHlwZTI7XG59KShDcmR0VHlwZSB8fCB7fSk7XG5mdW5jdGlvbiBpc1Jvb3RDcmR0KGNyZHQpIHtcbiAgcmV0dXJuIGNyZHQudHlwZSA9PT0gMCAvKiBPQkpFQ1QgKi8gJiYgIWlzQ2hpbGRDcmR0KGNyZHQpO1xufVxuZnVuY3Rpb24gaXNDaGlsZENyZHQoY3JkdCkge1xuICByZXR1cm4gY3JkdC5wYXJlbnRJZCAhPT0gdm9pZCAwICYmIGNyZHQucGFyZW50S2V5ICE9PSB2b2lkIDA7XG59XG5cbi8vIHNyYy9jcmR0cy9MaXZlUmVnaXN0ZXIudHNcbnZhciBMaXZlUmVnaXN0ZXIgPSBjbGFzcyBfTGl2ZVJlZ2lzdGVyIGV4dGVuZHMgQWJzdHJhY3RDcmR0IHtcbiAgI2RhdGE7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI2RhdGEgPSBkYXRhO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLiNkYXRhO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZShbaWQsIGl0ZW1dLCBfcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IHJlZ2lzdGVyID0gbmV3IF9MaXZlUmVnaXN0ZXIoaXRlbS5kYXRhKTtcbiAgICByZWdpc3Rlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICByZXR1cm4gcmVnaXN0ZXI7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9PcHMocGFyZW50SWQsIHBhcmVudEtleSwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ2Fubm90IHNlcmlhbGl6ZSByZWdpc3RlciBpZiBwYXJlbnRJZCBvciBwYXJlbnRLZXkgaXMgdW5kZWZpbmVkXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IDggLyogQ1JFQVRFX1JFR0lTVEVSICovLFxuICAgICAgICBvcElkOiBwb29sPy5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgICAgaWQ6IHRoaXMuX2lkLFxuICAgICAgICBwYXJlbnRJZCxcbiAgICAgICAgcGFyZW50S2V5LFxuICAgICAgICBkYXRhOiB0aGlzLmRhdGFcbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSAhPT0gXCJIYXNQYXJlbnRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBMaXZlUmVnaXN0ZXIgaWYgcGFyZW50IGlzIG1pc3NpbmdcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAzIC8qIFJFR0lTVEVSICovLFxuICAgICAgcGFyZW50SWQ6IG5uKHRoaXMucGFyZW50Lm5vZGUuX2lkLCBcIlBhcmVudCBub2RlIGV4cGVjdGVkIHRvIGhhdmUgSURcIiksXG4gICAgICBwYXJlbnRLZXk6IHRoaXMucGFyZW50LmtleSxcbiAgICAgIGRhdGE6IHRoaXMuZGF0YVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoQ2hpbGQoX29wKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoQ2hpbGQoX2NyZHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hcHBseShvcCwgaXNMb2NhbCkge1xuICAgIHJldHVybiBzdXBlci5fYXBwbHkob3AsIGlzTG9jYWwpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSnNvblwiLFxuICAgICAgaWQ6IHRoaXMuX2lkID8/IG5hbm9pZCgpLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogdGhpcy4jZGF0YVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RhdGE7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIGRlZXBDbG9uZSh0aGlzLmRhdGEpO1xuICB9XG59O1xuXG4vLyBzcmMvY3JkdHMvTGl2ZUxpc3QudHNcbmZ1bmN0aW9uIGNvbXBhcmVOb2RlUG9zaXRpb24oaXRlbUEsIGl0ZW1CKSB7XG4gIGNvbnN0IHBvc0EgPSBpdGVtQS5fcGFyZW50UG9zO1xuICBjb25zdCBwb3NCID0gaXRlbUIuX3BhcmVudFBvcztcbiAgcmV0dXJuIHBvc0EgPT09IHBvc0IgPyAwIDogcG9zQSA8IHBvc0IgPyAtMSA6IDE7XG59XG52YXIgTGl2ZUxpc3QgPSBjbGFzcyBfTGl2ZUxpc3QgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICAvLyBUT0RPOiBOYWl2ZSBhcnJheSBhdCBmaXJzdCwgZmluZCBhIGJldHRlciBkYXRhIHN0cnVjdHVyZS4gTWF5YmUgYW4gT3JkZXIgc3RhdGlzdGljcyB0cmVlP1xuICAjaXRlbXM7XG4gICNpbXBsaWNpdGx5RGVsZXRlZEl0ZW1zO1xuICAjdW5hY2tub3dsZWRnZWRTZXRzO1xuICBjb25zdHJ1Y3RvcihpdGVtcykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jaXRlbXMgPSBbXTtcbiAgICB0aGlzLiNpbXBsaWNpdGx5RGVsZXRlZEl0ZW1zID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgdGhpcy4jdW5hY2tub3dsZWRnZWRTZXRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgcG9zaXRpb24gPSB2b2lkIDA7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBjb25zdCBuZXdQb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICBjb25zdCBub2RlID0gbHNvblRvTGl2ZU5vZGUoaXRlbSk7XG4gICAgICBub2RlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld1Bvc2l0aW9uKTtcbiAgICAgIHRoaXMuI2l0ZW1zLnB1c2gobm9kZSk7XG4gICAgICBwb3NpdGlvbiA9IG5ld1Bvc2l0aW9uO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkXSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IGxpc3QgPSBuZXcgX0xpdmVMaXN0KFtdKTtcbiAgICBsaXN0Ll9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50VG9DaGlsZHJlbi5nZXQoaWQpO1xuICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbaWQyLCBjcmR0XSBvZiBjaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGQgPSBkZXNlcmlhbGl6ZShbaWQyLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayhsaXN0LCBjcmR0LnBhcmVudEtleSk7XG4gICAgICBsaXN0Ll9pbnNlcnRBbmRTb3J0KGNoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCB0aGUgcmVzdWx0aW5nIG9wcyB3aWxsIGJlIHNlbnQgdG8gdGhlIHNlcnZlciBpZiB0aGV5IGhhdmUgYW4gJ29wSWQnXG4gICAqIHNvIHdlIG11dGF0ZSBfdW5hY2tub3dsZWRnZWRTZXRzIHRvIGF2b2lkIHBvdGVudGlhbCBmbGlja2VyaW5nXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9saXZlYmxvY2tzL2xpdmVibG9ja3MvcHVsbC8xMTc3XG4gICAqXG4gICAqIFRoaXMgaXMgcXVpdGUgdW5pbnR1aXRpdmUgYW5kIHNob3VsZCBkaXNhcHBlYXIgYXMgc29vbiBhc1xuICAgKiB3ZSBpbnRyb2R1Y2UgYW4gZXhwbGljaXQgTGl2ZUxpc3QuU2V0IG9wZXJhdGlvblxuICAgKi9cbiAgX3RvT3BzKHBhcmVudElkLCBwYXJlbnRLZXksIHBvb2wpIHtcbiAgICBpZiAodGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBpdGVtIGlzIG5vdCBhdHRhY2hlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICBvcElkOiBwb29sPy5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgIHR5cGU6IDIgLyogQ1JFQVRFX0xJU1QgKi8sXG4gICAgICBwYXJlbnRJZCxcbiAgICAgIHBhcmVudEtleVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLiNpdGVtcykge1xuICAgICAgY29uc3QgcGFyZW50S2V5MiA9IGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKTtcbiAgICAgIGNvbnN0IGNoaWxkT3BzID0gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihcbiAgICAgICAgaXRlbS5fdG9PcHModGhpcy5faWQsIHBhcmVudEtleTIsIHBvb2wpLFxuICAgICAgICB2b2lkIDBcbiAgICAgICk7XG4gICAgICBjb25zdCBjaGlsZE9wSWQgPSBjaGlsZE9wc1swXS5vcElkO1xuICAgICAgaWYgKGNoaWxkT3BJZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuI3VuYWNrbm93bGVkZ2VkU2V0cy5zZXQocGFyZW50S2V5MiwgY2hpbGRPcElkKTtcbiAgICAgIH1cbiAgICAgIG9wcy5wdXNoKC4uLmNoaWxkT3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIEFkZHMgYSBuZXcgaXRlbSBpbnRvIHRoZSBzb3J0ZWQgbGlzdCwgaW4gdGhlIGNvcnJlY3QgcG9zaXRpb24uXG4gICAqL1xuICBfaW5zZXJ0QW5kU29ydChpdGVtKSB7XG4gICAgdGhpcy4jaXRlbXMucHVzaChpdGVtKTtcbiAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9zb3J0SXRlbXMoKSB7XG4gICAgdGhpcy4jaXRlbXMuc29ydChjb21wYXJlTm9kZVBvc2l0aW9uKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9pbmRleE9mUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy4jaXRlbXMuZmluZEluZGV4KFxuICAgICAgKGl0ZW0pID0+IGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKSA9PT0gcG9zaXRpb25cbiAgICApO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaChpZCwgcG9vbCkge1xuICAgIHN1cGVyLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLiNpdGVtcykge1xuICAgICAgaXRlbS5fYXR0YWNoKHBvb2wuZ2VuZXJhdGVJZCgpLCBwb29sKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoKCkge1xuICAgIHN1cGVyLl9kZXRhY2goKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy4jaXRlbXMpIHtcbiAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIH1cbiAgfVxuICAjYXBwbHlTZXRSZW1vdGUob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgY2hpbGQuX2F0dGFjaChpZCwgdGhpcy5fcG9vbCk7XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjb25zdCBkZWxldGVkSWQgPSBvcC5kZWxldGVkSWQ7XG4gICAgY29uc3QgaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IGl0ZW1XaXRoU2FtZVBvc2l0aW9uID0gdGhpcy4jaXRlbXNbaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uXTtcbiAgICAgIGlmIChpdGVtV2l0aFNhbWVQb3NpdGlvbi5faWQgPT09IGRlbGV0ZWRJZCkge1xuICAgICAgICBpdGVtV2l0aFNhbWVQb3NpdGlvbi5fZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuI2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl0gPSBjaGlsZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBzZXREZWx0YShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIGNoaWxkKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiNpbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmFkZChpdGVtV2l0aFNhbWVQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuI2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl0gPSBjaGlsZDtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBbXG4gICAgICAgICAgc2V0RGVsdGEoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uLCBjaGlsZClcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgZGVsZXRlRGVsdGEyID0gdGhpcy4jZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihcbiAgICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGRlbGV0ZURlbHRhMikge1xuICAgICAgICAgIGRlbHRhLnB1c2goZGVsZXRlRGVsdGEyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB1cGRhdGVzID0gW107XG4gICAgICBjb25zdCBkZWxldGVEZWx0YTIgPSB0aGlzLiNkZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKFxuICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICk7XG4gICAgICBpZiAoZGVsZXRlRGVsdGEyKSB7XG4gICAgICAgIHVwZGF0ZXMucHVzaChkZWxldGVEZWx0YTIpO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICB1cGRhdGVzLnB1c2goaW5zZXJ0RGVsdGEodGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSksIGNoaWxkKSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXZlcnNlOiBbXSxcbiAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgdXBkYXRlcylcbiAgICAgIH07XG4gICAgfVxuICB9XG4gICNhcHBseVNldEFjayhvcCkge1xuICAgIGlmICh0aGlzLl9wb29sID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGF0dGFjaCBjaGlsZCBpZiBtYW5hZ2VkIHBvb2wgaXMgbm90IHByZXNlbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IGRlbHRhID0gW107XG4gICAgY29uc3QgZGVsZXRlZERlbHRhID0gdGhpcy4jZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihvcC5kZWxldGVkSWQpO1xuICAgIGlmIChkZWxldGVkRGVsdGEpIHtcbiAgICAgIGRlbHRhLnB1c2goZGVsZXRlZERlbHRhKTtcbiAgICB9XG4gICAgY29uc3QgdW5hY2tub3dsZWRnZWRPcElkID0gdGhpcy4jdW5hY2tub3dsZWRnZWRTZXRzLmdldChvcC5wYXJlbnRLZXkpO1xuICAgIGlmICh1bmFja25vd2xlZGdlZE9wSWQgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHVuYWNrbm93bGVkZ2VkT3BJZCAhPT0gb3Aub3BJZCkge1xuICAgICAgICByZXR1cm4gZGVsdGEubGVuZ3RoID09PSAwID8geyBtb2RpZmllZDogZmFsc2UgfSA6IHsgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgZGVsdGEpLCByZXZlcnNlOiBbXSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4jdW5hY2tub3dsZWRnZWRTZXRzLmRlbGV0ZShvcC5wYXJlbnRLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gPSB0aGlzLl9pbmRleE9mUG9zaXRpb24ob3AucGFyZW50S2V5KTtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLiNpdGVtcy5maW5kKChpdGVtKSA9PiBpdGVtLl9pZCA9PT0gb3AuaWQpO1xuICAgIGlmIChleGlzdGluZ0l0ZW0gIT09IHZvaWQgMCkge1xuICAgICAgaWYgKGV4aXN0aW5nSXRlbS5fcGFyZW50S2V5ID09PSBvcC5wYXJlbnRLZXkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZGVsdGEubGVuZ3RoID4gMCA/IG1ha2VVcGRhdGUodGhpcywgZGVsdGEpIDogZmFsc2UsXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgIHRoaXMuI2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuYWRkKFxuICAgICAgICAgIHRoaXMuI2l0ZW1zW2luZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbl1cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgW3ByZXZOb2RlXSA9IHRoaXMuI2l0ZW1zLnNwbGljZShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIDEpO1xuICAgICAgICBkZWx0YS5wdXNoKGRlbGV0ZURlbHRhKGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiwgcHJldk5vZGUpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZJbmRleCA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoZXhpc3RpbmdJdGVtKTtcbiAgICAgIGV4aXN0aW5nSXRlbS5fc2V0UGFyZW50TGluayh0aGlzLCBvcC5wYXJlbnRLZXkpO1xuICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoZXhpc3RpbmdJdGVtKTtcbiAgICAgIGlmIChuZXdJbmRleCAhPT0gcHJldkluZGV4KSB7XG4gICAgICAgIGRlbHRhLnB1c2gobW92ZURlbHRhKHByZXZJbmRleCwgbmV3SW5kZXgsIGV4aXN0aW5nSXRlbSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IGRlbHRhLmxlbmd0aCA+IDAgPyBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSA6IGZhbHNlLFxuICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3JwaGFuID0gdGhpcy5fcG9vbC5nZXROb2RlKG9wLmlkKTtcbiAgICAgIGlmIChvcnBoYW4gJiYgdGhpcy4jaW1wbGljaXRseURlbGV0ZWRJdGVtcy5oYXMob3JwaGFuKSkge1xuICAgICAgICBvcnBoYW4uX3NldFBhcmVudExpbmsodGhpcywgb3AucGFyZW50S2V5KTtcbiAgICAgICAgdGhpcy4jaW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUob3JwaGFuKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChvcnBoYW4pO1xuICAgICAgICBjb25zdCByZWNyZWF0ZWRJdGVtSW5kZXggPSB0aGlzLiNpdGVtcy5pbmRleE9mKG9ycGhhbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gaXRlbSBhdCB0aGlzIHBvc2l0aW9uLCB1cGRhdGUgaXMgYSBzZXQsIGVsc2UgaXQncyBhbiBpbnNlcnRcbiAgICAgICAgICAgIGluZGV4T2ZJdGVtV2l0aFNhbWVQb3NpdGlvbiA9PT0gLTEgPyBpbnNlcnREZWx0YShyZWNyZWF0ZWRJdGVtSW5kZXgsIG9ycGhhbikgOiBzZXREZWx0YShyZWNyZWF0ZWRJdGVtSW5kZXgsIG9ycGhhbiksXG4gICAgICAgICAgICAuLi5kZWx0YVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW5kZXhPZkl0ZW1XaXRoU2FtZVBvc2l0aW9uICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuI2l0ZW1zLnNwbGljZShpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24sIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuI2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KFxuICAgICAgICAgIG9wLFxuICAgICAgICAgIG9wLnBhcmVudEtleVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGl0ZW0gYXQgdGhpcyBwb3NpdGlvbiwgdXBkYXRlIGlzIGEgc2V0LCBlbHNlIGl0J3MgYW4gaW5zZXJ0XG4gICAgICAgICAgICBpbmRleE9mSXRlbVdpdGhTYW1lUG9zaXRpb24gPT09IC0xID8gaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pIDogc2V0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pLFxuICAgICAgICAgICAgLi4uZGVsdGFcbiAgICAgICAgICBdKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdXBkYXRlIGRlbHRhIG9mIHRoZSBkZWxldGlvbiBvciBudWxsXG4gICAqL1xuICAjZGV0YWNoSXRlbUFzc29jaWF0ZWRUb1NldE9wZXJhdGlvbihkZWxldGVkSWQpIHtcbiAgICBpZiAoZGVsZXRlZElkID09PSB2b2lkIDAgfHwgdGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGVsZXRlZEl0ZW0gPSB0aGlzLl9wb29sLmdldE5vZGUoZGVsZXRlZElkKTtcbiAgICBpZiAoZGVsZXRlZEl0ZW0gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RldGFjaENoaWxkKGRlbGV0ZWRJdGVtKTtcbiAgICBpZiAocmVzdWx0Lm1vZGlmaWVkID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQubW9kaWZpZWQudXBkYXRlc1swXTtcbiAgfVxuICAjYXBwbHlSZW1vdGVJbnNlcnQob3ApIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBhc1BvcyhvcC5wYXJlbnRLZXkpO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy4jc2hpZnRJdGVtUG9zaXRpb24oZXhpc3RpbmdJdGVtSW5kZXgsIGtleSk7XG4gICAgfVxuICAgIGNvbnN0IHsgbmV3SXRlbSwgbmV3SW5kZXggfSA9IHRoaXMuI2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KG9wLCBrZXkpO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pXSksXG4gICAgICByZXZlcnNlOiBbXVxuICAgIH07XG4gIH1cbiAgI2FwcGx5SW5zZXJ0QWNrKG9wKSB7XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtID0gdGhpcy4jaXRlbXMuZmluZCgoaXRlbSkgPT4gaXRlbS5faWQgPT09IG9wLmlkKTtcbiAgICBjb25zdCBrZXkgPSBhc1BvcyhvcC5wYXJlbnRLZXkpO1xuICAgIGNvbnN0IGl0ZW1JbmRleEF0UG9zaXRpb24gPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtKSB7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtLl9wYXJlbnRLZXkgPT09IGtleSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb2xkUG9zaXRpb25JbmRleCA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoZXhpc3RpbmdJdGVtKTtcbiAgICAgICAgaWYgKGl0ZW1JbmRleEF0UG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy4jc2hpZnRJdGVtUG9zaXRpb24oaXRlbUluZGV4QXRQb3NpdGlvbiwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBleGlzdGluZ0l0ZW0uX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgICAgIGlmIChuZXdJbmRleCA9PT0gb2xkUG9zaXRpb25JbmRleCkge1xuICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW1xuICAgICAgICAgICAgbW92ZURlbHRhKG9sZFBvc2l0aW9uSW5kZXgsIG5ld0luZGV4LCBleGlzdGluZ0l0ZW0pXG4gICAgICAgICAgXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3JwaGFuID0gbm4odGhpcy5fcG9vbCkuZ2V0Tm9kZShvcC5pZCk7XG4gICAgICBpZiAob3JwaGFuICYmIHRoaXMuI2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuaGFzKG9ycGhhbikpIHtcbiAgICAgICAgb3JwaGFuLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIHRoaXMuI2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuZGVsZXRlKG9ycGhhbik7XG4gICAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQob3JwaGFuKTtcbiAgICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG9ycGhhbildKSxcbiAgICAgICAgICByZXZlcnNlOiBbXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGl0ZW1JbmRleEF0UG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy4jc2hpZnRJdGVtUG9zaXRpb24oaXRlbUluZGV4QXRQb3NpdGlvbiwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG5ld0l0ZW0sIG5ld0luZGV4IH0gPSB0aGlzLiNjcmVhdGVBdHRhY2hJdGVtQW5kU29ydChvcCwga2V5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEobmV3SW5kZXgsIG5ld0l0ZW0pXSksXG4gICAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI2FwcGx5SW5zZXJ0VW5kb1JlZG8ob3ApIHtcbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2w/LmdldE5vZGUoaWQpICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBjaGlsZC5fYXR0YWNoKGlkLCBubih0aGlzLl9wb29sKSk7XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihrZXkpO1xuICAgIGxldCBuZXdLZXkgPSBrZXk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgY29uc3QgYmVmb3JlMiA9IHRoaXMuI2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XT8uX3BhcmVudFBvcztcbiAgICAgIGNvbnN0IGFmdGVyMiA9IHRoaXMuI2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3M7XG4gICAgICBuZXdLZXkgPSBtYWtlUG9zaXRpb24oYmVmb3JlMiwgYWZ0ZXIyKTtcbiAgICAgIGNoaWxkLl9zZXRQYXJlbnRMaW5rKHRoaXMsIG5ld0tleSk7XG4gICAgfVxuICAgIHRoaXMuX2luc2VydEFuZFNvcnQoY2hpbGQpO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICByZXZlcnNlOiBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XVxuICAgIH07XG4gIH1cbiAgI2FwcGx5U2V0VW5kb1JlZG8ob3ApIHtcbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXk6IGtleSB9ID0gb3A7XG4gICAgY29uc3QgY2hpbGQgPSBjcmVhdGlvbk9wVG9MaXZlTm9kZShvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2w/LmdldE5vZGUoaWQpICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICB0aGlzLiN1bmFja25vd2xlZGdlZFNldHMuc2V0KGtleSwgbm4ob3Aub3BJZCkpO1xuICAgIGNvbnN0IGluZGV4T2ZJdGVtV2l0aFNhbWVLZXkgPSB0aGlzLl9pbmRleE9mUG9zaXRpb24oa2V5KTtcbiAgICBjaGlsZC5fYXR0YWNoKGlkLCBubih0aGlzLl9wb29sKSk7XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICBjb25zdCBuZXdLZXkgPSBrZXk7XG4gICAgaWYgKGluZGV4T2ZJdGVtV2l0aFNhbWVLZXkgIT09IC0xKSB7XG4gICAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLiNpdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lS2V5XTtcbiAgICAgIGV4aXN0aW5nSXRlbS5fZGV0YWNoKCk7XG4gICAgICB0aGlzLiNpdGVtc1tpbmRleE9mSXRlbVdpdGhTYW1lS2V5XSA9IGNoaWxkO1xuICAgICAgY29uc3QgcmV2ZXJzZSA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIGV4aXN0aW5nSXRlbS5fdG9PcHMobm4odGhpcy5faWQpLCBrZXksIHRoaXMuX3Bvb2wpLFxuICAgICAgICBvcC5pZFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGRlbHRhID0gW3NldERlbHRhKGluZGV4T2ZJdGVtV2l0aFNhbWVLZXksIGNoaWxkKV07XG4gICAgICBjb25zdCBkZWxldGVkRGVsdGEgPSB0aGlzLiNkZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKFxuICAgICAgICBvcC5kZWxldGVkSWRcbiAgICAgICk7XG4gICAgICBpZiAoZGVsZXRlZERlbHRhKSB7XG4gICAgICAgIGRlbHRhLnB1c2goZGVsZXRlZERlbHRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIGRlbHRhKSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICB0aGlzLiNkZXRhY2hJdGVtQXNzb2NpYXRlZFRvU2V0T3BlcmF0aW9uKG9wLmRlbGV0ZWRJZCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmV2ZXJzZTogW3sgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLywgaWQgfV0sXG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgY2hpbGQpXSlcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChvcC5pbnRlbnQgPT09IFwic2V0XCIpIHtcbiAgICAgIGlmIChzb3VyY2UgPT09IDEgLyogUkVNT1RFICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuI2FwcGx5U2V0UmVtb3RlKG9wKTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlID09PSAyIC8qIEFDSyAqLykge1xuICAgICAgICByZXN1bHQgPSB0aGlzLiNhcHBseVNldEFjayhvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLiNhcHBseVNldFVuZG9SZWRvKG9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNvdXJjZSA9PT0gMSAvKiBSRU1PVEUgKi8pIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy4jYXBwbHlSZW1vdGVJbnNlcnQob3ApO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2UgPT09IDIgLyogQUNLICovKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuI2FwcGx5SW5zZXJ0QWNrKG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuI2FwcGx5SW5zZXJ0VW5kb1JlZG8ob3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzdWx0Lm1vZGlmaWVkICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoQ2hpbGQoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGNvbnN0IHBhcmVudEtleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgICAgY29uc3QgcmV2ZXJzZSA9IGNoaWxkLl90b09wcyhubih0aGlzLl9pZCksIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgICBjb25zdCBpbmRleFRvRGVsZXRlID0gdGhpcy4jaXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBpZiAoaW5kZXhUb0RlbGV0ZSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFtwcmV2aW91c05vZGVdID0gdGhpcy4jaXRlbXMuc3BsaWNlKGluZGV4VG9EZWxldGUsIDEpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICBjaGlsZC5fZGV0YWNoKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbZGVsZXRlRGVsdGEoaW5kZXhUb0RlbGV0ZSwgcHJldmlvdXNOb2RlKV0pLFxuICAgICAgICByZXZlcnNlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgfVxuICAjYXBwbHlTZXRDaGlsZEtleVJlbW90ZShuZXdLZXksIGNoaWxkKSB7XG4gICAgaWYgKHRoaXMuI2ltcGxpY2l0bHlEZWxldGVkSXRlbXMuaGFzKGNoaWxkKSkge1xuICAgICAgdGhpcy4jaW1wbGljaXRseURlbGV0ZWRJdGVtcy5kZWxldGUoY2hpbGQpO1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX2luc2VydEFuZFNvcnQoY2hpbGQpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLiNpdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBtYWtlVXBkYXRlKHRoaXMsIFtpbnNlcnREZWx0YShuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICAgIHJldmVyc2U6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c0tleSA9IGNoaWxkLl9wYXJlbnRLZXk7XG4gICAgaWYgKG5ld0tleSA9PT0gcHJldmlvdXNLZXkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtSW5kZXggPSB0aGlzLl9pbmRleE9mUG9zaXRpb24obmV3S2V5KTtcbiAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggPT09IC0xKSB7XG4gICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy4jaXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKG5ld0luZGV4ID09PSBwcmV2aW91c0luZGV4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgbWFrZVBvc2l0aW9uKG5ld0tleSwgdGhpcy4jaXRlbXNbZXhpc3RpbmdJdGVtSW5kZXggKyAxXT8uX3BhcmVudFBvcylcbiAgICAgICk7XG4gICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy4jaXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgICAgaWYgKG5ld0luZGV4ID09PSBwcmV2aW91c0luZGV4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbbW92ZURlbHRhKHByZXZpb3VzSW5kZXgsIG5ld0luZGV4LCBjaGlsZCldKSxcbiAgICAgICAgcmV2ZXJzZTogW11cbiAgICAgIH07XG4gICAgfVxuICB9XG4gICNhcHBseVNldENoaWxkS2V5QWNrKG5ld0tleSwgY2hpbGQpIHtcbiAgICBjb25zdCBwcmV2aW91c0tleSA9IG5uKGNoaWxkLl9wYXJlbnRLZXkpO1xuICAgIGlmICh0aGlzLiNpbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmhhcyhjaGlsZCkpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgICB0aGlzLiNpbXBsaWNpdGx5RGVsZXRlZEl0ZW1zLmRlbGV0ZShjaGlsZCk7XG4gICAgICBpZiAoZXhpc3RpbmdJdGVtSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuI2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4XS5fc2V0UGFyZW50TGluayhcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIG1ha2VQb3NpdGlvbihuZXdLZXksIHRoaXMuI2l0ZW1zW2V4aXN0aW5nSXRlbUluZGV4ICsgMV0/Ll9wYXJlbnRQb3MpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBuZXdLZXkpO1xuICAgICAgdGhpcy5faW5zZXJ0QW5kU29ydChjaGlsZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtb2RpZmllZDogZmFsc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXdLZXkgPT09IHByZXZpb3VzS2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gdGhpcy4jaXRlbXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICBjb25zdCBleGlzdGluZ0l0ZW1JbmRleCA9IHRoaXMuX2luZGV4T2ZQb3NpdGlvbihuZXdLZXkpO1xuICAgICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLiNpdGVtc1tleGlzdGluZ0l0ZW1JbmRleF0uX3NldFBhcmVudExpbmsoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBtYWtlUG9zaXRpb24obmV3S2V5LCB0aGlzLiNpdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLiNpdGVtcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgIGlmIChwcmV2aW91c0luZGV4ID09PSBuZXdJbmRleCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtb2RpZmllZDogbWFrZVVwZGF0ZSh0aGlzLCBbXG4gICAgICAgICAgICBtb3ZlRGVsdGEocHJldmlvdXNJbmRleCwgbmV3SW5kZXgsIGNoaWxkKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHJldmVyc2U6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNhcHBseVNldENoaWxkS2V5VW5kb1JlZG8obmV3S2V5LCBjaGlsZCkge1xuICAgIGNvbnN0IHByZXZpb3VzS2V5ID0gbm4oY2hpbGQuX3BhcmVudEtleSk7XG4gICAgY29uc3QgcHJldmlvdXNJbmRleCA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgIGNvbnN0IGV4aXN0aW5nSXRlbUluZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKG5ld0tleSk7XG4gICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy4jaXRlbXNbZXhpc3RpbmdJdGVtSW5kZXhdLl9zZXRQYXJlbnRMaW5rKFxuICAgICAgICB0aGlzLFxuICAgICAgICBtYWtlUG9zaXRpb24obmV3S2V5LCB0aGlzLiNpdGVtc1tleGlzdGluZ0l0ZW1JbmRleCArIDFdPy5fcGFyZW50UG9zKVxuICAgICAgKTtcbiAgICB9XG4gICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywgbmV3S2V5KTtcbiAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICBjb25zdCBuZXdJbmRleCA9IHRoaXMuI2l0ZW1zLmluZGV4T2YoY2hpbGQpO1xuICAgIGlmIChwcmV2aW91c0luZGV4ID09PSBuZXdJbmRleCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbW9kaWZpZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IG1ha2VVcGRhdGUodGhpcywgW21vdmVEZWx0YShwcmV2aW91c0luZGV4LCBuZXdJbmRleCwgY2hpbGQpXSksXG4gICAgICByZXZlcnNlOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAxIC8qIFNFVF9QQVJFTlRfS0VZICovLFxuICAgICAgICAgIGlkOiBubihjaGlsZC5faWQpLFxuICAgICAgICAgIHBhcmVudEtleTogcHJldmlvdXNLZXlcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2V0Q2hpbGRLZXkobmV3S2V5LCBjaGlsZCwgc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZSA9PT0gMSAvKiBSRU1PVEUgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLiNhcHBseVNldENoaWxkS2V5UmVtb3RlKG5ld0tleSwgY2hpbGQpO1xuICAgIH0gZWxzZSBpZiAoc291cmNlID09PSAyIC8qIEFDSyAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuI2FwcGx5U2V0Q2hpbGRLZXlBY2sobmV3S2V5LCBjaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLiNhcHBseVNldENoaWxkS2V5VW5kb1JlZG8obmV3S2V5LCBjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5KG9wLCBpc0xvY2FsKSB7XG4gICAgcmV0dXJuIHN1cGVyLl9hcHBseShvcCwgaXNMb2NhbCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2VyaWFsaXplKCkge1xuICAgIGlmICh0aGlzLnBhcmVudC50eXBlICE9PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIExpdmVMaXN0IGlmIHBhcmVudCBpcyBtaXNzaW5nXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMSAvKiBMSVNUICovLFxuICAgICAgcGFyZW50SWQ6IG5uKHRoaXMucGFyZW50Lm5vZGUuX2lkLCBcIlBhcmVudCBub2RlIGV4cGVjdGVkIHRvIGhhdmUgSURcIiksXG4gICAgICBwYXJlbnRLZXk6IHRoaXMucGFyZW50LmtleVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cy5cbiAgICovXG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2l0ZW1zLmxlbmd0aDtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvbmUgZWxlbWVudCB0byB0aGUgZW5kIG9mIHRoZSBMaXZlTGlzdC5cbiAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSBlbmQgb2YgdGhlIExpdmVMaXN0LlxuICAgKi9cbiAgcHVzaChlbGVtZW50KSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnQoZWxlbWVudCwgdGhpcy5sZW5ndGgpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnRzIG9uZSBlbGVtZW50IGF0IGEgc3BlY2lmaWVkIGluZGV4LlxuICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBpbnNlcnQuXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggYXQgd2hpY2ggeW91IHdhbnQgdG8gaW5zZXJ0IHRoZSBlbGVtZW50LlxuICAgKi9cbiAgaW5zZXJ0KGVsZW1lbnQsIGluZGV4KSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGhpcy4jaXRlbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgaW5zZXJ0IGxpc3QgaXRlbSBhdCBpbmRleCBcIlx1MDAxZCR7aW5kZXh9XCIuIGluZGV4IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kICR7dGhpcy4jaXRlbXMubGVuZ3RofWBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGJlZm9yZTIgPSB0aGlzLiNpdGVtc1tpbmRleCAtIDFdID8gdGhpcy4jaXRlbXNbaW5kZXggLSAxXS5fcGFyZW50UG9zIDogdm9pZCAwO1xuICAgIGNvbnN0IGFmdGVyMiA9IHRoaXMuI2l0ZW1zW2luZGV4XSA/IHRoaXMuI2l0ZW1zW2luZGV4XS5fcGFyZW50UG9zIDogdm9pZCAwO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gbWFrZVBvc2l0aW9uKGJlZm9yZTIsIGFmdGVyMik7XG4gICAgY29uc3QgdmFsdWUgPSBsc29uVG9MaXZlTm9kZShlbGVtZW50KTtcbiAgICB2YWx1ZS5fc2V0UGFyZW50TGluayh0aGlzLCBwb3NpdGlvbik7XG4gICAgdGhpcy5faW5zZXJ0QW5kU29ydCh2YWx1ZSk7XG4gICAgaWYgKHRoaXMuX3Bvb2wgJiYgdGhpcy5faWQpIHtcbiAgICAgIGNvbnN0IGlkID0gdGhpcy5fcG9vbC5nZW5lcmF0ZUlkKCk7XG4gICAgICB2YWx1ZS5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2goXG4gICAgICAgIHZhbHVlLl90b09wcyh0aGlzLl9pZCwgcG9zaXRpb24sIHRoaXMuX3Bvb2wpLFxuICAgICAgICBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICAgIFt0aGlzLl9pZCwgbWFrZVVwZGF0ZSh0aGlzLCBbaW5zZXJ0RGVsdGEoaW5kZXgsIHZhbHVlKV0pXVxuICAgICAgICBdKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE1vdmUgb25lIGVsZW1lbnQgZnJvbSBvbmUgaW5kZXggdG8gYW5vdGhlci5cbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byBtb3ZlXG4gICAqIEBwYXJhbSB0YXJnZXRJbmRleCBUaGUgaW5kZXggd2hlcmUgdGhlIGVsZW1lbnQgc2hvdWxkIGJlIGFmdGVyIG1vdmluZy5cbiAgICovXG4gIG1vdmUoaW5kZXgsIHRhcmdldEluZGV4KSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAodGFyZ2V0SW5kZXggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXRJbmRleCBjYW5ub3QgYmUgbGVzcyB0aGFuIDBcIik7XG4gICAgfVxuICAgIGlmICh0YXJnZXRJbmRleCA+PSB0aGlzLiNpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJ0YXJnZXRJbmRleCBjYW5ub3QgYmUgZ3JlYXRlciBvciBlcXVhbCB0aGFuIHRoZSBsaXN0IGxlbmd0aFwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmRleCBjYW5ub3QgYmUgbGVzcyB0aGFuIDBcIik7XG4gICAgfVxuICAgIGlmIChpbmRleCA+PSB0aGlzLiNpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImluZGV4IGNhbm5vdCBiZSBncmVhdGVyIG9yIGVxdWFsIHRoYW4gdGhlIGxpc3QgbGVuZ3RoXCIpO1xuICAgIH1cbiAgICBsZXQgYmVmb3JlUG9zaXRpb24gPSBudWxsO1xuICAgIGxldCBhZnRlclBvc2l0aW9uID0gbnVsbDtcbiAgICBpZiAoaW5kZXggPCB0YXJnZXRJbmRleCkge1xuICAgICAgYWZ0ZXJQb3NpdGlvbiA9IHRhcmdldEluZGV4ID09PSB0aGlzLiNpdGVtcy5sZW5ndGggLSAxID8gdm9pZCAwIDogdGhpcy4jaXRlbXNbdGFyZ2V0SW5kZXggKyAxXS5fcGFyZW50UG9zO1xuICAgICAgYmVmb3JlUG9zaXRpb24gPSB0aGlzLiNpdGVtc1t0YXJnZXRJbmRleF0uX3BhcmVudFBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJQb3NpdGlvbiA9IHRoaXMuI2l0ZW1zW3RhcmdldEluZGV4XS5fcGFyZW50UG9zO1xuICAgICAgYmVmb3JlUG9zaXRpb24gPSB0YXJnZXRJbmRleCA9PT0gMCA/IHZvaWQgMCA6IHRoaXMuI2l0ZW1zW3RhcmdldEluZGV4IC0gMV0uX3BhcmVudFBvcztcbiAgICB9XG4gICAgY29uc3QgcG9zaXRpb24gPSBtYWtlUG9zaXRpb24oYmVmb3JlUG9zaXRpb24sIGFmdGVyUG9zaXRpb24pO1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLiNpdGVtc1tpbmRleF07XG4gICAgY29uc3QgcHJldmlvdXNQb3NpdGlvbiA9IGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKTtcbiAgICBpdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIHBvc2l0aW9uKTtcbiAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gICAgICAgIFt0aGlzLl9pZCwgbWFrZVVwZGF0ZSh0aGlzLCBbbW92ZURlbHRhKGluZGV4LCB0YXJnZXRJbmRleCwgaXRlbSldKV1cbiAgICAgIF0pO1xuICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgICAgW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgICBpZDogbm4oaXRlbS5faWQpLFxuICAgICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgICAgICAgIHBhcmVudEtleTogcG9zaXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAxIC8qIFNFVF9QQVJFTlRfS0VZICovLFxuICAgICAgICAgICAgaWQ6IG5uKGl0ZW0uX2lkKSxcbiAgICAgICAgICAgIHBhcmVudEtleTogcHJldmlvdXNQb3NpdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGFuIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIGRlbGV0ZVxuICAgKi9cbiAgZGVsZXRlKGluZGV4KSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuI2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IGRlbGV0ZSBsaXN0IGl0ZW0gYXQgaW5kZXggXCIke2luZGV4fVwiLiBpbmRleCBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAke3RoaXMuI2l0ZW1zLmxlbmd0aCAtIDF9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuI2l0ZW1zW2luZGV4XTtcbiAgICBpdGVtLl9kZXRhY2goKTtcbiAgICBjb25zdCBbcHJldl0gPSB0aGlzLiNpdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGlmICh0aGlzLl9wb29sKSB7XG4gICAgICBjb25zdCBjaGlsZFJlY29yZElkID0gaXRlbS5faWQ7XG4gICAgICBpZiAoY2hpbGRSZWNvcmRJZCkge1xuICAgICAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHN0b3JhZ2VVcGRhdGVzLnNldChcbiAgICAgICAgICBubih0aGlzLl9pZCksXG4gICAgICAgICAgbWFrZVVwZGF0ZSh0aGlzLCBbZGVsZXRlRGVsdGEoaW5kZXgsIHByZXYpXSlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgICAgICBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlkOiBjaGlsZFJlY29yZElkLFxuICAgICAgICAgICAgICBvcElkOiB0aGlzLl9wb29sLmdlbmVyYXRlT3BJZCgpLFxuICAgICAgICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXSxcbiAgICAgICAgICBpdGVtLl90b09wcyhubih0aGlzLl9pZCksIGl0ZW0uX2dldFBhcmVudEtleU9yVGhyb3coKSksXG4gICAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCkge1xuICAgICAgY29uc3Qgb3BzID0gW107XG4gICAgICBjb25zdCByZXZlcnNlT3BzID0gW107XG4gICAgICBjb25zdCB1cGRhdGVEZWx0YSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuI2l0ZW1zKSB7XG4gICAgICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgICAgICBjb25zdCBjaGlsZElkID0gaXRlbS5faWQ7XG4gICAgICAgIGlmIChjaGlsZElkKSB7XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICAgICAgICAgIGlkOiBjaGlsZElkLFxuICAgICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldmVyc2VPcHMucHVzaChcbiAgICAgICAgICAgIC4uLml0ZW0uX3RvT3BzKG5uKHRoaXMuX2lkKSwgaXRlbS5fZ2V0UGFyZW50S2V5T3JUaHJvdygpKVxuICAgICAgICAgICk7XG4gICAgICAgICAgdXBkYXRlRGVsdGEucHVzaChkZWxldGVEZWx0YSgwLCBpdGVtKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuI2l0ZW1zID0gW107XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzLnNldChubih0aGlzLl9pZCksIG1ha2VVcGRhdGUodGhpcywgdXBkYXRlRGVsdGEpKTtcbiAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2gob3BzLCByZXZlcnNlT3BzLCBzdG9yYWdlVXBkYXRlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLiNpdGVtcykge1xuICAgICAgICBpdGVtLl9kZXRhY2goKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI2l0ZW1zID0gW107XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICB9XG4gIH1cbiAgc2V0KGluZGV4LCBpdGVtKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuI2l0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IHNldCBsaXN0IGl0ZW0gYXQgaW5kZXggXCJcdTAwMWQke2luZGV4fVwiLiBpbmRleCBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAke3RoaXMuI2l0ZW1zLmxlbmd0aCAtIDF9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdJdGVtID0gdGhpcy4jaXRlbXNbaW5kZXhdO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gZXhpc3RpbmdJdGVtLl9nZXRQYXJlbnRLZXlPclRocm93KCk7XG4gICAgY29uc3QgZXhpc3RpbmdJZCA9IGV4aXN0aW5nSXRlbS5faWQ7XG4gICAgZXhpc3RpbmdJdGVtLl9kZXRhY2goKTtcbiAgICBjb25zdCB2YWx1ZSA9IGxzb25Ub0xpdmVOb2RlKGl0ZW0pO1xuICAgIHZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIHBvc2l0aW9uKTtcbiAgICB0aGlzLiNpdGVtc1tpbmRleF0gPSB2YWx1ZTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiB0aGlzLl9pZCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLl9wb29sLmdlbmVyYXRlSWQoKTtcbiAgICAgIHZhbHVlLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCBtYWtlVXBkYXRlKHRoaXMsIFtzZXREZWx0YShpbmRleCwgdmFsdWUpXSkpO1xuICAgICAgY29uc3Qgb3BzID0gSEFDS19hZGRJbnRlbnRBbmREZWxldGVkSWRUb09wZXJhdGlvbihcbiAgICAgICAgdmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBwb3NpdGlvbiwgdGhpcy5fcG9vbCksXG4gICAgICAgIGV4aXN0aW5nSWRcbiAgICAgICk7XG4gICAgICB0aGlzLiN1bmFja25vd2xlZGdlZFNldHMuc2V0KHBvc2l0aW9uLCBubihvcHNbMF0ub3BJZCkpO1xuICAgICAgY29uc3QgcmV2ZXJzZU9wcyA9IEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24oXG4gICAgICAgIGV4aXN0aW5nSXRlbS5fdG9PcHModGhpcy5faWQsIHBvc2l0aW9uLCB2b2lkIDApLFxuICAgICAgICBpZFxuICAgICAgKTtcbiAgICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2gob3BzLCByZXZlcnNlT3BzLCBzdG9yYWdlVXBkYXRlcyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIEFycmF5IG9mIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIExpdmVMaXN0LlxuICAgKi9cbiAgdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaXRlbXMubWFwKFxuICAgICAgKGVudHJ5KSA9PiBsaXZlTm9kZVRvTHNvbihlbnRyeSlcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF5eXl5eXl5eXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGSVhNRSEgVGhpcyBpc24ndCBzYWZlLlxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFRlc3RzIHdoZXRoZXIgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHRlc3QgaW1wbGVtZW50ZWQgYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIHRlc3QgZm9yIGVhY2ggZWxlbWVudCwgdGFraW5nIHR3byBhcmd1bWVudHMgKHRoZSBlbGVtZW50IGFuZCBpdHMgaW5kZXgpLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gcmV0dXJucyBhIHRydXRoeSB2YWx1ZSBmb3IgZXZlcnkgZWxlbWVudC4gT3RoZXJ3aXNlLCBmYWxzZS5cbiAgICovXG4gIGV2ZXJ5KHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5ldmVyeShwcmVkaWNhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGVsZW1lbnRzIHRoYXQgcGFzcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gdGVzdCBlYWNoIGVsZW1lbnQgb2YgdGhlIExpdmVMaXN0LiBSZXR1cm4gYSB2YWx1ZSB0aGF0IGNvZXJjZXMgdG8gdHJ1ZSB0byBrZWVwIHRoZSBlbGVtZW50LCBvciB0byBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IHdpdGggdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyB0aGUgdGVzdC5cbiAgICovXG4gIGZpbHRlcihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZmlsdGVyKHByZWRpY2F0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBzYXRpc2ZpZXMgdGhlIHByb3ZpZGVkIHRlc3RpbmcgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIHZhbHVlLlxuICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0IHRoYXQgc2F0aXNmaWVzIHRoZSBwcm92aWRlZCB0ZXN0aW5nIGZ1bmN0aW9uLiBPdGhlcndpc2UsIHVuZGVmaW5lZCBpcyByZXR1cm5lZC5cbiAgICovXG4gIGZpbmQocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZpbmQocHJlZGljYXRlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIExpdmVMaXN0IHRoYXQgc2F0aXNmaWVzIHRoZSBwcm92aWRlZCB0ZXN0aW5nIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZWFjaCB2YWx1ZSB1bnRpbCB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlLCBpbmRpY2F0aW5nIHRoYXQgdGhlIHNhdGlzZnlpbmcgZWxlbWVudCB3YXMgZm91bmQuXG4gICAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3QgdGhhdCBwYXNzZXMgdGhlIHRlc3QuIE90aGVyd2lzZSwgLTEuXG4gICAqL1xuICBmaW5kSW5kZXgocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZpbmRJbmRleChwcmVkaWNhdGUpO1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uY2UgZm9yIGVhY2ggZWxlbWVudC5cbiAgICogQHBhcmFtIGNhbGxiYWNrZm4gRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlYWNoIGVsZW1lbnQuXG4gICAqL1xuICBmb3JFYWNoKGNhbGxiYWNrZm4pIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZm9yRWFjaChjYWxsYmFja2ZuKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb24gdGhlIGVsZW1lbnQgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyBUaGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IG9yIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldChpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy4jaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gbGl2ZU5vZGVUb0xzb24odGhpcy4jaXRlbXNbaW5kZXhdKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiBlbGVtZW50IGNhbiBiZSBmb3VuZCBpbiB0aGUgTGl2ZUxpc3QsIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICAgKiBAcGFyYW0gc2VhcmNoRWxlbWVudCBFbGVtZW50IHRvIGxvY2F0ZS5cbiAgICogQHBhcmFtIGZyb21JbmRleCBUaGUgaW5kZXggdG8gc3RhcnQgdGhlIHNlYXJjaCBhdC5cbiAgICogQHJldHVybnMgVGhlIGZpcnN0IGluZGV4IG9mIHRoZSBlbGVtZW50IGluIHRoZSBMaXZlTGlzdDsgLTEgaWYgbm90IGZvdW5kLlxuICAgKi9cbiAgaW5kZXhPZihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuaW5kZXhPZihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsYXN0IGluZGV4IGF0IHdoaWNoIGEgZ2l2ZW4gZWxlbWVudCBjYW4gYmUgZm91bmQgaW4gdGhlIExpdmVMaXN0LCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC4gVGhlIExpdmVMc2l0IGlzIHNlYXJjaGVkIGJhY2t3YXJkcywgc3RhcnRpbmcgYXQgZnJvbUluZGV4LlxuICAgKiBAcGFyYW0gc2VhcmNoRWxlbWVudCBFbGVtZW50IHRvIGxvY2F0ZS5cbiAgICogQHBhcmFtIGZyb21JbmRleCBUaGUgaW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nIGJhY2t3YXJkcy5cbiAgICogQHJldHVybnNcbiAgICovXG4gIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5sYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IHBvcHVsYXRlZCB3aXRoIHRoZSByZXN1bHRzIG9mIGNhbGxpbmcgYSBwcm92aWRlZCBmdW5jdGlvbiBvbiBldmVyeSBlbGVtZW50LlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgZm9yIGV2ZXJ5IGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IHdpdGggZWFjaCBlbGVtZW50IGJlaW5nIHRoZSByZXN1bHQgb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKi9cbiAgbWFwKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuI2l0ZW1zLm1hcChcbiAgICAgIChlbnRyeSwgaSkgPT4gY2FsbGJhY2soXG4gICAgICAgIGxpdmVOb2RlVG9Mc29uKGVudHJ5KSxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIF5eXl5eXl5eXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBGSVhNRSEgVGhpcyBpc24ndCBzYWZlLlxuICAgICAgICBpXG4gICAgICApXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogVGVzdHMgd2hldGhlciBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgTGl2ZUxpc3QgcGFzc2VzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHByZWRpY2F0ZSBGdW5jdGlvbiB0byB0ZXN0IGZvciBlYWNoIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgZm9yIGF0IGxlYXN0IG9uZSBlbGVtZW50LiBPdGhlcndpc2UsIGZhbHNlLlxuICAgKi9cbiAgc29tZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuc29tZShwcmVkaWNhdGUpO1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBuZXcgTGl2ZUxpc3RJdGVyYXRvcih0aGlzLiNpdGVtcyk7XG4gIH1cbiAgI2NyZWF0ZUF0dGFjaEl0ZW1BbmRTb3J0KG9wLCBrZXkpIHtcbiAgICBjb25zdCBuZXdJdGVtID0gY3JlYXRpb25PcFRvTGl2ZU5vZGUob3ApO1xuICAgIG5ld0l0ZW0uX2F0dGFjaChvcC5pZCwgbm4odGhpcy5fcG9vbCkpO1xuICAgIG5ld0l0ZW0uX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICB0aGlzLl9pbnNlcnRBbmRTb3J0KG5ld0l0ZW0pO1xuICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5faW5kZXhPZlBvc2l0aW9uKGtleSk7XG4gICAgcmV0dXJuIHsgbmV3SXRlbSwgbmV3SW5kZXggfTtcbiAgfVxuICAjc2hpZnRJdGVtUG9zaXRpb24oaW5kZXgsIGtleSkge1xuICAgIGNvbnN0IHNoaWZ0ZWRQb3NpdGlvbiA9IG1ha2VQb3NpdGlvbihcbiAgICAgIGtleSxcbiAgICAgIHRoaXMuI2l0ZW1zLmxlbmd0aCA+IGluZGV4ICsgMSA/IHRoaXMuI2l0ZW1zW2luZGV4ICsgMV0/Ll9wYXJlbnRQb3MgOiB2b2lkIDBcbiAgICApO1xuICAgIHRoaXMuI2l0ZW1zW2luZGV4XS5fc2V0UGFyZW50TGluayh0aGlzLCBzaGlmdGVkUG9zaXRpb24pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICAgIGlkOiB0aGlzLl9pZCA/PyBuYW5vaWQoKSxcbiAgICAgIGtleSxcbiAgICAgIHBheWxvYWQ6IHRoaXMuI2l0ZW1zLm1hcChcbiAgICAgICAgKGl0ZW0sIGluZGV4KSA9PiBpdGVtLnRvVHJlZU5vZGUoaW5kZXgudG9TdHJpbmcoKSlcbiAgICAgIClcbiAgICB9O1xuICB9XG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci50b0ltbXV0YWJsZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI2l0ZW1zLm1hcCgobm9kZSkgPT4gbm9kZS50b0ltbXV0YWJsZSgpKTtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gcmVzdWx0IDogT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX0xpdmVMaXN0KHRoaXMuI2l0ZW1zLm1hcCgoaXRlbSkgPT4gaXRlbS5jbG9uZSgpKSk7XG4gIH1cbn07XG52YXIgTGl2ZUxpc3RJdGVyYXRvciA9IGNsYXNzIHtcbiAgI2lubmVySXRlcmF0b3I7XG4gIGNvbnN0cnVjdG9yKGl0ZW1zKSB7XG4gICAgdGhpcy4jaW5uZXJJdGVyYXRvciA9IGl0ZW1zW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgfVxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBuZXh0KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuI2lubmVySXRlcmF0b3IubmV4dCgpO1xuICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBsaXZlTm9kZVRvTHNvbihyZXN1bHQudmFsdWUpO1xuICAgIHJldHVybiB7IHZhbHVlIH07XG4gIH1cbn07XG5mdW5jdGlvbiBtYWtlVXBkYXRlKGxpdmVMaXN0LCBkZWx0YVVwZGF0ZXMpIHtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiBsaXZlTGlzdCxcbiAgICB0eXBlOiBcIkxpdmVMaXN0XCIsXG4gICAgdXBkYXRlczogZGVsdGFVcGRhdGVzXG4gIH07XG59XG5mdW5jdGlvbiBzZXREZWx0YShpbmRleCwgaXRlbSkge1xuICByZXR1cm4ge1xuICAgIGluZGV4LFxuICAgIHR5cGU6IFwic2V0XCIsXG4gICAgaXRlbTogaXRlbSBpbnN0YW5jZW9mIExpdmVSZWdpc3RlciA/IGl0ZW0uZGF0YSA6IGl0ZW1cbiAgfTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZURlbHRhKGluZGV4LCBkZWxldGVkTm9kZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZGVsZXRlXCIsXG4gICAgaW5kZXgsXG4gICAgZGVsZXRlZEl0ZW06IGRlbGV0ZWROb2RlIGluc3RhbmNlb2YgTGl2ZVJlZ2lzdGVyID8gZGVsZXRlZE5vZGUuZGF0YSA6IGRlbGV0ZWROb2RlXG4gIH07XG59XG5mdW5jdGlvbiBpbnNlcnREZWx0YShpbmRleCwgaXRlbSkge1xuICByZXR1cm4ge1xuICAgIGluZGV4LFxuICAgIHR5cGU6IFwiaW5zZXJ0XCIsXG4gICAgaXRlbTogaXRlbSBpbnN0YW5jZW9mIExpdmVSZWdpc3RlciA/IGl0ZW0uZGF0YSA6IGl0ZW1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1vdmVEZWx0YShwcmV2aW91c0luZGV4LCBpbmRleCwgaXRlbSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibW92ZVwiLFxuICAgIGluZGV4LFxuICAgIGl0ZW06IGl0ZW0gaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXIgPyBpdGVtLmRhdGEgOiBpdGVtLFxuICAgIHByZXZpb3VzSW5kZXhcbiAgfTtcbn1cbmZ1bmN0aW9uIEhBQ0tfYWRkSW50ZW50QW5kRGVsZXRlZElkVG9PcGVyYXRpb24ob3BzLCBkZWxldGVkSWQpIHtcbiAgcmV0dXJuIG9wcy5tYXAoKG9wLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgY29uc3QgZmlyc3RPcCA9IG9wO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZmlyc3RPcCxcbiAgICAgICAgaW50ZW50OiBcInNldFwiLFxuICAgICAgICBkZWxldGVkSWRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcDtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvY3JkdHMvTGl2ZU1hcC50c1xudmFyIExpdmVNYXAgPSBjbGFzcyBfTGl2ZU1hcCBleHRlbmRzIEFic3RyYWN0Q3JkdCB7XG4gICNtYXA7XG4gICN1bmFja25vd2xlZGdlZFNldDtcbiAgY29uc3RydWN0b3IoZW50cmllczIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI3VuYWNrbm93bGVkZ2VkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBpZiAoZW50cmllczIpIHtcbiAgICAgIGNvbnN0IG1hcHBlZEVudHJpZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMyKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBsc29uVG9MaXZlTm9kZSh2YWx1ZSk7XG4gICAgICAgIG5vZGUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgICAgbWFwcGVkRW50cmllcy5wdXNoKFtrZXksIG5vZGVdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI21hcCA9IG5ldyBNYXAobWFwcGVkRW50cmllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI21hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvT3BzKHBhcmVudElkLCBwYXJlbnRLZXksIHBvb2wpIHtcbiAgICBpZiAodGhpcy5faWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNlcmlhbGl6ZSBpdGVtIGlzIG5vdCBhdHRhY2hlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICBvcElkOiBwb29sPy5nZW5lcmF0ZU9wSWQoKSxcbiAgICAgIHR5cGU6IDcgLyogQ1JFQVRFX01BUCAqLyxcbiAgICAgIHBhcmVudElkLFxuICAgICAgcGFyZW50S2V5XG4gICAgfTtcbiAgICBvcHMucHVzaChvcCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy4jbWFwKSB7XG4gICAgICBvcHMucHVzaCguLi52YWx1ZS5fdG9PcHModGhpcy5faWQsIGtleSwgcG9vbCkpO1xuICAgIH1cbiAgICByZXR1cm4gb3BzO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZShbaWQsIF9pdGVtXSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBfTGl2ZU1hcCgpO1xuICAgIG1hcC5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KGlkKTtcbiAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbaWQyLCBjcmR0XSBvZiBjaGlsZHJlbikge1xuICAgICAgY29uc3QgY2hpbGQgPSBkZXNlcmlhbGl6ZShbaWQyLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgICBjaGlsZC5fc2V0UGFyZW50TGluayhtYXAsIGNyZHQucGFyZW50S2V5KTtcbiAgICAgIG1hcC4jbWFwLnNldChjcmR0LnBhcmVudEtleSwgY2hpbGQpO1xuICAgICAgbWFwLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2goaWQsIHBvb2wpIHtcbiAgICBzdXBlci5fYXR0YWNoKGlkLCBwb29sKTtcbiAgICBmb3IgKGNvbnN0IFtfa2V5LCB2YWx1ZV0gb2YgdGhpcy4jbWFwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX2F0dGFjaChwb29sLmdlbmVyYXRlSWQoKSwgcG9vbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBhdHRhY2ggY2hpbGQgaWYgbWFuYWdlZCBwb29sIGlzIG5vdCBwcmVzZW50XCIpO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCBwYXJlbnRLZXksIG9wSWQgfSA9IG9wO1xuICAgIGNvbnN0IGtleSA9IHBhcmVudEtleTtcbiAgICBjb25zdCBjaGlsZCA9IGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKTtcbiAgICBpZiAodGhpcy5fcG9vbC5nZXROb2RlKGlkKSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZSA9PT0gMiAvKiBBQ0sgKi8pIHtcbiAgICAgIGNvbnN0IGxhc3RVcGRhdGVPcElkID0gdGhpcy4jdW5hY2tub3dsZWRnZWRTZXQuZ2V0KGtleSk7XG4gICAgICBpZiAobGFzdFVwZGF0ZU9wSWQgPT09IG9wSWQpIHtcbiAgICAgICAgdGhpcy4jdW5hY2tub3dsZWRnZWRTZXQuZGVsZXRlKGtleSk7XG4gICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgfSBlbHNlIGlmIChsYXN0VXBkYXRlT3BJZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc291cmNlID09PSAxIC8qIFJFTU9URSAqLykge1xuICAgICAgdGhpcy4jdW5hY2tub3dsZWRnZWRTZXQuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0aGlzLiNtYXAuZ2V0KGtleSk7XG4gICAgbGV0IHJldmVyc2U7XG4gICAgaWYgKHByZXZpb3VzVmFsdWUpIHtcbiAgICAgIGNvbnN0IHRoaXNJZCA9IG5uKHRoaXMuX2lkKTtcbiAgICAgIHJldmVyc2UgPSBwcmV2aW91c1ZhbHVlLl90b09wcyh0aGlzSWQsIGtleSk7XG4gICAgICBwcmV2aW91c1ZhbHVlLl9kZXRhY2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV2ZXJzZSA9IFt7IHR5cGU6IDUgLyogREVMRVRFX0NSRFQgKi8sIGlkIH1dO1xuICAgIH1cbiAgICBjaGlsZC5fc2V0UGFyZW50TGluayh0aGlzLCBrZXkpO1xuICAgIGNoaWxkLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgIHRoaXMuI21hcC5zZXQoa2V5LCBjaGlsZCk7XG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGlmaWVkOiB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwidXBkYXRlXCIgfSB9XG4gICAgICB9LFxuICAgICAgcmV2ZXJzZVxuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoKCkge1xuICAgIHN1cGVyLl9kZXRhY2goKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy4jbWFwLnZhbHVlcygpKSB7XG4gICAgICBpdGVtLl9kZXRhY2goKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZGV0YWNoQ2hpbGQoY2hpbGQpIHtcbiAgICBjb25zdCBpZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICBjb25zdCByZXZlcnNlID0gY2hpbGQuX3RvT3BzKGlkLCBwYXJlbnRLZXksIHRoaXMuX3Bvb2wpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuI21hcCkge1xuICAgICAgaWYgKHZhbHVlID09PSBjaGlsZCkge1xuICAgICAgICB0aGlzLiNtYXAuZGVsZXRlKGtleSk7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjaGlsZC5fZGV0YWNoKCk7XG4gICAgY29uc3Qgc3RvcmFnZVVwZGF0ZSA9IHtcbiAgICAgIG5vZGU6IHRoaXMsXG4gICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgIHVwZGF0ZXM6IHsgW3BhcmVudEtleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICB9O1xuICAgIHJldHVybiB7IG1vZGlmaWVkOiBzdG9yYWdlVXBkYXRlLCByZXZlcnNlIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2VyaWFsaXplKCkge1xuICAgIGlmICh0aGlzLnBhcmVudC50eXBlICE9PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIExpdmVNYXAgaWYgcGFyZW50IGlzIG1pc3NpbmdcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAyIC8qIE1BUCAqLyxcbiAgICAgIHBhcmVudElkOiBubih0aGlzLnBhcmVudC5ub2RlLl9pZCwgXCJQYXJlbnQgbm9kZSBleHBlY3RlZCB0byBoYXZlIElEXCIpLFxuICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3BlY2lmaWVkIGVsZW1lbnQgZnJvbSB0aGUgTGl2ZU1hcC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICogQHJldHVybnMgVGhlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LCBvciB1bmRlZmluZWQgaWYgdGhlIGtleSBjYW4ndCBiZSBmb3VuZCBpbiB0aGUgTGl2ZU1hcC5cbiAgICovXG4gIGdldChrZXkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI21hcC5nZXQoa2V5KTtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVOb2RlVG9Mc29uKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIGFuIGVsZW1lbnQgd2l0aCBhIHNwZWNpZmllZCBrZXkgYW5kIGEgdmFsdWUuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byBhZGQuIFNob3VsZCBiZSBhIHN0cmluZy5cbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCB0byBhZGQuIFNob3VsZCBiZSBzZXJpYWxpemFibGUgdG8gSlNPTi5cbiAgICovXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuI21hcC5nZXQoa2V5KTtcbiAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IGxzb25Ub0xpdmVOb2RlKHZhbHVlKTtcbiAgICBpdGVtLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgdGhpcy4jbWFwLnNldChrZXksIGl0ZW0pO1xuICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIGlmICh0aGlzLl9wb29sICYmIHRoaXMuX2lkKSB7XG4gICAgICBjb25zdCBpZCA9IHRoaXMuX3Bvb2wuZ2VuZXJhdGVJZCgpO1xuICAgICAgaXRlbS5fYXR0YWNoKGlkLCB0aGlzLl9wb29sKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VVcGRhdGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHN0b3JhZ2VVcGRhdGVzLnNldCh0aGlzLl9pZCwge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcInVwZGF0ZVwiIH0gfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBvcHMgPSBpdGVtLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKTtcbiAgICAgIHRoaXMuI3VuYWNrbm93bGVkZ2VkU2V0LnNldChrZXksIG5uKG9wc1swXS5vcElkKSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBpdGVtLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKSxcbiAgICAgICAgb2xkVmFsdWUgPyBvbGRWYWx1ZS5fdG9PcHModGhpcy5faWQsIGtleSkgOiBbeyB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLCBpZCB9XSxcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIExpdmVNYXAuXG4gICAqL1xuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jbWFwLnNpemU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCBrZXkgZXhpc3RzIG9yIG5vdC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHRlc3QgZm9yIHByZXNlbmNlLlxuICAgKi9cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzLiNtYXAuaGFzKGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBlbGVtZW50IGJ5IGtleS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiBhbiBlbGVtZW50IGV4aXN0ZWQgYW5kIGhhcyBiZWVuIHJlbW92ZWQsIG9yIGZhbHNlIGlmIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0LlxuICAgKi9cbiAgZGVsZXRlKGtleSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuI21hcC5nZXQoa2V5KTtcbiAgICBpZiAoaXRlbSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGl0ZW0uX2RldGFjaCgpO1xuICAgIHRoaXMuI21hcC5kZWxldGUoa2V5KTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCAmJiBpdGVtLl9pZCkge1xuICAgICAgY29uc3QgdGhpc0lkID0gbm4odGhpcy5faWQpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXNJZCwge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVNYXBcIixcbiAgICAgICAgdXBkYXRlczogeyBba2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH0gfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9wb29sLmRpc3BhdGNoKFxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogNSAvKiBERUxFVEVfQ1JEVCAqLyxcbiAgICAgICAgICAgIGlkOiBpdGVtLl9pZCxcbiAgICAgICAgICAgIG9wSWQ6IHRoaXMuX3Bvb2wuZ2VuZXJhdGVPcElkKClcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGl0ZW0uX3RvT3BzKHRoaXNJZCwga2V5KSxcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBba2V5LCB2YWx1ZV0gcGFpcnMgZm9yIGVhY2ggZWxlbWVudC5cbiAgICovXG4gIGVudHJpZXMoKSB7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRoaXMuI21hcC5lbnRyaWVzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvclZhbHVlID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChpdGVyYXRvclZhbHVlLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gaXRlcmF0b3JWYWx1ZS52YWx1ZTtcbiAgICAgICAgY29uc3Qga2V5ID0gZW50cnlbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGl2ZU5vZGVUb0xzb24oaXRlcmF0b3JWYWx1ZS52YWx1ZVsxXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IFtrZXksIHZhbHVlXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNhbWUgZnVuY3Rpb24gb2JqZWN0IGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBlbnRyaWVzIG1ldGhvZC5cbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUga2V5cyBmb3IgZWFjaCBlbGVtZW50LlxuICAgKi9cbiAga2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy4jbWFwLmtleXMoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBJdGVyYXRvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgdmFsdWVzIGZvciBlYWNoIGVsZW1lbnQuXG4gICAqL1xuICB2YWx1ZXMoKSB7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRoaXMuI21hcC52YWx1ZXMoKTtcbiAgICByZXR1cm4ge1xuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yVmFsdWUgPSBpbm5lckl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yVmFsdWUuZG9uZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBsaXZlTm9kZVRvTHNvbihpdGVyYXRvclZhbHVlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uY2UgcGVyIGVhY2gga2V5L3ZhbHVlIHBhaXIgaW4gdGhlIE1hcCBvYmplY3QsIGluIGluc2VydGlvbiBvcmRlci5cbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZm9yIGVhY2ggZW50cnkgaW4gdGhlIG1hcC5cbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMpIHtcbiAgICAgIGNhbGxiYWNrKGVudHJ5WzFdLCBlbnRyeVswXSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvVHJlZU5vZGUoa2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgaWQ6IHRoaXMuX2lkID8/IG5hbm9pZCgpLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogQXJyYXkuZnJvbSh0aGlzLiNtYXAuZW50cmllcygpKS5tYXAoXG4gICAgICAgIChba2V5MiwgdmFsXSkgPT4gdmFsLnRvVHJlZU5vZGUoa2V5MilcbiAgICAgIClcbiAgICB9O1xuICB9XG4gIHRvSW1tdXRhYmxlKCkge1xuICAgIHJldHVybiBzdXBlci50b0ltbXV0YWJsZSgpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3RvSW1tdXRhYmxlKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy4jbWFwKSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUudG9JbW11dGFibGUoKSk7XG4gICAgfVxuICAgIHJldHVybiBmcmVlemUocmVzdWx0KTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9MaXZlTWFwKFxuICAgICAgQXJyYXkuZnJvbSh0aGlzLiNtYXApLm1hcCgoW2tleSwgbm9kZV0pID0+IFtrZXksIG5vZGUuY2xvbmUoKV0pXG4gICAgKTtcbiAgfVxufTtcblxuLy8gc3JjL2NyZHRzL0xpdmVPYmplY3QudHNcbnZhciBMaXZlT2JqZWN0ID0gY2xhc3MgX0xpdmVPYmplY3QgZXh0ZW5kcyBBYnN0cmFjdENyZHQge1xuICAjbWFwO1xuICAjcHJvcFRvTGFzdFVwZGF0ZTtcbiAgc3RhdGljICNidWlsZFJvb3RBbmRQYXJlbnRUb0NoaWxkcmVuKGl0ZW1zKSB7XG4gICAgY29uc3QgcGFyZW50VG9DaGlsZHJlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IHJvb3QgPSBudWxsO1xuICAgIGZvciAoY29uc3QgW2lkLCBjcmR0XSBvZiBpdGVtcykge1xuICAgICAgaWYgKGlzUm9vdENyZHQoY3JkdCkpIHtcbiAgICAgICAgcm9vdCA9IFtpZCwgY3JkdF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0dXBsZSA9IFtpZCwgY3JkdF07XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50VG9DaGlsZHJlbi5nZXQoY3JkdC5wYXJlbnRJZCk7XG4gICAgICAgIGlmIChjaGlsZHJlbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh0dXBsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyZW50VG9DaGlsZHJlbi5zZXQoY3JkdC5wYXJlbnRJZCwgW3R1cGxlXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJvb3QgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvb3QgY2FuJ3QgYmUgbnVsbFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFtyb290LCBwYXJlbnRUb0NoaWxkcmVuXTtcbiAgfVxuICAvKiogQHByaXZhdGUgRG8gbm90IHVzZSB0aGlzIEFQSSBkaXJlY3RseSAqL1xuICBzdGF0aWMgX2Zyb21JdGVtcyhpdGVtcywgcG9vbCkge1xuICAgIGNvbnN0IFtyb290LCBwYXJlbnRUb0NoaWxkcmVuXSA9IF9MaXZlT2JqZWN0LiNidWlsZFJvb3RBbmRQYXJlbnRUb0NoaWxkcmVuKGl0ZW1zKTtcbiAgICByZXR1cm4gX0xpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFxuICAgICAgcm9vdCxcbiAgICAgIHBhcmVudFRvQ2hpbGRyZW4sXG4gICAgICBwb29sXG4gICAgKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihvYmogPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jcHJvcFRvTGFzdFVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgbyA9IGNvbXBhY3RPYmplY3Qob2JqKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvW2tleV07XG4gICAgICBpZiAoaXNMaXZlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jbWFwID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhvKSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9PcHMocGFyZW50SWQsIHBhcmVudEtleSwgcG9vbCkge1xuICAgIGlmICh0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2VyaWFsaXplIGl0ZW0gaXMgbm90IGF0dGFjaGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBvcElkID0gcG9vbD8uZ2VuZXJhdGVPcElkKCk7XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgb3AgPSB7XG4gICAgICB0eXBlOiA0IC8qIENSRUFURV9PQkpFQ1QgKi8sXG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICBvcElkLFxuICAgICAgcGFyZW50SWQsXG4gICAgICBwYXJlbnRLZXksXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgb3BzLnB1c2gob3ApO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuI21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIG9wcy5wdXNoKC4uLnZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCBwb29sKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcC5kYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBfZGVzZXJpYWxpemUoW2lkLCBpdGVtXSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCkge1xuICAgIGNvbnN0IGxpdmVPYmogPSBuZXcgX0xpdmVPYmplY3QoaXRlbS5kYXRhKTtcbiAgICBsaXZlT2JqLl9hdHRhY2goaWQsIHBvb2wpO1xuICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZUNoaWxkcmVuKGxpdmVPYmosIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIF9kZXNlcmlhbGl6ZUNoaWxkcmVuKGxpdmVPYmosIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFRvQ2hpbGRyZW4uZ2V0KG5uKGxpdmVPYmouX2lkKSk7XG4gICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBsaXZlT2JqO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZCwgY3JkdF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGVzZXJpYWxpemVUb0xzb24oW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgICBpZiAoaXNMaXZlU3RydWN0dXJlKGNoaWxkKSkge1xuICAgICAgICBjaGlsZC5fc2V0UGFyZW50TGluayhsaXZlT2JqLCBjcmR0LnBhcmVudEtleSk7XG4gICAgICB9XG4gICAgICBsaXZlT2JqLiNtYXAuc2V0KGNyZHQucGFyZW50S2V5LCBjaGlsZCk7XG4gICAgICBsaXZlT2JqLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVPYmo7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfYXR0YWNoKGlkLCBwb29sKSB7XG4gICAgc3VwZXIuX2F0dGFjaChpZCwgcG9vbCk7XG4gICAgZm9yIChjb25zdCBbX2tleSwgdmFsdWVdIG9mIHRoaXMuI21hcCkge1xuICAgICAgaWYgKGlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLl9hdHRhY2gocG9vbC5nZW5lcmF0ZUlkKCksIHBvb2wpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9hdHRhY2hDaGlsZChvcCwgc291cmNlKSB7XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYXR0YWNoIGNoaWxkIGlmIG1hbmFnZWQgcG9vbCBpcyBub3QgcHJlc2VudFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgb3BJZCwgcGFyZW50S2V5OiBrZXkgfSA9IG9wO1xuICAgIGNvbnN0IGNoaWxkID0gY3JlYXRpb25PcFRvTHNvbihvcCk7XG4gICAgaWYgKHRoaXMuX3Bvb2wuZ2V0Tm9kZShpZCkgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wSWQpIHtcbiAgICAgICAgdGhpcy4jcHJvcFRvTGFzdFVwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBpZiAoc291cmNlID09PSAwIC8qIFVORE9SRURPX1JFQ09OTkVDVCAqLykge1xuICAgICAgdGhpcy4jcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihvcElkKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNwcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wSWQpIHtcbiAgICAgIHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuZGVsZXRlKGtleSk7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IHRoaXNJZCA9IG5uKHRoaXMuX2lkKTtcbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy4jbWFwLmdldChrZXkpO1xuICAgIGxldCByZXZlcnNlO1xuICAgIGlmIChpc0xpdmVOb2RlKHByZXZpb3VzVmFsdWUpKSB7XG4gICAgICByZXZlcnNlID0gcHJldmlvdXNWYWx1ZS5fdG9PcHModGhpc0lkLCBrZXkpO1xuICAgICAgcHJldmlvdXNWYWx1ZS5fZGV0YWNoKCk7XG4gICAgfSBlbHNlIGlmIChwcmV2aW91c1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldmVyc2UgPSBbeyB0eXBlOiA2IC8qIERFTEVURV9PQkpFQ1RfS0VZICovLCBpZDogdGhpc0lkLCBrZXkgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgaWQ6IHRoaXNJZCxcbiAgICAgICAgICBkYXRhOiB7IFtrZXldOiBwcmV2aW91c1ZhbHVlIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgdGhpcy4jbWFwLnNldChrZXksIGNoaWxkKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBpZiAoaXNMaXZlU3RydWN0dXJlKGNoaWxkKSkge1xuICAgICAgY2hpbGQuX3NldFBhcmVudExpbmsodGhpcywga2V5KTtcbiAgICAgIGNoaWxkLl9hdHRhY2goaWQsIHRoaXMuX3Bvb2wpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmV2ZXJzZSxcbiAgICAgIG1vZGlmaWVkOiB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIHR5cGU6IFwiTGl2ZU9iamVjdFwiLFxuICAgICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwidXBkYXRlXCIgfSB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF9kZXRhY2hDaGlsZChjaGlsZCkge1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgY29uc3QgaWQgPSBubih0aGlzLl9pZCk7XG4gICAgICBjb25zdCBwYXJlbnRLZXkgPSBubihjaGlsZC5fcGFyZW50S2V5KTtcbiAgICAgIGNvbnN0IHJldmVyc2UgPSBjaGlsZC5fdG9PcHMoaWQsIHBhcmVudEtleSwgdGhpcy5fcG9vbCk7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLiNtYXApIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBjaGlsZCkge1xuICAgICAgICAgIHRoaXMuI21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hpbGQuX2RldGFjaCgpO1xuICAgICAgY29uc3Qgc3RvcmFnZVVwZGF0ZSA9IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgICBbcGFyZW50S2V5XTogeyB0eXBlOiBcImRlbGV0ZVwiIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBzdG9yYWdlVXBkYXRlLCByZXZlcnNlIH07XG4gICAgfVxuICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2RldGFjaCgpIHtcbiAgICBzdXBlci5fZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLiNtYXAudmFsdWVzKCkpIHtcbiAgICAgIGlmIChpc0xpdmVOb2RlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX2FwcGx5KG9wLCBpc0xvY2FsKSB7XG4gICAgaWYgKG9wLnR5cGUgPT09IDMgLyogVVBEQVRFX09CSkVDVCAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuI2FwcGx5VXBkYXRlKG9wLCBpc0xvY2FsKTtcbiAgICB9IGVsc2UgaWYgKG9wLnR5cGUgPT09IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLiNhcHBseURlbGV0ZU9iamVjdEtleShvcCwgaXNMb2NhbCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5fYXBwbHkob3AsIGlzTG9jYWwpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgX3NlcmlhbGl6ZSgpIHtcbiAgICBjb25zdCBkYXRhID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy4jbWFwKSB7XG4gICAgICBpZiAoIWlzTGl2ZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnQudHlwZSA9PT0gXCJIYXNQYXJlbnRcIiAmJiB0aGlzLnBhcmVudC5ub2RlLl9pZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMCAvKiBPQkpFQ1QgKi8sXG4gICAgICAgIHBhcmVudElkOiB0aGlzLnBhcmVudC5ub2RlLl9pZCxcbiAgICAgICAgcGFyZW50S2V5OiB0aGlzLnBhcmVudC5rZXksXG4gICAgICAgIGRhdGFcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDAgLyogT0JKRUNUICovLFxuICAgICAgICBkYXRhXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAjYXBwbHlVcGRhdGUob3AsIGlzTG9jYWwpIHtcbiAgICBsZXQgaXNNb2RpZmllZCA9IGZhbHNlO1xuICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgIGNvbnN0IHJldmVyc2UgPSBbXTtcbiAgICBjb25zdCByZXZlcnNlVXBkYXRlID0ge1xuICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgaWQsXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3AuZGF0YSkge1xuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLiNtYXAuZ2V0KGtleSk7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgcmV2ZXJzZS5wdXNoKC4uLm9sZFZhbHVlLl90b09wcyhpZCwga2V5KSk7XG4gICAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICByZXZlcnNlVXBkYXRlLmRhdGFba2V5XSA9IG9sZFZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldmVyc2UucHVzaCh7IHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sIGlkLCBrZXkgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZURlbHRhID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3AuZGF0YSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvcC5kYXRhW2tleV07XG4gICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xvY2FsKSB7XG4gICAgICAgIHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuc2V0KGtleSwgbm4ob3Aub3BJZCkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLiNwcm9wVG9MYXN0VXBkYXRlLmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICAgICAgaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgPT09IG9wLm9wSWQpIHtcbiAgICAgICAgdGhpcy4jcHJvcFRvTGFzdFVwZGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy4jbWFwLmdldChrZXkpO1xuICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgIG9sZFZhbHVlLl9kZXRhY2goKTtcbiAgICAgIH1cbiAgICAgIGlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgdXBkYXRlRGVsdGFba2V5XSA9IHsgdHlwZTogXCJ1cGRhdGVcIiB9O1xuICAgICAgdGhpcy4jbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMocmV2ZXJzZVVwZGF0ZS5kYXRhKS5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldmVyc2UudW5zaGlmdChyZXZlcnNlVXBkYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzTW9kaWZpZWQgPyB7XG4gICAgICBtb2RpZmllZDoge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICB0eXBlOiBcIkxpdmVPYmplY3RcIixcbiAgICAgICAgdXBkYXRlczogdXBkYXRlRGVsdGFcbiAgICAgIH0sXG4gICAgICByZXZlcnNlXG4gICAgfSA6IHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gIH1cbiAgI2FwcGx5RGVsZXRlT2JqZWN0S2V5KG9wLCBpc0xvY2FsKSB7XG4gICAgY29uc3Qga2V5ID0gb3Aua2V5O1xuICAgIGlmICh0aGlzLiNtYXAuaGFzKGtleSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICB9XG4gICAgaWYgKCFpc0xvY2FsICYmIHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuZ2V0KGtleSkgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy4jbWFwLmdldChrZXkpO1xuICAgIGNvbnN0IGlkID0gbm4odGhpcy5faWQpO1xuICAgIGxldCByZXZlcnNlID0gW107XG4gICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICByZXZlcnNlID0gb2xkVmFsdWUuX3RvT3BzKGlkLCBvcC5rZXkpO1xuICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgcmV2ZXJzZSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDMgLyogVVBEQVRFX09CSkVDVCAqLyxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBkYXRhOiB7IFtrZXldOiBvbGRWYWx1ZSB9XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIHRoaXMuI21hcC5kZWxldGUoa2V5KTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZWQ6IHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICAgIHVwZGF0ZXM6IHsgW29wLmtleV06IHsgdHlwZTogXCJkZWxldGVcIiB9IH1cbiAgICAgIH0sXG4gICAgICByZXZlcnNlXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBMaXZlT2JqZWN0IGludG8gYSBqYXZhc2NyaXB0IG9iamVjdFxuICAgKi9cbiAgdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLiNtYXApO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgYSBwcm9wZXJ0eSB3aXRoIGEgc3BlY2lmaWVkIGtleSBhbmQgYSB2YWx1ZS5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhZGRcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gYWRkXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3Bvb2w/LmFzc2VydFN0b3JhZ2VJc1dyaXRhYmxlKCk7XG4gICAgdGhpcy51cGRhdGUoeyBba2V5XTogdmFsdWUgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzcGVjaWZpZWQgcHJvcGVydHkgZnJvbSB0aGUgTGl2ZU9iamVjdC5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXRcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy4jbWFwLmdldChrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEga2V5IGZyb20gdGhlIExpdmVPYmplY3RcbiAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShrZXkpIHtcbiAgICB0aGlzLl9wb29sPy5hc3NlcnRTdG9yYWdlSXNXcml0YWJsZSgpO1xuICAgIGNvbnN0IGtleUFzU3RyaW5nID0ga2V5O1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy4jbWFwLmdldChrZXlBc1N0cmluZyk7XG4gICAgaWYgKG9sZFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3Bvb2wgPT09IHZvaWQgMCB8fCB0aGlzLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoaXNMaXZlTm9kZShvbGRWYWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy4jbWFwLmRlbGV0ZShrZXlBc1N0cmluZyk7XG4gICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHJldmVyc2U7XG4gICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICBvbGRWYWx1ZS5fZGV0YWNoKCk7XG4gICAgICByZXZlcnNlID0gb2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXlBc1N0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgZGF0YTogeyBba2V5QXNTdHJpbmddOiBvbGRWYWx1ZSB9LFxuICAgICAgICAgIGlkOiB0aGlzLl9pZFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgICB0aGlzLiNtYXAuZGVsZXRlKGtleUFzU3RyaW5nKTtcbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICB1cGRhdGVzOiB7IFtrZXldOiB7IHR5cGU6IFwiZGVsZXRlXCIgfSB9XG4gICAgfSk7XG4gICAgdGhpcy5fcG9vbC5kaXNwYXRjaChcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sXG4gICAgICAgICAga2V5OiBrZXlBc1N0cmluZyxcbiAgICAgICAgICBpZDogdGhpcy5faWQsXG4gICAgICAgICAgb3BJZDogdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgcmV2ZXJzZSxcbiAgICAgIHN0b3JhZ2VVcGRhdGVzXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZSB3aXRoIGFuIG9iamVjdC5cbiAgICogQHBhcmFtIHBhdGNoIFRoZSBvYmplY3QgdXNlZCB0byBvdmVycmlkZXMgcHJvcGVydGllc1xuICAgKi9cbiAgdXBkYXRlKHBhdGNoKSB7XG4gICAgdGhpcy5fcG9vbD8uYXNzZXJ0U3RvcmFnZUlzV3JpdGFibGUoKTtcbiAgICBpZiAodGhpcy5fcG9vbCA9PT0gdm9pZCAwIHx8IHRoaXMuX2lkID09PSB2b2lkIDApIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhdGNoKSB7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gcGF0Y2hba2V5XTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuI21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGlzTGl2ZU5vZGUob2xkVmFsdWUpKSB7XG4gICAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xpdmVOb2RlKG5ld1ZhbHVlKSkge1xuICAgICAgICAgIG5ld1ZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbWFwLnNldChrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IHJldmVyc2VPcHMgPSBbXTtcbiAgICBjb25zdCBvcElkID0gdGhpcy5fcG9vbC5nZW5lcmF0ZU9wSWQoKTtcbiAgICBjb25zdCB1cGRhdGVkUHJvcHMgPSB7fTtcbiAgICBjb25zdCByZXZlcnNlVXBkYXRlT3AgPSB7XG4gICAgICBpZDogdGhpcy5faWQsXG4gICAgICB0eXBlOiAzIC8qIFVQREFURV9PQkpFQ1QgKi8sXG4gICAgICBkYXRhOiB7fVxuICAgIH07XG4gICAgY29uc3QgdXBkYXRlRGVsdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXRjaCkge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBwYXRjaFtrZXldO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuI21hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChpc0xpdmVOb2RlKG9sZFZhbHVlKSkge1xuICAgICAgICByZXZlcnNlT3BzLnB1c2goLi4ub2xkVmFsdWUuX3RvT3BzKHRoaXMuX2lkLCBrZXkpKTtcbiAgICAgICAgb2xkVmFsdWUuX2RldGFjaCgpO1xuICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldmVyc2VPcHMucHVzaCh7IHR5cGU6IDYgLyogREVMRVRFX09CSkVDVF9LRVkgKi8sIGlkOiB0aGlzLl9pZCwga2V5IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV2ZXJzZVVwZGF0ZU9wLmRhdGFba2V5XSA9IG9sZFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzTGl2ZU5vZGUobmV3VmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlLl9zZXRQYXJlbnRMaW5rKHRoaXMsIGtleSk7XG4gICAgICAgIG5ld1ZhbHVlLl9hdHRhY2godGhpcy5fcG9vbC5nZW5lcmF0ZUlkKCksIHRoaXMuX3Bvb2wpO1xuICAgICAgICBjb25zdCBuZXdBdHRhY2hDaGlsZE9wcyA9IG5ld1ZhbHVlLl90b09wcyh0aGlzLl9pZCwga2V5LCB0aGlzLl9wb29sKTtcbiAgICAgICAgY29uc3QgY3JlYXRlQ3JkdE9wID0gbmV3QXR0YWNoQ2hpbGRPcHMuZmluZChcbiAgICAgICAgICAob3ApID0+IG9wLnBhcmVudElkID09PSB0aGlzLl9pZFxuICAgICAgICApO1xuICAgICAgICBpZiAoY3JlYXRlQ3JkdE9wKSB7XG4gICAgICAgICAgdGhpcy4jcHJvcFRvTGFzdFVwZGF0ZS5zZXQoa2V5LCBubihjcmVhdGVDcmR0T3Aub3BJZCkpO1xuICAgICAgICB9XG4gICAgICAgIG9wcy5wdXNoKC4uLm5ld0F0dGFjaENoaWxkT3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZWRQcm9wc1trZXldID0gbmV3VmFsdWU7XG4gICAgICAgIHRoaXMuI3Byb3BUb0xhc3RVcGRhdGUuc2V0KGtleSwgb3BJZCk7XG4gICAgICB9XG4gICAgICB0aGlzLiNtYXAuc2V0KGtleSwgbmV3VmFsdWUpO1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICB1cGRhdGVEZWx0YVtrZXldID0geyB0eXBlOiBcInVwZGF0ZVwiIH07XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhyZXZlcnNlVXBkYXRlT3AuZGF0YSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXZlcnNlT3BzLnVuc2hpZnQocmV2ZXJzZVVwZGF0ZU9wKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZWRQcm9wcykubGVuZ3RoICE9PSAwKSB7XG4gICAgICBvcHMudW5zaGlmdCh7XG4gICAgICAgIG9wSWQsXG4gICAgICAgIGlkOiB0aGlzLl9pZCxcbiAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICBkYXRhOiB1cGRhdGVkUHJvcHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgc3RvcmFnZVVwZGF0ZXMuc2V0KHRoaXMuX2lkLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICB1cGRhdGVzOiB1cGRhdGVEZWx0YVxuICAgIH0pO1xuICAgIHRoaXMuX3Bvb2wuZGlzcGF0Y2gob3BzLCByZXZlcnNlT3BzLCBzdG9yYWdlVXBkYXRlcyk7XG4gIH1cbiAgdG9JbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnRvSW1tdXRhYmxlKCk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB0b1RyZWVOb2RlKGtleSkge1xuICAgIHJldHVybiBzdXBlci50b1RyZWVOb2RlKGtleSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdG9UcmVlTm9kZShrZXkpIHtcbiAgICBjb25zdCBub2RlSWQgPSB0aGlzLl9pZCA/PyBuYW5vaWQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICBpZDogbm9kZUlkLFxuICAgICAga2V5LFxuICAgICAgcGF5bG9hZDogQXJyYXkuZnJvbSh0aGlzLiNtYXAuZW50cmllcygpKS5tYXAoXG4gICAgICAgIChba2V5MiwgdmFsdWVdKSA9PiBpc0xpdmVOb2RlKHZhbHVlKSA/IHZhbHVlLnRvVHJlZU5vZGUoa2V5MikgOiB7IHR5cGU6IFwiSnNvblwiLCBpZDogYCR7bm9kZUlkfToke2tleTJ9YCwga2V5OiBrZXkyLCBwYXlsb2FkOiB2YWx1ZSB9XG4gICAgICApXG4gICAgfTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIF90b0ltbXV0YWJsZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy4jbWFwKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGlzTGl2ZVN0cnVjdHVyZSh2YWwpID8gdmFsLnRvSW1tdXRhYmxlKCkgOiB2YWw7XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyByZXN1bHQgOiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfTGl2ZU9iamVjdChcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLiNtYXApLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBbXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkgPyB2YWx1ZS5jbG9uZSgpIDogZGVlcENsb25lKHZhbHVlKVxuICAgICAgICBdKVxuICAgICAgKVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9jcmR0cy9saXZlYmxvY2tzLWhlbHBlcnMudHNcbmZ1bmN0aW9uIGNyZWF0aW9uT3BUb0xpdmVOb2RlKG9wKSB7XG4gIHJldHVybiBsc29uVG9MaXZlTm9kZShjcmVhdGlvbk9wVG9Mc29uKG9wKSk7XG59XG5mdW5jdGlvbiBjcmVhdGlvbk9wVG9Mc29uKG9wKSB7XG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgOCAvKiBDUkVBVEVfUkVHSVNURVIgKi86XG4gICAgICByZXR1cm4gb3AuZGF0YTtcbiAgICBjYXNlIDQgLyogQ1JFQVRFX09CSkVDVCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZU9iamVjdChvcC5kYXRhKTtcbiAgICBjYXNlIDcgLyogQ1JFQVRFX01BUCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZU1hcCgpO1xuICAgIGNhc2UgMiAvKiBDUkVBVEVfTElTVCAqLzpcbiAgICAgIHJldHVybiBuZXcgTGl2ZUxpc3QoW10pO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIob3AsIFwiVW5rbm93biBjcmVhdGlvbiBPcFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTYW1lTm9kZU9yQ2hpbGRPZihub2RlLCBwYXJlbnQpIHtcbiAgaWYgKG5vZGUgPT09IHBhcmVudCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChub2RlLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgcmV0dXJuIGlzU2FtZU5vZGVPckNoaWxkT2Yobm9kZS5wYXJlbnQubm9kZSwgcGFyZW50KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKSB7XG4gIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgY2FzZSAwIC8qIE9CSkVDVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVPYmplY3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDEgLyogTElTVCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVMaXN0Ll9kZXNlcmlhbGl6ZShbaWQsIGNyZHRdLCBwYXJlbnRUb0NoaWxkcmVuLCBwb29sKTtcbiAgICB9XG4gICAgY2FzZSAyIC8qIE1BUCAqLzoge1xuICAgICAgcmV0dXJuIExpdmVNYXAuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDMgLyogUkVHSVNURVIgKi86IHtcbiAgICAgIHJldHVybiBMaXZlUmVnaXN0ZXIuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIENSRFQgdHlwZVwiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplVG9Mc29uKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpIHtcbiAgc3dpdGNoIChjcmR0LnR5cGUpIHtcbiAgICBjYXNlIDAgLyogT0JKRUNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU9iamVjdC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMSAvKiBMSVNUICovOiB7XG4gICAgICByZXR1cm4gTGl2ZUxpc3QuX2Rlc2VyaWFsaXplKFtpZCwgY3JkdF0sIHBhcmVudFRvQ2hpbGRyZW4sIHBvb2wpO1xuICAgIH1cbiAgICBjYXNlIDIgLyogTUFQICovOiB7XG4gICAgICByZXR1cm4gTGl2ZU1hcC5fZGVzZXJpYWxpemUoW2lkLCBjcmR0XSwgcGFyZW50VG9DaGlsZHJlbiwgcG9vbCk7XG4gICAgfVxuICAgIGNhc2UgMyAvKiBSRUdJU1RFUiAqLzoge1xuICAgICAgcmV0dXJuIGNyZHQuZGF0YTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBDUkRUIHR5cGVcIik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpIHtcbiAgcmV0dXJuIGlzTGl2ZUxpc3QodmFsdWUpIHx8IGlzTGl2ZU1hcCh2YWx1ZSkgfHwgaXNMaXZlT2JqZWN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU5vZGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzTGl2ZVN0cnVjdHVyZSh2YWx1ZSkgfHwgaXNMaXZlUmVnaXN0ZXIodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNMaXZlTGlzdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlTGlzdDtcbn1cbmZ1bmN0aW9uIGlzTGl2ZU1hcCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwO1xufVxuZnVuY3Rpb24gaXNMaXZlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3Q7XG59XG5mdW5jdGlvbiBpc0xpdmVSZWdpc3Rlcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBMaXZlUmVnaXN0ZXI7XG59XG5mdW5jdGlvbiBjbG9uZUxzb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpc0xpdmVTdHJ1Y3R1cmUodmFsdWUpID8gdmFsdWUuY2xvbmUoKSA6IGRlZXBDbG9uZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBsaXZlTm9kZVRvTHNvbihvYmopIHtcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIExpdmVSZWdpc3Rlcikge1xuICAgIHJldHVybiBvYmouZGF0YTtcbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMaXZlTGlzdCB8fCBvYmogaW5zdGFuY2VvZiBMaXZlTWFwIHx8IG9iaiBpbnN0YW5jZW9mIExpdmVPYmplY3QpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc3NlcnROZXZlcihvYmosIFwiVW5rbm93biBBYnN0cmFjdENyZHRcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGxzb25Ub0xpdmVOb2RlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVPYmplY3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBMaXZlTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlUmVnaXN0ZXIodmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUcmVlc0RpZmZPcGVyYXRpb25zKGN1cnJlbnRJdGVtcywgbmV3SXRlbXMpIHtcbiAgY29uc3Qgb3BzID0gW107XG4gIGN1cnJlbnRJdGVtcy5mb3JFYWNoKChfLCBpZCkgPT4ge1xuICAgIGlmICghbmV3SXRlbXMuZ2V0KGlkKSkge1xuICAgICAgb3BzLnB1c2goe1xuICAgICAgICB0eXBlOiA1IC8qIERFTEVURV9DUkRUICovLFxuICAgICAgICBpZFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgbmV3SXRlbXMuZm9yRWFjaCgoY3JkdCwgaWQpID0+IHtcbiAgICBjb25zdCBjdXJyZW50Q3JkdCA9IGN1cnJlbnRJdGVtcy5nZXQoaWQpO1xuICAgIGlmIChjdXJyZW50Q3JkdCkge1xuICAgICAgaWYgKGNyZHQudHlwZSA9PT0gMCAvKiBPQkpFQ1QgKi8pIHtcbiAgICAgICAgaWYgKGN1cnJlbnRDcmR0LnR5cGUgIT09IDAgLyogT0JKRUNUICovIHx8IHN0cmluZ2lmeU9yTG9nKGNyZHQuZGF0YSkgIT09IHN0cmluZ2lmeU9yTG9nKGN1cnJlbnRDcmR0LmRhdGEpKSB7XG4gICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMyAvKiBVUERBVEVfT0JKRUNUICovLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBkYXRhOiBjcmR0LmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNyZHQucGFyZW50S2V5ICE9PSBjdXJyZW50Q3JkdC5wYXJlbnRLZXkpIHtcbiAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IDEgLyogU0VUX1BBUkVOVF9LRVkgKi8sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGFyZW50S2V5OiBubihjcmR0LnBhcmVudEtleSwgXCJQYXJlbnQga2V5IG11c3Qgbm90IGJlIG1pc3NpbmdcIilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoY3JkdC50eXBlKSB7XG4gICAgICAgIGNhc2UgMyAvKiBSRUdJU1RFUiAqLzpcbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA4IC8qIENSRUFURV9SRUdJU1RFUiAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5LFxuICAgICAgICAgICAgZGF0YTogY3JkdC5kYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBMSVNUICovOlxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDIgLyogQ1JFQVRFX0xJU1QgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDAgLyogT0JKRUNUICovOlxuICAgICAgICAgIGlmIChjcmR0LnBhcmVudElkID09PSB2b2lkIDAgfHwgY3JkdC5wYXJlbnRLZXkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBcIkludGVybmFsIGVycm9yLiBDYW5ub3Qgc2VyaWFsaXplIHN0b3JhZ2Ugcm9vdCBpbnRvIGFuIG9wZXJhdGlvblwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA0IC8qIENSRUFURV9PQkpFQ1QgKi8sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBjcmR0LnBhcmVudElkLFxuICAgICAgICAgICAgcGFyZW50S2V5OiBjcmR0LnBhcmVudEtleSxcbiAgICAgICAgICAgIGRhdGE6IGNyZHQuZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIgLyogTUFQICovOlxuICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDcgLyogQ1JFQVRFX01BUCAqLyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IGNyZHQucGFyZW50SWQsXG4gICAgICAgICAgICBwYXJlbnRLZXk6IGNyZHQucGFyZW50S2V5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG9wcztcbn1cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBjb25zdCB1cGRhdGVzID0gZmlyc3QudXBkYXRlcztcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZW50cmllcyhzZWNvbmQudXBkYXRlcykpIHtcbiAgICB1cGRhdGVzW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnNlY29uZCxcbiAgICB1cGRhdGVzXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZU1hcFN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgY29uc3QgdXBkYXRlcyA9IGZpcnN0LnVwZGF0ZXM7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMoc2Vjb25kLnVwZGF0ZXMpKSB7XG4gICAgdXBkYXRlc1trZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlc1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VMaXN0U3RvcmFnZVVwZGF0ZXMoZmlyc3QsIHNlY29uZCkge1xuICBjb25zdCB1cGRhdGVzID0gZmlyc3QudXBkYXRlcztcbiAgcmV0dXJuIHtcbiAgICAuLi5zZWNvbmQsXG4gICAgdXBkYXRlczogdXBkYXRlcy5jb25jYXQoc2Vjb25kLnVwZGF0ZXMpXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZVN0b3JhZ2VVcGRhdGVzKGZpcnN0LCBzZWNvbmQpIHtcbiAgaWYgKGZpcnN0ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gc2Vjb25kO1xuICB9XG4gIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVPYmplY3RcIiAmJiBzZWNvbmQudHlwZSA9PT0gXCJMaXZlT2JqZWN0XCIpIHtcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVNYXBcIiAmJiBzZWNvbmQudHlwZSA9PT0gXCJMaXZlTWFwXCIpIHtcbiAgICByZXR1cm4gbWVyZ2VNYXBTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIGlmIChmaXJzdC50eXBlID09PSBcIkxpdmVMaXN0XCIgJiYgc2Vjb25kLnR5cGUgPT09IFwiTGl2ZUxpc3RcIikge1xuICAgIHJldHVybiBtZXJnZUxpc3RTdG9yYWdlVXBkYXRlcyhmaXJzdCwgc2Vjb25kKTtcbiAgfSBlbHNlIHtcbiAgfVxuICByZXR1cm4gc2Vjb25kO1xufVxuZnVuY3Rpb24gaXNQbGFpbih2YWx1ZSkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUodmFsdWUsIHBhdGggPSBcIlwiKSB7XG4gIGlmICghaXNQbGFpbikge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBwYXRoIHx8IFwicm9vdFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCBuZXN0ZWRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgaWYgKCFpc1BsYWluKG5lc3RlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogbmVzdGVkUGF0aCxcbiAgICAgICAgdmFsdWU6IG5lc3RlZFZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCBub25TZXJpYWxpemFibGVOZXN0ZWRWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShcbiAgICAgICAgbmVzdGVkVmFsdWUsXG4gICAgICAgIG5lc3RlZFBhdGhcbiAgICAgICk7XG4gICAgICBpZiAobm9uU2VyaWFsaXphYmxlTmVzdGVkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5vblNlcmlhbGl6YWJsZU5lc3RlZFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNyYy9saWIvZGVidWcudHNcbmZ1bmN0aW9uIGNhcHR1cmVTdGFja1RyYWNlKG1zZywgdHJhY2VSb290KSB7XG4gIGNvbnN0IGVycm9yTGlrZSA9IHsgbmFtZTogbXNnIH07XG4gIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3JMaWtlLCB0cmFjZVJvb3QpO1xuICByZXR1cm4gZXJyb3JMaWtlLnN0YWNrO1xufVxuXG4vLyBzcmMvbGliL0RlcXVlLnRzXG52YXIgRGVxdWUgPSBjbGFzcyB7XG4gICNkYXRhO1xuICAjZnJvbnQ7XG4gICNiYWNrO1xuICAjc2l6ZTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy4jZGF0YSA9IHt9O1xuICAgIHRoaXMuI2Zyb250ID0gMDtcbiAgICB0aGlzLiNiYWNrID0gMTtcbiAgICB0aGlzLiNzaXplID0gMDtcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLiNzaXplO1xuICB9XG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBjb25zdCBzaXplID0gdGhpcy4jc2l6ZTtcbiAgICBjb25zdCBmcm9udCA9IHRoaXMuI2Zyb250O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICB5aWVsZCB0aGlzLiNkYXRhW2Zyb250ICsgaV07XG4gICAgfVxuICB9XG4gIHB1c2godmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZXMyID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgaWYgKHRoaXMuI2JhY2sgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiAtIHZhbHVlczIubGVuZ3RoIC0gMSlcbiAgICAgIHJhaXNlKFwiRGVxdWUgZnVsbFwiKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlMiBvZiB2YWx1ZXMyKSB7XG4gICAgICB0aGlzLiNkYXRhW3RoaXMuI2JhY2srKyAtIDFdID0gdmFsdWUyO1xuICAgIH1cbiAgICB0aGlzLiNzaXplICs9IHZhbHVlczIubGVuZ3RoO1xuICB9XG4gIHBvcCgpIHtcbiAgICBpZiAodGhpcy4jc2l6ZSA8IDEpIHJldHVybiB2b2lkIDA7XG4gICAgdGhpcy4jYmFjay0tO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jZGF0YVt0aGlzLiNiYWNrIC0gMV07XG4gICAgZGVsZXRlIHRoaXMuI2RhdGFbdGhpcy4jYmFjayAtIDFdO1xuICAgIHRoaXMuI3NpemUtLTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcHVzaExlZnQodmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZXMyID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgaWYgKHRoaXMuI2Zyb250IDwgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgKyB2YWx1ZXMyLmxlbmd0aClcbiAgICAgIHJhaXNlKFwiRGVxdWUgZnVsbFwiKTtcbiAgICBmb3IgKGxldCBpID0gdmFsdWVzMi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy4jZGF0YVstLXRoaXMuI2Zyb250XSA9IHZhbHVlczJbaV07XG4gICAgfVxuICAgIHRoaXMuI3NpemUgKz0gdmFsdWVzMi5sZW5ndGg7XG4gIH1cbiAgcG9wTGVmdCgpIHtcbiAgICBpZiAodGhpcy4jc2l6ZSA8IDEpIHJldHVybiB2b2lkIDA7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiNkYXRhW3RoaXMuI2Zyb250XTtcbiAgICBkZWxldGUgdGhpcy4jZGF0YVt0aGlzLiNmcm9udF07XG4gICAgdGhpcy4jZnJvbnQrKztcbiAgICB0aGlzLiNzaXplLS07XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL0pzb24udHNcbmZ1bmN0aW9uIGlzSnNvblNjYWxhcihkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSBudWxsIHx8IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBkYXRhID09PSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIGlzSnNvbkFycmF5KGRhdGEpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGF0YSk7XG59XG5mdW5jdGlvbiBpc0pzb25PYmplY3QoZGF0YSkge1xuICByZXR1cm4gIWlzSnNvblNjYWxhcihkYXRhKSAmJiAhaXNKc29uQXJyYXkoZGF0YSk7XG59XG5cbi8vIHNyYy9wcm90b2NvbC9DbGllbnRNc2cudHNcbnZhciBDbGllbnRNc2dDb2RlID0gLyogQF9fUFVSRV9fICovICgoQ2xpZW50TXNnQ29kZTIpID0+IHtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJVUERBVEVfUFJFU0VOQ0VcIl0gPSAxMDBdID0gXCJVUERBVEVfUFJFU0VOQ0VcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJCUk9BRENBU1RfRVZFTlRcIl0gPSAxMDNdID0gXCJCUk9BRENBU1RfRVZFTlRcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJGRVRDSF9TVE9SQUdFXCJdID0gMjAwXSA9IFwiRkVUQ0hfU1RPUkFHRVwiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIlVQREFURV9TVE9SQUdFXCJdID0gMjAxXSA9IFwiVVBEQVRFX1NUT1JBR0VcIjtcbiAgQ2xpZW50TXNnQ29kZTJbQ2xpZW50TXNnQ29kZTJbXCJGRVRDSF9ZRE9DXCJdID0gMzAwXSA9IFwiRkVUQ0hfWURPQ1wiO1xuICBDbGllbnRNc2dDb2RlMltDbGllbnRNc2dDb2RlMltcIlVQREFURV9ZRE9DXCJdID0gMzAxXSA9IFwiVVBEQVRFX1lET0NcIjtcbiAgcmV0dXJuIENsaWVudE1zZ0NvZGUyO1xufSkoQ2xpZW50TXNnQ29kZSB8fCB7fSk7XG5cbi8vIHNyYy9yZWZzL01hbmFnZWRPdGhlcnMudHNcbmZ1bmN0aW9uIG1ha2VVc2VyKGNvbm4sIHByZXNlbmNlKSB7XG4gIGNvbnN0IHsgY29ubmVjdGlvbklkLCBpZCwgaW5mbyB9ID0gY29ubjtcbiAgY29uc3QgY2FuV3JpdGUgPSBjYW5Xcml0ZVN0b3JhZ2UoY29ubi5zY29wZXMpO1xuICByZXR1cm4gZnJlZXplKFxuICAgIGNvbXBhY3RPYmplY3Qoe1xuICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgaWQsXG4gICAgICBpbmZvLFxuICAgICAgY2FuV3JpdGUsXG4gICAgICBjYW5Db21tZW50OiBjYW5Db21tZW50KGNvbm4uc2NvcGVzKSxcbiAgICAgIGlzUmVhZE9ubHk6ICFjYW5Xcml0ZSxcbiAgICAgIC8vIERlcHJlY2F0ZWQsIGtlcHQgZm9yIGJhY2t3YXJkLWNvbXBhdGliaWxpdHlcbiAgICAgIHByZXNlbmNlXG4gICAgfSlcbiAgKTtcbn1cbnZhciBNYW5hZ2VkT3RoZXJzID0gY2xhc3Mge1xuICAvLyBUcmFjayBtdXRhYmxlIHN0YXRlIGludGVybmFsbHksIGJ1dCBzaWduYWwgdG8gdGhlIG91dHNpZGUgd2hlbiB0aGVcbiAgLy8gb2JzZXJ2YWJsZSBkZXJpdmVkIHN0YXRlIGNoYW5nZXMgb25seVxuICAjaW50ZXJuYWw7XG4gICN1c2VyQ2FjaGU7XG4gIC8vIFRoZSBcImNsZWFuXCIgc2lnbmFsIHRoYXQgaXMgZXhwb3NlZCB0byB0aGUgb3V0c2lkZSB3b3JsZFxuICBzaWduYWw7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuI2ludGVybmFsID0gbmV3IE11dGFibGVTaWduYWwoe1xuICAgICAgY29ubmVjdGlvbnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICBwcmVzZW5jZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgICB9KTtcbiAgICB0aGlzLnNpZ25hbCA9IERlcml2ZWRTaWduYWwuZnJvbShcbiAgICAgIHRoaXMuI2ludGVybmFsLFxuICAgICAgKF9pZ25vcmUpID0+IGNvbXBhY3QoXG4gICAgICAgIEFycmF5LmZyb20odGhpcy4jaW50ZXJuYWwuZ2V0KCkucHJlc2VuY2VzLmtleXMoKSkubWFwKFxuICAgICAgICAgIChjb25uZWN0aW9uSWQpID0+IHRoaXMuZ2V0VXNlcihOdW1iZXIoY29ubmVjdGlvbklkKSlcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gICAgdGhpcy4jdXNlckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICAvLyBTaG9ydGhhbmQgZm9yIC5zaWduYWwuZ2V0KClcbiAgZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLnNpZ25hbC5nZXQoKTtcbiAgfVxuICBjb25uZWN0aW9uSWRzKCkge1xuICAgIHJldHVybiB0aGlzLiNpbnRlcm5hbC5nZXQoKS5jb25uZWN0aW9ucy5rZXlzKCk7XG4gIH1cbiAgY2xlYXJPdGhlcnMoKSB7XG4gICAgdGhpcy4jaW50ZXJuYWwubXV0YXRlKChzdGF0ZSkgPT4ge1xuICAgICAgc3RhdGUuY29ubmVjdGlvbnMuY2xlYXIoKTtcbiAgICAgIHN0YXRlLnByZXNlbmNlcy5jbGVhcigpO1xuICAgICAgdGhpcy4jdXNlckNhY2hlLmNsZWFyKCk7XG4gICAgfSk7XG4gIH1cbiAgI19nZXRVc2VyKGNvbm5lY3Rpb25JZCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy4jaW50ZXJuYWwuZ2V0KCk7XG4gICAgY29uc3QgY29ubiA9IHN0YXRlLmNvbm5lY3Rpb25zLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGNvbnN0IHByZXNlbmNlID0gc3RhdGUucHJlc2VuY2VzLmdldChjb25uZWN0aW9uSWQpO1xuICAgIGlmIChjb25uICE9PSB2b2lkIDAgJiYgcHJlc2VuY2UgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG1ha2VVc2VyKGNvbm4sIHByZXNlbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBnZXRVc2VyKGNvbm5lY3Rpb25JZCkge1xuICAgIGNvbnN0IGNhY2hlZFVzZXIgPSB0aGlzLiN1c2VyQ2FjaGUuZ2V0KGNvbm5lY3Rpb25JZCk7XG4gICAgaWYgKGNhY2hlZFVzZXIpIHtcbiAgICAgIHJldHVybiBjYWNoZWRVc2VyO1xuICAgIH1cbiAgICBjb25zdCBjb21wdXRlZFVzZXIgPSB0aGlzLiNfZ2V0VXNlcihjb25uZWN0aW9uSWQpO1xuICAgIGlmIChjb21wdXRlZFVzZXIpIHtcbiAgICAgIHRoaXMuI3VzZXJDYWNoZS5zZXQoY29ubmVjdGlvbklkLCBjb21wdXRlZFVzZXIpO1xuICAgICAgcmV0dXJuIGNvbXB1dGVkVXNlcjtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAjaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKSB7XG4gICAgdGhpcy4jdXNlckNhY2hlLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICB9XG4gIC8qKlxuICAgKiBSZWNvcmRzIGEga25vd24gY29ubmVjdGlvbi4gVGhpcyByZWNvcmRzIHRoZSBjb25uZWN0aW9uIElEIGFuZCB0aGVcbiAgICogYXNzb2NpYXRlZCBtZXRhZGF0YS5cbiAgICovXG4gIHNldENvbm5lY3Rpb24oY29ubmVjdGlvbklkLCBtZXRhVXNlcklkLCBtZXRhVXNlckluZm8sIHNjb3Blcykge1xuICAgIHRoaXMuI2ludGVybmFsLm11dGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgIHN0YXRlLmNvbm5lY3Rpb25zLnNldChcbiAgICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgICBmcmVlemUoe1xuICAgICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgICBpZDogbWV0YVVzZXJJZCxcbiAgICAgICAgICBpbmZvOiBtZXRhVXNlckluZm8sXG4gICAgICAgICAgc2NvcGVzXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgaWYgKCFzdGF0ZS5wcmVzZW5jZXMuaGFzKGNvbm5lY3Rpb25JZCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuI2ludmFsaWRhdGVVc2VyKGNvbm5lY3Rpb25JZCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBrbm93biBjb25uZWN0aW9uSWQuIFJlbW92ZXMgYm90aCB0aGUgY29ubmVjdGlvbidzIG1ldGFkYXRhIGFuZFxuICAgKiB0aGUgcHJlc2VuY2UgaW5mb3JtYXRpb24uXG4gICAqL1xuICByZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCkge1xuICAgIHRoaXMuI2ludGVybmFsLm11dGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgIHN0YXRlLmNvbm5lY3Rpb25zLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgICAgc3RhdGUucHJlc2VuY2VzLmRlbGV0ZShjb25uZWN0aW9uSWQpO1xuICAgICAgdGhpcy4jaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3RvcmVzIGEgbmV3IHVzZXIgZnJvbSBhIGZ1bGwgcHJlc2VuY2UgdXBkYXRlLiBJZiB0aGUgdXNlciBhbHJlYWR5IGV4aXN0cyxcbiAgICogaXRzIGtub3duIHByZXNlbmNlIGRhdGEgaXMgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBzZXRPdGhlcihjb25uZWN0aW9uSWQsIHByZXNlbmNlKSB7XG4gICAgdGhpcy4jaW50ZXJuYWwubXV0YXRlKChzdGF0ZSkgPT4ge1xuICAgICAgc3RhdGUucHJlc2VuY2VzLnNldChjb25uZWN0aW9uSWQsIGZyZWV6ZShjb21wYWN0T2JqZWN0KHByZXNlbmNlKSkpO1xuICAgICAgaWYgKCFzdGF0ZS5jb25uZWN0aW9ucy5oYXMoY29ubmVjdGlvbklkKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4jaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUGF0Y2hlcyB0aGUgcHJlc2VuY2UgZGF0YSBmb3IgYW4gZXhpc3RpbmcgXCJvdGhlclwiLiBJZiB3ZSBkb24ndCBrbm93IHRoZVxuICAgKiBpbml0aWFsIHByZXNlbmNlIGRhdGEgZm9yIHRoaXMgdXNlciB5ZXQsIGRpc2NhcmQgdGhpcyBwYXRjaCBhbmQgYXdhaXQgdGhlXG4gICAqIGZ1bGwgLnNldE90aGVyKCkgY2FsbCBmaXJzdC5cbiAgICovXG4gIHBhdGNoT3RoZXIoY29ubmVjdGlvbklkLCBwYXRjaCkge1xuICAgIHRoaXMuI2ludGVybmFsLm11dGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IG9sZFByZXNlbmNlID0gc3RhdGUucHJlc2VuY2VzLmdldChjb25uZWN0aW9uSWQpO1xuICAgICAgaWYgKG9sZFByZXNlbmNlID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3UHJlc2VuY2UgPSBtZXJnZShvbGRQcmVzZW5jZSwgcGF0Y2gpO1xuICAgICAgaWYgKG9sZFByZXNlbmNlID09PSBuZXdQcmVzZW5jZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wcmVzZW5jZXMuc2V0KGNvbm5lY3Rpb25JZCwgZnJlZXplKG5ld1ByZXNlbmNlKSk7XG4gICAgICByZXR1cm4gdGhpcy4jaW52YWxpZGF0ZVVzZXIoY29ubmVjdGlvbklkKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3R5cGVzL0xpdmVibG9ja3NFcnJvci50c1xudmFyIExpdmVibG9ja3NFcnJvciA9IGNsYXNzIF9MaXZlYmxvY2tzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnRleHQ7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvbnRleHQsIGNhdXNlKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgeyBjYXVzZSB9KTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubmFtZSA9IFwiTGl2ZWJsb2Nrc0Vycm9yXCI7XG4gIH1cbiAgLyoqIENvbnZlbmllbmNlIGFjY2Vzc29yIGZvciBlcnJvci5jb250ZXh0LnJvb21JZCAoaWYgYXZhaWxhYmxlKSAqL1xuICBnZXQgcm9vbUlkKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQucm9vbUlkO1xuICB9XG4gIC8qKiBAZGVwcmVjYXRlZCBQcmVmZXIgdXNpbmcgYGNvbnRleHQuY29kZWAgaW5zdGVhZCwgdG8gZW5hYmxlIHR5cGUgbmFycm93aW5nICovXG4gIGdldCBjb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuY29kZTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIExpdmVibG9ja3NFcnJvciBmcm9tIGEgZ2VuZXJpYyBlcnJvciwgYnkgYXR0YWNoaW5nIExpdmVibG9ja3NcbiAgICogY29udGV4dHVhbCBpbmZvcm1hdGlvbiBsaWtlIHJvb20gSUQsIHRocmVhZCBJRCwgZXRjLlxuICAgKi9cbiAgc3RhdGljIGZyb20oY29udGV4dCwgY2F1c2UpIHtcbiAgICByZXR1cm4gbmV3IF9MaXZlYmxvY2tzRXJyb3IoXG4gICAgICBkZWZhdWx0TWVzc2FnZUZyb21Db250ZXh0KGNvbnRleHQpLFxuICAgICAgY29udGV4dCxcbiAgICAgIGNhdXNlXG4gICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGRlZmF1bHRNZXNzYWdlRnJvbUNvbnRleHQoY29udGV4dCkge1xuICBzd2l0Y2ggKGNvbnRleHQudHlwZSkge1xuICAgIGNhc2UgXCJST09NX0NPTk5FQ1RJT05fRVJST1JcIjoge1xuICAgICAgc3dpdGNoIChjb250ZXh0LmNvZGUpIHtcbiAgICAgICAgY2FzZSA0MDAxOlxuICAgICAgICAgIHJldHVybiBcIk5vdCBhbGxvd2VkIHRvIGNvbm5lY3QgdG8gdGhlIHJvb21cIjtcbiAgICAgICAgY2FzZSA0MDA1OlxuICAgICAgICAgIHJldHVybiBcIlJvb20gaXMgYWxyZWFkeSBmdWxsXCI7XG4gICAgICAgIGNhc2UgNDAwNjpcbiAgICAgICAgICByZXR1cm4gXCJLaWNrZWQgb3V0IG9mIHRoZSByb29tLCBiZWNhdXNlIHRoZSByb29tIElEIGNoYW5nZWRcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gXCJDb3VsZCBub3QgY29ubmVjdCB0byB0aGUgcm9vbVwiO1xuICAgICAgfVxuICAgIH1cbiAgICBjYXNlIFwiQ1JFQVRFX1RIUkVBRF9FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IGNyZWF0ZSBuZXcgdGhyZWFkXCI7XG4gICAgY2FzZSBcIkRFTEVURV9USFJFQURfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBkZWxldGUgdGhyZWFkXCI7XG4gICAgY2FzZSBcIkVESVRfVEhSRUFEX01FVEFEQVRBX0VSUk9SXCI6XG4gICAgICByZXR1cm4gXCJDb3VsZCBub3QgZWRpdCB0aHJlYWQgbWV0YWRhdGFcIjtcbiAgICBjYXNlIFwiTUFSS19USFJFQURfQVNfUkVTT0xWRURfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBtYXJrIHRocmVhZCBhcyByZXNvbHZlZFwiO1xuICAgIGNhc2UgXCJNQVJLX1RIUkVBRF9BU19VTlJFU09MVkVEX0VSUk9SXCI6XG4gICAgICByZXR1cm4gXCJDb3VsZCBub3QgbWFyayB0aHJlYWQgYXMgdW5yZXNvbHZlZFwiO1xuICAgIGNhc2UgXCJDUkVBVEVfQ09NTUVOVF9FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IGNyZWF0ZSBuZXcgY29tbWVudFwiO1xuICAgIGNhc2UgXCJFRElUX0NPTU1FTlRfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBlZGl0IGNvbW1lbnRcIjtcbiAgICBjYXNlIFwiREVMRVRFX0NPTU1FTlRfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBkZWxldGUgY29tbWVudFwiO1xuICAgIGNhc2UgXCJBRERfUkVBQ1RJT05fRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBhZGQgcmVhY3Rpb25cIjtcbiAgICBjYXNlIFwiUkVNT1ZFX1JFQUNUSU9OX0VSUk9SXCI6XG4gICAgICByZXR1cm4gXCJDb3VsZCBub3QgcmVtb3ZlIHJlYWN0aW9uXCI7XG4gICAgY2FzZSBcIk1BUktfSU5CT1hfTk9USUZJQ0FUSU9OX0FTX1JFQURfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBtYXJrIGluYm94IG5vdGlmaWNhdGlvbiBhcyByZWFkXCI7XG4gICAgY2FzZSBcIkRFTEVURV9JTkJPWF9OT1RJRklDQVRJT05fRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBkZWxldGUgaW5ib3ggbm90aWZpY2F0aW9uXCI7XG4gICAgY2FzZSBcIk1BUktfQUxMX0lOQk9YX05PVElGSUNBVElPTlNfQVNfUkVBRF9FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IG1hcmsgYWxsIGluYm94IG5vdGlmaWNhdGlvbnMgYXMgcmVhZFwiO1xuICAgIGNhc2UgXCJERUxFVEVfQUxMX0lOQk9YX05PVElGSUNBVElPTlNfRVJST1JcIjpcbiAgICAgIHJldHVybiBcIkNvdWxkIG5vdCBkZWxldGUgYWxsIGluYm94IG5vdGlmaWNhdGlvbnNcIjtcbiAgICBjYXNlIFwiVVBEQVRFX05PVElGSUNBVElPTl9TRVRUSU5HU19FUlJPUlwiOlxuICAgICAgcmV0dXJuIFwiQ291bGQgbm90IHVwZGF0ZSBub3RpZmljYXRpb24gc2V0dGluZ3NcIjtcbiAgICBjYXNlIFwiVVBEQVRFX1VTRVJfTk9USUZJQ0FUSU9OX1NFVFRJTkdTX0VSUk9SXCI6XG4gICAgICByZXR1cm4gXCJDb3VsZCBub3QgdXBkYXRlIHVzZXIgbm90aWZpY2F0aW9uIHNldHRpbmdzXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBhc3NlcnROZXZlcihjb250ZXh0LCBcIlVuaGFuZGxlZCBjYXNlXCIpO1xuICB9XG59XG5cbi8vIHNyYy9yb29tLnRzXG52YXIgTUFYX1NPQ0tFVF9NRVNTQUdFX1NJWkUgPSAxMDI0ICogMTAyNCAtIDUxMjtcbmZ1bmN0aW9uIG1ha2VJZEZhY3RvcnkoY29ubmVjdGlvbklkKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIHJldHVybiAoKSA9PiBgJHtjb25uZWN0aW9uSWR9OiR7Y291bnQrK31gO1xufVxuZnVuY3Rpb24gdXNlclRvVHJlZU5vZGUoa2V5LCB1c2VyKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJVc2VyXCIsXG4gICAgaWQ6IGAke3VzZXIuY29ubmVjdGlvbklkfWAsXG4gICAga2V5LFxuICAgIHBheWxvYWQ6IHtcbiAgICAgIGNvbm5lY3Rpb25JZDogdXNlci5jb25uZWN0aW9uSWQsXG4gICAgICBpZDogdXNlci5pZCxcbiAgICAgIGluZm86IHVzZXIuaW5mbyxcbiAgICAgIHByZXNlbmNlOiB1c2VyLnByZXNlbmNlLFxuICAgICAgaXNSZWFkT25seTogIXVzZXIuY2FuV3JpdGVcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpbnN0YWxsQmFja2dyb3VuZFRhYlNweSgpIHtcbiAgY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB2b2lkIDA7XG4gIGNvbnN0IGluQmFja2dyb3VuZFNpbmNlID0geyBjdXJyZW50OiBudWxsIH07XG4gIGZ1bmN0aW9uIG9uVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICBpZiAoZG9jPy52aXNpYmlsaXR5U3RhdGUgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgIGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgPSBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ID8/IERhdGUubm93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluQmFja2dyb3VuZFNpbmNlLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBkb2M/LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gIGNvbnN0IHVuc3ViID0gKCkgPT4ge1xuICAgIGRvYz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgfTtcbiAgcmV0dXJuIFtpbkJhY2tncm91bmRTaW5jZSwgdW5zdWJdO1xufVxuZnVuY3Rpb24gY3JlYXRlUm9vbShvcHRpb25zLCBjb25maWcpIHtcbiAgY29uc3Qgcm9vbUlkID0gY29uZmlnLnJvb21JZDtcbiAgY29uc3QgaW5pdGlhbFByZXNlbmNlID0gb3B0aW9ucy5pbml0aWFsUHJlc2VuY2U7XG4gIGNvbnN0IGluaXRpYWxTdG9yYWdlID0gb3B0aW9ucy5pbml0aWFsU3RvcmFnZTtcbiAgY29uc3QgaHR0cENsaWVudCA9IGNvbmZpZy5yb29tSHR0cENsaWVudDtcbiAgY29uc3QgW2luQmFja2dyb3VuZFNpbmNlLCB1bmluc3RhbGxCZ1RhYlNweV0gPSBpbnN0YWxsQmFja2dyb3VuZFRhYlNweSgpO1xuICBjb25zdCBkZWxlZ2F0ZXMgPSB7XG4gICAgLi4uY29uZmlnLmRlbGVnYXRlcyxcbiAgICAvLyBBIGNvbm5lY3Rpb24gaXMgYWxsb3dlZCB0byBnbyBpbnRvIFwiem9tYmllIHN0YXRlXCIgb25seSBpZiBhbGwgb2YgdGhlXG4gICAgLy8gZm9sbG93aW5nIGNvbmRpdGlvbnMgYXBwbHk6XG4gICAgLy9cbiAgICAvLyAtIFRoZSBgYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXRgIGNsaWVudCBvcHRpb24gaXMgY29uZmlndXJlZFxuICAgIC8vIC0gVGhlIGJyb3dzZXIgd2luZG93IGhhcyBiZWVuIGluIHRoZSBiYWNrZ3JvdW5kIGZvciBhdCBsZWFzdFxuICAgIC8vICAgYGJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0YCBtaWxsaXNlY29uZHNcbiAgICAvLyAtIFRoZXJlIGFyZSBubyBwZW5kaW5nIGNoYW5nZXNcbiAgICAvL1xuICAgIGNhblpvbWJpZSgpIHtcbiAgICAgIHJldHVybiBjb25maWcuYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXQgIT09IHZvaWQgMCAmJiBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ICE9PSBudWxsICYmIERhdGUubm93KCkgPiBpbkJhY2tncm91bmRTaW5jZS5jdXJyZW50ICsgY29uZmlnLmJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0ICYmIGdldFN0b3JhZ2VTdGF0dXMoKSAhPT0gXCJzeW5jaHJvbml6aW5nXCI7XG4gICAgfVxuICB9O1xuICBjb25zdCBtYW5hZ2VkU29ja2V0ID0gbmV3IE1hbmFnZWRTb2NrZXQoXG4gICAgZGVsZWdhdGVzLFxuICAgIGNvbmZpZy5lbmFibGVEZWJ1Z0xvZ2dpbmdcbiAgKTtcbiAgY29uc3QgY29udGV4dCA9IHtcbiAgICBidWZmZXI6IHtcbiAgICAgIGZsdXNoVGltZXJJRDogdm9pZCAwLFxuICAgICAgbGFzdEZsdXNoZWRBdDogMCxcbiAgICAgIHByZXNlbmNlVXBkYXRlczogKFxuICAgICAgICAvLyBRdWV1ZSB1cCB0aGUgaW5pdGlhbCBwcmVzZW5jZSBtZXNzYWdlIGFzIGEgRnVsbCBQcmVzZW5jZeKEoiB1cGRhdGVcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiZnVsbFwiLFxuICAgICAgICAgIGRhdGE6IGluaXRpYWxQcmVzZW5jZVxuICAgICAgICB9XG4gICAgICApLFxuICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgc3RvcmFnZU9wZXJhdGlvbnM6IFtdXG4gICAgfSxcbiAgICBzdGF0aWNTZXNzaW9uSW5mb1NpZzogbmV3IFNpZ25hbChudWxsKSxcbiAgICBkeW5hbWljU2Vzc2lvbkluZm9TaWc6IG5ldyBTaWduYWwobnVsbCksXG4gICAgbXlQcmVzZW5jZTogbmV3IFBhdGNoYWJsZVNpZ25hbChpbml0aWFsUHJlc2VuY2UpLFxuICAgIG90aGVyczogbmV3IE1hbmFnZWRPdGhlcnMoKSxcbiAgICBpbml0aWFsU3RvcmFnZSxcbiAgICBpZEZhY3Rvcnk6IG51bGwsXG4gICAgLy8gVGhlIFlqcyBwcm92aWRlciBhc3NvY2lhdGVkIHRvIHRoaXMgcm9vbVxuICAgIHlqc1Byb3ZpZGVyOiB2b2lkIDAsXG4gICAgeWpzUHJvdmlkZXJEaWRDaGFuZ2U6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIC8vIFN0b3JhZ2VcbiAgICBwb29sOiBjcmVhdGVNYW5hZ2VkUG9vbChyb29tSWQsIHtcbiAgICAgIGdldEN1cnJlbnRDb25uZWN0aW9uSWQsXG4gICAgICBvbkRpc3BhdGNoLFxuICAgICAgaXNTdG9yYWdlV3JpdGFibGVcbiAgICB9KSxcbiAgICByb290OiB2b2lkIDAsXG4gICAgdW5kb1N0YWNrOiBbXSxcbiAgICByZWRvU3RhY2s6IFtdLFxuICAgIHBhdXNlZEhpc3Rvcnk6IG51bGwsXG4gICAgYWN0aXZlQmF0Y2g6IG51bGwsXG4gICAgdW5hY2tub3dsZWRnZWRPcHM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgLy8gRGVidWdcbiAgICBvcFN0YWNrVHJhY2VzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpIDogdm9pZCAwXG4gIH07XG4gIGxldCBsYXN0VG9rZW5LZXk7XG4gIGZ1bmN0aW9uIG9uU3RhdHVzRGlkQ2hhbmdlKG5ld1N0YXR1cykge1xuICAgIGNvbnN0IGF1dGhWYWx1ZSA9IG1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlO1xuICAgIGlmIChhdXRoVmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHRva2VuS2V5ID0gZ2V0QmVhcmVyVG9rZW5Gcm9tQXV0aFZhbHVlKGF1dGhWYWx1ZSk7XG4gICAgICBpZiAodG9rZW5LZXkgIT09IGxhc3RUb2tlbktleSkge1xuICAgICAgICBsYXN0VG9rZW5LZXkgPSB0b2tlbktleTtcbiAgICAgICAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInNlY3JldFwiKSB7XG4gICAgICAgICAgY29uc3QgdG9rZW4gPSBhdXRoVmFsdWUudG9rZW4ucGFyc2VkO1xuICAgICAgICAgIGNvbnRleHQuc3RhdGljU2Vzc2lvbkluZm9TaWcuc2V0KHtcbiAgICAgICAgICAgIHVzZXJJZDogdG9rZW4uayA9PT0gXCJzZWMtbGVnYWN5XCIgLyogU0VDUkVUX0xFR0FDWSAqLyA/IHRva2VuLmlkIDogdG9rZW4udWlkLFxuICAgICAgICAgICAgdXNlckluZm86IHRva2VuLmsgPT09IFwic2VjLWxlZ2FjeVwiIC8qIFNFQ1JFVF9MRUdBQ1kgKi8gPyB0b2tlbi5pbmZvIDogdG9rZW4udWlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LnN0YXRpY1Nlc3Npb25JbmZvU2lnLnNldCh7XG4gICAgICAgICAgICB1c2VySWQ6IHZvaWQgMCxcbiAgICAgICAgICAgIHVzZXJJbmZvOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBldmVudEh1Yi5zdGF0dXMubm90aWZ5KG5ld1N0YXR1cyk7XG4gICAgbm90aWZ5U2VsZkNoYW5nZWQoKTtcbiAgfVxuICBsZXQgX2Nvbm5lY3Rpb25Mb3NzVGltZXJJZDtcbiAgbGV0IF9oYXNMb3N0Q29ubmVjdGlvbiA9IGZhbHNlO1xuICBmdW5jdGlvbiBoYW5kbGVDb25uZWN0aW9uTG9zc0V2ZW50KG5ld1N0YXR1cykge1xuICAgIGlmIChuZXdTdGF0dXMgPT09IFwicmVjb25uZWN0aW5nXCIpIHtcbiAgICAgIF9jb25uZWN0aW9uTG9zc1RpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwibG9zdFwiKTtcbiAgICAgICAgX2hhc0xvc3RDb25uZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgY29udGV4dC5vdGhlcnMuY2xlYXJPdGhlcnMoKTtcbiAgICAgICAgbm90aWZ5KHsgb3RoZXJzOiBbeyB0eXBlOiBcInJlc2V0XCIgfV0gfSk7XG4gICAgICB9LCBjb25maWcubG9zdENvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJUaW1lb3V0KF9jb25uZWN0aW9uTG9zc1RpbWVySWQpO1xuICAgICAgaWYgKF9oYXNMb3N0Q29ubmVjdGlvbikge1xuICAgICAgICBpZiAobmV3U3RhdHVzID09PSBcImRpc2Nvbm5lY3RlZFwiKSB7XG4gICAgICAgICAgZXZlbnRIdWIubG9zdENvbm5lY3Rpb24ubm90aWZ5KFwiZmFpbGVkXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV2ZW50SHViLmxvc3RDb25uZWN0aW9uLm5vdGlmeShcInJlc3RvcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9oYXNMb3N0Q29ubmVjdGlvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvbkRpZENvbm5lY3QoKSB7XG4gICAgY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID0ge1xuICAgICAgdHlwZTogXCJmdWxsXCIsXG4gICAgICBkYXRhOiAoXG4gICAgICAgIC8vIEJlY2F1c2UgY29udGV4dC5tZS5jdXJyZW50IGlzIGEgcmVhZG9ubHkgb2JqZWN0LCB3ZSdsbCBoYXZlIHRvXG4gICAgICAgIC8vIG1ha2UgYSBjb3B5IGhlcmUuIE90aGVyd2lzZSwgdHlwZSBlcnJvcnMgaGFwcGVuIGxhdGVyIHdoZW5cbiAgICAgICAgLy8gXCJwYXRjaGluZ1wiIG15IHByZXNlbmNlLlxuICAgICAgICB7IC4uLmNvbnRleHQubXlQcmVzZW5jZS5nZXQoKSB9XG4gICAgICApXG4gICAgfTtcbiAgICBpZiAoX2dldFN0b3JhZ2UkICE9PSBudWxsKSB7XG4gICAgICByZWZyZXNoU3RvcmFnZSh7IGZsdXNoOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBvbkRpZERpc2Nvbm5lY3QoKSB7XG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuYnVmZmVyLmZsdXNoVGltZXJJRCk7XG4gIH1cbiAgbWFuYWdlZFNvY2tldC5ldmVudHMub25NZXNzYWdlLnN1YnNjcmliZShoYW5kbGVTZXJ2ZXJNZXNzYWdlKTtcbiAgbWFuYWdlZFNvY2tldC5ldmVudHMuc3RhdHVzRGlkQ2hhbmdlLnN1YnNjcmliZShvblN0YXR1c0RpZENoYW5nZSk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLnN0YXR1c0RpZENoYW5nZS5zdWJzY3JpYmUoaGFuZGxlQ29ubmVjdGlvbkxvc3NFdmVudCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLmRpZENvbm5lY3Quc3Vic2NyaWJlKG9uRGlkQ29ubmVjdCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLmRpZERpc2Nvbm5lY3Quc3Vic2NyaWJlKG9uRGlkRGlzY29ubmVjdCk7XG4gIG1hbmFnZWRTb2NrZXQuZXZlbnRzLm9uQ29ubmVjdGlvbkVycm9yLnN1YnNjcmliZSgoeyBtZXNzYWdlLCBjb2RlIH0pID0+IHtcbiAgICBjb25zdCB0eXBlID0gXCJST09NX0NPTk5FQ1RJT05fRVJST1JcIjtcbiAgICBjb25zdCBlcnIgPSBuZXcgTGl2ZWJsb2Nrc0Vycm9yKG1lc3NhZ2UsIHsgdHlwZSwgY29kZSwgcm9vbUlkIH0pO1xuICAgIGNvbnN0IGRpZE5vdGlmeSA9IGNvbmZpZy5lcnJvckV2ZW50U291cmNlLm5vdGlmeShlcnIpO1xuICAgIGlmICghZGlkTm90aWZ5KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGVycm9yMihcbiAgICAgICAgICBgQ29ubmVjdGlvbiB0byB3ZWJzb2NrZXQgc2VydmVyIGNsb3NlZC4gUmVhc29uOiAke21lc3NhZ2V9IChjb2RlOiAke2NvZGV9KS5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gb25EaXNwYXRjaChvcHMsIHJldmVyc2UsIHN0b3JhZ2VVcGRhdGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc3Qgc3RhY2tUcmFjZSA9IGNhcHR1cmVTdGFja1RyYWNlKFwiU3RvcmFnZSBtdXRhdGlvblwiLCBvbkRpc3BhdGNoKTtcbiAgICAgIGlmIChzdGFja1RyYWNlKSB7XG4gICAgICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgICAgICAgaWYgKG9wLm9wSWQpIHtcbiAgICAgICAgICAgIG5uKGNvbnRleHQub3BTdGFja1RyYWNlcykuc2V0KG9wLm9wSWQsIHN0YWNrVHJhY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgZm9yIChjb25zdCBvcCBvZiBvcHMpIHtcbiAgICAgICAgY29udGV4dC5hY3RpdmVCYXRjaC5vcHMucHVzaChvcCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzdG9yYWdlVXBkYXRlcykge1xuICAgICAgICBjb250ZXh0LmFjdGl2ZUJhdGNoLnVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBtZXJnZVN0b3JhZ2VVcGRhdGVzKFxuICAgICAgICAgICAgY29udGV4dC5hY3RpdmVCYXRjaC51cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLmdldChrZXkpLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmFjdGl2ZUJhdGNoLnJldmVyc2VPcHMucHVzaExlZnQocmV2ZXJzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZFRvVW5kb1N0YWNrKHJldmVyc2UpO1xuICAgICAgY29udGV4dC5yZWRvU3RhY2subGVuZ3RoID0gMDtcbiAgICAgIGRpc3BhdGNoT3BzKG9wcyk7XG4gICAgICBub3RpZnkoeyBzdG9yYWdlVXBkYXRlcyB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNTdG9yYWdlV3JpdGFibGUoKSB7XG4gICAgY29uc3Qgc2NvcGVzID0gY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm9TaWcuZ2V0KCk/LnNjb3BlcztcbiAgICByZXR1cm4gc2NvcGVzICE9PSB2b2lkIDAgPyBjYW5Xcml0ZVN0b3JhZ2Uoc2NvcGVzKSA6IHRydWU7XG4gIH1cbiAgY29uc3QgZXZlbnRIdWIgPSB7XG4gICAgc3RhdHVzOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICAvLyBOZXcvcmVjb21tZW5kZWQgQVBJXG4gICAgbG9zdENvbm5lY3Rpb246IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIGN1c3RvbUV2ZW50OiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBzZWxmOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBteVByZXNlbmNlOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICBvdGhlcnM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHN0b3JhZ2VCYXRjaDogbWFrZUV2ZW50U291cmNlKCksXG4gICAgaGlzdG9yeTogbWFrZUV2ZW50U291cmNlKCksXG4gICAgc3RvcmFnZURpZExvYWQ6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHN0b3JhZ2VTdGF0dXM6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIHlkb2M6IG1ha2VFdmVudFNvdXJjZSgpLFxuICAgIGNvbW1lbnRzOiBtYWtlRXZlbnRTb3VyY2UoKSxcbiAgICByb29tV2lsbERlc3Ryb3k6IG1ha2VFdmVudFNvdXJjZSgpXG4gIH07XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRleHRNZW50aW9uKHVzZXJJZCwgbWVudGlvbklkKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuY3JlYXRlVGV4dE1lbnRpb24oeyByb29tSWQsIHVzZXJJZCwgbWVudGlvbklkIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVRleHRNZW50aW9uKG1lbnRpb25JZCkge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmRlbGV0ZVRleHRNZW50aW9uKHsgcm9vbUlkLCBtZW50aW9uSWQgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmVwb3J0VGV4dEVkaXRvcih0eXBlLCByb290S2V5KSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5yZXBvcnRUZXh0RWRpdG9yKHsgcm9vbUlkLCB0eXBlLCByb290S2V5IH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGxpc3RUZXh0VmVyc2lvbnMoKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQubGlzdFRleHRWZXJzaW9ucyh7IHJvb21JZCB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBsaXN0VGV4dFZlcnNpb25zU2luY2Uob3B0aW9uczIpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5saXN0VGV4dFZlcnNpb25zU2luY2Uoe1xuICAgICAgcm9vbUlkLFxuICAgICAgc2luY2U6IG9wdGlvbnMyLnNpbmNlLFxuICAgICAgc2lnbmFsOiBvcHRpb25zMi5zaWduYWxcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUZXh0VmVyc2lvbih2ZXJzaW9uSWQpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5nZXRUZXh0VmVyc2lvbih7IHJvb21JZCwgdmVyc2lvbklkIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRleHRWZXJzaW9uKCkge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmNyZWF0ZVRleHRWZXJzaW9uKHsgcm9vbUlkIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVDb250ZXh0dWFsUHJvbXB0KG9wdGlvbnMyKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZXhlY3V0ZUNvbnRleHR1YWxQcm9tcHQoe1xuICAgICAgcm9vbUlkLFxuICAgICAgLi4ub3B0aW9uczJcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiogY2h1bmtPcHMobXNnKSB7XG4gICAgY29uc3QgeyBvcHMsIC4uLnJlc3QgfSA9IG1zZztcbiAgICBpZiAob3BzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzcGxpdCBvcHMgaW50byBzbWFsbGVyIGNodW5rc1wiKTtcbiAgICB9XG4gICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcihvcHMubGVuZ3RoIC8gMik7XG4gICAgY29uc3QgZmlyc3RIYWxmID0gb3BzLnNsaWNlKDAsIG1pZCk7XG4gICAgY29uc3Qgc2Vjb25kSGFsZiA9IG9wcy5zbGljZShtaWQpO1xuICAgIGZvciAoY29uc3QgaGFsZk9wcyBvZiBbZmlyc3RIYWxmLCBzZWNvbmRIYWxmXSkge1xuICAgICAgY29uc3QgaGFsZiA9IHsgb3BzOiBoYWxmT3BzLCAuLi5yZXN0IH07XG4gICAgICBjb25zdCB0ZXh0ID0gc3RyaW5naWZ5T3JMb2coW2hhbGZdKTtcbiAgICAgIGlmICghaXNUb29CaWdGb3JXZWJTb2NrZXQodGV4dCkpIHtcbiAgICAgICAgeWllbGQgdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkKiBjaHVua09wcyhoYWxmKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24qIGNodW5rTWVzc2FnZXMobWVzc2FnZXMpIHtcbiAgICBpZiAobWVzc2FnZXMubGVuZ3RoIDwgMikge1xuICAgICAgaWYgKG1lc3NhZ2VzWzBdLnR5cGUgPT09IDIwMSAvKiBVUERBVEVfU1RPUkFHRSAqLykge1xuICAgICAgICB5aWVsZCogY2h1bmtPcHMobWVzc2FnZXNbMF0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJDYW5ub3Qgc3BsaXQgaW50byBjaHVua3Mgc21hbGxlciB0aGFuIHRoZSBhbGxvd2VkIG1lc3NhZ2Ugc2l6ZVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IobWVzc2FnZXMubGVuZ3RoIC8gMik7XG4gICAgY29uc3QgZmlyc3RIYWxmID0gbWVzc2FnZXMuc2xpY2UoMCwgbWlkKTtcbiAgICBjb25zdCBzZWNvbmRIYWxmID0gbWVzc2FnZXMuc2xpY2UobWlkKTtcbiAgICBmb3IgKGNvbnN0IGhhbGYgb2YgW2ZpcnN0SGFsZiwgc2Vjb25kSGFsZl0pIHtcbiAgICAgIGNvbnN0IHRleHQgPSBzdHJpbmdpZnlPckxvZyhoYWxmKTtcbiAgICAgIGlmICghaXNUb29CaWdGb3JXZWJTb2NrZXQodGV4dCkpIHtcbiAgICAgICAgeWllbGQgdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkKiBjaHVua01lc3NhZ2VzKGhhbGYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc1Rvb0JpZ0ZvcldlYlNvY2tldCh0ZXh0KSB7XG4gICAgaWYgKHRleHQubGVuZ3RoICogNCA8IE1BWF9TT0NLRVRfTUVTU0FHRV9TSVpFKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGV4dCkubGVuZ3RoID49IE1BWF9TT0NLRVRfTUVTU0FHRV9TSVpFO1xuICB9XG4gIGZ1bmN0aW9uIHNlbmRNZXNzYWdlcyhtZXNzYWdlcykge1xuICAgIGNvbnN0IHN0cmF0ZWd5ID0gY29uZmlnLmxhcmdlTWVzc2FnZVN0cmF0ZWd5ID8/IFwiZGVmYXVsdFwiO1xuICAgIGNvbnN0IHRleHQgPSBzdHJpbmdpZnlPckxvZyhtZXNzYWdlcyk7XG4gICAgaWYgKCFpc1Rvb0JpZ0ZvcldlYlNvY2tldCh0ZXh0KSkge1xuICAgICAgcmV0dXJuIG1hbmFnZWRTb2NrZXQuc2VuZCh0ZXh0KTtcbiAgICB9XG4gICAgc3dpdGNoIChzdHJhdGVneSkge1xuICAgICAgY2FzZSBcImRlZmF1bHRcIjoge1xuICAgICAgICBlcnJvcjIoXCJNZXNzYWdlIGlzIHRvbyBsYXJnZSBmb3Igd2Vic29ja2V0cywgbm90IHNlbmRpbmcuIENvbmZpZ3VyZSBsYXJnZU1lc3NhZ2VTdHJhdGVneSBvcHRpb24gdG8gZGVhbCB3aXRoIHRoaXMuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYXNlIFwic3BsaXRcIjoge1xuICAgICAgICB3YXJuKFwiTWVzc2FnZSBpcyB0b28gbGFyZ2UgZm9yIHdlYnNvY2tldHMsIHNwbGl0dGluZyBpbnRvIHNtYWxsZXIgY2h1bmtzXCIpO1xuICAgICAgICBmb3IgKGNvbnN0IGNodW5rMiBvZiBjaHVua01lc3NhZ2VzKG1lc3NhZ2VzKSkge1xuICAgICAgICAgIG1hbmFnZWRTb2NrZXQuc2VuZChjaHVuazIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJleHBlcmltZW50YWwtZmFsbGJhY2stdG8taHR0cFwiOiB7XG4gICAgICAgIHdhcm4oXCJNZXNzYWdlIGlzIHRvbyBsYXJnZSBmb3Igd2Vic29ja2V0cywgc28gc2VuZGluZyBvdmVyIEhUVFAgaW5zdGVhZFwiKTtcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mb1NpZy5nZXQoKT8ubm9uY2UgPz8gcmFpc2UoXCJTZXNzaW9uIGlzIG5vdCBhdXRob3JpemVkIHRvIHNlbmQgbWVzc2FnZSBvdmVyIEhUVFBcIik7XG4gICAgICAgIHZvaWQgaHR0cENsaWVudC5zZW5kTWVzc2FnZXMoeyByb29tSWQsIG5vbmNlLCBtZXNzYWdlcyB9KS50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXNwLm9rICYmIHJlc3Auc3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgICAgIG1hbmFnZWRTb2NrZXQucmVjb25uZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBzZWxmID0gRGVyaXZlZFNpZ25hbC5mcm9tKFxuICAgIGNvbnRleHQuc3RhdGljU2Vzc2lvbkluZm9TaWcsXG4gICAgY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm9TaWcsXG4gICAgY29udGV4dC5teVByZXNlbmNlLFxuICAgIChzdGF0aWNTZXNzaW9uLCBkeW5hbWljU2Vzc2lvbiwgbXlQcmVzZW5jZSkgPT4ge1xuICAgICAgaWYgKHN0YXRpY1Nlc3Npb24gPT09IG51bGwgfHwgZHluYW1pY1Nlc3Npb24gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjYW5Xcml0ZSA9IGNhbldyaXRlU3RvcmFnZShkeW5hbWljU2Vzc2lvbi5zY29wZXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbm5lY3Rpb25JZDogZHluYW1pY1Nlc3Npb24uYWN0b3IsXG4gICAgICAgICAgaWQ6IHN0YXRpY1Nlc3Npb24udXNlcklkLFxuICAgICAgICAgIGluZm86IHN0YXRpY1Nlc3Npb24udXNlckluZm8sXG4gICAgICAgICAgcHJlc2VuY2U6IG15UHJlc2VuY2UsXG4gICAgICAgICAgY2FuV3JpdGUsXG4gICAgICAgICAgY2FuQ29tbWVudDogY2FuQ29tbWVudChkeW5hbWljU2Vzc2lvbi5zY29wZXMpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICApO1xuICBsZXQgX2xhc3RTZWxmO1xuICBmdW5jdGlvbiBub3RpZnlTZWxmQ2hhbmdlZCgpIHtcbiAgICBjb25zdCBjdXJyU2VsZiA9IHNlbGYuZ2V0KCk7XG4gICAgaWYgKGN1cnJTZWxmICE9PSBudWxsICYmIGN1cnJTZWxmICE9PSBfbGFzdFNlbGYpIHtcbiAgICAgIGV2ZW50SHViLnNlbGYubm90aWZ5KGN1cnJTZWxmKTtcbiAgICAgIF9sYXN0U2VsZiA9IGN1cnJTZWxmO1xuICAgIH1cbiAgfVxuICBjb25zdCBzZWxmQXNUcmVlTm9kZSA9IERlcml2ZWRTaWduYWwuZnJvbShcbiAgICBzZWxmLFxuICAgIChtZSkgPT4gbWUgIT09IG51bGwgPyB1c2VyVG9UcmVlTm9kZShcIk1lXCIsIG1lKSA6IG51bGxcbiAgKTtcbiAgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVSb290RnJvbU1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlLml0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgZXJyb3I6IGNhbm5vdCBsb2FkIHN0b3JhZ2Ugd2l0aG91dCBpdGVtc1wiKTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQucm9vdCAhPT0gdm9pZCAwKSB7XG4gICAgICB1cGRhdGVSb290KG1lc3NhZ2UuaXRlbXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnJvb3QgPSBMaXZlT2JqZWN0Ll9mcm9tSXRlbXMobWVzc2FnZS5pdGVtcywgY29udGV4dC5wb29sKTtcbiAgICB9XG4gICAgY29uc3QgY2FuV3JpdGUgPSBzZWxmLmdldCgpPy5jYW5Xcml0ZSA/PyB0cnVlO1xuICAgIGNvbnN0IHN0YWNrU2l6ZUJlZm9yZSA9IGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aDtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjb250ZXh0LmluaXRpYWxTdG9yYWdlKSB7XG4gICAgICBpZiAoY29udGV4dC5yb290LmdldChrZXkpID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKGNhbldyaXRlKSB7XG4gICAgICAgICAgY29udGV4dC5yb290LnNldChrZXksIGNsb25lTHNvbihjb250ZXh0LmluaXRpYWxTdG9yYWdlW2tleV0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYEF0dGVtcHRlZCB0byBwb3B1bGF0ZSBtaXNzaW5nIHN0b3JhZ2Uga2V5ICcke2tleX0nLCBidXQgY3VycmVudCB1c2VyIGhhcyBubyB3cml0ZSBhY2Nlc3NgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPSBzdGFja1NpemVCZWZvcmU7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlUm9vdChpdGVtcykge1xuICAgIGlmIChjb250ZXh0LnJvb3QgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50SXRlbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW2lkLCBub2RlXSBvZiBjb250ZXh0LnBvb2wubm9kZXMpIHtcbiAgICAgIGN1cnJlbnRJdGVtcy5zZXQoaWQsIG5vZGUuX3NlcmlhbGl6ZSgpKTtcbiAgICB9XG4gICAgY29uc3Qgb3BzID0gZ2V0VHJlZXNEaWZmT3BlcmF0aW9ucyhjdXJyZW50SXRlbXMsIG5ldyBNYXAoaXRlbXMpKTtcbiAgICBjb25zdCByZXN1bHQgPSBhcHBseU9wcyhvcHMsIGZhbHNlKTtcbiAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMpO1xuICB9XG4gIGZ1bmN0aW9uIF9hZGRUb1JlYWxVbmRvU3RhY2soaGlzdG9yeU9wcykge1xuICAgIGlmIChjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPj0gNTApIHtcbiAgICAgIGNvbnRleHQudW5kb1N0YWNrLnNoaWZ0KCk7XG4gICAgfVxuICAgIGNvbnRleHQudW5kb1N0YWNrLnB1c2goaGlzdG9yeU9wcyk7XG4gICAgb25IaXN0b3J5Q2hhbmdlKCk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkVG9VbmRvU3RhY2soaGlzdG9yeU9wcykge1xuICAgIGlmIChjb250ZXh0LnBhdXNlZEhpc3RvcnkgIT09IG51bGwpIHtcbiAgICAgIGNvbnRleHQucGF1c2VkSGlzdG9yeS5wdXNoTGVmdChoaXN0b3J5T3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2FkZFRvUmVhbFVuZG9TdGFjayhoaXN0b3J5T3BzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbm90aWZ5KHVwZGF0ZXMpIHtcbiAgICBjb25zdCBzdG9yYWdlVXBkYXRlcyA9IHVwZGF0ZXMuc3RvcmFnZVVwZGF0ZXM7XG4gICAgY29uc3Qgb3RoZXJzVXBkYXRlcyA9IHVwZGF0ZXMub3RoZXJzO1xuICAgIGlmIChvdGhlcnNVcGRhdGVzICE9PSB2b2lkIDAgJiYgb3RoZXJzVXBkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBvdGhlcnMgPSBjb250ZXh0Lm90aGVycy5nZXQoKTtcbiAgICAgIGZvciAoY29uc3QgZXZlbnQgb2Ygb3RoZXJzVXBkYXRlcykge1xuICAgICAgICBldmVudEh1Yi5vdGhlcnMubm90aWZ5KHsgLi4uZXZlbnQsIG90aGVycyB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHVwZGF0ZXMucHJlc2VuY2UgPz8gZmFsc2UpIHtcbiAgICAgIG5vdGlmeVNlbGZDaGFuZ2VkKCk7XG4gICAgICBldmVudEh1Yi5teVByZXNlbmNlLm5vdGlmeShjb250ZXh0Lm15UHJlc2VuY2UuZ2V0KCkpO1xuICAgIH1cbiAgICBpZiAoc3RvcmFnZVVwZGF0ZXMgIT09IHZvaWQgMCAmJiBzdG9yYWdlVXBkYXRlcy5zaXplID4gMCkge1xuICAgICAgY29uc3QgdXBkYXRlczIgPSBBcnJheS5mcm9tKHN0b3JhZ2VVcGRhdGVzLnZhbHVlcygpKTtcbiAgICAgIGV2ZW50SHViLnN0b3JhZ2VCYXRjaC5ub3RpZnkodXBkYXRlczIpO1xuICAgIH1cbiAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudENvbm5lY3Rpb25JZCgpIHtcbiAgICBjb25zdCBpbmZvID0gY29udGV4dC5keW5hbWljU2Vzc2lvbkluZm9TaWcuZ2V0KCk7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgIHJldHVybiBpbmZvLmFjdG9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludGVybmFsLiBUcmllZCB0byBnZXQgY29ubmVjdGlvbiBpZCBidXQgY29ubmVjdGlvbiB3YXMgbmV2ZXIgb3BlblwiXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseU9wcyhyYXdPcHMsIGlzTG9jYWwpIHtcbiAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICByZXZlcnNlOiBuZXcgRGVxdWUoKSxcbiAgICAgIHN0b3JhZ2VVcGRhdGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgcHJlc2VuY2U6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBjcmVhdGVkTm9kZUlkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3Qgb3BzID0gcmF3T3BzLm1hcCgob3ApID0+IHtcbiAgICAgIGlmIChvcC50eXBlICE9PSBcInByZXNlbmNlXCIgJiYgIW9wLm9wSWQpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4ub3AsIG9wSWQ6IGNvbnRleHQucG9vbC5nZW5lcmF0ZU9wSWQoKSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgICBpZiAob3AudHlwZSA9PT0gXCJwcmVzZW5jZVwiKSB7XG4gICAgICAgIGNvbnN0IHJldmVyc2UgPSB7XG4gICAgICAgICAgdHlwZTogXCJwcmVzZW5jZVwiLFxuICAgICAgICAgIGRhdGE6IHt9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wLmRhdGEpIHtcbiAgICAgICAgICByZXZlcnNlLmRhdGFba2V5XSA9IGNvbnRleHQubXlQcmVzZW5jZS5nZXQoKVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQubXlQcmVzZW5jZS5wYXRjaChvcC5kYXRhKTtcbiAgICAgICAgaWYgKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcyA9IHsgdHlwZTogXCJwYXJ0aWFsXCIsIGRhdGE6IG9wLmRhdGEgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcC5kYXRhKSB7XG4gICAgICAgICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVtrZXldID0gb3AuZGF0YVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQucmV2ZXJzZS5wdXNoTGVmdChyZXZlcnNlKTtcbiAgICAgICAgb3V0cHV0LnByZXNlbmNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBzb3VyY2U7XG4gICAgICAgIGlmIChpc0xvY2FsKSB7XG4gICAgICAgICAgc291cmNlID0gMCAvKiBVTkRPUkVET19SRUNPTk5FQ1QgKi87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgb3BJZCA9IG5uKG9wLm9wSWQpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIG5uKGNvbnRleHQub3BTdGFja1RyYWNlcykuZGVsZXRlKG9wSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkZWxldGVkID0gY29udGV4dC51bmFja25vd2xlZGdlZE9wcy5kZWxldGUob3BJZCk7XG4gICAgICAgICAgc291cmNlID0gZGVsZXRlZCA/IDIgLyogQUNLICovIDogMSAvKiBSRU1PVEUgKi87XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBwbHlPcFJlc3VsdCA9IGFwcGx5T3Aob3AsIHNvdXJjZSk7XG4gICAgICAgIGlmIChhcHBseU9wUmVzdWx0Lm1vZGlmaWVkKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZUlkID0gYXBwbHlPcFJlc3VsdC5tb2RpZmllZC5ub2RlLl9pZDtcbiAgICAgICAgICBpZiAoIShub2RlSWQgJiYgY3JlYXRlZE5vZGVJZHMuaGFzKG5vZGVJZCkpKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3RvcmFnZVVwZGF0ZXMuc2V0KFxuICAgICAgICAgICAgICBubihhcHBseU9wUmVzdWx0Lm1vZGlmaWVkLm5vZGUuX2lkKSxcbiAgICAgICAgICAgICAgbWVyZ2VTdG9yYWdlVXBkYXRlcyhcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3RvcmFnZVVwZGF0ZXMuZ2V0KG5uKGFwcGx5T3BSZXN1bHQubW9kaWZpZWQubm9kZS5faWQpKSxcbiAgICAgICAgICAgICAgICBhcHBseU9wUmVzdWx0Lm1vZGlmaWVkXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvdXRwdXQucmV2ZXJzZS5wdXNoTGVmdChhcHBseU9wUmVzdWx0LnJldmVyc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3AudHlwZSA9PT0gMiAvKiBDUkVBVEVfTElTVCAqLyB8fCBvcC50eXBlID09PSA3IC8qIENSRUFURV9NQVAgKi8gfHwgb3AudHlwZSA9PT0gNCAvKiBDUkVBVEVfT0JKRUNUICovKSB7XG4gICAgICAgICAgICBjcmVhdGVkTm9kZUlkcy5hZGQobm4ob3AuaWQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wcyxcbiAgICAgIHJldmVyc2U6IEFycmF5LmZyb20ob3V0cHV0LnJldmVyc2UpLFxuICAgICAgdXBkYXRlczoge1xuICAgICAgICBzdG9yYWdlVXBkYXRlczogb3V0cHV0LnN0b3JhZ2VVcGRhdGVzLFxuICAgICAgICBwcmVzZW5jZTogb3V0cHV0LnByZXNlbmNlXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseU9wKG9wLCBzb3VyY2UpIHtcbiAgICBpZiAoaXNBY2tPcChvcCkpIHtcbiAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgIH1cbiAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgIGNhc2UgNiAvKiBERUxFVEVfT0JKRUNUX0tFWSAqLzpcbiAgICAgIGNhc2UgMyAvKiBVUERBVEVfT0JKRUNUICovOlxuICAgICAgY2FzZSA1IC8qIERFTEVURV9DUkRUICovOiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBjb250ZXh0LnBvb2wubm9kZXMuZ2V0KG9wLmlkKTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiB7IG1vZGlmaWVkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLl9hcHBseShvcCwgc291cmNlID09PSAwIC8qIFVORE9SRURPX1JFQ09OTkVDVCAqLyk7XG4gICAgICB9XG4gICAgICBjYXNlIDEgLyogU0VUX1BBUkVOVF9LRVkgKi86IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGNvbnRleHQucG9vbC5ub2Rlcy5nZXQob3AuaWQpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09IFwiSGFzUGFyZW50XCIgJiYgaXNMaXZlTGlzdChub2RlLnBhcmVudC5ub2RlKSkge1xuICAgICAgICAgIHJldHVybiBub2RlLnBhcmVudC5ub2RlLl9zZXRDaGlsZEtleShcbiAgICAgICAgICAgIGFzUG9zKG9wLnBhcmVudEtleSksXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgc291cmNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtb2RpZmllZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgNCAvKiBDUkVBVEVfT0JKRUNUICovOlxuICAgICAgY2FzZSAyIC8qIENSRUFURV9MSVNUICovOlxuICAgICAgY2FzZSA3IC8qIENSRUFURV9NQVAgKi86XG4gICAgICBjYXNlIDggLyogQ1JFQVRFX1JFR0lTVEVSICovOiB7XG4gICAgICAgIGlmIChvcC5wYXJlbnRJZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGNvbnRleHQucG9vbC5ub2Rlcy5nZXQob3AucGFyZW50SWQpO1xuICAgICAgICBpZiAocGFyZW50Tm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbW9kaWZpZWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudE5vZGUuX2F0dGFjaENoaWxkKG9wLCBzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVQcmVzZW5jZShwYXRjaCwgb3B0aW9uczIpIHtcbiAgICBjb25zdCBvbGRWYWx1ZXMgPSB7fTtcbiAgICBpZiAoY29udGV4dC5idWZmZXIucHJlc2VuY2VVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMgPSB7XG4gICAgICAgIHR5cGU6IFwicGFydGlhbFwiLFxuICAgICAgICBkYXRhOiB7fVxuICAgICAgfTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGF0Y2gpIHtcbiAgICAgIGNvbnN0IG92ZXJyaWRlVmFsdWUgPSBwYXRjaFtrZXldO1xuICAgICAgaWYgKG92ZXJyaWRlVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy5kYXRhW2tleV0gPSBvdmVycmlkZVZhbHVlO1xuICAgICAgb2xkVmFsdWVzW2tleV0gPSBjb250ZXh0Lm15UHJlc2VuY2UuZ2V0KClba2V5XTtcbiAgICB9XG4gICAgY29udGV4dC5teVByZXNlbmNlLnBhdGNoKHBhdGNoKTtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgaWYgKG9wdGlvbnMyPy5hZGRUb0hpc3RvcnkpIHtcbiAgICAgICAgY29udGV4dC5hY3RpdmVCYXRjaC5yZXZlcnNlT3BzLnB1c2hMZWZ0KHtcbiAgICAgICAgICB0eXBlOiBcInByZXNlbmNlXCIsXG4gICAgICAgICAgZGF0YTogb2xkVmFsdWVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29udGV4dC5hY3RpdmVCYXRjaC51cGRhdGVzLnByZXNlbmNlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmx1c2hOb3dPclNvb24oKTtcbiAgICAgIGlmIChvcHRpb25zMj8uYWRkVG9IaXN0b3J5KSB7XG4gICAgICAgIGFkZFRvVW5kb1N0YWNrKFt7IHR5cGU6IFwicHJlc2VuY2VcIiwgZGF0YTogb2xkVmFsdWVzIH1dKTtcbiAgICAgIH1cbiAgICAgIG5vdGlmeSh7IHByZXNlbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvblVwZGF0ZVByZXNlbmNlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UudGFyZ2V0QWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3Qgb2xkVXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgICBjb250ZXh0Lm90aGVycy5zZXRPdGhlcihtZXNzYWdlLmFjdG9yLCBtZXNzYWdlLmRhdGEpO1xuICAgICAgY29uc3QgbmV3VXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgICBpZiAob2xkVXNlciA9PT0gdm9pZCAwICYmIG5ld1VzZXIgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVudGVyXCIsIHVzZXI6IG5ld1VzZXIgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5vdGhlcnMucGF0Y2hPdGhlcihtZXNzYWdlLmFjdG9yLCBtZXNzYWdlLmRhdGEpLCBtZXNzYWdlO1xuICAgIH1cbiAgICBjb25zdCB1c2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICBpZiAodXNlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcbiAgICAgICAgdXBkYXRlczogbWVzc2FnZS5kYXRhLFxuICAgICAgICB1c2VyXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvblVzZXJMZWZ0TWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29uc3QgdXNlciA9IGNvbnRleHQub3RoZXJzLmdldFVzZXIobWVzc2FnZS5hY3Rvcik7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIGNvbnRleHQub3RoZXJzLnJlbW92ZUNvbm5lY3Rpb24obWVzc2FnZS5hY3Rvcik7XG4gICAgICByZXR1cm4geyB0eXBlOiBcImxlYXZlXCIsIHVzZXIgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gb25Sb29tU3RhdGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb250ZXh0LmR5bmFtaWNTZXNzaW9uSW5mb1NpZy5zZXQoe1xuICAgICAgYWN0b3I6IG1lc3NhZ2UuYWN0b3IsXG4gICAgICBub25jZTogbWVzc2FnZS5ub25jZSxcbiAgICAgIHNjb3BlczogbWVzc2FnZS5zY29wZXNcbiAgICB9KTtcbiAgICBjb250ZXh0LmlkRmFjdG9yeSA9IG1ha2VJZEZhY3RvcnkobWVzc2FnZS5hY3Rvcik7XG4gICAgbm90aWZ5U2VsZkNoYW5nZWQoKTtcbiAgICBmb3IgKGNvbnN0IGNvbm5lY3Rpb25JZCBvZiBjb250ZXh0Lm90aGVycy5jb25uZWN0aW9uSWRzKCkpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBtZXNzYWdlLnVzZXJzW2Nvbm5lY3Rpb25JZF07XG4gICAgICBpZiAodXNlciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRleHQub3RoZXJzLnJlbW92ZUNvbm5lY3Rpb24oY29ubmVjdGlvbklkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWVzc2FnZS51c2Vycykge1xuICAgICAgY29uc3QgdXNlciA9IG1lc3NhZ2UudXNlcnNba2V5XTtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb25JZCA9IE51bWJlcihrZXkpO1xuICAgICAgY29udGV4dC5vdGhlcnMuc2V0Q29ubmVjdGlvbihcbiAgICAgICAgY29ubmVjdGlvbklkLFxuICAgICAgICB1c2VyLmlkLFxuICAgICAgICB1c2VyLmluZm8sXG4gICAgICAgIHVzZXIuc2NvcGVzXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcInJlc2V0XCIgfTtcbiAgfVxuICBmdW5jdGlvbiBjYW5VbmRvKCkge1xuICAgIHJldHVybiBjb250ZXh0LnVuZG9TdGFjay5sZW5ndGggPiAwO1xuICB9XG4gIGZ1bmN0aW9uIGNhblJlZG8oKSB7XG4gICAgcmV0dXJuIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA+IDA7XG4gIH1cbiAgZnVuY3Rpb24gb25IaXN0b3J5Q2hhbmdlKCkge1xuICAgIGV2ZW50SHViLmhpc3Rvcnkubm90aWZ5KHsgY2FuVW5kbzogY2FuVW5kbygpLCBjYW5SZWRvOiBjYW5SZWRvKCkgfSk7XG4gIH1cbiAgZnVuY3Rpb24gb25Vc2VySm9pbmVkTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29udGV4dC5vdGhlcnMuc2V0Q29ubmVjdGlvbihcbiAgICAgIG1lc3NhZ2UuYWN0b3IsXG4gICAgICBtZXNzYWdlLmlkLFxuICAgICAgbWVzc2FnZS5pbmZvLFxuICAgICAgbWVzc2FnZS5zY29wZXNcbiAgICApO1xuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goe1xuICAgICAgdHlwZTogMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLyxcbiAgICAgIGRhdGE6IGNvbnRleHQubXlQcmVzZW5jZS5nZXQoKSxcbiAgICAgIHRhcmdldEFjdG9yOiBtZXNzYWdlLmFjdG9yXG4gICAgfSk7XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgICBjb25zdCB1c2VyID0gY29udGV4dC5vdGhlcnMuZ2V0VXNlcihtZXNzYWdlLmFjdG9yKTtcbiAgICByZXR1cm4gdXNlciA/IHsgdHlwZTogXCJlbnRlclwiLCB1c2VyIH0gOiB2b2lkIDA7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VTZXJ2ZXJNZXNzYWdlKGRhdGEpIHtcbiAgICBpZiAoIWlzSnNvbk9iamVjdChkYXRhKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlU2VydmVyTWVzc2FnZXModGV4dCkge1xuICAgIGNvbnN0IGRhdGEgPSB0cnlQYXJzZUpzb24odGV4dCk7XG4gICAgaWYgKGRhdGEgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChpc0pzb25BcnJheShkYXRhKSkge1xuICAgICAgcmV0dXJuIGNvbXBhY3QoZGF0YS5tYXAoKGl0ZW0pID0+IHBhcnNlU2VydmVyTWVzc2FnZShpdGVtKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29tcGFjdChbcGFyc2VTZXJ2ZXJNZXNzYWdlKGRhdGEpXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFwcGx5QW5kU2VuZE9wcyhvZmZsaW5lT3BzKSB7XG4gICAgaWYgKG9mZmxpbmVPcHMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGNvbnN0IGluT3BzID0gQXJyYXkuZnJvbShvZmZsaW5lT3BzLnZhbHVlcygpKTtcbiAgICBjb25zdCByZXN1bHQgPSBhcHBseU9wcyhpbk9wcywgdHJ1ZSk7XG4gICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICB0eXBlOiAyMDEgLyogVVBEQVRFX1NUT1JBR0UgKi8sXG4gICAgICBvcHM6IHJlc3VsdC5vcHNcbiAgICB9KTtcbiAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMpO1xuICAgIHNlbmRNZXNzYWdlcyhtZXNzYWdlcyk7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlU2VydmVyTWVzc2FnZShldmVudCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnQuZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IHBhcnNlU2VydmVyTWVzc2FnZXMoZXZlbnQuZGF0YSk7XG4gICAgaWYgKG1lc3NhZ2VzID09PSBudWxsIHx8IG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVzID0ge1xuICAgICAgc3RvcmFnZVVwZGF0ZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICBvdGhlcnM6IFtdXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgIGNhc2UgMTAxIC8qIFVTRVJfSk9JTkVEICovOiB7XG4gICAgICAgICAgY29uc3QgdXNlckpvaW5lZFVwZGF0ZSA9IG9uVXNlckpvaW5lZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgaWYgKHVzZXJKb2luZWRVcGRhdGUpIHtcbiAgICAgICAgICAgIHVwZGF0ZXMub3RoZXJzLnB1c2godXNlckpvaW5lZFVwZGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLzoge1xuICAgICAgICAgIGNvbnN0IG90aGVyc1ByZXNlbmNlVXBkYXRlID0gb25VcGRhdGVQcmVzZW5jZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgaWYgKG90aGVyc1ByZXNlbmNlVXBkYXRlKSB7XG4gICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKG90aGVyc1ByZXNlbmNlVXBkYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxMDMgLyogQlJPQURDQVNURURfRVZFTlQgKi86IHtcbiAgICAgICAgICBjb25zdCBvdGhlcnMgPSBjb250ZXh0Lm90aGVycy5nZXQoKTtcbiAgICAgICAgICBldmVudEh1Yi5jdXN0b21FdmVudC5ub3RpZnkoe1xuICAgICAgICAgICAgY29ubmVjdGlvbklkOiBtZXNzYWdlLmFjdG9yLFxuICAgICAgICAgICAgdXNlcjogbWVzc2FnZS5hY3RvciA8IDAgPyBudWxsIDogb3RoZXJzLmZpbmQoKHUpID0+IHUuY29ubmVjdGlvbklkID09PSBtZXNzYWdlLmFjdG9yKSA/PyBudWxsLFxuICAgICAgICAgICAgZXZlbnQ6IG1lc3NhZ2UuZXZlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDEwMiAvKiBVU0VSX0xFRlQgKi86IHtcbiAgICAgICAgICBjb25zdCBldmVudDIgPSBvblVzZXJMZWZ0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICBpZiAoZXZlbnQyKSB7XG4gICAgICAgICAgICB1cGRhdGVzLm90aGVycy5wdXNoKGV2ZW50Mik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMzAwIC8qIFVQREFURV9ZRE9DICovOiB7XG4gICAgICAgICAgZXZlbnRIdWIueWRvYy5ub3RpZnkobWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxMDQgLyogUk9PTV9TVEFURSAqLzoge1xuICAgICAgICAgIHVwZGF0ZXMub3RoZXJzLnB1c2gob25Sb29tU3RhdGVNZXNzYWdlKG1lc3NhZ2UpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDIwMCAvKiBJTklUSUFMX1NUT1JBR0VfU1RBVEUgKi86IHtcbiAgICAgICAgICBwcm9jZXNzSW5pdGlhbFN0b3JhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV3JpdGUgZXZlbnRcbiAgICAgICAgY2FzZSAyMDEgLyogVVBEQVRFX1NUT1JBR0UgKi86IHtcbiAgICAgICAgICBjb25zdCBhcHBseVJlc3VsdCA9IGFwcGx5T3BzKG1lc3NhZ2Uub3BzLCBmYWxzZSk7XG4gICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYXBwbHlSZXN1bHQudXBkYXRlcy5zdG9yYWdlVXBkYXRlcykge1xuICAgICAgICAgICAgdXBkYXRlcy5zdG9yYWdlVXBkYXRlcy5zZXQoXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgbWVyZ2VTdG9yYWdlVXBkYXRlcyh1cGRhdGVzLnN0b3JhZ2VVcGRhdGVzLmdldChrZXkpLCB2YWx1ZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY2VpdmluZyBhIFJlamVjdGVkT3BzIG1lc3NhZ2UgaW4gdGhlIGNsaWVudCBtZWFucyB0aGF0IHRoZSBzZXJ2ZXIgaXMgbm9cbiAgICAgICAgLy8gbG9uZ2VyIGluIHN5bmMgd2l0aCB0aGUgY2xpZW50LiBUcnlpbmcgdG8gc3luY2hyb25pemUgdGhlIGNsaWVudCBhZ2FpbiBieVxuICAgICAgICAvLyByb2xsaW5nIGJhY2sgcGFydGljdWxhciBPcHMgbWF5IGJlIGhhcmQvaW1wb3NzaWJsZS4gSXQncyBmaW5lIHRvIG5vdCB0cnkgYW5kXG4gICAgICAgIC8vIGFjY2VwdCB0aGUgb3V0LW9mLXN5bmMgcmVhbGl0eSBhbmQgdGhyb3cgYW4gZXJyb3IuIFdlIGxvb2sgYXQgdGhpcyBraW5kIG9mIGJ1Z1xuICAgICAgICAvLyBhcyBhIGRldmVsb3Blci1vd25lZCBidWcuIEluIHByb2R1Y3Rpb24sIHRoZXNlIGVycm9ycyBhcmUgbm90IGV4cGVjdGVkIHRvIGhhcHBlbi5cbiAgICAgICAgY2FzZSAyOTkgLyogUkVKRUNUX1NUT1JBR0VfT1AgKi86IHtcbiAgICAgICAgICBlcnJvcldpdGhUaXRsZShcbiAgICAgICAgICAgIFwiU3RvcmFnZSBtdXRhdGlvbiByZWplY3Rpb24gZXJyb3JcIixcbiAgICAgICAgICAgIG1lc3NhZ2UucmVhc29uXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFjZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcElkIG9mIG1lc3NhZ2Uub3BJZHMpIHtcbiAgICAgICAgICAgICAgY29uc3QgdHJhY2UgPSBjb250ZXh0Lm9wU3RhY2tUcmFjZXM/LmdldChvcElkKTtcbiAgICAgICAgICAgICAgaWYgKHRyYWNlKSB7XG4gICAgICAgICAgICAgICAgdHJhY2VzLmFkZCh0cmFjZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFjZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgd2FybldpdGhUaXRsZShcbiAgICAgICAgICAgICAgICBcIlRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gY2FsbHMgY2F1c2VkIHRoZSByZWplY3RlZCBzdG9yYWdlIG11dGF0aW9uczpcIixcbiAgICAgICAgICAgICAgICBgXG5cbiR7QXJyYXkuZnJvbSh0cmFjZXMpLmpvaW4oXCJcXG5cXG5cIil9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgU3RvcmFnZSBtdXRhdGlvbnMgcmVqZWN0ZWQgYnkgc2VydmVyOiAke21lc3NhZ2UucmVhc29ufWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNDAwIC8qIFRIUkVBRF9DUkVBVEVEICovOlxuICAgICAgICBjYXNlIDQwNyAvKiBUSFJFQURfREVMRVRFRCAqLzpcbiAgICAgICAgY2FzZSA0MDEgLyogVEhSRUFEX01FVEFEQVRBX1VQREFURUQgKi86XG4gICAgICAgIGNhc2UgNDA4IC8qIFRIUkVBRF9VUERBVEVEICovOlxuICAgICAgICBjYXNlIDQwNSAvKiBDT01NRU5UX1JFQUNUSU9OX0FEREVEICovOlxuICAgICAgICBjYXNlIDQwNiAvKiBDT01NRU5UX1JFQUNUSU9OX1JFTU9WRUQgKi86XG4gICAgICAgIGNhc2UgNDAyIC8qIENPTU1FTlRfQ1JFQVRFRCAqLzpcbiAgICAgICAgY2FzZSA0MDMgLyogQ09NTUVOVF9FRElURUQgKi86XG4gICAgICAgIGNhc2UgNDA0IC8qIENPTU1FTlRfREVMRVRFRCAqLzoge1xuICAgICAgICAgIGV2ZW50SHViLmNvbW1lbnRzLm5vdGlmeShtZXNzYWdlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBub3RpZnkodXBkYXRlcyk7XG4gIH1cbiAgZnVuY3Rpb24gZmx1c2hOb3dPclNvb24oKSB7XG4gICAgY29uc3Qgc3RvcmFnZU9wcyA9IGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zO1xuICAgIGlmIChzdG9yYWdlT3BzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoY29uc3Qgb3Agb2Ygc3RvcmFnZU9wcykge1xuICAgICAgICBjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzLnNldChubihvcC5vcElkKSwgb3ApO1xuICAgICAgfVxuICAgICAgbm90aWZ5U3RvcmFnZVN0YXR1cygpO1xuICAgIH1cbiAgICBpZiAobWFuYWdlZFNvY2tldC5nZXRTdGF0dXMoKSAhPT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnMgPSBbXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBlbGFwc2VkTWlsbGlzID0gbm93IC0gY29udGV4dC5idWZmZXIubGFzdEZsdXNoZWRBdDtcbiAgICBpZiAoZWxhcHNlZE1pbGxpcyA+PSBjb25maWcudGhyb3R0bGVEZWxheSkge1xuICAgICAgY29uc3QgbWVzc2FnZXNUb0ZsdXNoID0gc2VyaWFsaXplQnVmZmVyKCk7XG4gICAgICBpZiAobWVzc2FnZXNUb0ZsdXNoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZW5kTWVzc2FnZXMobWVzc2FnZXNUb0ZsdXNoKTtcbiAgICAgIGNvbnRleHQuYnVmZmVyID0ge1xuICAgICAgICBmbHVzaFRpbWVySUQ6IHZvaWQgMCxcbiAgICAgICAgbGFzdEZsdXNoZWRBdDogbm93LFxuICAgICAgICBtZXNzYWdlczogW10sXG4gICAgICAgIHN0b3JhZ2VPcGVyYXRpb25zOiBbXSxcbiAgICAgICAgcHJlc2VuY2VVcGRhdGVzOiBudWxsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclRpbWVvdXQoY29udGV4dC5idWZmZXIuZmx1c2hUaW1lcklEKTtcbiAgICAgIGNvbnRleHQuYnVmZmVyLmZsdXNoVGltZXJJRCA9IHNldFRpbWVvdXQoXG4gICAgICAgIGZsdXNoTm93T3JTb29uLFxuICAgICAgICBjb25maWcudGhyb3R0bGVEZWxheSAtIGVsYXBzZWRNaWxsaXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZUJ1ZmZlcigpIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGlmIChjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMpIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goXG4gICAgICAgIGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy50eXBlID09PSBcImZ1bGxcIiA/IHtcbiAgICAgICAgICB0eXBlOiAxMDAgLyogVVBEQVRFX1BSRVNFTkNFICovLFxuICAgICAgICAgIC8vIFBvcHVsYXRpbmcgdGhlIGB0YXJnZXRBY3RvcmAgZmllbGQgdHVybnMgdGhpcyBtZXNzYWdlIGludG9cbiAgICAgICAgICAvLyBhIEZ1bGwgUHJlc2VuY2XihKIgdXBkYXRlIG1lc3NhZ2UgKG5vdCBhIHBhdGNoKSwgd2hpY2ggd2lsbCBnZXRcbiAgICAgICAgICAvLyBpbnRlcnByZXRlZCBieSBvdGhlciBjbGllbnRzIGFzIHN1Y2guXG4gICAgICAgICAgdGFyZ2V0QWN0b3I6IC0xLFxuICAgICAgICAgIGRhdGE6IGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcy5kYXRhXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgdHlwZTogMTAwIC8qIFVQREFURV9QUkVTRU5DRSAqLyxcbiAgICAgICAgICBkYXRhOiBjb250ZXh0LmJ1ZmZlci5wcmVzZW5jZVVwZGF0ZXMuZGF0YVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICB0eXBlOiAyMDEgLyogVVBEQVRFX1NUT1JBR0UgKi8sXG4gICAgICAgIG9wczogY29udGV4dC5idWZmZXIuc3RvcmFnZU9wZXJhdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZXM7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlWURvYyh1cGRhdGUsIGd1aWQsIGlzVjIpIHtcbiAgICBjb25zdCBjbGllbnRNc2cgPSB7XG4gICAgICB0eXBlOiAzMDEgLyogVVBEQVRFX1lET0MgKi8sXG4gICAgICB1cGRhdGUsXG4gICAgICBndWlkLFxuICAgICAgdjI6IGlzVjJcbiAgICB9O1xuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goY2xpZW50TXNnKTtcbiAgICBldmVudEh1Yi55ZG9jLm5vdGlmeShjbGllbnRNc2cpO1xuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gYnJvYWRjYXN0RXZlbnQoZXZlbnQsIG9wdGlvbnMyID0ge1xuICAgIHNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5OiBmYWxzZVxuICB9KSB7XG4gICAgaWYgKG1hbmFnZWRTb2NrZXQuZ2V0U3RhdHVzKCkgIT09IFwiY29ubmVjdGVkXCIgJiYgIW9wdGlvbnMyLnNob3VsZFF1ZXVlRXZlbnRJZk5vdFJlYWR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goe1xuICAgICAgdHlwZTogMTAzIC8qIEJST0FEQ0FTVF9FVkVOVCAqLyxcbiAgICAgIGV2ZW50XG4gICAgfSk7XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwYXRjaE9wcyhvcHMpIHtcbiAgICBjb25zdCB7IHN0b3JhZ2VPcGVyYXRpb25zIH0gPSBjb250ZXh0LmJ1ZmZlcjtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgc3RvcmFnZU9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgbGV0IF9nZXRTdG9yYWdlJCA9IG51bGw7XG4gIGxldCBfcmVzb2x2ZVN0b3JhZ2VQcm9taXNlID0gbnVsbDtcbiAgZnVuY3Rpb24gcHJvY2Vzc0luaXRpYWxTdG9yYWdlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCB1bmFja25vd2xlZGdlZE9wcyA9IG5ldyBNYXAoY29udGV4dC51bmFja25vd2xlZGdlZE9wcyk7XG4gICAgY3JlYXRlT3JVcGRhdGVSb290RnJvbU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgYXBwbHlBbmRTZW5kT3BzKHVuYWNrbm93bGVkZ2VkT3BzKTtcbiAgICBfcmVzb2x2ZVN0b3JhZ2VQcm9taXNlPy4oKTtcbiAgICBub3RpZnlTdG9yYWdlU3RhdHVzKCk7XG4gICAgZXZlbnRIdWIuc3RvcmFnZURpZExvYWQubm90aWZ5KCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc3RyZWFtU3RvcmFnZSgpIHtcbiAgICBpZiAoIW1hbmFnZWRTb2NrZXQuYXV0aFZhbHVlKSByZXR1cm47XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCBodHRwQ2xpZW50LnN0cmVhbVN0b3JhZ2UoeyByb29tSWQgfSk7XG4gICAgcHJvY2Vzc0luaXRpYWxTdG9yYWdlKHsgdHlwZTogMjAwIC8qIElOSVRJQUxfU1RPUkFHRV9TVEFURSAqLywgaXRlbXMgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVmcmVzaFN0b3JhZ2Uob3B0aW9uczIpIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzO1xuICAgIGlmIChjb25maWcudW5zdGFibGVfc3RyZWFtRGF0YSkge1xuICAgICAgdm9pZCBzdHJlYW1TdG9yYWdlKCk7XG4gICAgfSBlbHNlIGlmICghbWVzc2FnZXMuc29tZSgobXNnKSA9PiBtc2cudHlwZSA9PT0gMjAwIC8qIEZFVENIX1NUT1JBR0UgKi8pKSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKHsgdHlwZTogMjAwIC8qIEZFVENIX1NUT1JBR0UgKi8gfSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zMi5mbHVzaCkge1xuICAgICAgZmx1c2hOb3dPclNvb24oKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3RhcnRMb2FkaW5nU3RvcmFnZSgpIHtcbiAgICBpZiAoX2dldFN0b3JhZ2UkID09PSBudWxsKSB7XG4gICAgICByZWZyZXNoU3RvcmFnZSh7IGZsdXNoOiB0cnVlIH0pO1xuICAgICAgX2dldFN0b3JhZ2UkID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgX3Jlc29sdmVTdG9yYWdlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICB9KTtcbiAgICAgIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXRTdG9yYWdlJDtcbiAgfVxuICBmdW5jdGlvbiBnZXRTdG9yYWdlU25hcHNob3QoKSB7XG4gICAgY29uc3Qgcm9vdCA9IGNvbnRleHQucm9vdDtcbiAgICBpZiAocm9vdCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdm9pZCBzdGFydExvYWRpbmdTdG9yYWdlKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0U3RvcmFnZSgpIHtcbiAgICBpZiAoY29udGV4dC5yb290ICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICByb290OiBjb250ZXh0LnJvb3RcbiAgICAgIH0pO1xuICAgIH1cbiAgICBhd2FpdCBzdGFydExvYWRpbmdTdG9yYWdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3Q6IG5uKGNvbnRleHQucm9vdClcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGZldGNoWURvYyh2ZWN0b3IsIGd1aWQsIGlzVjIpIHtcbiAgICBpZiAoIWNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLmZpbmQoKG0pID0+IHtcbiAgICAgIHJldHVybiBtLnR5cGUgPT09IDMwMCAvKiBGRVRDSF9ZRE9DICovICYmIG0udmVjdG9yID09PSB2ZWN0b3IgJiYgbS5ndWlkID09PSBndWlkICYmIG0udjIgPT09IGlzVjI7XG4gICAgfSkpIHtcbiAgICAgIGNvbnRleHQuYnVmZmVyLm1lc3NhZ2VzLnB1c2goe1xuICAgICAgICB0eXBlOiAzMDAgLyogRkVUQ0hfWURPQyAqLyxcbiAgICAgICAgdmVjdG9yLFxuICAgICAgICBndWlkLFxuICAgICAgICB2MjogaXNWMlxuICAgICAgfSk7XG4gICAgfVxuICAgIGZsdXNoTm93T3JTb29uKCk7XG4gIH1cbiAgZnVuY3Rpb24gdW5kbygpIHtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5kbyBpcyBub3QgYWxsb3dlZCBkdXJpbmcgYSBiYXRjaFwiKTtcbiAgICB9XG4gICAgY29uc3QgaGlzdG9yeU9wcyA9IGNvbnRleHQudW5kb1N0YWNrLnBvcCgpO1xuICAgIGlmIChoaXN0b3J5T3BzID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gbnVsbDtcbiAgICBjb25zdCByZXN1bHQgPSBhcHBseU9wcyhoaXN0b3J5T3BzLCB0cnVlKTtcbiAgICBub3RpZnkocmVzdWx0LnVwZGF0ZXMpO1xuICAgIGNvbnRleHQucmVkb1N0YWNrLnB1c2gocmVzdWx0LnJldmVyc2UpO1xuICAgIG9uSGlzdG9yeUNoYW5nZSgpO1xuICAgIGZvciAoY29uc3Qgb3Agb2YgcmVzdWx0Lm9wcykge1xuICAgICAgaWYgKG9wLnR5cGUgIT09IFwicHJlc2VuY2VcIikge1xuICAgICAgICBjb250ZXh0LmJ1ZmZlci5zdG9yYWdlT3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hOb3dPclNvb24oKTtcbiAgfVxuICBmdW5jdGlvbiByZWRvKCkge1xuICAgIGlmIChjb250ZXh0LmFjdGl2ZUJhdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWRvIGlzIG5vdCBhbGxvd2VkIGR1cmluZyBhIGJhdGNoXCIpO1xuICAgIH1cbiAgICBjb25zdCBoaXN0b3J5T3BzID0gY29udGV4dC5yZWRvU3RhY2sucG9wKCk7XG4gICAgaWYgKGhpc3RvcnlPcHMgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBudWxsO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGx5T3BzKGhpc3RvcnlPcHMsIHRydWUpO1xuICAgIG5vdGlmeShyZXN1bHQudXBkYXRlcyk7XG4gICAgY29udGV4dC51bmRvU3RhY2sucHVzaChyZXN1bHQucmV2ZXJzZSk7XG4gICAgb25IaXN0b3J5Q2hhbmdlKCk7XG4gICAgZm9yIChjb25zdCBvcCBvZiByZXN1bHQub3BzKSB7XG4gICAgICBpZiAob3AudHlwZSAhPT0gXCJwcmVzZW5jZVwiKSB7XG4gICAgICAgIGNvbnRleHQuYnVmZmVyLnN0b3JhZ2VPcGVyYXRpb25zLnB1c2gob3ApO1xuICAgICAgfVxuICAgIH1cbiAgICBmbHVzaE5vd09yU29vbigpO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGNvbnRleHQudW5kb1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgY29udGV4dC5yZWRvU3RhY2subGVuZ3RoID0gMDtcbiAgfVxuICBmdW5jdGlvbiBiYXRjaDIoY2FsbGJhY2spIHtcbiAgICBpZiAoY29udGV4dC5hY3RpdmVCYXRjaCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGxldCByZXR1cm5WYWx1ZSA9IHZvaWQgMDtcbiAgICBjb250ZXh0LmFjdGl2ZUJhdGNoID0ge1xuICAgICAgb3BzOiBbXSxcbiAgICAgIHVwZGF0ZXM6IHtcbiAgICAgICAgc3RvcmFnZVVwZGF0ZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICAgIHByZXNlbmNlOiBmYWxzZSxcbiAgICAgICAgb3RoZXJzOiBbXVxuICAgICAgfSxcbiAgICAgIHJldmVyc2VPcHM6IG5ldyBEZXF1ZSgpXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuVmFsdWUgPSBjYWxsYmFjaygpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjb25zdCBjdXJyZW50QmF0Y2ggPSBjb250ZXh0LmFjdGl2ZUJhdGNoO1xuICAgICAgY29udGV4dC5hY3RpdmVCYXRjaCA9IG51bGw7XG4gICAgICBpZiAoY3VycmVudEJhdGNoLnJldmVyc2VPcHMubGVuZ3RoID4gMCkge1xuICAgICAgICBhZGRUb1VuZG9TdGFjayhBcnJheS5mcm9tKGN1cnJlbnRCYXRjaC5yZXZlcnNlT3BzKSk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudEJhdGNoLm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnRleHQucmVkb1N0YWNrLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudEJhdGNoLm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRpc3BhdGNoT3BzKGN1cnJlbnRCYXRjaC5vcHMpO1xuICAgICAgfVxuICAgICAgbm90aWZ5KGN1cnJlbnRCYXRjaC51cGRhdGVzKTtcbiAgICAgIGZsdXNoTm93T3JTb29uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBwYXVzZUhpc3RvcnkoKSB7XG4gICAgaWYgKGNvbnRleHQucGF1c2VkSGlzdG9yeSA9PT0gbnVsbCkge1xuICAgICAgY29udGV4dC5wYXVzZWRIaXN0b3J5ID0gbmV3IERlcXVlKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlc3VtZUhpc3RvcnkoKSB7XG4gICAgY29uc3QgaGlzdG9yeU9wcyA9IGNvbnRleHQucGF1c2VkSGlzdG9yeTtcbiAgICBjb250ZXh0LnBhdXNlZEhpc3RvcnkgPSBudWxsO1xuICAgIGlmIChoaXN0b3J5T3BzICE9PSBudWxsICYmIGhpc3RvcnlPcHMubGVuZ3RoID4gMCkge1xuICAgICAgX2FkZFRvUmVhbFVuZG9TdGFjayhBcnJheS5mcm9tKGhpc3RvcnlPcHMpKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3luY1NvdXJjZUZvclN0b3JhZ2UgPSBjb25maWcuY3JlYXRlU3luY1NvdXJjZSgpO1xuICBmdW5jdGlvbiBnZXRTdG9yYWdlU3RhdHVzKCkge1xuICAgIGlmIChjb250ZXh0LnJvb3QgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIF9nZXRTdG9yYWdlJCA9PT0gbnVsbCA/IFwibm90LWxvYWRlZFwiIDogXCJsb2FkaW5nXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb250ZXh0LnVuYWNrbm93bGVkZ2VkT3BzLnNpemUgPT09IDAgPyBcInN5bmNocm9uaXplZFwiIDogXCJzeW5jaHJvbml6aW5nXCI7XG4gICAgfVxuICB9XG4gIGxldCBfbGFzdFN0b3JhZ2VTdGF0dXMgPSBnZXRTdG9yYWdlU3RhdHVzKCk7XG4gIGZ1bmN0aW9uIG5vdGlmeVN0b3JhZ2VTdGF0dXMoKSB7XG4gICAgY29uc3Qgc3RvcmFnZVN0YXR1cyA9IGdldFN0b3JhZ2VTdGF0dXMoKTtcbiAgICBpZiAoX2xhc3RTdG9yYWdlU3RhdHVzICE9PSBzdG9yYWdlU3RhdHVzKSB7XG4gICAgICBfbGFzdFN0b3JhZ2VTdGF0dXMgPSBzdG9yYWdlU3RhdHVzO1xuICAgICAgZXZlbnRIdWIuc3RvcmFnZVN0YXR1cy5ub3RpZnkoc3RvcmFnZVN0YXR1cyk7XG4gICAgfVxuICAgIHN5bmNTb3VyY2VGb3JTdG9yYWdlLnNldFN5bmNTdGF0dXMoXG4gICAgICBzdG9yYWdlU3RhdHVzID09PSBcInN5bmNocm9uaXppbmdcIiA/IFwic3luY2hyb25pemluZ1wiIDogXCJzeW5jaHJvbml6ZWRcIlxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gaXNQcmVzZW5jZVJlYWR5KCkge1xuICAgIHJldHVybiBzZWxmLmdldCgpICE9PSBudWxsO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHdhaXRVbnRpbFByZXNlbmNlUmVhZHkoKSB7XG4gICAgd2hpbGUgKCFpc1ByZXNlbmNlUmVhZHkoKSkge1xuICAgICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlIH0gPSBQcm9taXNlX3dpdGhSZXNvbHZlcnMoKTtcbiAgICAgIGNvbnN0IHVuc3ViMSA9IGV2ZW50cy5zZWxmLnN1YnNjcmliZU9uY2UocmVzb2x2ZSk7XG4gICAgICBjb25zdCB1bnN1YjIgPSBldmVudHMuc3RhdHVzLnN1YnNjcmliZU9uY2UocmVzb2x2ZSk7XG4gICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgdW5zdWIxKCk7XG4gICAgICB1bnN1YjIoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNTdG9yYWdlUmVhZHkoKSB7XG4gICAgcmV0dXJuIGdldFN0b3JhZ2VTbmFwc2hvdCgpICE9PSBudWxsO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHdhaXRVbnRpbFN0b3JhZ2VSZWFkeSgpIHtcbiAgICB3aGlsZSAoIWlzU3RvcmFnZVJlYWR5KCkpIHtcbiAgICAgIGF3YWl0IGdldFN0b3JhZ2UoKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgb3RoZXJzX2ZvckRldlRvb2xzID0gRGVyaXZlZFNpZ25hbC5mcm9tKFxuICAgIGNvbnRleHQub3RoZXJzLnNpZ25hbCxcbiAgICAob3RoZXJzKSA9PiBvdGhlcnMubWFwKChvdGhlciwgaW5kZXgpID0+IHVzZXJUb1RyZWVOb2RlKGBPdGhlciAke2luZGV4fWAsIG90aGVyKSlcbiAgKTtcbiAgY29uc3QgZXZlbnRzID0ge1xuICAgIHN0YXR1czogZXZlbnRIdWIuc3RhdHVzLm9ic2VydmFibGUsXG4gICAgbG9zdENvbm5lY3Rpb246IGV2ZW50SHViLmxvc3RDb25uZWN0aW9uLm9ic2VydmFibGUsXG4gICAgY3VzdG9tRXZlbnQ6IGV2ZW50SHViLmN1c3RvbUV2ZW50Lm9ic2VydmFibGUsXG4gICAgb3RoZXJzOiBldmVudEh1Yi5vdGhlcnMub2JzZXJ2YWJsZSxcbiAgICBzZWxmOiBldmVudEh1Yi5zZWxmLm9ic2VydmFibGUsXG4gICAgbXlQcmVzZW5jZTogZXZlbnRIdWIubXlQcmVzZW5jZS5vYnNlcnZhYmxlLFxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIHN0b3JhZ2U6IGV2ZW50SHViLnN0b3JhZ2VCYXRjaC5vYnNlcnZhYmxlLFxuICAgIHN0b3JhZ2VCYXRjaDogZXZlbnRIdWIuc3RvcmFnZUJhdGNoLm9ic2VydmFibGUsXG4gICAgaGlzdG9yeTogZXZlbnRIdWIuaGlzdG9yeS5vYnNlcnZhYmxlLFxuICAgIHN0b3JhZ2VEaWRMb2FkOiBldmVudEh1Yi5zdG9yYWdlRGlkTG9hZC5vYnNlcnZhYmxlLFxuICAgIHN0b3JhZ2VTdGF0dXM6IGV2ZW50SHViLnN0b3JhZ2VTdGF0dXMub2JzZXJ2YWJsZSxcbiAgICB5ZG9jOiBldmVudEh1Yi55ZG9jLm9ic2VydmFibGUsXG4gICAgY29tbWVudHM6IGV2ZW50SHViLmNvbW1lbnRzLm9ic2VydmFibGUsXG4gICAgcm9vbVdpbGxEZXN0cm95OiBldmVudEh1Yi5yb29tV2lsbERlc3Ryb3kub2JzZXJ2YWJsZVxuICB9O1xuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWRzU2luY2Uob3B0aW9uczIpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5nZXRUaHJlYWRzU2luY2Uoe1xuICAgICAgcm9vbUlkLFxuICAgICAgc2luY2U6IG9wdGlvbnMyLnNpbmNlLFxuICAgICAgc2lnbmFsOiBvcHRpb25zMi5zaWduYWxcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXRUaHJlYWRzKG9wdGlvbnMyKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZ2V0VGhyZWFkcyh7XG4gICAgICByb29tSWQsXG4gICAgICBxdWVyeTogb3B0aW9uczI/LnF1ZXJ5LFxuICAgICAgY3Vyc29yOiBvcHRpb25zMj8uY3Vyc29yXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VGhyZWFkKHRocmVhZElkKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZ2V0VGhyZWFkKHsgcm9vbUlkLCB0aHJlYWRJZCB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVUaHJlYWQob3B0aW9uczIpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5jcmVhdGVUaHJlYWQoe1xuICAgICAgcm9vbUlkLFxuICAgICAgdGhyZWFkSWQ6IG9wdGlvbnMyLnRocmVhZElkLFxuICAgICAgY29tbWVudElkOiBvcHRpb25zMi5jb21tZW50SWQsXG4gICAgICBtZXRhZGF0YTogb3B0aW9uczIubWV0YWRhdGEsXG4gICAgICBib2R5OiBvcHRpb25zMi5ib2R5LFxuICAgICAgYXR0YWNobWVudElkczogb3B0aW9uczIuYXR0YWNobWVudElkc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVRocmVhZCh0aHJlYWRJZCkge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmRlbGV0ZVRocmVhZCh7IHJvb21JZCwgdGhyZWFkSWQgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZWRpdFRocmVhZE1ldGFkYXRhKHtcbiAgICBtZXRhZGF0YSxcbiAgICB0aHJlYWRJZFxuICB9KSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuZWRpdFRocmVhZE1ldGFkYXRhKHsgcm9vbUlkLCB0aHJlYWRJZCwgbWV0YWRhdGEgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya1RocmVhZEFzUmVzb2x2ZWQodGhyZWFkSWQpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5tYXJrVGhyZWFkQXNSZXNvbHZlZCh7IHJvb21JZCwgdGhyZWFkSWQgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbWFya1RocmVhZEFzVW5yZXNvbHZlZCh0aHJlYWRJZCkge1xuICAgIHJldHVybiBodHRwQ2xpZW50Lm1hcmtUaHJlYWRBc1VucmVzb2x2ZWQoe1xuICAgICAgcm9vbUlkLFxuICAgICAgdGhyZWFkSWRcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb21tZW50KG9wdGlvbnMyKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQuY3JlYXRlQ29tbWVudCh7XG4gICAgICByb29tSWQsXG4gICAgICB0aHJlYWRJZDogb3B0aW9uczIudGhyZWFkSWQsXG4gICAgICBjb21tZW50SWQ6IG9wdGlvbnMyLmNvbW1lbnRJZCxcbiAgICAgIGJvZHk6IG9wdGlvbnMyLmJvZHksXG4gICAgICBhdHRhY2htZW50SWRzOiBvcHRpb25zMi5hdHRhY2htZW50SWRzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZWRpdENvbW1lbnQob3B0aW9uczIpIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5lZGl0Q29tbWVudCh7XG4gICAgICByb29tSWQsXG4gICAgICB0aHJlYWRJZDogb3B0aW9uczIudGhyZWFkSWQsXG4gICAgICBjb21tZW50SWQ6IG9wdGlvbnMyLmNvbW1lbnRJZCxcbiAgICAgIGJvZHk6IG9wdGlvbnMyLmJvZHksXG4gICAgICBhdHRhY2htZW50SWRzOiBvcHRpb25zMi5hdHRhY2htZW50SWRzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlQ29tbWVudCh7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkXG4gIH0pIHtcbiAgICByZXR1cm4gaHR0cENsaWVudC5kZWxldGVDb21tZW50KHsgcm9vbUlkLCB0aHJlYWRJZCwgY29tbWVudElkIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGFkZFJlYWN0aW9uKHtcbiAgICB0aHJlYWRJZCxcbiAgICBjb21tZW50SWQsXG4gICAgZW1vamlcbiAgfSkge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmFkZFJlYWN0aW9uKHsgcm9vbUlkLCB0aHJlYWRJZCwgY29tbWVudElkLCBlbW9qaSB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZW1vdmVSZWFjdGlvbih7XG4gICAgdGhyZWFkSWQsXG4gICAgY29tbWVudElkLFxuICAgIGVtb2ppXG4gIH0pIHtcbiAgICByZXR1cm4gYXdhaXQgaHR0cENsaWVudC5yZW1vdmVSZWFjdGlvbih7XG4gICAgICByb29tSWQsXG4gICAgICB0aHJlYWRJZCxcbiAgICAgIGNvbW1lbnRJZCxcbiAgICAgIGVtb2ppXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcHJlcGFyZUF0dGFjaG1lbnQoZmlsZSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxvY2FsQXR0YWNobWVudFwiLFxuICAgICAgc3RhdHVzOiBcImlkbGVcIixcbiAgICAgIGlkOiBjcmVhdGVDb21tZW50QXR0YWNobWVudElkKCksXG4gICAgICBuYW1lOiBmaWxlLm5hbWUsXG4gICAgICBzaXplOiBmaWxlLnNpemUsXG4gICAgICBtaW1lVHlwZTogZmlsZS50eXBlLFxuICAgICAgZmlsZVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gdXBsb2FkQXR0YWNobWVudChhdHRhY2htZW50LCBvcHRpb25zMiA9IHt9KSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQudXBsb2FkQXR0YWNobWVudCh7XG4gICAgICByb29tSWQsXG4gICAgICBhdHRhY2htZW50LFxuICAgICAgc2lnbmFsOiBvcHRpb25zMi5zaWduYWxcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRBdHRhY2htZW50VXJsKGF0dGFjaG1lbnRJZCkge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmdldEF0dGFjaG1lbnRVcmwoeyByb29tSWQsIGF0dGFjaG1lbnRJZCB9KTtcbiAgfVxuICBmdW5jdGlvbiBnZXROb3RpZmljYXRpb25TZXR0aW5ncyhvcHRpb25zMikge1xuICAgIHJldHVybiBodHRwQ2xpZW50LmdldE5vdGlmaWNhdGlvblNldHRpbmdzKHtcbiAgICAgIHJvb21JZCxcbiAgICAgIHNpZ25hbDogb3B0aW9uczI/LnNpZ25hbFxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQudXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3MoeyByb29tSWQsIHNldHRpbmdzIH0pO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZChpbmJveE5vdGlmaWNhdGlvbklkKSB7XG4gICAgYXdhaXQgaHR0cENsaWVudC5tYXJrUm9vbUluYm94Tm90aWZpY2F0aW9uQXNSZWFkKHtcbiAgICAgIHJvb21JZCxcbiAgICAgIGluYm94Tm90aWZpY2F0aW9uSWRcbiAgICB9KTtcbiAgfVxuICBjb25zdCBzeW5jU291cmNlRm9yWWpzID0gY29uZmlnLmNyZWF0ZVN5bmNTb3VyY2UoKTtcbiAgZnVuY3Rpb24geWpzU3RhdHVzRGlkQ2hhbmdlKHN0YXR1cykge1xuICAgIHJldHVybiBzeW5jU291cmNlRm9yWWpzLnNldFN5bmNTdGF0dXMoXG4gICAgICBzdGF0dXMgPT09IFwic3luY2hyb25pemluZ1wiID8gXCJzeW5jaHJvbml6aW5nXCIgOiBcInN5bmNocm9uaXplZFwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIHtcbiAgICAgIFtrSW50ZXJuYWxdOiB7XG4gICAgICAgIGdldCBwcmVzZW5jZUJ1ZmZlcigpIHtcbiAgICAgICAgICByZXR1cm4gZGVlcENsb25lKGNvbnRleHQuYnVmZmVyLnByZXNlbmNlVXBkYXRlcz8uZGF0YSA/PyBudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGdldCB1bmRvU3RhY2soKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZXBDbG9uZShjb250ZXh0LnVuZG9TdGFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBnZXQgbm9kZUNvdW50KCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LnBvb2wubm9kZXMuc2l6ZTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGdldFlqc1Byb3ZpZGVyKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Lnlqc1Byb3ZpZGVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXRZanNQcm92aWRlcihuZXdQcm92aWRlcikge1xuICAgICAgICAgIGNvbnRleHQueWpzUHJvdmlkZXI/Lm9mZihcInN0YXR1c1wiLCB5anNTdGF0dXNEaWRDaGFuZ2UpO1xuICAgICAgICAgIGNvbnRleHQueWpzUHJvdmlkZXIgPSBuZXdQcm92aWRlcjtcbiAgICAgICAgICBuZXdQcm92aWRlcj8ub24oXCJzdGF0dXNcIiwgeWpzU3RhdHVzRGlkQ2hhbmdlKTtcbiAgICAgICAgICBjb250ZXh0Lnlqc1Byb3ZpZGVyRGlkQ2hhbmdlLm5vdGlmeSgpO1xuICAgICAgICB9LFxuICAgICAgICB5anNQcm92aWRlckRpZENoYW5nZTogY29udGV4dC55anNQcm92aWRlckRpZENoYW5nZS5vYnNlcnZhYmxlLFxuICAgICAgICAvLyBzZW5kIG1ldGFkYXRhIHdoZW4gdXNpbmcgYSB0ZXh0IGVkaXRvclxuICAgICAgICByZXBvcnRUZXh0RWRpdG9yLFxuICAgICAgICAvLyBjcmVhdGUgYSB0ZXh0IG1lbnRpb24gd2hlbiB1c2luZyBhIHRleHQgZWRpdG9yXG4gICAgICAgIGNyZWF0ZVRleHRNZW50aW9uLFxuICAgICAgICAvLyBkZWxldGUgYSB0ZXh0IG1lbnRpb24gd2hlbiB1c2luZyBhIHRleHQgZWRpdG9yXG4gICAgICAgIGRlbGV0ZVRleHRNZW50aW9uLFxuICAgICAgICAvLyBsaXN0IHZlcnNpb25zIG9mIHRoZSBkb2N1bWVudFxuICAgICAgICBsaXN0VGV4dFZlcnNpb25zLFxuICAgICAgICAvLyBMaXN0IHZlcnNpb25zIG9mIHRoZSBkb2N1bWVudCBzaW5jZSB0aGUgc3BlY2lmaWVkIGRhdGVcbiAgICAgICAgbGlzdFRleHRWZXJzaW9uc1NpbmNlLFxuICAgICAgICAvLyBnZXQgYSBzcGVjaWZpYyB2ZXJzaW9uXG4gICAgICAgIGdldFRleHRWZXJzaW9uLFxuICAgICAgICAvLyBjcmVhdGUgYSB2ZXJzaW9uXG4gICAgICAgIGNyZWF0ZVRleHRWZXJzaW9uLFxuICAgICAgICAvLyBleGVjdXRlIGEgY29udGV4dHVhbCBwcm9tcHRcbiAgICAgICAgZXhlY3V0ZUNvbnRleHR1YWxQcm9tcHQsXG4gICAgICAgIC8vIFN1cHBvcnQgZm9yIHRoZSBMaXZlYmxvY2tzIGJyb3dzZXIgZXh0ZW5zaW9uXG4gICAgICAgIGdldFNlbGZfZm9yRGV2VG9vbHM6ICgpID0+IHNlbGZBc1RyZWVOb2RlLmdldCgpLFxuICAgICAgICBnZXRPdGhlcnNfZm9yRGV2VG9vbHM6ICgpID0+IG90aGVyc19mb3JEZXZUb29scy5nZXQoKSxcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHNpbXVsYXRlOiB7XG4gICAgICAgICAgLy8gVGhlc2UgZXhpc3Qgb25seSBmb3Igb3VyIEUyRSB0ZXN0aW5nIGFwcFxuICAgICAgICAgIGV4cGxpY2l0Q2xvc2U6IChldmVudCkgPT4gbWFuYWdlZFNvY2tldC5fcHJpdmF0ZVNlbmRNYWNoaW5lRXZlbnQoeyB0eXBlOiBcIkVYUExJQ0lUX1NPQ0tFVF9DTE9TRVwiLCBldmVudCB9KSxcbiAgICAgICAgICByYXdTZW5kOiAoZGF0YSkgPT4gbWFuYWdlZFNvY2tldC5zZW5kKGRhdGEpXG4gICAgICAgIH0sXG4gICAgICAgIGF0dGFjaG1lbnRVcmxzU3RvcmU6IGh0dHBDbGllbnQuZ2V0T3JDcmVhdGVBdHRhY2htZW50VXJsc1N0b3JlKHJvb21JZClcbiAgICAgIH0sXG4gICAgICBpZDogcm9vbUlkLFxuICAgICAgc3Vic2NyaWJlOiBtYWtlQ2xhc3NpY1N1YnNjcmliZUZuKFxuICAgICAgICByb29tSWQsXG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgY29uZmlnLmVycm9yRXZlbnRTb3VyY2VcbiAgICAgICksXG4gICAgICBjb25uZWN0OiAoKSA9PiBtYW5hZ2VkU29ja2V0LmNvbm5lY3QoKSxcbiAgICAgIHJlY29ubmVjdDogKCkgPT4gbWFuYWdlZFNvY2tldC5yZWNvbm5lY3QoKSxcbiAgICAgIGRpc2Nvbm5lY3Q6ICgpID0+IG1hbmFnZWRTb2NrZXQuZGlzY29ubmVjdCgpLFxuICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJvb21XaWxsRGVzdHJveSwgLi4uZXZlbnRzRXhjZXB0RGVzdHJveSB9ID0gZXZlbnRIdWI7XG4gICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIE9iamVjdC52YWx1ZXMoZXZlbnRzRXhjZXB0RGVzdHJveSkpIHtcbiAgICAgICAgICBzb3VyY2VbU3ltYm9sLmRpc3Bvc2VdKCk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRIdWIucm9vbVdpbGxEZXN0cm95Lm5vdGlmeSgpO1xuICAgICAgICBjb250ZXh0Lnlqc1Byb3ZpZGVyPy5vZmYoXCJzdGF0dXNcIiwgeWpzU3RhdHVzRGlkQ2hhbmdlKTtcbiAgICAgICAgc3luY1NvdXJjZUZvclN0b3JhZ2UuZGVzdHJveSgpO1xuICAgICAgICBzeW5jU291cmNlRm9yWWpzLmRlc3Ryb3koKTtcbiAgICAgICAgdW5pbnN0YWxsQmdUYWJTcHkoKTtcbiAgICAgICAgbWFuYWdlZFNvY2tldC5kZXN0cm95KCk7XG4gICAgICAgIHJvb21XaWxsRGVzdHJveVtTeW1ib2wuZGlzcG9zZV0oKTtcbiAgICAgIH0sXG4gICAgICAvLyBQcmVzZW5jZVxuICAgICAgdXBkYXRlUHJlc2VuY2UsXG4gICAgICB1cGRhdGVZRG9jLFxuICAgICAgYnJvYWRjYXN0RXZlbnQsXG4gICAgICAvLyBTdG9yYWdlXG4gICAgICBiYXRjaDogYmF0Y2gyLFxuICAgICAgaGlzdG9yeToge1xuICAgICAgICB1bmRvLFxuICAgICAgICByZWRvLFxuICAgICAgICBjYW5VbmRvLFxuICAgICAgICBjYW5SZWRvLFxuICAgICAgICBjbGVhcixcbiAgICAgICAgcGF1c2U6IHBhdXNlSGlzdG9yeSxcbiAgICAgICAgcmVzdW1lOiByZXN1bWVIaXN0b3J5XG4gICAgICB9LFxuICAgICAgZmV0Y2hZRG9jLFxuICAgICAgZ2V0U3RvcmFnZSxcbiAgICAgIGdldFN0b3JhZ2VTbmFwc2hvdCxcbiAgICAgIGdldFN0b3JhZ2VTdGF0dXMsXG4gICAgICBpc1ByZXNlbmNlUmVhZHksXG4gICAgICBpc1N0b3JhZ2VSZWFkeSxcbiAgICAgIHdhaXRVbnRpbFByZXNlbmNlUmVhZHk6IG1lbW9pemVPblN1Y2Nlc3Mod2FpdFVudGlsUHJlc2VuY2VSZWFkeSksXG4gICAgICB3YWl0VW50aWxTdG9yYWdlUmVhZHk6IG1lbW9pemVPblN1Y2Nlc3Mod2FpdFVudGlsU3RvcmFnZVJlYWR5KSxcbiAgICAgIGV2ZW50cyxcbiAgICAgIC8vIENvcmVcbiAgICAgIGdldFN0YXR1czogKCkgPT4gbWFuYWdlZFNvY2tldC5nZXRTdGF0dXMoKSxcbiAgICAgIGdldFNlbGY6ICgpID0+IHNlbGYuZ2V0KCksXG4gICAgICAvLyBQcmVzZW5jZVxuICAgICAgZ2V0UHJlc2VuY2U6ICgpID0+IGNvbnRleHQubXlQcmVzZW5jZS5nZXQoKSxcbiAgICAgIGdldE90aGVyczogKCkgPT4gY29udGV4dC5vdGhlcnMuZ2V0KCksXG4gICAgICAvLyBDb21tZW50c1xuICAgICAgZ2V0VGhyZWFkcyxcbiAgICAgIGdldFRocmVhZHNTaW5jZSxcbiAgICAgIGdldFRocmVhZCxcbiAgICAgIGNyZWF0ZVRocmVhZCxcbiAgICAgIGRlbGV0ZVRocmVhZCxcbiAgICAgIGVkaXRUaHJlYWRNZXRhZGF0YSxcbiAgICAgIG1hcmtUaHJlYWRBc1Jlc29sdmVkLFxuICAgICAgbWFya1RocmVhZEFzVW5yZXNvbHZlZCxcbiAgICAgIGNyZWF0ZUNvbW1lbnQsXG4gICAgICBlZGl0Q29tbWVudCxcbiAgICAgIGRlbGV0ZUNvbW1lbnQsXG4gICAgICBhZGRSZWFjdGlvbixcbiAgICAgIHJlbW92ZVJlYWN0aW9uLFxuICAgICAgcHJlcGFyZUF0dGFjaG1lbnQsXG4gICAgICB1cGxvYWRBdHRhY2htZW50LFxuICAgICAgZ2V0QXR0YWNobWVudFVybCxcbiAgICAgIC8vIE5vdGlmaWNhdGlvbnNcbiAgICAgIGdldE5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgICAgdXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgICBtYXJrSW5ib3hOb3RpZmljYXRpb25Bc1JlYWRcbiAgICB9LFxuICAgIC8vIEV4cGxpY3RseSBtYWtlIHRoZSBpbnRlcm5hbCBmaWVsZCBub24tZW51bWVyYWJsZSwgdG8gYXZvaWQgYWdncmVzc2l2ZVxuICAgIC8vIGZyZWV6aW5nIHdoZW4gdXNlZCB3aXRoIEltbWVyXG4gICAga0ludGVybmFsLFxuICAgIHsgZW51bWVyYWJsZTogZmFsc2UgfVxuICApO1xufVxuZnVuY3Rpb24gbWFrZUNsYXNzaWNTdWJzY3JpYmVGbihyb29tSWQsIGV2ZW50cywgZXJyb3JFdmVudHMpIHtcbiAgZnVuY3Rpb24gc3Vic2NyaWJlVG9MaXZlU3RydWN0dXJlRGVlcGx5KG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGV2ZW50cy5zdG9yYWdlQmF0Y2guc3Vic2NyaWJlKCh1cGRhdGVzKSA9PiB7XG4gICAgICBjb25zdCByZWxhdGVkVXBkYXRlcyA9IHVwZGF0ZXMuZmlsdGVyKFxuICAgICAgICAodXBkYXRlKSA9PiBpc1NhbWVOb2RlT3JDaGlsZE9mKHVwZGF0ZS5ub2RlLCBub2RlKVxuICAgICAgKTtcbiAgICAgIGlmIChyZWxhdGVkVXBkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNhbGxiYWNrKHJlbGF0ZWRVcGRhdGVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmVUb0xpdmVTdHJ1Y3R1cmVTaGFsbG93bHkobm9kZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZXZlbnRzLnN0b3JhZ2VCYXRjaC5zdWJzY3JpYmUoKHVwZGF0ZXMpID0+IHtcbiAgICAgIGZvciAoY29uc3QgdXBkYXRlIG9mIHVwZGF0ZXMpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS5ub2RlLl9pZCA9PT0gbm9kZS5faWQpIHtcbiAgICAgICAgICBjYWxsYmFjayh1cGRhdGUubm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmUoZmlyc3QsIHNlY29uZCwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgZmlyc3QgPT09IFwic3RyaW5nXCIgJiYgaXNSb29tRXZlbnROYW1lKGZpcnN0KSkge1xuICAgICAgaWYgKHR5cGVvZiBzZWNvbmQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIGNhbGxiYWNrIGZ1bmN0aW9uXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FsbGJhY2sgPSBzZWNvbmQ7XG4gICAgICBzd2l0Y2ggKGZpcnN0KSB7XG4gICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuY3VzdG9tRXZlbnQuc3Vic2NyaWJlKFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwibXktcHJlc2VuY2VcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLm15UHJlc2VuY2Uuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICAgICAgY2FzZSBcIm90aGVyc1wiOiB7XG4gICAgICAgICAgY29uc3QgY2IgPSBjYWxsYmFjaztcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLm90aGVycy5zdWJzY3JpYmUoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG90aGVycywgLi4uaW50ZXJuYWxFdmVudCB9ID0gZXZlbnQ7XG4gICAgICAgICAgICByZXR1cm4gY2Iob3RoZXJzLCBpbnRlcm5hbEV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICAgIHJldHVybiBlcnJvckV2ZW50cy5zdWJzY3JpYmUoKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVyci5yb29tSWQgPT09IHJvb21JZCkge1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwic3RhdHVzXCI6XG4gICAgICAgICAgcmV0dXJuIGV2ZW50cy5zdGF0dXMuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgICAgICAgY2FzZSBcImxvc3QtY29ubmVjdGlvblwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMubG9zdENvbm5lY3Rpb24uc3Vic2NyaWJlKFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwiaGlzdG9yeVwiOlxuICAgICAgICAgIHJldHVybiBldmVudHMuaGlzdG9yeS5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICBjYXNlIFwic3RvcmFnZS1zdGF0dXNcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLnN0b3JhZ2VTdGF0dXMuc3Vic2NyaWJlKFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwiY29tbWVudHNcIjpcbiAgICAgICAgICByZXR1cm4gZXZlbnRzLmNvbW1lbnRzLnN1YnNjcmliZShcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIoXG4gICAgICAgICAgICBmaXJzdCxcbiAgICAgICAgICAgIGBcIiR7U3RyaW5nKGZpcnN0KX1cIiBpcyBub3QgYSB2YWxpZCBldmVudCBuYW1lYFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzZWNvbmQgPT09IHZvaWQgMCB8fCB0eXBlb2YgZmlyc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VDYWxsYmFjayA9IGZpcnN0O1xuICAgICAgICByZXR1cm4gZXZlbnRzLnN0b3JhZ2VCYXRjaC5zdWJzY3JpYmUoc3RvcmFnZUNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBzcGVjaWZ5IGEgbGlzdGVuZXIgY2FsbGJhY2tcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0xpdmVOb2RlKGZpcnN0KSkge1xuICAgICAgY29uc3Qgbm9kZSA9IGZpcnN0O1xuICAgICAgaWYgKG9wdGlvbnM/LmlzRGVlcCkge1xuICAgICAgICBjb25zdCBzdG9yYWdlQ2FsbGJhY2sgPSBzZWNvbmQ7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVUb0xpdmVTdHJ1Y3R1cmVEZWVwbHkobm9kZSwgc3RvcmFnZUNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5vZGVDYWxsYmFjayA9IHNlY29uZDtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZVRvTGl2ZVN0cnVjdHVyZVNoYWxsb3dseShub2RlLCBub2RlQ2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgJHtTdHJpbmcoZmlyc3QpfSBpcyBub3QgYSB2YWx1ZSB0aGF0IGNhbiBiZSBzdWJzY3JpYmVkIHRvLmBcbiAgICApO1xuICB9XG4gIHJldHVybiBzdWJzY3JpYmU7XG59XG5mdW5jdGlvbiBpc1Jvb21FdmVudE5hbWUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBcIm15LXByZXNlbmNlXCIgfHwgdmFsdWUgPT09IFwib3RoZXJzXCIgfHwgdmFsdWUgPT09IFwiZXZlbnRcIiB8fCB2YWx1ZSA9PT0gXCJlcnJvclwiIHx8IHZhbHVlID09PSBcImhpc3RvcnlcIiB8fCB2YWx1ZSA9PT0gXCJzdGF0dXNcIiB8fCB2YWx1ZSA9PT0gXCJzdG9yYWdlLXN0YXR1c1wiIHx8IHZhbHVlID09PSBcImxvc3QtY29ubmVjdGlvblwiIHx8IHZhbHVlID09PSBcImNvbm5lY3Rpb25cIiB8fCB2YWx1ZSA9PT0gXCJjb21tZW50c1wiO1xufVxuZnVuY3Rpb24gbWFrZUF1dGhEZWxlZ2F0ZUZvclJvb20ocm9vbUlkLCBhdXRoTWFuYWdlcikge1xuICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgIHJldHVybiBhdXRoTWFuYWdlci5nZXRBdXRoVmFsdWUoeyByZXF1ZXN0ZWRTY29wZTogXCJyb29tOnJlYWRcIiwgcm9vbUlkIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gbWFrZUNyZWF0ZVNvY2tldERlbGVnYXRlRm9yUm9vbShyb29tSWQsIGJhc2VVcmwsIFdlYlNvY2tldFBvbHlmaWxsKSB7XG4gIHJldHVybiAoYXV0aFZhbHVlKSA9PiB7XG4gICAgY29uc3Qgd3MgPSBXZWJTb2NrZXRQb2x5ZmlsbCA/PyAodHlwZW9mIFdlYlNvY2tldCA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IFdlYlNvY2tldCk7XG4gICAgaWYgKHdzID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBTdG9wUmV0cnlpbmcoXG4gICAgICAgIFwiVG8gdXNlIExpdmVibG9ja3MgY2xpZW50IGluIGEgbm9uLURPTSBlbnZpcm9ubWVudCwgeW91IG5lZWQgdG8gcHJvdmlkZSBhIFdlYlNvY2tldCBwb2x5ZmlsbC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdXJsMiA9IG5ldyBVUkwoYmFzZVVybCk7XG4gICAgdXJsMi5wcm90b2NvbCA9IHVybDIucHJvdG9jb2wgPT09IFwiaHR0cDpcIiA/IFwid3NcIiA6IFwid3NzXCI7XG4gICAgdXJsMi5wYXRobmFtZSA9IFwiL3Y3XCI7XG4gICAgdXJsMi5zZWFyY2hQYXJhbXMuc2V0KFwicm9vbUlkXCIsIHJvb21JZCk7XG4gICAgaWYgKGF1dGhWYWx1ZS50eXBlID09PSBcInNlY3JldFwiKSB7XG4gICAgICB1cmwyLnNlYXJjaFBhcmFtcy5zZXQoXCJ0b2tcIiwgYXV0aFZhbHVlLnRva2VuLnJhdyk7XG4gICAgfSBlbHNlIGlmIChhdXRoVmFsdWUudHlwZSA9PT0gXCJwdWJsaWNcIikge1xuICAgICAgdXJsMi5zZWFyY2hQYXJhbXMuc2V0KFwicHVia2V5XCIsIGF1dGhWYWx1ZS5wdWJsaWNBcGlLZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXNzZXJ0TmV2ZXIoYXV0aFZhbHVlLCBcIlVuaGFuZGxlZCBjYXNlXCIpO1xuICAgIH1cbiAgICB1cmwyLnNlYXJjaFBhcmFtcy5zZXQoXCJ2ZXJzaW9uXCIsIFBLR19WRVJTSU9OIHx8IFwiZGV2XCIpO1xuICAgIHJldHVybiBuZXcgd3ModXJsMi50b1N0cmluZygpKTtcbiAgfTtcbn1cblxuLy8gc3JjL2NsaWVudC50c1xudmFyIE1JTl9USFJPVFRMRSA9IDE2O1xudmFyIE1BWF9USFJPVFRMRSA9IDFlMztcbnZhciBERUZBVUxUX1RIUk9UVExFID0gMTAwO1xudmFyIE1JTl9CQUNLR1JPVU5EX0tFRVBfQUxJVkVfVElNRU9VVCA9IDE1ZTM7XG52YXIgTUlOX0xPU1RfQ09OTkVDVElPTl9USU1FT1VUID0gMjAwO1xudmFyIFJFQ09NTUVOREVEX01JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDFlMztcbnZhciBNQVhfTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQgPSAzZTQ7XG52YXIgREVGQVVMVF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDVlMztcbnZhciBSRVNPTFZFX1VTRVJTX0JBVENIX0RFTEFZID0gNTA7XG52YXIgUkVTT0xWRV9ST09NU19JTkZPX0JBVENIX0RFTEFZID0gNTA7XG5mdW5jdGlvbiBnZXRCYXNlVXJsKGJhc2VVcmwpIHtcbiAgaWYgKHR5cGVvZiBiYXNlVXJsID09PSBcInN0cmluZ1wiICYmIGJhc2VVcmwuc3RhcnRzV2l0aChcImh0dHBcIikpIHtcbiAgICByZXR1cm4gYmFzZVVybDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gREVGQVVMVF9CQVNFX1VSTDtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50KG9wdGlvbnMpIHtcbiAgY29uc3QgY2xpZW50T3B0aW9ucyA9IG9wdGlvbnM7XG4gIGNvbnN0IHRocm90dGxlRGVsYXkgPSBnZXRUaHJvdHRsZShjbGllbnRPcHRpb25zLnRocm90dGxlID8/IERFRkFVTFRfVEhST1RUTEUpO1xuICBjb25zdCBsb3N0Q29ubmVjdGlvblRpbWVvdXQgPSBnZXRMb3N0Q29ubmVjdGlvblRpbWVvdXQoXG4gICAgY2xpZW50T3B0aW9ucy5sb3N0Q29ubmVjdGlvblRpbWVvdXQgPz8gREVGQVVMVF9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVFxuICApO1xuICBjb25zdCBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCA9IGdldEJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0KFxuICAgIGNsaWVudE9wdGlvbnMuYmFja2dyb3VuZEtlZXBBbGl2ZVRpbWVvdXRcbiAgKTtcbiAgY29uc3QgYmFzZVVybCA9IGdldEJhc2VVcmwoY2xpZW50T3B0aW9ucy5iYXNlVXJsKTtcbiAgY29uc3QgY3VycmVudFVzZXJJZCA9IG5ldyBTaWduYWwodm9pZCAwKTtcbiAgY29uc3QgYXV0aE1hbmFnZXIgPSBjcmVhdGVBdXRoTWFuYWdlcihvcHRpb25zLCAodG9rZW4pID0+IHtcbiAgICBjb25zdCB1c2VySWQgPSB0b2tlbi5rID09PSBcInNlYy1sZWdhY3lcIiAvKiBTRUNSRVRfTEVHQUNZICovID8gdG9rZW4uaWQgOiB0b2tlbi51aWQ7XG4gICAgY3VycmVudFVzZXJJZC5zZXQoKCkgPT4gdXNlcklkKTtcbiAgfSk7XG4gIGNvbnN0IGZldGNoUG9seWZpbGwgPSBjbGllbnRPcHRpb25zLnBvbHlmaWxscz8uZmV0Y2ggfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2xvYmFsVGhpcy5mZXRjaD8uYmluZChnbG9iYWxUaGlzKTtcbiAgY29uc3QgaHR0cENsaWVudCA9IGNyZWF0ZUFwaUNsaWVudCh7XG4gICAgYmFzZVVybCxcbiAgICBmZXRjaFBvbHlmaWxsLFxuICAgIGF1dGhNYW5hZ2VyXG4gIH0pO1xuICBjb25zdCByb29tc0J5SWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiB0ZWFyZG93blJvb20ocm9vbSkge1xuICAgIHVubGlua0RldlRvb2xzKHJvb20uaWQpO1xuICAgIHJvb21zQnlJZC5kZWxldGUocm9vbS5pZCk7XG4gICAgcm9vbS5kZXN0cm95KCk7XG4gIH1cbiAgZnVuY3Rpb24gbGVhc2VSb29tKGRldGFpbHMpIHtcbiAgICBjb25zdCBsZWF2ZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGYgPSBsZWF2ZTtcbiAgICAgIGlmICghZGV0YWlscy51bnN1YnMuZGVsZXRlKHNlbGYpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJUaGlzIGxlYXZlIGZ1bmN0aW9uIHdhcyBhbHJlYWR5IGNhbGxlZC4gQ2FsbGluZyBpdCBtb3JlIHRoYW4gb25jZSBoYXMgbm8gZWZmZWN0LlwiXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZGV0YWlscy51bnN1YnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRlYXJkb3duUm9vbShkZXRhaWxzLnJvb20pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBkZXRhaWxzLnVuc3Vicy5hZGQobGVhdmUpO1xuICAgIHJldHVybiB7XG4gICAgICByb29tOiBkZXRhaWxzLnJvb20sXG4gICAgICBsZWF2ZVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZW50ZXJSb29tKHJvb21JZCwgLi4uYXJncykge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gcm9vbXNCeUlkLmdldChyb29tSWQpO1xuICAgIGlmIChleGlzdGluZyAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbGVhc2VSb29tKGV4aXN0aW5nKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9uczIgPSBhcmdzWzBdID8/IHt9O1xuICAgIGNvbnN0IGluaXRpYWxQcmVzZW5jZSA9ICh0eXBlb2Ygb3B0aW9uczIuaW5pdGlhbFByZXNlbmNlID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zMi5pbml0aWFsUHJlc2VuY2Uocm9vbUlkKSA6IG9wdGlvbnMyLmluaXRpYWxQcmVzZW5jZSkgPz8ge307XG4gICAgY29uc3QgaW5pdGlhbFN0b3JhZ2UgPSAodHlwZW9mIG9wdGlvbnMyLmluaXRpYWxTdG9yYWdlID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zMi5pbml0aWFsU3RvcmFnZShyb29tSWQpIDogb3B0aW9uczIuaW5pdGlhbFN0b3JhZ2UpID8/IHt9O1xuICAgIGNvbnN0IG5ld1Jvb20gPSBjcmVhdGVSb29tKFxuICAgICAgeyBpbml0aWFsUHJlc2VuY2UsIGluaXRpYWxTdG9yYWdlIH0sXG4gICAgICB7XG4gICAgICAgIHJvb21JZCxcbiAgICAgICAgdGhyb3R0bGVEZWxheSxcbiAgICAgICAgbG9zdENvbm5lY3Rpb25UaW1lb3V0LFxuICAgICAgICBiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dCxcbiAgICAgICAgcG9seWZpbGxzOiBjbGllbnRPcHRpb25zLnBvbHlmaWxscyxcbiAgICAgICAgZGVsZWdhdGVzOiBjbGllbnRPcHRpb25zLm1vY2tlZERlbGVnYXRlcyA/PyB7XG4gICAgICAgICAgY3JlYXRlU29ja2V0OiBtYWtlQ3JlYXRlU29ja2V0RGVsZWdhdGVGb3JSb29tKFxuICAgICAgICAgICAgcm9vbUlkLFxuICAgICAgICAgICAgYmFzZVVybCxcbiAgICAgICAgICAgIGNsaWVudE9wdGlvbnMucG9seWZpbGxzPy5XZWJTb2NrZXRcbiAgICAgICAgICApLFxuICAgICAgICAgIGF1dGhlbnRpY2F0ZTogbWFrZUF1dGhEZWxlZ2F0ZUZvclJvb20ocm9vbUlkLCBhdXRoTWFuYWdlcilcbiAgICAgICAgfSxcbiAgICAgICAgZW5hYmxlRGVidWdMb2dnaW5nOiBjbGllbnRPcHRpb25zLmVuYWJsZURlYnVnTG9nZ2luZyxcbiAgICAgICAgYmFzZVVybCxcbiAgICAgICAgZXJyb3JFdmVudFNvdXJjZTogbGl2ZWJsb2Nrc0Vycm9yU291cmNlLFxuICAgICAgICBsYXJnZU1lc3NhZ2VTdHJhdGVneTogY2xpZW50T3B0aW9ucy5sYXJnZU1lc3NhZ2VTdHJhdGVneSA/PyAoY2xpZW50T3B0aW9ucy51bnN0YWJsZV9mYWxsYmFja1RvSFRUUCA/IFwiZXhwZXJpbWVudGFsLWZhbGxiYWNrLXRvLWh0dHBcIiA6IHZvaWQgMCksXG4gICAgICAgIHVuc3RhYmxlX3N0cmVhbURhdGE6ICEhY2xpZW50T3B0aW9ucy51bnN0YWJsZV9zdHJlYW1EYXRhLFxuICAgICAgICByb29tSHR0cENsaWVudDogaHR0cENsaWVudCxcbiAgICAgICAgY3JlYXRlU3luY1NvdXJjZVxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgbmV3Um9vbURldGFpbHMgPSB7XG4gICAgICByb29tOiBuZXdSb29tLFxuICAgICAgdW5zdWJzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gICAgfTtcbiAgICByb29tc0J5SWQuc2V0KHJvb21JZCwgbmV3Um9vbURldGFpbHMpO1xuICAgIHNldHVwRGV2VG9vbHMoKCkgPT4gQXJyYXkuZnJvbShyb29tc0J5SWQua2V5cygpKSk7XG4gICAgbGlua0RldlRvb2xzKHJvb21JZCwgbmV3Um9vbSk7XG4gICAgY29uc3Qgc2hvdWxkQ29ubmVjdCA9IG9wdGlvbnMyLmF1dG9Db25uZWN0ID8/IHRydWU7XG4gICAgaWYgKHNob3VsZENvbm5lY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgYXRvYiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoY2xpZW50T3B0aW9ucy5wb2x5ZmlsbHM/LmF0b2IgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiWW91IG5lZWQgdG8gcG9seWZpbGwgYXRvYiB0byB1c2UgdGhlIGNsaWVudCBpbiB5b3VyIGVudmlyb25tZW50LiBQbGVhc2UgZm9sbG93IHRoZSBpbnN0cnVjdGlvbnMgYXQgaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2xpdmVibG9ja3MtY2xpZW50L2F0b2ItcG9seWZpbGxcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFsLmF0b2IgPSBjbGllbnRPcHRpb25zLnBvbHlmaWxscy5hdG9iO1xuICAgICAgfVxuICAgICAgbmV3Um9vbS5jb25uZWN0KCk7XG4gICAgfVxuICAgIHJldHVybiBsZWFzZVJvb20obmV3Um9vbURldGFpbHMpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFJvb20ocm9vbUlkKSB7XG4gICAgY29uc3Qgcm9vbSA9IHJvb21zQnlJZC5nZXQocm9vbUlkKT8ucm9vbTtcbiAgICByZXR1cm4gcm9vbSA/IHJvb20gOiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGxvZ291dCgpIHtcbiAgICBhdXRoTWFuYWdlci5yZXNldCgpO1xuICAgIGN1cnJlbnRVc2VySWQuc2V0KCgpID0+IHZvaWQgMCk7XG4gICAgZm9yIChjb25zdCB7IHJvb20gfSBvZiByb29tc0J5SWQudmFsdWVzKCkpIHtcbiAgICAgIGlmICghaXNJZGxlKHJvb20uZ2V0U3RhdHVzKCkpKSB7XG4gICAgICAgIHJvb20ucmVjb25uZWN0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc29sdmVVc2VycyA9IGNsaWVudE9wdGlvbnMucmVzb2x2ZVVzZXJzO1xuICBjb25zdCB3YXJuSWZOb1Jlc29sdmVVc2VycyA9IGNyZWF0ZURldmVsb3BtZW50V2FybmluZyhcbiAgICAoKSA9PiAhcmVzb2x2ZVVzZXJzLFxuICAgIFwiU2V0IHRoZSByZXNvbHZlVXNlcnMgb3B0aW9uIGluIGNyZWF0ZUNsaWVudCB0byBzcGVjaWZ5IHVzZXIgaW5mby5cIlxuICApO1xuICBjb25zdCBiYXRjaGVkUmVzb2x2ZVVzZXJzID0gbmV3IEJhdGNoKFxuICAgIGFzeW5jIChiYXRjaGVkVXNlcklkcykgPT4ge1xuICAgICAgY29uc3QgdXNlcklkcyA9IGJhdGNoZWRVc2VySWRzLmZsYXQoKTtcbiAgICAgIGNvbnN0IHVzZXJzID0gYXdhaXQgcmVzb2x2ZVVzZXJzPy4oeyB1c2VySWRzIH0pO1xuICAgICAgd2FybklmTm9SZXNvbHZlVXNlcnMoKTtcbiAgICAgIHJldHVybiB1c2VycyA/PyB1c2VySWRzLm1hcCgoKSA9PiB2b2lkIDApO1xuICAgIH0sXG4gICAgeyBkZWxheTogUkVTT0xWRV9VU0VSU19CQVRDSF9ERUxBWSB9XG4gICk7XG4gIGNvbnN0IHVzZXJzU3RvcmUgPSBjcmVhdGVCYXRjaFN0b3JlKGJhdGNoZWRSZXNvbHZlVXNlcnMpO1xuICBmdW5jdGlvbiBpbnZhbGlkYXRlUmVzb2x2ZWRVc2Vycyh1c2VySWRzKSB7XG4gICAgdXNlcnNTdG9yZS5pbnZhbGlkYXRlKHVzZXJJZHMpO1xuICB9XG4gIGNvbnN0IHJlc29sdmVSb29tc0luZm8gPSBjbGllbnRPcHRpb25zLnJlc29sdmVSb29tc0luZm87XG4gIGNvbnN0IHdhcm5JZk5vUmVzb2x2ZVJvb21zSW5mbyA9IGNyZWF0ZURldmVsb3BtZW50V2FybmluZyhcbiAgICAoKSA9PiAhcmVzb2x2ZVJvb21zSW5mbyxcbiAgICBcIlNldCB0aGUgcmVzb2x2ZVJvb21zSW5mbyBvcHRpb24gaW4gY3JlYXRlQ2xpZW50IHRvIHNwZWNpZnkgcm9vbSBpbmZvLlwiXG4gICk7XG4gIGNvbnN0IGJhdGNoZWRSZXNvbHZlUm9vbXNJbmZvID0gbmV3IEJhdGNoKFxuICAgIGFzeW5jIChiYXRjaGVkUm9vbUlkcykgPT4ge1xuICAgICAgY29uc3Qgcm9vbUlkcyA9IGJhdGNoZWRSb29tSWRzLmZsYXQoKTtcbiAgICAgIGNvbnN0IHJvb21zSW5mbyA9IGF3YWl0IHJlc29sdmVSb29tc0luZm8/Lih7IHJvb21JZHMgfSk7XG4gICAgICB3YXJuSWZOb1Jlc29sdmVSb29tc0luZm8oKTtcbiAgICAgIHJldHVybiByb29tc0luZm8gPz8gcm9vbUlkcy5tYXAoKCkgPT4gdm9pZCAwKTtcbiAgICB9LFxuICAgIHsgZGVsYXk6IFJFU09MVkVfUk9PTVNfSU5GT19CQVRDSF9ERUxBWSB9XG4gICk7XG4gIGNvbnN0IHJvb21zSW5mb1N0b3JlID0gY3JlYXRlQmF0Y2hTdG9yZShiYXRjaGVkUmVzb2x2ZVJvb21zSW5mbyk7XG4gIGZ1bmN0aW9uIGludmFsaWRhdGVSZXNvbHZlZFJvb21zSW5mbyhyb29tSWRzKSB7XG4gICAgcm9vbXNJbmZvU3RvcmUuaW52YWxpZGF0ZShyb29tSWRzKTtcbiAgfVxuICBjb25zdCBtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIGludmFsaWRhdGVSZXNvbHZlZE1lbnRpb25TdWdnZXN0aW9ucygpIHtcbiAgICBtZW50aW9uU3VnZ2VzdGlvbnNDYWNoZS5jbGVhcigpO1xuICB9XG4gIGNvbnN0IHN5bmNTdGF0dXNTb3VyY2VzID0gW107XG4gIGNvbnN0IHN5bmNTdGF0dXNTaWduYWwgPSBuZXcgU2lnbmFsKFwic3luY2hyb25pemVkXCIpO1xuICBjb25zdCBsaXZlYmxvY2tzRXJyb3JTb3VyY2UgPSBtYWtlRXZlbnRTb3VyY2UoKTtcbiAgZnVuY3Rpb24gZ2V0U3luY1N0YXR1cygpIHtcbiAgICBjb25zdCBzdGF0dXMgPSBzeW5jU3RhdHVzU2lnbmFsLmdldCgpO1xuICAgIHJldHVybiBzdGF0dXMgPT09IFwic3luY2hyb25pemluZ1wiID8gc3RhdHVzIDogXCJzeW5jaHJvbml6ZWRcIjtcbiAgfVxuICBmdW5jdGlvbiByZWNvbXB1dGUoKSB7XG4gICAgc3luY1N0YXR1c1NpZ25hbC5zZXQoXG4gICAgICBzeW5jU3RhdHVzU291cmNlcy5zb21lKChzcmMpID0+IHNyYy5nZXQoKSA9PT0gXCJzeW5jaHJvbml6aW5nXCIpID8gXCJzeW5jaHJvbml6aW5nXCIgOiBzeW5jU3RhdHVzU291cmNlcy5zb21lKChzcmMpID0+IHNyYy5nZXQoKSA9PT0gXCJoYXMtbG9jYWwtY2hhbmdlc1wiKSA/IFwiaGFzLWxvY2FsLWNoYW5nZXNcIiA6IFwic3luY2hyb25pemVkXCJcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVN5bmNTb3VyY2UoKSB7XG4gICAgY29uc3Qgc291cmNlID0gbmV3IFNpZ25hbChcInN5bmNocm9uaXplZFwiKTtcbiAgICBzeW5jU3RhdHVzU291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgY29uc3QgdW5zdWIgPSBzb3VyY2Uuc3Vic2NyaWJlKCgpID0+IHJlY29tcHV0ZSgpKTtcbiAgICBmdW5jdGlvbiBzZXRTeW5jU3RhdHVzKHN0YXR1cykge1xuICAgICAgc291cmNlLnNldChzdGF0dXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdW5zdWIoKTtcbiAgICAgIGNvbnN0IGluZGV4ID0gc3luY1N0YXR1c1NvdXJjZXMuZmluZEluZGV4KChpdGVtKSA9PiBpdGVtID09PSBzb3VyY2UpO1xuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgY29uc3QgW3JlZl0gPSBzeW5jU3RhdHVzU291cmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBjb25zdCB3YXNTdGlsbFBlbmRpbmcgPSByZWYuZ2V0KCkgIT09IFwic3luY2hyb25pemVkXCI7XG4gICAgICAgIGlmICh3YXNTdGlsbFBlbmRpbmcpIHtcbiAgICAgICAgICByZWNvbXB1dGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzZXRTeW5jU3RhdHVzLCBkZXN0cm95IH07XG4gIH1cbiAge1xuICAgIGNvbnN0IG1heWJlUHJldmVudENsb3NlID0gKGUpID0+IHtcbiAgICAgIGlmIChjbGllbnRPcHRpb25zLnByZXZlbnRVbnNhdmVkQ2hhbmdlcyAmJiBzeW5jU3RhdHVzU2lnbmFsLmdldCgpICE9PSBcInN5bmNocm9uaXplZFwiKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB2b2lkIDA7XG4gICAgd2luPy5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIG1heWJlUHJldmVudENsb3NlKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBnZXROb3RpZmljYXRpb25TZXR0aW5ncyhvcHRpb25zMikge1xuICAgIGNvbnN0IHBsYWluU2V0dGluZ3MgPSBhd2FpdCBodHRwQ2xpZW50LmdldFVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyhvcHRpb25zMik7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBjcmVhdGVVc2VyTm90aWZpY2F0aW9uU2V0dGluZ3MocGxhaW5TZXR0aW5ncyk7XG4gICAgcmV0dXJuIHNldHRpbmdzO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZU5vdGlmaWNhdGlvblNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgY29uc3QgcGxhaW5TZXR0aW5ncyA9IGF3YWl0IGh0dHBDbGllbnQudXBkYXRlVXNlck5vdGlmaWNhdGlvblNldHRpbmdzKHNldHRpbmdzKTtcbiAgICBjb25zdCBzZXR0aW5nc09iamVjdCA9IGNyZWF0ZVVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyhwbGFpblNldHRpbmdzKTtcbiAgICByZXR1cm4gc2V0dGluZ3NPYmplY3Q7XG4gIH1cbiAgY29uc3QgY2xpZW50ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIHtcbiAgICAgIGVudGVyUm9vbSxcbiAgICAgIGdldFJvb20sXG4gICAgICBsb2dvdXQsXG4gICAgICAvLyBQdWJsaWMgaW5ib3ggbm90aWZpY2F0aW9ucyBBUElcbiAgICAgIGdldEluYm94Tm90aWZpY2F0aW9uczogaHR0cENsaWVudC5nZXRJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICBnZXRJbmJveE5vdGlmaWNhdGlvbnNTaW5jZTogaHR0cENsaWVudC5nZXRJbmJveE5vdGlmaWNhdGlvbnNTaW5jZSxcbiAgICAgIGdldFVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50OiBodHRwQ2xpZW50LmdldFVucmVhZEluYm94Tm90aWZpY2F0aW9uc0NvdW50LFxuICAgICAgbWFya0FsbEluYm94Tm90aWZpY2F0aW9uc0FzUmVhZDogaHR0cENsaWVudC5tYXJrQWxsSW5ib3hOb3RpZmljYXRpb25zQXNSZWFkLFxuICAgICAgbWFya0luYm94Tm90aWZpY2F0aW9uQXNSZWFkOiBodHRwQ2xpZW50Lm1hcmtJbmJveE5vdGlmaWNhdGlvbkFzUmVhZCxcbiAgICAgIGRlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9uczogaHR0cENsaWVudC5kZWxldGVBbGxJbmJveE5vdGlmaWNhdGlvbnMsXG4gICAgICBkZWxldGVJbmJveE5vdGlmaWNhdGlvbjogaHR0cENsaWVudC5kZWxldGVJbmJveE5vdGlmaWNhdGlvbixcbiAgICAgIC8vIFB1YmxpYyB1c2VyIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBBUElcbiAgICAgIGdldE5vdGlmaWNhdGlvblNldHRpbmdzLFxuICAgICAgdXBkYXRlTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gICAgICAvLyBBZHZhbmNlZCByZXNvbHZlcnMgQVBJc1xuICAgICAgcmVzb2x2ZXJzOiB7XG4gICAgICAgIGludmFsaWRhdGVVc2VyczogaW52YWxpZGF0ZVJlc29sdmVkVXNlcnMsXG4gICAgICAgIGludmFsaWRhdGVSb29tc0luZm86IGludmFsaWRhdGVSZXNvbHZlZFJvb21zSW5mbyxcbiAgICAgICAgaW52YWxpZGF0ZU1lbnRpb25TdWdnZXN0aW9uczogaW52YWxpZGF0ZVJlc29sdmVkTWVudGlvblN1Z2dlc3Rpb25zXG4gICAgICB9LFxuICAgICAgZ2V0U3luY1N0YXR1cyxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICBlcnJvcjogbGl2ZWJsb2Nrc0Vycm9yU291cmNlLFxuICAgICAgICBzeW5jU3RhdHVzOiBzeW5jU3RhdHVzU2lnbmFsXG4gICAgICB9LFxuICAgICAgLy8gSW50ZXJuYWxcbiAgICAgIFtrSW50ZXJuYWxdOiB7XG4gICAgICAgIGN1cnJlbnRVc2VySWQsXG4gICAgICAgIG1lbnRpb25TdWdnZXN0aW9uc0NhY2hlLFxuICAgICAgICByZXNvbHZlTWVudGlvblN1Z2dlc3Rpb25zOiBjbGllbnRPcHRpb25zLnJlc29sdmVNZW50aW9uU3VnZ2VzdGlvbnMsXG4gICAgICAgIHVzZXJzU3RvcmUsXG4gICAgICAgIHJvb21zSW5mb1N0b3JlLFxuICAgICAgICBnZXRSb29tSWRzKCkge1xuICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHJvb21zQnlJZC5rZXlzKCkpO1xuICAgICAgICB9LFxuICAgICAgICBodHRwQ2xpZW50LFxuICAgICAgICAvLyBUeXBlLWxldmVsIGhlbHBlciBvbmx5LCBpdCdzIGVmZmVjdGl2ZWx5IG9ubHkgYW4gaWRlbnRpdHktZnVuY3Rpb24gYXQgcnVudGltZVxuICAgICAgICBhczogKCkgPT4gY2xpZW50LFxuICAgICAgICBjcmVhdGVTeW5jU291cmNlLFxuICAgICAgICBlbWl0RXJyb3I6IChjb250ZXh0LCBjYXVzZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGVycm9yMyA9IExpdmVibG9ja3NFcnJvci5mcm9tKGNvbnRleHQsIGNhdXNlKTtcbiAgICAgICAgICBjb25zdCBkaWROb3RpZnkgPSBsaXZlYmxvY2tzRXJyb3JTb3VyY2Uubm90aWZ5KGVycm9yMyk7XG4gICAgICAgICAgaWYgKCFkaWROb3RpZnkpIHtcbiAgICAgICAgICAgIGVycm9yMihlcnJvcjMubWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBrSW50ZXJuYWwsXG4gICAge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9XG4gICk7XG4gIHJldHVybiBjbGllbnQ7XG59XG5mdW5jdGlvbiBjaGVja0JvdW5kcyhvcHRpb24sIHZhbHVlLCBtaW4sIG1heCwgcmVjb21tZW5kZWRNaW4pIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIiB8fCB2YWx1ZSA8IG1pbiB8fCBtYXggIT09IHZvaWQgMCAmJiB2YWx1ZSA+IG1heCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIG1heCAhPT0gdm9pZCAwID8gYCR7b3B0aW9ufSBzaG91bGQgYmUgYmV0d2VlbiAke3JlY29tbWVuZGVkTWluID8/IG1pbn0gYW5kICR7bWF4fS5gIDogYCR7b3B0aW9ufSBzaG91bGQgYmUgYXQgbGVhc3QgJHtyZWNvbW1lbmRlZE1pbiA/PyBtaW59LmBcbiAgICApO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRLZWVwQWxpdmVUaW1lb3V0KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4gY2hlY2tCb3VuZHMoXG4gICAgXCJiYWNrZ3JvdW5kS2VlcEFsaXZlVGltZW91dFwiLFxuICAgIHZhbHVlLFxuICAgIE1JTl9CQUNLR1JPVU5EX0tFRVBfQUxJVkVfVElNRU9VVFxuICApO1xufVxuZnVuY3Rpb24gZ2V0VGhyb3R0bGUodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm91bmRzKFwidGhyb3R0bGVcIiwgdmFsdWUsIE1JTl9USFJPVFRMRSwgTUFYX1RIUk9UVExFKTtcbn1cbmZ1bmN0aW9uIGdldExvc3RDb25uZWN0aW9uVGltZW91dCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3VuZHMoXG4gICAgXCJsb3N0Q29ubmVjdGlvblRpbWVvdXRcIixcbiAgICB2YWx1ZSxcbiAgICBNSU5fTE9TVF9DT05ORUNUSU9OX1RJTUVPVVQsXG4gICAgTUFYX0xPU1RfQ09OTkVDVElPTl9USU1FT1VULFxuICAgIFJFQ09NTUVOREVEX01JTl9MT1NUX0NPTk5FQ1RJT05fVElNRU9VVFxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlRGV2ZWxvcG1lbnRXYXJuaW5nKGNvbmRpdGlvbiwgLi4uYXJncykge1xuICBsZXQgaGFzV2FybmVkID0gZmFsc2U7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKCFoYXNXYXJuZWQgJiYgKHR5cGVvZiBjb25kaXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IGNvbmRpdGlvbigpIDogY29uZGl0aW9uKSkge1xuICAgICAgICB3YXJuKC4uLmFyZ3MpO1xuICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9jb21tZW50cy9jb21tZW50LWJvZHkudHNcbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlQYXJhZ3JhcGgoZWxlbWVudCkge1xuICByZXR1cm4gXCJ0eXBlXCIgaW4gZWxlbWVudCAmJiBlbGVtZW50LnR5cGUgPT09IFwicGFyYWdyYXBoXCI7XG59XG5mdW5jdGlvbiBpc0NvbW1lbnRCb2R5VGV4dChlbGVtZW50KSB7XG4gIHJldHVybiAhKFwidHlwZVwiIGluIGVsZW1lbnQpICYmIFwidGV4dFwiIGluIGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQudGV4dCA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlNZW50aW9uKGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwidHlwZVwiIGluIGVsZW1lbnQgJiYgZWxlbWVudC50eXBlID09PSBcIm1lbnRpb25cIjtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudEJvZHlMaW5rKGVsZW1lbnQpIHtcbiAgcmV0dXJuIFwidHlwZVwiIGluIGVsZW1lbnQgJiYgZWxlbWVudC50eXBlID09PSBcImxpbmtcIjtcbn1cbnZhciBjb21tZW50Qm9keUVsZW1lbnRzR3VhcmRzID0ge1xuICBwYXJhZ3JhcGg6IGlzQ29tbWVudEJvZHlQYXJhZ3JhcGgsXG4gIHRleHQ6IGlzQ29tbWVudEJvZHlUZXh0LFxuICBsaW5rOiBpc0NvbW1lbnRCb2R5TGluayxcbiAgbWVudGlvbjogaXNDb21tZW50Qm9keU1lbnRpb25cbn07XG52YXIgY29tbWVudEJvZHlFbGVtZW50c1R5cGVzID0ge1xuICBwYXJhZ3JhcGg6IFwiYmxvY2tcIixcbiAgdGV4dDogXCJpbmxpbmVcIixcbiAgbGluazogXCJpbmxpbmVcIixcbiAgbWVudGlvbjogXCJpbmxpbmVcIlxufTtcbmZ1bmN0aW9uIHRyYXZlcnNlQ29tbWVudEJvZHkoYm9keSwgZWxlbWVudE9yVmlzaXRvciwgcG9zc2libHlWaXNpdG9yKSB7XG4gIGlmICghYm9keSB8fCAhYm9keT8uY29udGVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBlbGVtZW50ID0gdHlwZW9mIGVsZW1lbnRPclZpc2l0b3IgPT09IFwic3RyaW5nXCIgPyBlbGVtZW50T3JWaXNpdG9yIDogdm9pZCAwO1xuICBjb25zdCB0eXBlID0gZWxlbWVudCA/IGNvbW1lbnRCb2R5RWxlbWVudHNUeXBlc1tlbGVtZW50XSA6IFwiYWxsXCI7XG4gIGNvbnN0IGd1YXJkID0gZWxlbWVudCA/IGNvbW1lbnRCb2R5RWxlbWVudHNHdWFyZHNbZWxlbWVudF0gOiAoKSA9PiB0cnVlO1xuICBjb25zdCB2aXNpdG9yID0gdHlwZW9mIGVsZW1lbnRPclZpc2l0b3IgPT09IFwiZnVuY3Rpb25cIiA/IGVsZW1lbnRPclZpc2l0b3IgOiBwb3NzaWJseVZpc2l0b3I7XG4gIGZvciAoY29uc3QgYmxvY2sgb2YgYm9keS5jb250ZW50KSB7XG4gICAgaWYgKHR5cGUgPT09IFwiYWxsXCIgfHwgdHlwZSA9PT0gXCJibG9ja1wiKSB7XG4gICAgICBpZiAoZ3VhcmQoYmxvY2spKSB7XG4gICAgICAgIHZpc2l0b3I/LihibG9jayk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImFsbFwiIHx8IHR5cGUgPT09IFwiaW5saW5lXCIpIHtcbiAgICAgIGZvciAoY29uc3QgaW5saW5lIG9mIGJsb2NrLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChndWFyZChpbmxpbmUpKSB7XG4gICAgICAgICAgdmlzaXRvcj8uKGlubGluZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keShib2R5KSB7XG4gIGNvbnN0IG1lbnRpb25lZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHRyYXZlcnNlQ29tbWVudEJvZHkoXG4gICAgYm9keSxcbiAgICBcIm1lbnRpb25cIixcbiAgICAobWVudGlvbikgPT4gbWVudGlvbmVkSWRzLmFkZChtZW50aW9uLmlkKVxuICApO1xuICByZXR1cm4gQXJyYXkuZnJvbShtZW50aW9uZWRJZHMpO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVVzZXJzSW5Db21tZW50Qm9keShib2R5LCByZXNvbHZlVXNlcnMpIHtcbiAgY29uc3QgcmVzb2x2ZWRVc2VycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGlmICghcmVzb2x2ZVVzZXJzKSB7XG4gICAgcmV0dXJuIHJlc29sdmVkVXNlcnM7XG4gIH1cbiAgY29uc3QgdXNlcklkcyA9IGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keShib2R5KTtcbiAgY29uc3QgdXNlcnMgPSBhd2FpdCByZXNvbHZlVXNlcnMoe1xuICAgIHVzZXJJZHNcbiAgfSk7XG4gIGZvciAoY29uc3QgW2luZGV4LCB1c2VySWRdIG9mIHVzZXJJZHMuZW50cmllcygpKSB7XG4gICAgY29uc3QgdXNlciA9IHVzZXJzPy5baW5kZXhdO1xuICAgIGlmICh1c2VyKSB7XG4gICAgICByZXNvbHZlZFVzZXJzLnNldCh1c2VySWQsIHVzZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzb2x2ZWRVc2Vycztcbn1cbnZhciBodG1sRXNjYXBhYmxlcyA9IHtcbiAgXCImXCI6IFwiJmFtcDtcIixcbiAgXCI8XCI6IFwiJmx0O1wiLFxuICBcIj5cIjogXCImZ3Q7XCIsXG4gICdcIic6IFwiJnF1b3Q7XCIsXG4gIFwiJ1wiOiBcIiYjMzk7XCJcbn07XG52YXIgaHRtbEVzY2FwYWJsZXNSZWdleCA9IG5ldyBSZWdFeHAoXG4gIE9iamVjdC5rZXlzKGh0bWxFc2NhcGFibGVzKS5tYXAoKGVudGl0eSkgPT4gYFxcXFwke2VudGl0eX1gKS5qb2luKFwifFwiKSxcbiAgXCJnXCJcbik7XG5mdW5jdGlvbiBodG1sU2FmZSh2YWx1ZSkge1xuICByZXR1cm4gbmV3IEh0bWxTYWZlU3RyaW5nKFtTdHJpbmcodmFsdWUpXSwgW10pO1xufVxuZnVuY3Rpb24gam9pbkh0bWwoc3RyaW5ncykge1xuICBpZiAoc3RyaW5ncy5sZW5ndGggPD0gMCkge1xuICAgIHJldHVybiBuZXcgSHRtbFNhZmVTdHJpbmcoW1wiXCJdLCBbXSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBIdG1sU2FmZVN0cmluZyhcbiAgICBbXCJcIiwgLi4uQXJyYXkoc3RyaW5ncy5sZW5ndGggLSAxKS5maWxsKFwiXCIpLCBcIlwiXSxcbiAgICBzdHJpbmdzXG4gICk7XG59XG5mdW5jdGlvbiBlc2NhcGVIdG1sKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEh0bWxTYWZlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGpvaW5IdG1sKHZhbHVlKS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiBTdHJpbmcodmFsdWUpLnJlcGxhY2UoXG4gICAgaHRtbEVzY2FwYWJsZXNSZWdleCxcbiAgICAoY2hhcmFjdGVyKSA9PiBodG1sRXNjYXBhYmxlc1tjaGFyYWN0ZXJdXG4gICk7XG59XG52YXIgSHRtbFNhZmVTdHJpbmcgPSBjbGFzcyB7XG4gICNzdHJpbmdzO1xuICAjdmFsdWVzO1xuICBjb25zdHJ1Y3RvcihzdHJpbmdzLCB2YWx1ZXMyKSB7XG4gICAgdGhpcy4jc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgdGhpcy4jdmFsdWVzID0gdmFsdWVzMjtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RyaW5ncy5yZWR1Y2UoKHJlc3VsdCwgc3RyLCBpKSA9PiB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgZXNjYXBlSHRtbChubih0aGlzLiN2YWx1ZXNbaSAtIDFdKSkgKyBzdHI7XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBodG1sKHN0cmluZ3MsIC4uLnZhbHVlczIpIHtcbiAgcmV0dXJuIG5ldyBIdG1sU2FmZVN0cmluZyhzdHJpbmdzLCB2YWx1ZXMyKTtcbn1cbnZhciBtYXJrZG93bkVzY2FwYWJsZXMgPSB7XG4gIF86IFwiXFxcXF9cIixcbiAgXCIqXCI6IFwiXFxcXCpcIixcbiAgXCIjXCI6IFwiXFxcXCNcIixcbiAgXCJgXCI6IFwiXFxcXGBcIixcbiAgXCJ+XCI6IFwiXFxcXH5cIixcbiAgXCIhXCI6IFwiXFxcXCFcIixcbiAgXCJ8XCI6IFwiXFxcXHxcIixcbiAgXCIoXCI6IFwiXFxcXChcIixcbiAgXCIpXCI6IFwiXFxcXClcIixcbiAgXCJ7XCI6IFwiXFxcXHtcIixcbiAgXCJ9XCI6IFwiXFxcXH1cIixcbiAgXCJbXCI6IFwiXFxcXFtcIixcbiAgXCJdXCI6IFwiXFxcXF1cIlxufTtcbnZhciBtYXJrZG93bkVzY2FwYWJsZXNSZWdleCA9IG5ldyBSZWdFeHAoXG4gIE9iamVjdC5rZXlzKG1hcmtkb3duRXNjYXBhYmxlcykubWFwKChlbnRpdHkpID0+IGBcXFxcJHtlbnRpdHl9YCkuam9pbihcInxcIiksXG4gIFwiZ1wiXG4pO1xuZnVuY3Rpb24gam9pbk1hcmtkb3duKHN0cmluZ3MpIHtcbiAgaWYgKHN0cmluZ3MubGVuZ3RoIDw9IDApIHtcbiAgICByZXR1cm4gbmV3IE1hcmtkb3duU2FmZVN0cmluZyhbXCJcIl0sIFtdKTtcbiAgfVxuICByZXR1cm4gbmV3IE1hcmtkb3duU2FmZVN0cmluZyhcbiAgICBbXCJcIiwgLi4uQXJyYXkoc3RyaW5ncy5sZW5ndGggLSAxKS5maWxsKFwiXCIpLCBcIlwiXSxcbiAgICBzdHJpbmdzXG4gICk7XG59XG5mdW5jdGlvbiBlc2NhcGVNYXJrZG93bih2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXJrZG93blNhZmVTdHJpbmcpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gam9pbk1hcmtkb3duKHZhbHVlKS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiBTdHJpbmcodmFsdWUpLnJlcGxhY2UoXG4gICAgbWFya2Rvd25Fc2NhcGFibGVzUmVnZXgsXG4gICAgKGNoYXJhY3RlcikgPT4gbWFya2Rvd25Fc2NhcGFibGVzW2NoYXJhY3Rlcl1cbiAgKTtcbn1cbnZhciBNYXJrZG93blNhZmVTdHJpbmcgPSBjbGFzcyB7XG4gICNzdHJpbmdzO1xuICAjdmFsdWVzO1xuICBjb25zdHJ1Y3RvcihzdHJpbmdzLCB2YWx1ZXMyKSB7XG4gICAgdGhpcy4jc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgdGhpcy4jdmFsdWVzID0gdmFsdWVzMjtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RyaW5ncy5yZWR1Y2UoKHJlc3VsdCwgc3RyLCBpKSA9PiB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgZXNjYXBlTWFya2Rvd24obm4odGhpcy4jdmFsdWVzW2kgLSAxXSkpICsgc3RyO1xuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gbWFya2Rvd24oc3RyaW5ncywgLi4udmFsdWVzMikge1xuICByZXR1cm4gbmV3IE1hcmtkb3duU2FmZVN0cmluZyhzdHJpbmdzLCB2YWx1ZXMyKTtcbn1cbmZ1bmN0aW9uIHRvQWJzb2x1dGVVcmwodXJsMikge1xuICBpZiAodXJsMi5zdGFydHNXaXRoKFwiaHR0cDovL1wiKSB8fCB1cmwyLnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKSkge1xuICAgIHJldHVybiB1cmwyO1xuICB9IGVsc2UgaWYgKHVybDIuc3RhcnRzV2l0aChcInd3dy5cIikpIHtcbiAgICByZXR1cm4gXCJodHRwczovL1wiICsgdXJsMjtcbiAgfVxuICByZXR1cm47XG59XG52YXIgc3RyaW5naWZ5Q29tbWVudEJvZHlQbGFpbkVsZW1lbnRzID0ge1xuICBwYXJhZ3JhcGg6ICh7IGNoaWxkcmVuIH0pID0+IGNoaWxkcmVuLFxuICB0ZXh0OiAoeyBlbGVtZW50IH0pID0+IGVsZW1lbnQudGV4dCxcbiAgbGluazogKHsgZWxlbWVudCB9KSA9PiBlbGVtZW50LnRleHQgPz8gZWxlbWVudC51cmwsXG4gIG1lbnRpb246ICh7IGVsZW1lbnQsIHVzZXIgfSkgPT4ge1xuICAgIHJldHVybiBgQCR7dXNlcj8ubmFtZSA/PyBlbGVtZW50LmlkfWA7XG4gIH1cbn07XG52YXIgc3RyaW5naWZ5Q29tbWVudEJvZHlIdG1sRWxlbWVudHMgPSB7XG4gIHBhcmFncmFwaDogKHsgY2hpbGRyZW4gfSkgPT4ge1xuICAgIHJldHVybiBjaGlsZHJlbiA/IGh0bWxgPHA+JHtodG1sU2FmZShjaGlsZHJlbil9PC9wPmAgOiBjaGlsZHJlbjtcbiAgfSxcbiAgdGV4dDogKHsgZWxlbWVudCB9KSA9PiB7XG4gICAgbGV0IGNoaWxkcmVuID0gZWxlbWVudC50ZXh0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBodG1sYCR7Y2hpbGRyZW59YDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuYm9sZCkge1xuICAgICAgY2hpbGRyZW4gPSBodG1sYDxzdHJvbmc+JHtjaGlsZHJlbn08L3N0cm9uZz5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5pdGFsaWMpIHtcbiAgICAgIGNoaWxkcmVuID0gaHRtbGA8ZW0+JHtjaGlsZHJlbn08L2VtPmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnN0cmlrZXRocm91Z2gpIHtcbiAgICAgIGNoaWxkcmVuID0gaHRtbGA8cz4ke2NoaWxkcmVufTwvcz5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5jb2RlKSB7XG4gICAgICBjaGlsZHJlbiA9IGh0bWxgPGNvZGU+JHtjaGlsZHJlbn08L2NvZGU+YDtcbiAgICB9XG4gICAgcmV0dXJuIGh0bWxgJHtjaGlsZHJlbn1gO1xuICB9LFxuICBsaW5rOiAoeyBlbGVtZW50LCBocmVmIH0pID0+IHtcbiAgICByZXR1cm4gaHRtbGA8YSBocmVmPVwiJHtocmVmfVwiIHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIj4ke2VsZW1lbnQudGV4dCA/IGh0bWxgJHtlbGVtZW50LnRleHR9YCA6IGVsZW1lbnQudXJsfTwvYT5gO1xuICB9LFxuICBtZW50aW9uOiAoeyBlbGVtZW50LCB1c2VyIH0pID0+IHtcbiAgICByZXR1cm4gaHRtbGA8c3BhbiBkYXRhLW1lbnRpb24+QCR7dXNlcj8ubmFtZSA/IGh0bWxgJHt1c2VyPy5uYW1lfWAgOiBlbGVtZW50LmlkfTwvc3Bhbj5gO1xuICB9XG59O1xudmFyIHN0cmluZ2lmeUNvbW1lbnRCb2R5TWFya2Rvd25FbGVtZW50cyA9IHtcbiAgcGFyYWdyYXBoOiAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9LFxuICB0ZXh0OiAoeyBlbGVtZW50IH0pID0+IHtcbiAgICBsZXQgY2hpbGRyZW4gPSBlbGVtZW50LnRleHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5ib2xkKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYCoqJHtjaGlsZHJlbn0qKmA7XG4gICAgfVxuICAgIGlmIChlbGVtZW50Lml0YWxpYykge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmBfJHtjaGlsZHJlbn1fYDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuc3RyaWtldGhyb3VnaCkge1xuICAgICAgY2hpbGRyZW4gPSBtYXJrZG93bmB+fiR7Y2hpbGRyZW59fn5gO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5jb2RlKSB7XG4gICAgICBjaGlsZHJlbiA9IG1hcmtkb3duYFxcYCR7Y2hpbGRyZW59XFxgYDtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9LFxuICBsaW5rOiAoeyBlbGVtZW50LCBocmVmIH0pID0+IHtcbiAgICByZXR1cm4gbWFya2Rvd25gWyR7ZWxlbWVudC50ZXh0ID8/IGVsZW1lbnQudXJsfV0oJHtocmVmfSlgO1xuICB9LFxuICBtZW50aW9uOiAoeyBlbGVtZW50LCB1c2VyIH0pID0+IHtcbiAgICByZXR1cm4gbWFya2Rvd25gQCR7dXNlcj8ubmFtZSA/PyBlbGVtZW50LmlkfWA7XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiBzdHJpbmdpZnlDb21tZW50Qm9keShib2R5LCBvcHRpb25zKSB7XG4gIGNvbnN0IGZvcm1hdCA9IG9wdGlvbnM/LmZvcm1hdCA/PyBcInBsYWluXCI7XG4gIGNvbnN0IHNlcGFyYXRvciA9IG9wdGlvbnM/LnNlcGFyYXRvciA/PyAoZm9ybWF0ID09PSBcIm1hcmtkb3duXCIgPyBcIlxcblxcblwiIDogXCJcXG5cIik7XG4gIGNvbnN0IGVsZW1lbnRzID0ge1xuICAgIC4uLmZvcm1hdCA9PT0gXCJodG1sXCIgPyBzdHJpbmdpZnlDb21tZW50Qm9keUh0bWxFbGVtZW50cyA6IGZvcm1hdCA9PT0gXCJtYXJrZG93blwiID8gc3RyaW5naWZ5Q29tbWVudEJvZHlNYXJrZG93bkVsZW1lbnRzIDogc3RyaW5naWZ5Q29tbWVudEJvZHlQbGFpbkVsZW1lbnRzLFxuICAgIC4uLm9wdGlvbnM/LmVsZW1lbnRzXG4gIH07XG4gIGNvbnN0IHJlc29sdmVkVXNlcnMgPSBhd2FpdCByZXNvbHZlVXNlcnNJbkNvbW1lbnRCb2R5KFxuICAgIGJvZHksXG4gICAgb3B0aW9ucz8ucmVzb2x2ZVVzZXJzXG4gICk7XG4gIGNvbnN0IGJsb2NrcyA9IGJvZHkuY29udGVudC5mbGF0TWFwKChibG9jaywgYmxvY2tJbmRleCkgPT4ge1xuICAgIHN3aXRjaCAoYmxvY2sudHlwZSkge1xuICAgICAgY2FzZSBcInBhcmFncmFwaFwiOiB7XG4gICAgICAgIGNvbnN0IGlubGluZXMgPSBibG9jay5jaGlsZHJlbi5mbGF0TWFwKChpbmxpbmUsIGlubGluZUluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKGlzQ29tbWVudEJvZHlNZW50aW9uKGlubGluZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmxpbmUuaWQgPyBbXG4gICAgICAgICAgICAgIGVsZW1lbnRzLm1lbnRpb24oXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudDogaW5saW5lLFxuICAgICAgICAgICAgICAgICAgdXNlcjogcmVzb2x2ZWRVc2Vycy5nZXQoaW5saW5lLmlkKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5saW5lSW5kZXhcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXSA6IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNDb21tZW50Qm9keUxpbmsoaW5saW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgZWxlbWVudHMubGluayhcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50OiBpbmxpbmUsXG4gICAgICAgICAgICAgICAgICBocmVmOiB0b0Fic29sdXRlVXJsKGlubGluZS51cmwpID8/IGlubGluZS51cmxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlubGluZUluZGV4XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0NvbW1lbnRCb2R5VGV4dChpbmxpbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW2VsZW1lbnRzLnRleHQoeyBlbGVtZW50OiBpbmxpbmUgfSwgaW5saW5lSW5kZXgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBlbGVtZW50cy5wYXJhZ3JhcGgoXG4gICAgICAgICAgICB7IGVsZW1lbnQ6IGJsb2NrLCBjaGlsZHJlbjogaW5saW5lcy5qb2luKFwiXCIpIH0sXG4gICAgICAgICAgICBibG9ja0luZGV4XG4gICAgICAgICAgKVxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBibG9ja3Muam9pbihzZXBhcmF0b3IpO1xufVxuXG4vLyBzcmMvY29tbWVudHMvY29tbWVudC11cmwudHNcbnZhciBQTEFDRUhPTERFUl9CQVNFX1VSTCA9IFwiaHR0cHM6Ly9sb2NhbGhvc3Q6OTk5OVwiO1xudmFyIEFCU09MVVRFX1VSTF9SRUdFWCA9IC9eW2EtekEtWl1bYS16QS1aXFxkK1xcLS5dKj86LztcbmZ1bmN0aW9uIGdlbmVyYXRlQ29tbWVudFVybCh7XG4gIHJvb21VcmwsXG4gIGNvbW1lbnRJZFxufSkge1xuICBjb25zdCBpc0Fic29sdXRlID0gQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3Qocm9vbVVybCk7XG4gIGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwoXG4gICAgcm9vbVVybCxcbiAgICBpc0Fic29sdXRlID8gdm9pZCAwIDogUExBQ0VIT0xERVJfQkFTRV9VUkxcbiAgKTtcbiAgdXJsT2JqZWN0Lmhhc2ggPSBgIyR7Y29tbWVudElkfWA7XG4gIHJldHVybiBpc0Fic29sdXRlID8gdXJsT2JqZWN0LmhyZWYgOiB1cmxPYmplY3QuaHJlZi5yZXBsYWNlKFBMQUNFSE9MREVSX0JBU0VfVVJMLCBcIlwiKTtcbn1cblxuLy8gc3JjL2NyZHRzL3V0aWxzLnRzXG5mdW5jdGlvbiB0b1BsYWluTHNvbihsc29uKSB7XG4gIGlmIChsc29uIGluc3RhbmNlb2YgTGl2ZU9iamVjdCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXZlYmxvY2tzVHlwZTogXCJMaXZlT2JqZWN0XCIsXG4gICAgICBkYXRhOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGxzb24udG9PYmplY3QoKSkuZmxhdE1hcChcbiAgICAgICAgICAoW2tleSwgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gdm9pZCAwID8gW1trZXksIHRvUGxhaW5Mc29uKHZhbHVlKV1dIDogW11cbiAgICAgICAgKVxuICAgICAgKVxuICAgIH07XG4gIH0gZWxzZSBpZiAobHNvbiBpbnN0YW5jZW9mIExpdmVNYXApIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl2ZWJsb2Nrc1R5cGU6IFwiTGl2ZU1hcFwiLFxuICAgICAgZGF0YTogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBbLi4ubHNvbl0ubWFwKChba2V5LCB2YWx1ZV0pID0+IFtrZXksIHRvUGxhaW5Mc29uKHZhbHVlKV0pXG4gICAgICApXG4gICAgfTtcbiAgfSBlbHNlIGlmIChsc29uIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl2ZWJsb2Nrc1R5cGU6IFwiTGl2ZUxpc3RcIixcbiAgICAgIGRhdGE6IFsuLi5sc29uXS5tYXAoKGl0ZW0pID0+IHRvUGxhaW5Mc29uKGl0ZW0pKVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxzb247XG4gIH1cbn1cblxuLy8gc3JjL2ltbXV0YWJsZS50c1xuZnVuY3Rpb24gbHNvbk9iamVjdFRvSnNvbihvYmopIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGNvbnN0IHZhbCA9IG9ialtrZXldO1xuICAgIGlmICh2YWwgIT09IHZvaWQgMCkge1xuICAgICAgcmVzdWx0W2tleV0gPSBsc29uVG9Kc29uKHZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBsaXZlT2JqZWN0VG9Kc29uKGxpdmVPYmplY3QpIHtcbiAgcmV0dXJuIGxzb25PYmplY3RUb0pzb24obGl2ZU9iamVjdC50b09iamVjdCgpKTtcbn1cbmZ1bmN0aW9uIGxpdmVNYXBUb0pzb24obWFwKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXAuZW50cmllcygpKSB7XG4gICAgcmVzdWx0W2tleV0gPSBsc29uVG9Kc29uKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbHNvbkxpc3RUb0pzb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLm1hcChsc29uVG9Kc29uKTtcbn1cbmZ1bmN0aW9uIGxpdmVMaXN0VG9Kc29uKHZhbHVlKSB7XG4gIHJldHVybiBsc29uTGlzdFRvSnNvbih2YWx1ZS50b0FycmF5KCkpO1xufVxuZnVuY3Rpb24gbHNvblRvSnNvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMaXZlT2JqZWN0KSB7XG4gICAgcmV0dXJuIGxpdmVPYmplY3RUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZUxpc3QpIHtcbiAgICByZXR1cm4gbGl2ZUxpc3RUb0pzb24odmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGl2ZU1hcCkge1xuICAgIHJldHVybiBsaXZlTWFwVG9Kc29uKHZhbHVlKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExpdmVSZWdpc3Rlcikge1xuICAgIHJldHVybiB2YWx1ZS5kYXRhO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBsc29uTGlzdFRvSnNvbih2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbHNvbk9iamVjdFRvSnNvbih2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZGVlcExpdmVpZnkodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBMaXZlTGlzdCh2YWx1ZS5tYXAoZGVlcExpdmVpZnkpKTtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIGNvbnN0IGluaXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgY29uc3QgdmFsID0gdmFsdWVba2V5XTtcbiAgICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGluaXRba2V5XSA9IGRlZXBMaXZlaWZ5KHZhbCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGl2ZU9iamVjdChpbml0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoTGl2ZUxpc3QobGl2ZUxpc3QsIHByZXYsIG5leHQpIHtcbiAgbGV0IGkgPSAwO1xuICBsZXQgcHJldkVuZCA9IHByZXYubGVuZ3RoIC0gMTtcbiAgbGV0IG5leHRFbmQgPSBuZXh0Lmxlbmd0aCAtIDE7XG4gIGxldCBwcmV2Tm9kZSA9IHByZXZbMF07XG4gIGxldCBuZXh0Tm9kZSA9IG5leHRbMF07XG4gIG91dGVyOiB7XG4gICAgd2hpbGUgKHByZXZOb2RlID09PSBuZXh0Tm9kZSkge1xuICAgICAgKytpO1xuICAgICAgaWYgKGkgPiBwcmV2RW5kIHx8IGkgPiBuZXh0RW5kKSB7XG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfVxuICAgICAgcHJldk5vZGUgPSBwcmV2W2ldO1xuICAgICAgbmV4dE5vZGUgPSBuZXh0W2ldO1xuICAgIH1cbiAgICBwcmV2Tm9kZSA9IHByZXZbcHJldkVuZF07XG4gICAgbmV4dE5vZGUgPSBuZXh0W25leHRFbmRdO1xuICAgIHdoaWxlIChwcmV2Tm9kZSA9PT0gbmV4dE5vZGUpIHtcbiAgICAgIHByZXZFbmQtLTtcbiAgICAgIG5leHRFbmQtLTtcbiAgICAgIGlmIChpID4gcHJldkVuZCB8fCBpID4gbmV4dEVuZCkge1xuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cbiAgICAgIHByZXZOb2RlID0gcHJldltwcmV2RW5kXTtcbiAgICAgIG5leHROb2RlID0gbmV4dFtuZXh0RW5kXTtcbiAgICB9XG4gIH1cbiAgaWYgKGkgPiBwcmV2RW5kKSB7XG4gICAgaWYgKGkgPD0gbmV4dEVuZCkge1xuICAgICAgd2hpbGUgKGkgPD0gbmV4dEVuZCkge1xuICAgICAgICBsaXZlTGlzdC5pbnNlcnQoZGVlcExpdmVpZnkobmV4dFtpXSksIGkpO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGkgPiBuZXh0RW5kKSB7XG4gICAgbGV0IGxvY2FsSSA9IGk7XG4gICAgd2hpbGUgKGxvY2FsSSA8PSBwcmV2RW5kKSB7XG4gICAgICBsaXZlTGlzdC5kZWxldGUoaSk7XG4gICAgICBsb2NhbEkrKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGkgPD0gcHJldkVuZCAmJiBpIDw9IG5leHRFbmQpIHtcbiAgICAgIHByZXZOb2RlID0gcHJldltpXTtcbiAgICAgIG5leHROb2RlID0gbmV4dFtpXTtcbiAgICAgIGNvbnN0IGxpdmVMaXN0Tm9kZSA9IGxpdmVMaXN0LmdldChpKTtcbiAgICAgIGlmIChpc0xpdmVPYmplY3QobGl2ZUxpc3ROb2RlKSAmJiBpc1BsYWluT2JqZWN0KHByZXZOb2RlKSAmJiBpc1BsYWluT2JqZWN0KG5leHROb2RlKSkge1xuICAgICAgICBwYXRjaExpdmVPYmplY3QobGl2ZUxpc3ROb2RlLCBwcmV2Tm9kZSwgbmV4dE5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGl2ZUxpc3Quc2V0KGksIGRlZXBMaXZlaWZ5KG5leHROb2RlKSk7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHdoaWxlIChpIDw9IG5leHRFbmQpIHtcbiAgICAgIGxpdmVMaXN0Lmluc2VydChkZWVwTGl2ZWlmeShuZXh0W2ldKSwgaSk7XG4gICAgICBpKys7XG4gICAgfVxuICAgIGxldCBsb2NhbEkgPSBpO1xuICAgIHdoaWxlIChsb2NhbEkgPD0gcHJldkVuZCkge1xuICAgICAgbGl2ZUxpc3QuZGVsZXRlKGkpO1xuICAgICAgbG9jYWxJKys7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwYXRjaExpdmVPYmplY3RLZXkobGl2ZU9iamVjdCwga2V5LCBwcmV2LCBuZXh0KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zdCBub25TZXJpYWxpemFibGVWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShuZXh0KTtcbiAgICBpZiAobm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcbiAgICAgIGVycm9yMihcbiAgICAgICAgYE5ldyBzdGF0ZSBwYXRoOiAnJHtub25TZXJpYWxpemFibGVWYWx1ZS5wYXRofScgdmFsdWU6ICcke1N0cmluZyhcbiAgICAgICAgICBub25TZXJpYWxpemFibGVWYWx1ZS52YWx1ZVxuICAgICAgICApfScgaXMgbm90IHNlcmlhbGl6YWJsZS5cbk9ubHkgc2VyaWFsaXphYmxlIHZhbHVlIGNhbiBiZSBzeW5jZWQgd2l0aCBMaXZlYmxvY2tzLmBcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGNvbnN0IHZhbHVlID0gbGl2ZU9iamVjdC5nZXQoa2V5KTtcbiAgaWYgKG5leHQgPT09IHZvaWQgMCkge1xuICAgIGxpdmVPYmplY3QuZGVsZXRlKGtleSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgIGxpdmVPYmplY3Quc2V0KGtleSwgZGVlcExpdmVpZnkobmV4dCkpO1xuICB9IGVsc2UgaWYgKHByZXYgPT09IG5leHQpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoaXNMaXZlTGlzdCh2YWx1ZSkgJiYgQXJyYXkuaXNBcnJheShwcmV2KSAmJiBBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgcGF0Y2hMaXZlTGlzdCh2YWx1ZSwgcHJldiwgbmV4dCk7XG4gIH0gZWxzZSBpZiAoaXNMaXZlT2JqZWN0KHZhbHVlKSAmJiBpc1BsYWluT2JqZWN0KHByZXYpICYmIGlzUGxhaW5PYmplY3QobmV4dCkpIHtcbiAgICBwYXRjaExpdmVPYmplY3QodmFsdWUsIHByZXYsIG5leHQpO1xuICB9IGVsc2Uge1xuICAgIGxpdmVPYmplY3Quc2V0KGtleSwgZGVlcExpdmVpZnkobmV4dCkpO1xuICB9XG59XG5mdW5jdGlvbiBwYXRjaExpdmVPYmplY3Qocm9vdCwgcHJldiwgbmV4dCkge1xuICBjb25zdCB1cGRhdGVzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcbiAgICBwYXRjaExpdmVPYmplY3RLZXkocm9vdCwga2V5LCBwcmV2W2tleV0sIG5leHRba2V5XSk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gcHJldikge1xuICAgIGlmIChuZXh0W2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgcm9vdC5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH1cbiAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICByb290LnVwZGF0ZSh1cGRhdGVzKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UGFyZW50c1BhdGgobm9kZSkge1xuICBjb25zdCBwYXRoID0gW107XG4gIHdoaWxlIChub2RlLnBhcmVudC50eXBlID09PSBcIkhhc1BhcmVudFwiKSB7XG4gICAgaWYgKGlzTGl2ZUxpc3Qobm9kZS5wYXJlbnQubm9kZSkpIHtcbiAgICAgIHBhdGgucHVzaChub2RlLnBhcmVudC5ub2RlLl9pbmRleE9mUG9zaXRpb24obm9kZS5wYXJlbnQua2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGgucHVzaChub2RlLnBhcmVudC5rZXkpO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnQubm9kZTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbmZ1bmN0aW9uIGxlZ2FjeV9wYXRjaEltbXV0YWJsZU9iamVjdChzdGF0ZSwgdXBkYXRlcykge1xuICByZXR1cm4gdXBkYXRlcy5yZWR1Y2UoXG4gICAgKHN0YXRlMiwgdXBkYXRlKSA9PiBsZWdhY3lfcGF0Y2hJbW11dGFibGVPYmplY3RXaXRoVXBkYXRlKHN0YXRlMiwgdXBkYXRlKSxcbiAgICBzdGF0ZVxuICApO1xufVxuZnVuY3Rpb24gbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0V2l0aFVwZGF0ZShzdGF0ZSwgdXBkYXRlKSB7XG4gIGNvbnN0IHBhdGggPSBnZXRQYXJlbnRzUGF0aCh1cGRhdGUubm9kZSk7XG4gIHJldHVybiBsZWdhY3lfcGF0Y2hJbW11dGFibGVOb2RlKHN0YXRlLCBwYXRoLCB1cGRhdGUpO1xufVxuZnVuY3Rpb24gbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShzdGF0ZSwgcGF0aCwgdXBkYXRlKSB7XG4gIGNvbnN0IHBhdGhJdGVtID0gcGF0aC5wb3AoKTtcbiAgaWYgKHBhdGhJdGVtID09PSB2b2lkIDApIHtcbiAgICBzd2l0Y2ggKHVwZGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIFwiTGl2ZU9iamVjdFwiOiB7XG4gICAgICAgIGlmICghaXNKc29uT2JqZWN0KHN0YXRlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiSW50ZXJuYWw6IHJlY2VpdmVkIHVwZGF0ZSBvbiBMaXZlT2JqZWN0IGJ1dCBzdGF0ZSB3YXMgbm90IGFuIG9iamVjdFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdXBkYXRlLnVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAodXBkYXRlLnVwZGF0ZXNba2V5XT8udHlwZSA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gdXBkYXRlLm5vZGUuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGVba2V5XSA9IGxzb25Ub0pzb24odmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdTdGF0ZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgICBjYXNlIFwiTGl2ZUxpc3RcIjoge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3RhdGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJJbnRlcm5hbDogcmVjZWl2ZWQgdXBkYXRlIG9uIExpdmVMaXN0IGJ1dCBzdGF0ZSB3YXMgbm90IGFuIGFycmF5XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdTdGF0ZSA9IHN0YXRlLm1hcCgoeCkgPT4geCk7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdFVwZGF0ZSBvZiB1cGRhdGUudXBkYXRlcykge1xuICAgICAgICAgIGlmIChsaXN0VXBkYXRlLnR5cGUgPT09IFwic2V0XCIpIHtcbiAgICAgICAgICAgIG5ld1N0YXRlID0gbmV3U3RhdGUubWFwKFxuICAgICAgICAgICAgICAoaXRlbSwgaW5kZXgpID0+IGluZGV4ID09PSBsaXN0VXBkYXRlLmluZGV4ID8gbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pIDogaXRlbVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJpbnNlcnRcIikge1xuICAgICAgICAgICAgaWYgKGxpc3RVcGRhdGUuaW5kZXggPT09IG5ld1N0YXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZS5wdXNoKGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdTdGF0ZSA9IFtcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZSgwLCBsaXN0VXBkYXRlLmluZGV4KSxcbiAgICAgICAgICAgICAgICBsc29uVG9Kc29uKGxpc3RVcGRhdGUuaXRlbSksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5pbmRleClcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGxpc3RVcGRhdGUudHlwZSA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgICAgbmV3U3RhdGUuc3BsaWNlKGxpc3RVcGRhdGUuaW5kZXgsIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGlzdFVwZGF0ZS50eXBlID09PSBcIm1vdmVcIikge1xuICAgICAgICAgICAgaWYgKGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCA+IGxpc3RVcGRhdGUuaW5kZXgpIHtcbiAgICAgICAgICAgICAgbmV3U3RhdGUgPSBbXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoMCwgbGlzdFVwZGF0ZS5pbmRleCksXG4gICAgICAgICAgICAgICAgbHNvblRvSnNvbihsaXN0VXBkYXRlLml0ZW0pLFxuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKGxpc3RVcGRhdGUuaW5kZXgsIGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UobGlzdFVwZGF0ZS5wcmV2aW91c0luZGV4ICsgMSlcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gW1xuICAgICAgICAgICAgICAgIC4uLm5ld1N0YXRlLnNsaWNlKDAsIGxpc3RVcGRhdGUucHJldmlvdXNJbmRleCksXG4gICAgICAgICAgICAgICAgLi4ubmV3U3RhdGUuc2xpY2UoXG4gICAgICAgICAgICAgICAgICBsaXN0VXBkYXRlLnByZXZpb3VzSW5kZXggKyAxLFxuICAgICAgICAgICAgICAgICAgbGlzdFVwZGF0ZS5pbmRleCArIDFcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGxzb25Ub0pzb24obGlzdFVwZGF0ZS5pdGVtKSxcbiAgICAgICAgICAgICAgICAuLi5uZXdTdGF0ZS5zbGljZShsaXN0VXBkYXRlLmluZGV4ICsgMSlcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfVxuICAgICAgY2FzZSBcIkxpdmVNYXBcIjoge1xuICAgICAgICBpZiAoIWlzSnNvbk9iamVjdChzdGF0ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkludGVybmFsOiByZWNlaXZlZCB1cGRhdGUgb24gTGl2ZU1hcCBidXQgc3RhdGUgd2FzIG5vdCBhbiBvYmplY3RcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHVwZGF0ZS51cGRhdGVzKSB7XG4gICAgICAgICAgaWYgKHVwZGF0ZS51cGRhdGVzW2tleV0/LnR5cGUgPT09IFwidXBkYXRlXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdXBkYXRlLm5vZGUuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBuZXdTdGF0ZVtrZXldID0gbHNvblRvSnNvbih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh1cGRhdGUudXBkYXRlc1trZXldPy50eXBlID09PSBcImRlbGV0ZVwiKSB7XG4gICAgICAgICAgICBkZWxldGUgbmV3U3RhdGVba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICBjb25zdCBuZXdBcnJheSA9IFsuLi5zdGF0ZV07XG4gICAgbmV3QXJyYXlbcGF0aEl0ZW1dID0gbGVnYWN5X3BhdGNoSW1tdXRhYmxlTm9kZShcbiAgICAgIHN0YXRlW3BhdGhJdGVtXSxcbiAgICAgIHBhdGgsXG4gICAgICB1cGRhdGVcbiAgICApO1xuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfSBlbHNlIGlmIChpc0pzb25PYmplY3Qoc3RhdGUpKSB7XG4gICAgY29uc3Qgbm9kZSA9IHN0YXRlW3BhdGhJdGVtXTtcbiAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0YXRlQXNPYmogPSBzdGF0ZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlQXNPYmosXG4gICAgICAgIFtwYXRoSXRlbV06IGxlZ2FjeV9wYXRjaEltbXV0YWJsZU5vZGUobm9kZSwgcGF0aCwgdXBkYXRlKVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbi8vIHNyYy9saWIvYWJvcnRDb250cm9sbGVyLnRzXG5mdW5jdGlvbiBtYWtlQWJvcnRDb250cm9sbGVyKGV4dGVybmFsU2lnbmFsKSB7XG4gIGNvbnN0IGN0bCA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgcmV0dXJuIHtcbiAgICBzaWduYWw6IGV4dGVybmFsU2lnbmFsID8gQWJvcnRTaWduYWwuYW55KFtjdGwuc2lnbmFsLCBleHRlcm5hbFNpZ25hbF0pIDogY3RsLnNpZ25hbCxcbiAgICBhYm9ydDogY3RsLmFib3J0LmJpbmQoY3RsKVxuICB9O1xufVxuXG4vLyBzcmMvbGliL2RlcHJlY2F0aW9uLnRzXG52YXIgX2VtaXR0ZWREZXByZWNhdGlvbldhcm5pbmdzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbmZ1bmN0aW9uIGRlcHJlY2F0ZShtZXNzYWdlLCBrZXkgPSBtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIV9lbWl0dGVkRGVwcmVjYXRpb25XYXJuaW5ncy5oYXMoa2V5KSkge1xuICAgICAgX2VtaXR0ZWREZXByZWNhdGlvbldhcm5pbmdzLmFkZChrZXkpO1xuICAgICAgZXJyb3JXaXRoVGl0bGUoXCJEZXByZWNhdGlvbiB3YXJuaW5nXCIsIG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGVwcmVjYXRlSWYoY29uZGl0aW9uLCBtZXNzYWdlLCBrZXkgPSBtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICBkZXByZWNhdGUobWVzc2FnZSwga2V5KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRocm93VXNhZ2VFcnJvcihtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zdCB1c2FnZUVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIHVzYWdlRXJyb3IubmFtZSA9IFwiVXNhZ2UgZXJyb3JcIjtcbiAgICBlcnJvcldpdGhUaXRsZShcIlVzYWdlIGVycm9yXCIsIG1lc3NhZ2UpO1xuICAgIHRocm93IHVzYWdlRXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9ySWYoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICB0aHJvd1VzYWdlRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9saWIvUG9sbGVyLnRzXG52YXIgQkFDS09GRl9ERUxBWVMyID0gWzFlMywgMmUzLCA0ZTMsIDhlMywgMWU0XTtcbmZ1bmN0aW9uIG1ha2VQb2xsZXIoY2FsbGJhY2ssIGludGVydmFsTXMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gIGNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogdm9pZCAwO1xuICBjb25zdCB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdm9pZCAwO1xuICBjb25zdCBtYXhTdGFsZVRpbWVNcyA9IG9wdGlvbnM/Lm1heFN0YWxlVGltZU1zID8/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgY29uc3QgY29udGV4dCA9IHtcbiAgICBpbkZvcmVncm91bmQ6IGRvYz8udmlzaWJpbGl0eVN0YXRlICE9PSBcImhpZGRlblwiLFxuICAgIGxhc3RTdWNjZXNzZnVsUG9sbEF0OiBzdGFydFRpbWUsXG4gICAgY291bnQ6IDAsXG4gICAgYmFja29mZjogMFxuICB9O1xuICBmdW5jdGlvbiBtYXlQb2xsKCkge1xuICAgIHJldHVybiBjb250ZXh0LmNvdW50ID4gMCAmJiBjb250ZXh0LmluRm9yZWdyb3VuZDtcbiAgfVxuICBjb25zdCBmc20gPSBuZXcgRlNNKHt9KS5hZGRTdGF0ZShcIkBpZGxlXCIpLmFkZFN0YXRlKFwiQGVuYWJsZWRcIikuYWRkU3RhdGUoXCJAcG9sbGluZ1wiKTtcbiAgZnNtLmFkZFRyYW5zaXRpb25zKFwiQGlkbGVcIiwgeyBTVEFSVDogXCJAZW5hYmxlZFwiIH0pO1xuICBmc20uYWRkVHJhbnNpdGlvbnMoXCJAZW5hYmxlZFwiLCB7IFNUT1A6IFwiQGlkbGVcIiwgUE9MTDogXCJAcG9sbGluZ1wiIH0pO1xuICBmc20uYWRkVGltZWRUcmFuc2l0aW9uKFxuICAgIFwiQGVuYWJsZWRcIixcbiAgICAoKSA9PiB7XG4gICAgICBjb25zdCBsYXN0UG9sbCA9IGNvbnRleHQubGFzdFN1Y2Nlc3NmdWxQb2xsQXQ7XG4gICAgICBjb25zdCBuZXh0UG9sbCA9IGxhc3RQb2xsICsgaW50ZXJ2YWxNcztcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBuZXh0UG9sbCAtIHBlcmZvcm1hbmNlLm5vdygpKSArIGNvbnRleHQuYmFja29mZjtcbiAgICB9LFxuICAgIFwiQHBvbGxpbmdcIlxuICApO1xuICBmc20ub25FbnRlckFzeW5jKFxuICAgIFwiQHBvbGxpbmdcIixcbiAgICBhc3luYyAoX2N0eCwgc2lnbmFsKSA9PiB7XG4gICAgICBhd2FpdCBjYWxsYmFjayhzaWduYWwpO1xuICAgICAgaWYgKCFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICBjb250ZXh0Lmxhc3RTdWNjZXNzZnVsUG9sbEF0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBXaGVuIE9LXG4gICAgKCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBtYXlQb2xsKCkgPyBcIkBlbmFibGVkXCIgOiBcIkBpZGxlXCIsXG4gICAgICAgIGVmZmVjdDogKCkgPT4ge1xuICAgICAgICAgIGNvbnRleHQuYmFja29mZiA9IDA7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBXaGVuIGVycm9yXG4gICAgKCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBtYXlQb2xsKCkgPyBcIkBlbmFibGVkXCIgOiBcIkBpZGxlXCIsXG4gICAgICAgIGVmZmVjdDogKCkgPT4ge1xuICAgICAgICAgIGNvbnRleHQuYmFja29mZiA9IEJBQ0tPRkZfREVMQVlTMi5maW5kKChkZWxheSkgPT4gZGVsYXkgPiBjb250ZXh0LmJhY2tvZmYpID8/IEJBQ0tPRkZfREVMQVlTMltCQUNLT0ZGX0RFTEFZUzIubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICAzZTRcbiAgICAvLyBBYm9ydCB0aGUgcG9sbCBpZiB0aGUgY2FsbGJhY2sgdGFrZXMgbW9yZSB0aGFuIDMwIHNlY29uZHMgdG8gY29tcGxldGVcbiAgKTtcbiAgZnVuY3Rpb24gc3RhcnRPclN0b3AoKSB7XG4gICAgaWYgKG1heVBvbGwoKSkge1xuICAgICAgZnNtLnNlbmQoeyB0eXBlOiBcIlNUQVJUXCIgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZzbS5zZW5kKHsgdHlwZTogXCJTVE9QXCIgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGluYygpIHtcbiAgICBjb250ZXh0LmNvdW50Kys7XG4gICAgc3RhcnRPclN0b3AoKTtcbiAgfVxuICBmdW5jdGlvbiBkZWMoKSB7XG4gICAgY29udGV4dC5jb3VudC0tO1xuICAgIGlmIChjb250ZXh0LmNvdW50IDwgMCkge1xuICAgICAgY29udGV4dC5jb3VudCA9IDA7XG4gICAgfVxuICAgIHN0YXJ0T3JTdG9wKCk7XG4gIH1cbiAgZnVuY3Rpb24gcG9sbE5vd0lmU3RhbGUoKSB7XG4gICAgaWYgKHBlcmZvcm1hbmNlLm5vdygpIC0gY29udGV4dC5sYXN0U3VjY2Vzc2Z1bFBvbGxBdCA+IG1heFN0YWxlVGltZU1zKSB7XG4gICAgICBmc20uc2VuZCh7IHR5cGU6IFwiUE9MTFwiIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRJbkZvcmVncm91bmQoaW5Gb3JlZ3JvdW5kKSB7XG4gICAgY29udGV4dC5pbkZvcmVncm91bmQgPSBpbkZvcmVncm91bmQ7XG4gICAgc3RhcnRPclN0b3AoKTtcbiAgICBwb2xsTm93SWZTdGFsZSgpO1xuICB9XG4gIGZ1bmN0aW9uIG9uVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICBzZXRJbkZvcmVncm91bmQoZG9jPy52aXNpYmlsaXR5U3RhdGUgIT09IFwiaGlkZGVuXCIpO1xuICB9XG4gIGRvYz8uYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgb25WaXNpYmlsaXR5Q2hhbmdlKTtcbiAgd2luPy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gIHdpbj8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHBvbGxOb3dJZlN0YWxlKTtcbiAgZnNtLnN0YXJ0KCk7XG4gIHJldHVybiB7XG4gICAgaW5jLFxuICAgIGRlYyxcbiAgICBwb2xsTm93SWZTdGFsZSxcbiAgICAvLyBJbnRlcm5hbCBBUEksIHVzZWQgYnkgdW5pdCB0ZXN0cyBvbmx5IHRvIHNpbXVsYXRlIHZpc2liaWxpdHkgZXZlbnRzXG4gICAgc2V0SW5Gb3JlZ3JvdW5kXG4gIH07XG59XG5cbi8vIHNyYy9saWIvc2hhbGxvdy50c1xuZnVuY3Rpb24gc2hhbGxvd0FycmF5KHhzLCB5cykge1xuICBpZiAoeHMubGVuZ3RoICE9PSB5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghT2JqZWN0LmlzKHhzW2ldLCB5c1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzaGFsbG93T2JqKG9iakEsIG9iakIpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KG9iakEpIHx8ICFpc1BsYWluT2JqZWN0KG9iakIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG9iakIpLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4ga2V5c0EuZXZlcnkoXG4gICAgKGtleSkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleSkgJiYgT2JqZWN0LmlzKG9iakFba2V5XSwgb2JqQltrZXldKVxuICApO1xufVxuZnVuY3Rpb24gc2hhbGxvdyhhLCBiKSB7XG4gIGlmIChPYmplY3QuaXMoYSwgYikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gIGNvbnN0IGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgaWYgKGlzQXJyYXlBIHx8IGlzQXJyYXlCKSB7XG4gICAgaWYgKCFpc0FycmF5QSB8fCAhaXNBcnJheUIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWxsb3dBcnJheShhLCBiKTtcbiAgfVxuICByZXR1cm4gc2hhbGxvd09iaihhLCBiKTtcbn1cblxuLy8gc3JjL2xpYi9Tb3J0ZWRMaXN0LnRzXG5mdW5jdGlvbiBiaXNlY3RSaWdodChhcnIsIHgsIGx0KSB7XG4gIGxldCBsbyA9IDA7XG4gIGxldCBoaSA9IGFyci5sZW5ndGg7XG4gIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgY29uc3QgbWlkID0gbG8gKyAoaGkgLSBsbyA+PiAxKTtcbiAgICBpZiAobHQoeCwgYXJyW21pZF0pKSB7XG4gICAgICBoaSA9IG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG8gPSBtaWQgKyAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbG87XG59XG52YXIgU29ydGVkTGlzdCA9IGNsYXNzIF9Tb3J0ZWRMaXN0IHtcbiAgI2RhdGE7XG4gICNsdDtcbiAgY29uc3RydWN0b3IoYWxyZWFkeVNvcnRlZExpc3QsIGx0KSB7XG4gICAgdGhpcy4jbHQgPSBsdDtcbiAgICB0aGlzLiNkYXRhID0gYWxyZWFkeVNvcnRlZExpc3Q7XG4gIH1cbiAgc3RhdGljIGZyb20oYXJyLCBsdCkge1xuICAgIGNvbnN0IHNvcnRlZCA9IG5ldyBfU29ydGVkTGlzdChbXSwgbHQpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgIHNvcnRlZC5hZGQoaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBzb3J0ZWQ7XG4gIH1cbiAgc3RhdGljIGZyb21BbHJlYWR5U29ydGVkKGFscmVhZHlTb3J0ZWQsIGx0KSB7XG4gICAgcmV0dXJuIG5ldyBfU29ydGVkTGlzdChhbHJlYWR5U29ydGVkLCBsdCk7XG4gIH1cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgc29ydGVkIGxpc3QgdG8gYSBuZXcgaW5zdGFuY2UuXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9Tb3J0ZWRMaXN0KHRoaXMuI2RhdGEuc2xpY2UoKSwgdGhpcy4jbHQpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IGl0ZW0gdG8gdGhlIHNvcnRlZCBsaXN0LCBzdWNoIHRoYXQgaXQgcmVtYWlucyBzb3J0ZWQuXG4gICAqL1xuICBhZGQodmFsdWUpIHtcbiAgICBjb25zdCBpZHggPSBiaXNlY3RSaWdodCh0aGlzLiNkYXRhLCB2YWx1ZSwgdGhpcy4jbHQpO1xuICAgIHRoaXMuI2RhdGEuc3BsaWNlKGlkeCwgMCwgdmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBnaXZlbiB2YWx1ZSBmcm9tIHRoZSBzb3J0ZWQgbGlzdCwgaWYgaXQgZXhpc3RzLiBUaGUgZ2l2ZW5cbiAgICogdmFsdWUgbXVzdCBiZSBgPT09YCB0byBvbmUgb2YgdGhlIGxpc3QgaXRlbXMuIE9ubHkgdGhlIGZpcnN0IGVudHJ5IHdpbGwgYmVcbiAgICogcmVtb3ZlZCBpZiB0aGUgZWxlbWVudCBleGlzdHMgaW4gdGhlIHNvcnRlZCBsaXN0IG11bHRpcGxlIHRpbWVzLlxuICAgKi9cbiAgcmVtb3ZlKHZhbHVlKSB7XG4gICAgY29uc3QgaWR4ID0gdGhpcy4jZGF0YS5pbmRleE9mKHZhbHVlKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIHRoaXMuI2RhdGEuc3BsaWNlKGlkeCwgMSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RhdGEubGVuZ3RoO1xuICB9XG4gICpmaWx0ZXIocHJlZGljYXRlKSB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuI2RhdGEpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoaXRlbSkpIHtcbiAgICAgICAgeWllbGQgaXRlbTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RhdGFbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICB9XG59O1xuXG4vLyBzcmMvdHlwZXMvT3RoZXJzLnRzXG52YXIgVGV4dEVkaXRvclR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChUZXh0RWRpdG9yVHlwZTIpID0+IHtcbiAgVGV4dEVkaXRvclR5cGUyW1wiTGV4aWNhbFwiXSA9IFwibGV4aWNhbFwiO1xuICBUZXh0RWRpdG9yVHlwZTJbXCJUaXBUYXBcIl0gPSBcInRpcHRhcFwiO1xuICByZXR1cm4gVGV4dEVkaXRvclR5cGUyO1xufSkoVGV4dEVkaXRvclR5cGUgfHwge30pO1xuXG4vLyBzcmMvaW5kZXgudHNcbmRldGVjdER1cGVzKFBLR19OQU1FLCBQS0dfVkVSU0lPTiwgUEtHX0ZPUk1BVCk7XG52YXIgQ29tbWVudHNBcGlFcnJvciA9IEh0dHBFcnJvcjtcbnZhciBOb3RpZmljYXRpb25zQXBpRXJyb3IgPSBIdHRwRXJyb3I7XG5leHBvcnQge1xuICBDbGllbnRNc2dDb2RlLFxuICBDb21tZW50c0FwaUVycm9yLFxuICBDcmR0VHlwZSxcbiAgRGVmYXVsdE1hcCxcbiAgRGVyaXZlZFNpZ25hbCxcbiAgSHR0cEVycm9yLFxuICBMaXZlTGlzdCxcbiAgTGl2ZU1hcCxcbiAgTGl2ZU9iamVjdCxcbiAgTGl2ZWJsb2Nrc0Vycm9yLFxuICBNdXRhYmxlU2lnbmFsLFxuICBOb3RpZmljYXRpb25zQXBpRXJyb3IsXG4gIE9wQ29kZSxcbiAgUGVybWlzc2lvbixcbiAgUHJvbWlzZV93aXRoUmVzb2x2ZXJzLFxuICBTZXJ2ZXJNc2dDb2RlLFxuICBTaWduYWwsXG4gIFNvcnRlZExpc3QsXG4gIFRleHRFZGl0b3JUeXBlLFxuICBXZWJzb2NrZXRDbG9zZUNvZGVzLFxuICBhY2tPcCxcbiAgYXNQb3MsXG4gIGFzc2VydCxcbiAgYXNzZXJ0TmV2ZXIsXG4gIGF1dG9SZXRyeSxcbiAgYjY0ZGVjb2RlLFxuICBiYXRjaCxcbiAgY2hlY2tCb3VuZHMsXG4gIGNodW5rLFxuICBjbG9uZUxzb24sXG4gIGNvbXBhY3RPYmplY3QsXG4gIGZhbmN5X2NvbnNvbGVfZXhwb3J0cyBhcyBjb25zb2xlLFxuICBjb252ZXJ0VG9Db21tZW50RGF0YSxcbiAgY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbixcbiAgY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhLFxuICBjb252ZXJ0VG9UaHJlYWREYXRhLFxuICBjcmVhdGVDbGllbnQsXG4gIGNyZWF0ZUNvbW1lbnRBdHRhY2htZW50SWQsXG4gIGNyZWF0ZUNvbW1lbnRJZCxcbiAgY3JlYXRlSW5ib3hOb3RpZmljYXRpb25JZCxcbiAgY3JlYXRlTWFuYWdlZFBvb2wsXG4gIGNyZWF0ZVRocmVhZElkLFxuICBjcmVhdGVVc2VyTm90aWZpY2F0aW9uU2V0dGluZ3MsXG4gIGRlcHJlY2F0ZSxcbiAgZGVwcmVjYXRlSWYsXG4gIGRldGVjdER1cGVzLFxuICBlbnRyaWVzLFxuICBlcnJvcklmLFxuICBmcmVlemUsXG4gIGdlbmVyYXRlQ29tbWVudFVybCxcbiAgZ2V0TWVudGlvbmVkSWRzRnJvbUNvbW1lbnRCb2R5LFxuICBodG1sLFxuICBodG1sU2FmZSxcbiAgaXNDaGlsZENyZHQsXG4gIGlzQ29tbWVudEJvZHlMaW5rLFxuICBpc0NvbW1lbnRCb2R5TWVudGlvbixcbiAgaXNDb21tZW50Qm9keVRleHQsXG4gIGlzSnNvbkFycmF5LFxuICBpc0pzb25PYmplY3QsXG4gIGlzSnNvblNjYWxhcixcbiAgaXNMaXZlTm9kZSxcbiAgaXNOb3RpZmljYXRpb25DaGFubmVsRW5hYmxlZCxcbiAgaXNQbGFpbk9iamVjdCxcbiAgaXNSb290Q3JkdCxcbiAgaXNTdGFydHNXaXRoT3BlcmF0b3IsXG4gIGtJbnRlcm5hbCxcbiAga2V5cyxcbiAgbGVnYWN5X3BhdGNoSW1tdXRhYmxlT2JqZWN0LFxuICBsc29uVG9Kc29uLFxuICBtYWtlQWJvcnRDb250cm9sbGVyLFxuICBtYWtlRXZlbnRTb3VyY2UsXG4gIG1ha2VQb2xsZXIsXG4gIG1ha2VQb3NpdGlvbixcbiAgbWFwVmFsdWVzLFxuICBtZW1vaXplT25TdWNjZXNzLFxuICBuYW5vaWQsXG4gIG5uLFxuICBvYmplY3RUb1F1ZXJ5LFxuICBwYXRjaExpdmVPYmplY3RLZXksXG4gIHBhdGNoVXNlck5vdGlmaWNhdGlvblNldHRpbmdzLFxuICByYWlzZSxcbiAgcmVzb2x2ZVVzZXJzSW5Db21tZW50Qm9keSxcbiAgc2hhbGxvdyxcbiAgc3RhYmxlU3RyaW5naWZ5LFxuICBzdHJpbmdpZnlDb21tZW50Qm9keSxcbiAgdGhyb3dVc2FnZUVycm9yLFxuICB0b0Fic29sdXRlVXJsLFxuICB0b1BsYWluTHNvbixcbiAgdHJ5UGFyc2VKc29uLFxuICB1cmwsXG4gIHVybGpvaW4sXG4gIHdhaXQsXG4gIHdpdGhUaW1lb3V0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@liveblocks/core/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@liveblocks/node/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@liveblocks/node/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Liveblocks: () => (/* binding */ Liveblocks),\n/* harmony export */   LiveblocksError: () => (/* binding */ LiveblocksError),\n/* harmony export */   WebhookHandler: () => (/* binding */ WebhookHandler),\n/* harmony export */   getMentionedIdsFromCommentBody: () => (/* reexport safe */ _liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.getMentionedIdsFromCommentBody),\n/* harmony export */   isCustomNotificationEvent: () => (/* binding */ isCustomNotificationEvent),\n/* harmony export */   isNotificationChannelEnabled: () => (/* reexport safe */ _liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.isNotificationChannelEnabled),\n/* harmony export */   isTextMentionNotificationEvent: () => (/* binding */ isTextMentionNotificationEvent),\n/* harmony export */   isThreadNotificationEvent: () => (/* binding */ isThreadNotificationEvent),\n/* harmony export */   stringifyCommentBody: () => (/* reexport safe */ _liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.stringifyCommentBody)\n/* harmony export */ });\n/* harmony import */ var _liveblocks_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @liveblocks/core */ \"(rsc)/./node_modules/@liveblocks/core/dist/index.js\");\n/* harmony import */ var _stablelib_base64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @stablelib/base64 */ \"(rsc)/./node_modules/@stablelib/base64/lib/base64.js\");\n/* harmony import */ var fast_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fast-sha256 */ \"(rsc)/./node_modules/fast-sha256/sha256.js\");\n// src/index.ts\n\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/node\";\nvar PKG_VERSION = \"2.22.0\";\nvar PKG_FORMAT = \"esm\";\n\n// src/client.ts\n\n\n// src/lib/itertools.ts\nasync function asyncConsume(iterable) {\n  const result = [];\n  for await (const item of iterable) {\n    result.push(item);\n  }\n  return result;\n}\nasync function runConcurrently(iterable, fn, concurrency) {\n  const queue = /* @__PURE__ */ new Set();\n  for await (const item of iterable) {\n    if (queue.size >= concurrency) {\n      await Promise.race(queue);\n    }\n    const promise = (async () => {\n      try {\n        await fn(item);\n      } finally {\n        queue.delete(promise);\n      }\n    })();\n    queue.add(promise);\n  }\n  if (queue.size > 0) {\n    await Promise.all(queue);\n  }\n}\n\n// src/lib/ndjson.ts\nvar LineStream = class extends TransformStream {\n  constructor() {\n    let buffer = \"\";\n    super({\n      transform(chunk, controller) {\n        buffer += chunk;\n        if (buffer.includes(\"\\n\")) {\n          const lines = buffer.split(\"\\n\");\n          for (let i = 0; i < lines.length - 1; i++) {\n            if (lines[i].length > 0) {\n              controller.enqueue(lines[i]);\n            }\n          }\n          buffer = lines[lines.length - 1];\n        }\n      },\n      flush(controller) {\n        if (buffer.length > 0) {\n          controller.enqueue(buffer);\n        }\n      }\n    });\n  }\n};\nvar NdJsonStream = class extends TransformStream {\n  constructor() {\n    super({\n      transform(line, controller) {\n        const json = JSON.parse(line);\n        controller.enqueue(json);\n      }\n    });\n  }\n};\n\n// src/Session.ts\n\n\n// src/utils.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\nvar VALID_KEY_CHARS_REGEX = /^[\\w-]+$/;\nfunction getBaseUrl(baseUrl) {\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nasync function fetchPolyfill() {\n  return typeof globalThis.fetch !== \"undefined\" ? globalThis.fetch : (await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/whatwg-url\"), __webpack_require__.e(\"vendor-chunks/tr46\"), __webpack_require__.e(\"vendor-chunks/node-fetch\"), __webpack_require__.e(\"vendor-chunks/webidl-conversions\")]).then(__webpack_require__.bind(__webpack_require__, /*! node-fetch */ \"(rsc)/./node_modules/node-fetch/lib/index.mjs\"))).default;\n}\nfunction isString(value) {\n  return typeof value === \"string\";\n}\nfunction startsWith(value, prefix) {\n  return isString(value) && value.startsWith(prefix);\n}\nfunction isNonEmpty(value) {\n  return isString(value) && value.length > 0;\n}\nfunction assertNonEmpty(value, field) {\n  if (!isNonEmpty(value)) {\n    throw new Error(\n      `Invalid value for field '${field}'. Please provide a non-empty string. For more information: https://liveblocks.io/docs/api-reference/liveblocks-node#authorize`\n    );\n  }\n}\nfunction assertSecretKey(value, field) {\n  if (!startsWith(value, \"sk_\")) {\n    throw new Error(\n      `Invalid value for field '${field}'. Secret keys must start with 'sk_'. Please provide the secret key from your Liveblocks dashboard at https://liveblocks.io/dashboard/apikeys.`\n    );\n  }\n  if (!VALID_KEY_CHARS_REGEX.test(value)) {\n    throw new Error(\n      `Invalid chars found in field '${field}'. Please check that you correctly copied the secret key from your Liveblocks dashboard at https://liveblocks.io/dashboard/apikeys.`\n    );\n  }\n}\nfunction normalizeStatusCode(statusCode) {\n  if (statusCode >= 200 && statusCode < 300) {\n    return 200;\n  } else if (statusCode >= 500) {\n    return 503;\n  } else {\n    return 403;\n  }\n}\n\n// src/Session.ts\nvar ALL_PERMISSIONS = Object.freeze([\n  \"room:write\",\n  \"room:read\",\n  \"room:presence:write\",\n  \"comments:write\",\n  \"comments:read\"\n]);\nfunction isPermission(value) {\n  return ALL_PERMISSIONS.includes(value);\n}\nvar MAX_PERMS_PER_SET = 10;\nvar READ_ACCESS = Object.freeze([\n  \"room:read\",\n  \"room:presence:write\",\n  \"comments:read\"\n]);\nvar FULL_ACCESS = Object.freeze([\"room:write\", \"comments:write\"]);\nvar roomPatternRegex = /^([*]|[^*]{1,128}[*]?)$/;\nvar Session = class {\n  FULL_ACCESS = FULL_ACCESS;\n  READ_ACCESS = READ_ACCESS;\n  #postFn;\n  #userId;\n  #userInfo;\n  #sealed = false;\n  #permissions = /* @__PURE__ */ new Map();\n  /** @internal */\n  constructor(postFn, userId, userInfo) {\n    assertNonEmpty(userId, \"userId\");\n    this.#postFn = postFn;\n    this.#userId = userId;\n    this.#userInfo = userInfo;\n  }\n  #getOrCreate(roomId) {\n    if (this.#sealed) {\n      throw new Error(\"You can no longer change these permissions.\");\n    }\n    let perms = this.#permissions.get(roomId);\n    if (perms) {\n      return perms;\n    } else {\n      if (this.#permissions.size >= MAX_PERMS_PER_SET) {\n        throw new Error(\n          \"You cannot add permissions for more than 10 rooms in a single token\"\n        );\n      }\n      perms = /* @__PURE__ */ new Set();\n      this.#permissions.set(roomId, perms);\n      return perms;\n    }\n  }\n  allow(roomIdOrPattern, newPerms) {\n    if (typeof roomIdOrPattern !== \"string\") {\n      throw new Error(\"Room name or pattern must be a string\");\n    }\n    if (!roomPatternRegex.test(roomIdOrPattern)) {\n      throw new Error(\"Invalid room name or pattern\");\n    }\n    if (newPerms.length === 0) {\n      throw new Error(\"Permission list cannot be empty\");\n    }\n    const existingPerms = this.#getOrCreate(roomIdOrPattern);\n    for (const perm of newPerms) {\n      if (!isPermission(perm)) {\n        throw new Error(`Not a valid permission: ${perm}`);\n      }\n      existingPerms.add(perm);\n    }\n    return this;\n  }\n  /** @internal - For unit tests only */\n  hasPermissions() {\n    return this.#permissions.size > 0;\n  }\n  /** @internal - For unit tests only */\n  seal() {\n    if (this.#sealed) {\n      throw new Error(\n        \"You cannot reuse Session instances. Please create a new session every time.\"\n      );\n    }\n    this.#sealed = true;\n  }\n  /** @internal - For unit tests only */\n  serializePermissions() {\n    return Object.fromEntries(\n      Array.from(this.#permissions.entries()).map(([pat, perms]) => [\n        pat,\n        Array.from(perms)\n      ])\n    );\n  }\n  /**\n   * Call this to authorize the session to access Liveblocks. Note that this\n   * will return a Liveblocks \"access token\". Anyone that obtains such access\n   * token will have access to the allowed resources.\n   */\n  async authorize() {\n    this.seal();\n    if (!this.hasPermissions()) {\n      console.warn(\n        \"Access tokens without any permission will not be supported soon, you should use wildcards when the client requests a token for resources outside a room. See https://liveblocks.io/docs/errors/liveblocks-client/access-tokens-not-enough-permissions\"\n      );\n    }\n    try {\n      const resp = await this.#postFn((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/authorize-user`, {\n        // Required\n        userId: this.#userId,\n        permissions: this.serializePermissions(),\n        // Optional metadata\n        userInfo: this.#userInfo\n      });\n      return {\n        status: normalizeStatusCode(resp.status),\n        body: await resp.text()\n      };\n    } catch (er) {\n      return {\n        status: 503,\n        body: 'Call to /v2/authorize-user failed. See \"error\" for more information.',\n        error: er\n      };\n    }\n  }\n};\n\n// src/client.ts\nvar Liveblocks = class {\n  #secret;\n  #baseUrl;\n  /**\n   * Interact with the Liveblocks API from your Node.js backend.\n   */\n  constructor(options) {\n    const options_ = options;\n    const secret = options_.secret;\n    assertSecretKey(secret, \"secret\");\n    this.#secret = secret;\n    this.#baseUrl = new URL(getBaseUrl(options.baseUrl));\n  }\n  async #post(path, json, options) {\n    const url3 = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.urljoin)(this.#baseUrl, path);\n    const headers = {\n      Authorization: `Bearer ${this.#secret}`,\n      \"Content-Type\": \"application/json\"\n    };\n    const fetch = await fetchPolyfill();\n    const res = await fetch(url3, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(json),\n      signal: options?.signal\n    });\n    return res;\n  }\n  async #put(path, json, options) {\n    const url3 = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.urljoin)(this.#baseUrl, path);\n    const headers = {\n      Authorization: `Bearer ${this.#secret}`,\n      \"Content-Type\": \"application/json\"\n    };\n    const fetch = await fetchPolyfill();\n    return await fetch(url3, {\n      method: \"PUT\",\n      headers,\n      body: JSON.stringify(json),\n      signal: options?.signal\n    });\n  }\n  async #putBinary(path, body, params, options) {\n    const url3 = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.urljoin)(this.#baseUrl, path, params);\n    const headers = {\n      Authorization: `Bearer ${this.#secret}`,\n      \"Content-Type\": \"application/octet-stream\"\n    };\n    const fetch = await fetchPolyfill();\n    return await fetch(url3, {\n      method: \"PUT\",\n      headers,\n      body,\n      signal: options?.signal\n    });\n  }\n  async #delete(path, options) {\n    const url3 = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.urljoin)(this.#baseUrl, path);\n    const headers = {\n      Authorization: `Bearer ${this.#secret}`\n    };\n    const fetch = await fetchPolyfill();\n    const res = await fetch(url3, {\n      method: \"DELETE\",\n      headers,\n      signal: options?.signal\n    });\n    return res;\n  }\n  async #get(path, params, options) {\n    const url3 = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.urljoin)(this.#baseUrl, path, params);\n    const headers = {\n      Authorization: `Bearer ${this.#secret}`\n    };\n    const fetch = await fetchPolyfill();\n    const res = await fetch(url3, {\n      method: \"GET\",\n      headers,\n      signal: options?.signal\n    });\n    return res;\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Authentication\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Prepares a new session to authorize a user to access Liveblocks.\n   *\n   * IMPORTANT:\n   * Always make sure that you trust the user making the request to your\n   * backend before calling .prepareSession()!\n   *\n   * @param userId Tell Liveblocks the user ID of the user to authorize. Must\n   * uniquely identify the user account in your system. The uniqueness of this\n   * value will determine how many MAUs will be counted/billed.\n   *\n   * @param options.userInfo Custom metadata to attach to this user. Data you\n   * add here will be visible to all other clients in the room, through the\n   * `other.info` property.\n   *\n   */\n  prepareSession(userId, ...rest) {\n    const options = rest[0];\n    return new Session(this.#post.bind(this), userId, options?.userInfo);\n  }\n  /**\n   * Call this to authenticate the user as an actor you want to allow to use\n   * Liveblocks.\n   *\n   * You should use this method only if you want to manage your permissions\n   * through the Liveblocks Permissions API. This method is more complicated to\n   * set up, but allows for finer-grained specification of permissions.\n   *\n   * Calling `.identifyUser()` only lets you securely identify a user (and what\n   * groups they belong to). What permissions this user will end up having is\n   * determined by whatever permissions you assign the user/group in your\n   * Liveblocks account, through the Permissions API:\n   * https://liveblocks.io/docs/rooms/permissions\n   *\n   * IMPORTANT:\n   * Always verify that you trust the user making the request before calling\n   * .identifyUser()!\n   *\n   * @param identity Tell Liveblocks the user ID of the user to authenticate.\n   * Must uniquely identify the user account in your system. The uniqueness of\n   * this value will determine how many MAUs will be counted/billed.\n   *\n   * If you also want to assign which groups this user belongs to, use the\n   * object form and specify the `groupIds` property. Those `groupIds` should\n   * match the groupIds you assigned permissions to via the Liveblocks\n   * Permissions API, see\n   * https://liveblocks.io/docs/rooms/permissions#permissions-levels-groups-accesses-example\n   *\n   * @param options.userInfo Custom metadata to attach to this user. Data you\n   * add here will be visible to all other clients in the room, through the\n   * `other.info` property.\n   */\n  // These fields define the security identity of the user. Whatever you pass in here will define which\n  async identifyUser(identity, ...rest) {\n    const options = rest[0];\n    const path = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/identify-user`;\n    const userId = typeof identity === \"string\" ? identity : identity.userId;\n    const groupIds = typeof identity === \"string\" ? void 0 : identity.groupIds;\n    assertNonEmpty(userId, \"userId\");\n    try {\n      const resp = await this.#post(path, {\n        userId,\n        groupIds,\n        // Optional metadata\n        userInfo: options?.userInfo\n      });\n      return {\n        status: normalizeStatusCode(resp.status),\n        body: await resp.text()\n      };\n    } catch (er) {\n      return {\n        status: 503,\n        body: `Call to ${(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.urljoin)(\n          this.#baseUrl,\n          path\n        )} failed. See \"error\" for more information.`,\n        error: er\n      };\n    }\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Room\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Returns a list of your rooms. The rooms are returned sorted by creation date, from newest to oldest. You can filter rooms by metadata, users accesses and groups accesses.\n   * @param params.limit (optional) A limit on the number of rooms to be returned. The limit can range between 1 and 100, and defaults to 20.\n   * @param params.startingAfter (optional) A cursor used for pagination. You get the value from the response of the previous page.\n   * @param params.userId (optional) A filter on users accesses.\n   * @param params.metadata (optional) A filter on metadata. Multiple metadata keys can be used to filter rooms.\n   * @param params.groupIds (optional) A filter on groups accesses. Multiple groups can be used.\n   * @param params.query (optional) A query to filter rooms by. It is based on our query language. You can filter by metadata and room ID.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns A list of rooms.\n   */\n  async getRooms(params = {}, options) {\n    const path = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms`;\n    let query;\n    if (typeof params.query === \"string\") {\n      query = params.query;\n    } else if (typeof params.query === \"object\") {\n      query = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.objectToQuery)(params.query);\n    }\n    const queryParams = {\n      limit: params.limit,\n      startingAfter: params.startingAfter,\n      userId: params.userId,\n      groupIds: params.groupIds ? params.groupIds.join(\",\") : void 0,\n      // \"Flatten\" {metadata: {foo: \"bar\"}} to {\"metadata.foo\": \"bar\"}\n      ...Object.fromEntries(\n        Object.entries(params.metadata ?? {}).map(([key, val]) => [\n          `metadata.${key}`,\n          val\n        ])\n      ),\n      query\n    };\n    const res = await this.#get(path, queryParams, options);\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const page = await res.json();\n    const rooms = page.data.map((room) => {\n      const lastConnectionAt = room.lastConnectionAt ? new Date(room.lastConnectionAt) : void 0;\n      const createdAt = new Date(room.createdAt);\n      return {\n        ...room,\n        createdAt,\n        lastConnectionAt\n      };\n    });\n    return {\n      ...page,\n      data: rooms\n    };\n  }\n  /**\n   * Iterates over all rooms that match the given criteria.\n   *\n   * The difference with .getRooms() is that pagination will happen\n   * automatically under the hood, using the given `pageSize`.\n   *\n   * @param criteria.userId (optional) A filter on users accesses.\n   * @param criteria.groupIds (optional) A filter on groups accesses. Multiple groups can be used.\n   * @param criteria.query.roomId (optional) A filter by room ID.\n   * @param criteria.query.metadata (optional) A filter by metadata.\n   *\n   * @param options.pageSize (optional) The page size to use for each request.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async *iterRooms(criteria, options) {\n    const { signal } = options ?? {};\n    const pageSize = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.checkBounds)(\"pageSize\", options?.pageSize ?? 40, 20);\n    let cursor = void 0;\n    while (true) {\n      const { nextCursor, data } = await this.getRooms(\n        { ...criteria, startingAfter: cursor, limit: pageSize },\n        { signal }\n      );\n      for (const item of data) {\n        yield item;\n      }\n      if (!nextCursor) {\n        break;\n      }\n      cursor = nextCursor;\n    }\n  }\n  /**\n   * Creates a new room with the given id.\n   * @param roomId The id of the room to create.\n   * @param params.defaultAccesses The default accesses for the room.\n   * @param params.groupsAccesses (optional) The group accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.usersAccesses (optional) The user accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.metadata (optional) The metadata for the room. Supports upto a maximum of 50 entries. Key length has a limit of 40 characters. Value length has a limit of 256 characters.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The created room.\n   */\n  async createRoom(roomId, params, options) {\n    const { defaultAccesses, groupsAccesses, usersAccesses, metadata } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms`,\n      {\n        id: roomId,\n        defaultAccesses,\n        groupsAccesses,\n        usersAccesses,\n        metadata\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    const lastConnectionAt = data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0;\n    const createdAt = new Date(data.createdAt);\n    return {\n      ...data,\n      lastConnectionAt,\n      createdAt\n    };\n  }\n  /**\n   * Returns a room with the given id, or creates one with the given creation\n   * options if it doesn't exist yet.\n   *\n   * @param roomId The id of the room.\n   * @param params.defaultAccesses The default accesses for the room if the room will be created.\n   * @param params.groupsAccesses (optional) The group accesses for the room if the room will be created. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.usersAccesses (optional) The user accesses for the room if the room will be created. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.metadata (optional) The metadata for the room if the room will be created. Supports upto a maximum of 50 entries. Key length has a limit of 40 characters. Value length has a limit of 256 characters.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The room.\n   */\n  async getOrCreateRoom(roomId, params, options) {\n    try {\n      return await this.createRoom(roomId, params, options);\n    } catch (err) {\n      if (err instanceof LiveblocksError && err.status === 409) {\n        return await this.getRoom(roomId, options);\n      } else {\n        throw err;\n      }\n    }\n  }\n  /**\n   * Updates or creates a new room with the given properties.\n   *\n   * @param roomId The id of the room to update or create.\n   * @param params.defaultAccesses The default accesses for the room.\n   * @param params.groupsAccesses (optional) The group accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.usersAccesses (optional) The user accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.metadata (optional) The metadata for the room. Supports upto a maximum of 50 entries. Key length has a limit of 40 characters. Value length has a limit of 256 characters.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The room.\n   */\n  async upsertRoom(roomId, params, options) {\n    try {\n      return await this.createRoom(roomId, params, options);\n    } catch (err) {\n      if (err instanceof LiveblocksError && err.status === 409) {\n        return await this.updateRoom(roomId, params, options);\n      } else {\n        throw err;\n      }\n    }\n  }\n  /**\n   * Returns a room with the given id.\n   * @param roomId The id of the room to return.\n   * @returns The room with the given id.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async getRoom(roomId, options) {\n    const res = await this.#get((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}`, void 0, options);\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    const lastConnectionAt = data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0;\n    const createdAt = new Date(data.createdAt);\n    return {\n      ...data,\n      createdAt,\n      lastConnectionAt\n    };\n  }\n  /**\n   * Updates specific properties of a room. Its not necessary to provide the entire rooms information.\n   * Setting a property to `null` means to delete this property.\n   * @param roomId The id of the room to update.\n   * @param params.defaultAccesses (optional) The default accesses for the room.\n   * @param params.groupsAccesses (optional) The group accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.usersAccesses (optional) The user accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.\n   * @param params.metadata (optional) The metadata for the room. Supports upto a maximum of 50 entries. Key length has a limit of 40 characters. Value length has a limit of 256 characters.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The updated room.\n   */\n  async updateRoom(roomId, params, options) {\n    const { defaultAccesses, groupsAccesses, usersAccesses, metadata } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}`,\n      {\n        defaultAccesses,\n        groupsAccesses,\n        usersAccesses,\n        metadata\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    const lastConnectionAt = data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0;\n    const createdAt = new Date(data.createdAt);\n    return {\n      ...data,\n      lastConnectionAt,\n      createdAt\n    };\n  }\n  /**\n   * Deletes a room with the given id. A deleted room is no longer accessible from the API or the dashboard and it cannot be restored.\n   * @param roomId The id of the room to delete.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteRoom(roomId, options) {\n    const res = await this.#delete((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}`, options);\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Returns a list of users currently present in the requested room. For better performance, we recommand to call this endpoint every 10 seconds maximum. Duplicates can happen if a user is in the requested room with multiple browser tabs opened.\n   * @param roomId The id of the room to get the users from.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns A list of users currently present in the requested room.\n   */\n  async getActiveUsers(roomId, options) {\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/active_users`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Boadcasts an event to a room without having to connect to it via the client from @liveblocks/client. The connectionId passed to event listeners is -1 when using this API.\n   * @param roomId The id of the room to broadcast the event to.\n   * @param message The message to broadcast. It can be any JSON serializable value.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async broadcastEvent(roomId, message, options) {\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/broadcast_event`,\n      message,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  async getStorageDocument(roomId, format = \"plain-lson\", options) {\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/storage`,\n      { format },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  async #requestStorageMutation(roomId, options) {\n    const resp = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/request-storage-mutation`,\n      {},\n      options\n    );\n    if (!resp.ok) {\n      throw await LiveblocksError.from(resp);\n    }\n    if (resp.headers.get(\"content-type\") !== \"application/x-ndjson\") {\n      throw new Error(\"Unexpected response content type\");\n    }\n    if (resp.body === null) {\n      throw new Error(\"Unexpected null body in response\");\n    }\n    const stream = resp.body.pipeThrough(new TextDecoderStream()).pipeThrough(new LineStream()).pipeThrough(new NdJsonStream());\n    const iter = stream[Symbol.asyncIterator]();\n    const { actor } = await iter.next();\n    const nodes = await asyncConsume(iter);\n    return { actor, nodes };\n  }\n  /**\n   * Initializes a rooms Storage. The room must already exist and have an empty Storage.\n   * Calling this endpoint will disconnect all users from the room if there are any.\n   *\n   * @param roomId The id of the room to initialize the storage from.\n   * @param document The document to initialize the storage with.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The initialized storage document. It is of the same format as the one passed in.\n   */\n  async initializeStorageDocument(roomId, document, options) {\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/storage`,\n      document,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Deletes all of the rooms Storage data and disconnect all users from the room if there are any. Note that this does not delete the Yjs document in the room if one exists.\n   * @param roomId The id of the room to delete the storage from.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteStorageDocument(roomId, options) {\n    const res = await this.#delete((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/storage`, options);\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Yjs\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Returns a JSON representation of the rooms Yjs document.\n   * @param roomId The id of the room to get the Yjs document from.\n   * @param params.format (optional) If true, YText will return formatting.\n   * @param params.key (optional) If provided, returns only a single keys value, e.g. doc.get(key).toJSON().\n   * @param params.type (optional) Used with key to override the inferred type, i.e. \"ymap\" will return doc.get(key, Y.Map).\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns A JSON representation of the rooms Yjs document.\n   */\n  async getYjsDocument(roomId, params = {}, options) {\n    const { format, key, type } = params;\n    const path = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`v2/rooms/${roomId}/ydoc`;\n    const res = await this.#get(\n      path,\n      { formatting: format ? \"true\" : void 0, key, type },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Send a Yjs binary update to the rooms Yjs document. You can use this endpoint to initialize Yjs data for the room or to update the rooms Yjs document.\n   * @param roomId The id of the room to send the Yjs binary update to.\n   * @param update The Yjs update to send. Typically the result of calling `Yjs.encodeStateAsUpdate(doc)`. Read the [Yjs documentation](https://docs.yjs.dev/api/document-updates) to learn how to create a binary update.\n   * @param params.guid (optional) If provided, the binary update will be applied to the Yjs subdocument with the given guid. If not provided, the binary update will be applied to the root Yjs document.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async sendYjsBinaryUpdate(roomId, update, params = {}, options) {\n    const res = await this.#putBinary(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/ydoc`,\n      update,\n      { guid: params.guid },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Returns the rooms Yjs document encoded as a single binary update. This can be used by Y.applyUpdate(responseBody) to get a copy of the document in your backend.\n   * See [Yjs documentation](https://docs.yjs.dev/api/document-updates) for more information on working with updates.\n   * @param roomId The id of the room to get the Yjs document from.\n   * @param params.guid (optional) If provided, returns the binary update of the Yjs subdocument with the given guid. If not provided, returns the binary update of the root Yjs document.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The rooms Yjs document encoded as a single binary update.\n   */\n  async getYjsDocumentAsBinaryUpdate(roomId, params = {}, options) {\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/ydoc-binary`,\n      { guid: params.guid },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return res.arrayBuffer();\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Schema Validation\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Creates a new schema which can be referenced later to enforce a rooms Storage data structure.\n   * @param name The name used to reference the schema. Must be a non-empty string with less than 65 characters and only contain lowercase letters, numbers and dashes\n   * @param body The exact allowed shape of data in the room. It is a multi-line string written in the [Liveblocks schema syntax](https://liveblocks.io/docs/platform/schema-validation/syntax).\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The created schema.\n   */\n  async createSchema(name, body, options) {\n    const res = await this.#post((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/schemas`, { name, body }, options);\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    const createdAt = new Date(data.createdAt);\n    const updatedAt = new Date(data.updatedAt);\n    return {\n      ...data,\n      createdAt,\n      updatedAt\n    };\n  }\n  /**\n   * Returns a schema by its id.\n   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The schema with the given id.\n   */\n  async getSchema(schemaId, options) {\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/schemas/${schemaId}`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    const createdAt = new Date(data.createdAt);\n    const updatedAt = new Date(data.updatedAt);\n    return {\n      ...data,\n      createdAt,\n      updatedAt\n    };\n  }\n  /**\n   * Updates the body for the schema. A schema can only be updated if it is not used by any room.\n   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.\n   * @param body The exact allowed shape of data in the room. It is a multi-line string written in the [Liveblocks schema syntax](https://liveblocks.io/docs/platform/schema-validation/syntax).\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The updated schema. The version of the schema will be incremented.\n   */\n  async updateSchema(schemaId, body, options) {\n    const res = await this.#put(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/schemas/${schemaId}`,\n      { body },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    const createdAt = new Date(data.createdAt);\n    const updatedAt = new Date(data.updatedAt);\n    return {\n      ...data,\n      createdAt,\n      updatedAt\n    };\n  }\n  /**\n   * Deletes a schema by its id. A schema can only be deleted if it is not used by any room.\n   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteSchema(schemaId, options) {\n    const res = await this.#delete((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/schemas/${schemaId}`, options);\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Returns the schema attached to a room.\n   * @param roomId The id of the room to get the schema from.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns\n   */\n  async getSchemaByRoomId(roomId, options) {\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/schema`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    const createdAt = new Date(data.createdAt);\n    const updatedAt = new Date(data.updatedAt);\n    return {\n      ...data,\n      createdAt,\n      updatedAt\n    };\n  }\n  /**\n   * Attaches a schema to a room, and instantly enables runtime schema validation for the room.\n   * If the current contents of the rooms Storage do not match the schema, attaching will fail and the error message will give details on why the schema failed to attach.\n   * @param roomId The id of the room to attach the schema to.\n   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The schema id as JSON.\n   */\n  async attachSchemaToRoom(roomId, schemaId, options) {\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/schema`,\n      { schema: schemaId },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Detaches a schema from a room, and disables runtime schema validation for the room.\n   * @param roomId The id of the room to detach the schema from.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async detachSchemaFromRoom(roomId, options) {\n    const res = await this.#delete((0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/schema`, options);\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /* -------------------------------------------------------------------------------------------------\n   * Comments\n   * -----------------------------------------------------------------------------------------------*/\n  /**\n   * Gets all the threads in a room.\n   *\n   * @param params.roomId The room ID to get the threads from.\n   * @param params.query The query to filter threads by. It is based on our query language and can filter by metadata.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns A list of threads.\n   */\n  async getThreads(params, options) {\n    const { roomId } = params;\n    let query;\n    if (typeof params.query === \"string\") {\n      query = params.query;\n    } else if (typeof params.query === \"object\") {\n      query = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.objectToQuery)(params.query);\n    }\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads`,\n      { query },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const { data } = await res.json();\n    return {\n      data: data.map((thread) => (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(thread))\n    };\n  }\n  /**\n   * Gets a thread.\n   *\n   * @param params.roomId The room ID to get the thread from.\n   * @param params.threadId The thread ID.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns A thread.\n   */\n  async getThread(params, options) {\n    const { roomId, threadId } = params;\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(await res.json());\n  }\n  /**\n   * Gets a thread's participants.\n   *\n   * Participants are users who have commented on the thread\n   * or users and groups that have been mentioned in a comment.\n   *\n   * @param params.roomId The room ID to get the thread participants from.\n   * @param params.threadId The thread ID to get the participants from.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns An object containing an array of participant IDs.\n   */\n  async getThreadParticipants(params, options) {\n    const { roomId, threadId } = params;\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/participants`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Gets a thread's comment.\n   *\n   * @param params.roomId The room ID to get the comment from.\n   * @param params.threadId The thread ID to get the comment from.\n   * @param params.commentId The comment ID.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns A comment.\n   */\n  async getComment(params, options) {\n    const { roomId, threadId, commentId } = params;\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToCommentData)(await res.json());\n  }\n  /**\n   * Creates a comment.\n   *\n   * @param params.roomId The room ID to create the comment in.\n   * @param params.threadId The thread ID to create the comment in.\n   * @param params.data.userId The user ID of the user who is set to create the comment.\n   * @param params.data.createdAt (optional) The date the comment is set to be created.\n   * @param params.data.body The body of the comment.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The created comment.\n   */\n  async createComment(params, options) {\n    const { roomId, threadId, data } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/comments`,\n      {\n        ...data,\n        createdAt: data.createdAt?.toISOString()\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToCommentData)(await res.json());\n  }\n  /**\n   * Edits a comment.\n   * @param params.roomId The room ID to edit the comment in.\n   * @param params.threadId The thread ID to edit the comment in.\n   * @param params.commentId The comment ID to edit.\n   * @param params.data.body The body of the comment.\n   * @param params.data.editedAt (optional) The date the comment was edited.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The edited comment.\n   */\n  async editComment(params, options) {\n    const { roomId, threadId, commentId, data } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}`,\n      { ...data, editedAt: data.editedAt?.toISOString() },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToCommentData)(await res.json());\n  }\n  /**\n   * Deletes a comment. Deletes a comment. If there are no remaining comments in the thread, the thread is also deleted.\n   * @param params.roomId The room ID to delete the comment in.\n   * @param params.threadId The thread ID to delete the comment in.\n   * @param params.commentId The comment ID to delete.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteComment(params, options) {\n    const { roomId, threadId, commentId } = params;\n    const res = await this.#delete(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}`,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Creates a new thread. The thread will be created with the specified comment as its first comment.\n   * If the thread already exists, a `LiveblocksError` will be thrown with status code 409.\n   * @param params.roomId The room ID to create the thread in.\n   * @param params.thread.metadata (optional) The metadata for the thread. Supports upto a maximum of 10 entries. Value must be a string, boolean or number\n   * @param params.thread.comment.userId The user ID of the user who created the comment.\n   * @param params.thread.comment.createdAt (optional) The date the comment was created.\n   * @param params.thread.comment.body The body of the comment.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The created thread. The thread will be created with the specified comment as its first comment.\n   */\n  async createThread(params, options) {\n    const { roomId, data } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads`,\n      {\n        ...data,\n        comment: {\n          ...data.comment,\n          createdAt: data.comment.createdAt?.toISOString()\n        }\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(await res.json());\n  }\n  /**\n   * Deletes a thread and all of its comments.\n   * @param params.roomId The room ID to delete the thread in.\n   * @param params.threadId The thread ID to delete.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteThread(params, options) {\n    const { roomId, threadId } = params;\n    const res = await this.#delete(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}`,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Mark a thread as resolved.\n   * @param params.roomId The room ID of the thread.\n   * @param params.threadId The thread ID to mark as resolved.\n   * @param params.data.userId The user ID of the user who marked the thread as resolved.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The thread marked as resolved.\n   */\n  async markThreadAsResolved(params, options) {\n    const { roomId, threadId } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/mark-as-resolved`,\n      { userId: params.data.userId },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(await res.json());\n  }\n  /**\n   * Mark a thread as unresolved.\n   * @param params.roomId The room ID of the thread.\n   * @param params.threadId The thread ID to mark as unresolved.\n   * @param params.data.userId The user ID of the user who marked the thread as unresolved.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The thread marked as unresolved.\n   */\n  async markThreadAsUnresolved(params, options) {\n    const { roomId, threadId } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/mark-as-unresolved`,\n      { userId: params.data.userId },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToThreadData)(await res.json());\n  }\n  /**\n   * Updates the metadata of the specified thread in a room.\n   * @param params.roomId The room ID to update the thread in.\n   * @param params.threadId The thread ID to update.\n   * @param params.data.metadata The metadata for the thread. Value must be a string, boolean or number\n   * @param params.data.userId The user ID of the user who updated the thread.\n   * @param params.data.updatedAt (optional) The date the thread is set to be updated.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The updated thread metadata.\n   */\n  async editThreadMetadata(params, options) {\n    const { roomId, threadId, data } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/metadata`,\n      {\n        ...data,\n        updatedAt: data.updatedAt?.toISOString()\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Adds a new comment reaction to a comment.\n   * @param params.roomId The room ID to add the comment reaction in.\n   * @param params.threadId The thread ID to add the comment reaction in.\n   * @param params.commentId The comment ID to add the reaction in.\n   * @param params.data.emoji The (emoji) reaction to add.\n   * @param params.data.userId The user ID of the user associated with the reaction.\n   * @param params.data.createdAt (optional) The date the reaction is set to be created.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   * @returns The created comment reaction.\n   */\n  async addCommentReaction(params, options) {\n    const { roomId, threadId, commentId, data } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}/add-reaction`,\n      {\n        ...data,\n        createdAt: data.createdAt?.toISOString()\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const reaction = await res.json();\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToCommentUserReaction)(reaction);\n  }\n  /**\n   * Removes a reaction from a comment.\n   * @param params.roomId The room ID to remove the comment reaction from.\n   * @param params.threadId The thread ID to remove the comment reaction from.\n   * @param params.commentId The comment ID to remove the reaction from.\n   * @param params.data.emoji The (emoji) reaction to remove.\n   * @param params.data.userId The user ID of the user associated with the reaction.\n   * @param params.data.removedAt (optional) The date the reaction is set to be removed.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async removeCommentReaction(params, options) {\n    const { roomId, threadId, data } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/threads/${threadId}/comments/${params.commentId}/remove-reaction`,\n      {\n        ...data,\n        removedAt: data.removedAt?.toISOString()\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Returns the inbox notifications for a user.\n   * @param params.userId The user ID to get the inbox notifications from.\n   * @param params.inboxNotificationId The ID of the inbox notification to get.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async getInboxNotification(params, options) {\n    const { userId, inboxNotificationId } = params;\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/users/${userId}/inbox-notifications/${inboxNotificationId}`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToInboxNotificationData)(\n      await res.json()\n    );\n  }\n  /**\n   * Returns the inbox notifications for a user.\n   * @param params.userId The user ID to get the inbox notifications from.\n   * @param params.query The query to filter inbox notifications by. It is based on our query language and can filter by unread.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async getInboxNotifications(params, options) {\n    const { userId } = params;\n    let query;\n    if (typeof params.query === \"string\") {\n      query = params.query;\n    } else if (typeof params.query === \"object\") {\n      query = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.objectToQuery)(params.query);\n    }\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/users/${userId}/inbox-notifications`,\n      {\n        query,\n        limit: params?.limit,\n        startingAfter: params?.startingAfter\n      },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const page = await res.json();\n    return {\n      ...page,\n      data: page.data.map(_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.convertToInboxNotificationData)\n    };\n  }\n  /**\n   * Iterates over all inbox notifications for a user.\n   *\n   * The difference with .getInboxNotifications() is that pagination will\n   * happen automatically under the hood, using the given `pageSize`.\n   *\n   * @param criteria.userId The user ID to get the inbox notifications from.\n   * @param criteria.query The query to filter inbox notifications by. It is based on our query language and can filter by unread.\n   * @param options.pageSize (optional) The page size to use for each request.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async *iterInboxNotifications(criteria, options) {\n    const { signal } = options ?? {};\n    const pageSize = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.checkBounds)(\"pageSize\", options?.pageSize ?? 50, 10);\n    let cursor = void 0;\n    while (true) {\n      const { nextCursor, data } = await this.getInboxNotifications(\n        { ...criteria, startingAfter: cursor, limit: pageSize },\n        { signal }\n      );\n      for (const item of data) {\n        yield item;\n      }\n      if (!nextCursor) {\n        break;\n      }\n      cursor = nextCursor;\n    }\n  }\n  /**\n   * Gets the user's room notification settings.\n   * @param params.userId The user ID to get the room notifications from.\n   * @param params.roomId The room ID to get the room notification settings from.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async getRoomNotificationSettings(params, options) {\n    const { userId, roomId } = params;\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/users/${userId}/notification-settings`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Updates the user's room notification settings.\n   * @param params.userId The user ID to update the room notification settings for.\n   * @param params.roomId The room ID to update the room notification settings for.\n   * @param params.data The new room notification settings for the user.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async updateRoomNotificationSettings(params, options) {\n    const { userId, roomId, data } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/users/${userId}/notification-settings`,\n      data,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    return await res.json();\n  }\n  /**\n   * Delete the user's room notification settings.\n   * @param params.userId The user ID to delete the room notification settings from.\n   * @param params.roomId The room ID to delete the room notification settings from.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteRoomNotificationSettings(params, options) {\n    const { userId, roomId } = params;\n    const res = await this.#delete(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/users/${userId}/notification-settings`,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Update a room ID.\n   * @param params.roomId The current ID of the room.\n   * @param params.newRoomId The new room ID.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async updateRoomId(params, options) {\n    const { currentRoomId, newRoomId } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${currentRoomId}/update-room-id`,\n      { newRoomId },\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const data = await res.json();\n    return {\n      ...data,\n      createdAt: new Date(data.createdAt),\n      lastConnectionAt: data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0\n    };\n  }\n  async triggerInboxNotification(params, options) {\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/inbox-notifications/trigger`,\n      params,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Deletes an inbox notification for a user.\n   * @param params.userId The user ID for which to delete the inbox notification.\n   * @param params.inboxNotificationId The ID of the inbox notification to delete.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteInboxNotification(params, options) {\n    const { userId, inboxNotificationId } = params;\n    const res = await this.#delete(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/users/${userId}/inbox-notifications/${inboxNotificationId}`,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Deletes all inbox notifications for a user.\n   * @param params.userId The user ID for which to delete all the inbox notifications.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteAllInboxNotifications(params, options) {\n    const { userId } = params;\n    const res = await this.#delete(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/users/${userId}/inbox-notifications`,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Get notification settings for a user for a project.\n   * @param params.userId The user ID to get the notifications settings for.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async getNotificationSettings(params, options) {\n    const { userId } = params;\n    const res = await this.#get(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/users/${userId}/notification-settings`,\n      void 0,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const plainSettings = await res.json();\n    const settings = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.createUserNotificationSettings)(plainSettings);\n    return settings;\n  }\n  /**\n   * Update the user's notification settings.\n   * @param params.userId The user ID to update the notification settings for.\n   * @param params.data The new notification settings for the user.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async updateNotificationSettings(params, options) {\n    const { userId, data } = params;\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/users/${userId}/notification-settings`,\n      data,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n    const plainSettings = await res.json();\n    const settings = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.createUserNotificationSettings)(plainSettings);\n    return settings;\n  }\n  /**\n   * Delete the user's notification settings\n   * @param params.userId The user ID to update the notification settings for.\n   * @param options.signal (optional) An abort signal to cancel the request.\n   */\n  async deleteNotificationSettings(params, options) {\n    const { userId } = params;\n    const res = await this.#delete(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/users/${userId}/notification-settings`,\n      options\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n  /**\n   * Retrieves the current Storage contents for the given room ID and calls the\n   * provided callback function, in which you can mutate the Storage contents\n   * at will.\n   *\n   * If you need to run the same mutation across multiple rooms, prefer using\n   * `.massMutateStorage()` instead of looping over room IDs yourself.\n   */\n  async mutateStorage(roomId, callback, options) {\n    return this.#_mutateOneRoom(roomId, void 0, callback, options);\n  }\n  /**\n   * Retrieves the Storage contents for each room that matches the given\n   * criteria and calls the provided callback function, in which you can mutate\n   * the Storage contents at will.\n   *\n   * You can use the `criteria` parameter to select which rooms to process by\n   * their metadata. If you pass `{}` (empty object), all rooms will be\n   * selected and processed.\n   *\n   * This method will execute mutations in parallel, using the specified\n   * `concurrency` value. If you which to run the mutations serially, set\n   * `concurrency` to 1.\n   */\n  async massMutateStorage(criteria, callback, massOptions) {\n    const concurrency = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.checkBounds)(\n      \"concurrency\",\n      massOptions?.concurrency ?? 8,\n      1,\n      20\n    );\n    const pageSize = Math.max(20, concurrency * 4);\n    const { signal } = massOptions ?? {};\n    const rooms = this.iterRooms(criteria, { pageSize, signal });\n    const options = { signal };\n    await runConcurrently(\n      rooms,\n      (roomData) => this.#_mutateOneRoom(roomData.id, roomData, callback, options),\n      concurrency\n    );\n  }\n  async #_mutateOneRoom(roomId, room, callback, options) {\n    const debounceInterval = 200;\n    const { signal, abort } = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.makeAbortController)(options?.signal);\n    let opsBuffer = [];\n    let outstandingFlush$ = void 0;\n    let lastFlush = performance.now();\n    const flushIfNeeded = (force) => {\n      if (opsBuffer.length === 0)\n        return;\n      if (outstandingFlush$) {\n        return;\n      }\n      const now = performance.now();\n      if (!(force || now - lastFlush > debounceInterval)) {\n        return;\n      }\n      lastFlush = now;\n      const ops = opsBuffer;\n      opsBuffer = [];\n      outstandingFlush$ = this.#sendMessage(\n        roomId,\n        [{ type: _liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.ClientMsgCode.UPDATE_STORAGE, ops }],\n        { signal }\n      ).catch((err) => {\n        abort(err);\n      }).finally(() => {\n        outstandingFlush$ = void 0;\n      });\n    };\n    try {\n      const resp = await this.#requestStorageMutation(roomId, { signal });\n      const { actor, nodes } = resp;\n      const pool = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.createManagedPool)(roomId, {\n        getCurrentConnectionId: () => actor,\n        onDispatch: (ops, _reverse, _storageUpdates) => {\n          if (ops.length === 0) return;\n          for (const op of ops) {\n            opsBuffer.push(op);\n          }\n          flushIfNeeded(\n            /* force */\n            false\n          );\n        }\n      });\n      const root = _liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.LiveObject._fromItems(nodes, pool);\n      const callback$ = callback({ room, root });\n      flushIfNeeded(\n        /* force */\n        true\n      );\n      await callback$;\n    } catch (e) {\n      abort();\n      throw e;\n    } finally {\n      await outstandingFlush$;\n      flushIfNeeded(\n        /* force */\n        true\n      );\n      await outstandingFlush$;\n    }\n  }\n  async #sendMessage(roomId, messages, options) {\n    const res = await this.#post(\n      (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.url)`/v2/rooms/${roomId}/send-message`,\n      { messages },\n      { signal: options?.signal }\n    );\n    if (!res.ok) {\n      throw await LiveblocksError.from(res);\n    }\n  }\n};\nvar LiveblocksError = class _LiveblocksError extends Error {\n  status;\n  details;\n  constructor(message, status, details) {\n    super(message);\n    this.name = \"LiveblocksError\";\n    this.status = status;\n    this.details = details;\n  }\n  toString() {\n    let msg = `${this.name}: ${this.message} (status ${this.status})`;\n    if (this.details) {\n      msg += `\n${this.details}`;\n    }\n    return msg;\n  }\n  static async from(res) {\n    const FALLBACK = \"An error happened without an error message\";\n    let text;\n    try {\n      text = await res.text();\n    } catch {\n      text = FALLBACK;\n    }\n    const obj = (0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.tryParseJson)(text) ?? { message: text };\n    const message = obj.message || FALLBACK;\n    const details = [\n      obj.suggestion ? `Suggestion: ${String(obj.suggestion)}` : void 0,\n      obj.docs ? `See also: ${String(obj.docs)}` : void 0\n    ].filter(Boolean).join(\"\\n\") || void 0;\n    return new _LiveblocksError(message, res.status, details);\n  }\n};\n\n// src/webhooks.ts\n\n\nvar WebhookHandler = class _WebhookHandler {\n  #secretBuffer;\n  static #secretPrefix = \"whsec_\";\n  constructor(secret) {\n    if (!secret) throw new Error(\"Secret is required\");\n    if (typeof secret !== \"string\") throw new Error(\"Secret must be a string\");\n    if (secret.startsWith(_WebhookHandler.#secretPrefix) === false)\n      throw new Error(\"Invalid secret, must start with whsec_\");\n    const secretKey = secret.slice(_WebhookHandler.#secretPrefix.length);\n    this.#secretBuffer = Buffer.from(secretKey, \"base64\");\n  }\n  /**\n   * Verifies a webhook request and returns the event\n   */\n  verifyRequest(request) {\n    const { headers, rawBody } = request;\n    const { webhookId, timestamp, rawSignatures } = this.#verifyHeaders(headers);\n    if (typeof rawBody !== \"string\") {\n      throw new Error(\n        `Invalid rawBody field, must be a string, got \"${typeof rawBody}\" instead. It is likely that you need to JSON.stringify the body before passing it.`\n      );\n    }\n    this.#verifyTimestamp(timestamp);\n    const signature = this.#sign(`${webhookId}.${timestamp}.${rawBody}`);\n    const expectedSignatures = rawSignatures.split(\" \").map((rawSignature) => {\n      const [, parsedSignature] = rawSignature.split(\",\");\n      return parsedSignature;\n    }).filter(isNotUndefined);\n    if (expectedSignatures.includes(signature) === false)\n      throw new Error(\n        `Invalid signature, expected one of ${expectedSignatures.join(\n          \", \"\n        )}, got ${signature}`\n      );\n    const event = JSON.parse(rawBody);\n    this.#verifyWebhookEventType(event);\n    return event;\n  }\n  /**\n   * Verifies the headers and returns the webhookId, timestamp and rawSignatures\n   */\n  #verifyHeaders(headers) {\n    const usingNativeHeaders = typeof Headers !== \"undefined\" && headers instanceof Headers;\n    const normalizedHeaders = usingNativeHeaders ? Object.fromEntries(headers) : headers;\n    const sanitizedHeaders = {};\n    Object.keys(normalizedHeaders).forEach((key) => {\n      sanitizedHeaders[key.toLowerCase()] = normalizedHeaders[key];\n    });\n    const webhookId = sanitizedHeaders[\"webhook-id\"];\n    if (typeof webhookId !== \"string\")\n      throw new Error(\"Invalid webhook-id header\");\n    const timestamp = sanitizedHeaders[\"webhook-timestamp\"];\n    if (typeof timestamp !== \"string\")\n      throw new Error(\"Invalid webhook-timestamp header\");\n    const rawSignatures = sanitizedHeaders[\"webhook-signature\"];\n    if (typeof rawSignatures !== \"string\")\n      throw new Error(\"Invalid webhook-signature header\");\n    return { webhookId, timestamp, rawSignatures };\n  }\n  /**\n   * Signs the content with the secret\n   * @param content\n   * @returns `string`\n   */\n  #sign(content) {\n    const encoder = new TextEncoder();\n    const toSign = encoder.encode(content);\n    return _stablelib_base64__WEBPACK_IMPORTED_MODULE_1__.encode(fast_sha256__WEBPACK_IMPORTED_MODULE_2__.hmac(this.#secretBuffer, toSign));\n  }\n  /**\n   * Verifies that the timestamp is not too old or in the future\n   */\n  #verifyTimestamp(timestampHeader) {\n    const now = Math.floor(Date.now() / 1e3);\n    const timestamp = parseInt(timestampHeader, 10);\n    if (isNaN(timestamp)) {\n      throw new Error(\"Invalid timestamp\");\n    }\n    if (timestamp < now - WEBHOOK_TOLERANCE_IN_SECONDS) {\n      throw new Error(\"Timestamp too old\");\n    }\n    if (timestamp > now + WEBHOOK_TOLERANCE_IN_SECONDS) {\n      throw new Error(\"Timestamp in the future\");\n    }\n  }\n  /**\n   * Ensures that the event is a known event type\n   * or throws and prompts the user to upgrade to a higher version of @liveblocks/node\n   */\n  #verifyWebhookEventType(event) {\n    if (event && event.type && [\n      \"storageUpdated\",\n      \"userEntered\",\n      \"userLeft\",\n      \"roomCreated\",\n      \"roomDeleted\",\n      \"commentCreated\",\n      \"commentEdited\",\n      \"commentDeleted\",\n      \"commentReactionAdded\",\n      \"commentReactionRemoved\",\n      \"threadMetadataUpdated\",\n      \"threadCreated\",\n      \"threadDeleted\",\n      \"ydocUpdated\",\n      \"notification\",\n      \"threadMarkedAsResolved\",\n      \"threadMarkedAsUnresolved\"\n    ].includes(event.type)) {\n      if (event.type === \"notification\") {\n        const notification = event;\n        if (notification.data.kind === \"thread\" || notification.data.kind === \"textMention\" || isCustomKind(notification.data.kind)) {\n          return;\n        } else {\n          throw new Error(\n            `Unknown notification kind: ${JSON.stringify(notification.data.kind)}`\n          );\n        }\n      }\n      return;\n    }\n    throw new Error(\n      \"Unknown event type, please upgrade to a higher version of @liveblocks/node\"\n    );\n  }\n};\nvar WEBHOOK_TOLERANCE_IN_SECONDS = 5 * 60;\nvar isNotUndefined = (value) => value !== void 0;\nvar isCustomKind = (value) => {\n  return isString(value) && value.startsWith(\"$\");\n};\nfunction isThreadNotificationEvent(event) {\n  return event.type === \"notification\" && event.data.kind === \"thread\";\n}\nfunction isTextMentionNotificationEvent(event) {\n  return event.type === \"notification\" && event.data.kind === \"textMention\";\n}\nfunction isCustomNotificationEvent(event) {\n  return event.type === \"notification\" && isCustomKind(event.data.kind);\n}\n\n// src/index.ts\n\n(0,_liveblocks_core__WEBPACK_IMPORTED_MODULE_0__.detectDupes)(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3Mvbm9kZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQytDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQWdCMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUN1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGlXQUFvQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE1BQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsTUFBTTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELEtBQUs7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscURBQUc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5REFBTztBQUN4QjtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlEQUFPO0FBQ3hCO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUJBQWlCLHlEQUFPO0FBQ3hCO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUJBQWlCLHlEQUFPO0FBQ3hCO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5REFBTztBQUN4QjtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscURBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx5QkFBeUIseURBQU87QUFDaEM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsaUJBQWlCLHFEQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixjQUFjLCtEQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXLGFBQWEsSUFBSTtBQUNoRDtBQUNBLDRDQUE0QztBQUM1QyxzQkFBc0IsSUFBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixxQkFBcUIsNkRBQVc7QUFDaEM7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDLFVBQVUscURBQXFEO0FBQy9ELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJEQUEyRDtBQUN2RTtBQUNBLE1BQU0scURBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscURBQUksYUFBYSxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkRBQTJEO0FBQ3ZFO0FBQ0EsTUFBTSxxREFBSSxhQUFhLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHFEQUFJLGFBQWEsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFEQUFJLGFBQWEsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0scURBQUksYUFBYSxPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0scURBQUksYUFBYSxPQUFPO0FBQzlCLFFBQVEsUUFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFEQUFJLGFBQWEsT0FBTztBQUM5QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxREFBSSxhQUFhLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxREFBSSxhQUFhLE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsWUFBWSxvQkFBb0I7QUFDaEMsaUJBQWlCLHFEQUFJLFlBQVksT0FBTztBQUN4QztBQUNBO0FBQ0EsUUFBUSxpREFBaUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLE1BQU0scURBQUksYUFBYSxPQUFPO0FBQzlCO0FBQ0EsUUFBUSxtQkFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLE1BQU0scURBQUksYUFBYSxPQUFPO0FBQzlCLFFBQVEsbUJBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxREFBSSxpQkFBaUIsWUFBWTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxREFBSSxlQUFlLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxREFBSSxlQUFlLFNBQVM7QUFDbEMsUUFBUSxNQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxREFBSSxlQUFlLFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxREFBSSxhQUFhLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFEQUFJLGFBQWEsT0FBTztBQUM5QixRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxREFBSSxhQUFhLE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGNBQWMsK0RBQWE7QUFDM0I7QUFDQTtBQUNBLE1BQU0scURBQUksYUFBYSxPQUFPO0FBQzlCLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxpQ0FBaUMscUVBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBLE1BQU0scURBQUksYUFBYSxPQUFPLFdBQVcsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFFQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0EsTUFBTSxxREFBSSxhQUFhLE9BQU8sV0FBVyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOEJBQThCO0FBQzFDO0FBQ0EsTUFBTSxxREFBSSxhQUFhLE9BQU8sV0FBVyxTQUFTLFlBQVksVUFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNFQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0EsTUFBTSxxREFBSSxhQUFhLE9BQU8sV0FBVyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzRUFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQSxNQUFNLHFEQUFJLGFBQWEsT0FBTyxXQUFXLFNBQVMsWUFBWSxVQUFVO0FBQ3hFLFFBQVEsaURBQWlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNFQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhCQUE4QjtBQUMxQztBQUNBLE1BQU0scURBQUksYUFBYSxPQUFPLFdBQVcsU0FBUyxZQUFZLFVBQVU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0EsTUFBTSxxREFBSSxhQUFhLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFFQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQSxNQUFNLHFEQUFJLGFBQWEsT0FBTyxXQUFXLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQSxNQUFNLHFEQUFJLGFBQWEsT0FBTyxXQUFXLFNBQVM7QUFDbEQsUUFBUSw0QkFBNEI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUVBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQSxNQUFNLHFEQUFJLGFBQWEsT0FBTyxXQUFXLFNBQVM7QUFDbEQsUUFBUSw0QkFBNEI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUVBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0EsTUFBTSxxREFBSSxhQUFhLE9BQU8sV0FBVyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0NBQW9DO0FBQ2hEO0FBQ0EsTUFBTSxxREFBSSxhQUFhLE9BQU8sV0FBVyxTQUFTLFlBQVksVUFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4RUFBNEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQSxNQUFNLHFEQUFJLGFBQWEsT0FBTyxXQUFXLFNBQVMsWUFBWSxpQkFBaUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4QkFBOEI7QUFDMUM7QUFDQSxNQUFNLHFEQUFJLGFBQWEsT0FBTyx1QkFBdUIsb0JBQW9CO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0ZBQThCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixjQUFjLCtEQUFhO0FBQzNCO0FBQ0E7QUFDQSxNQUFNLHFEQUFJLGFBQWEsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRFQUE4QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLHFCQUFxQiw2REFBVztBQUNoQztBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakMsVUFBVSxxREFBcUQ7QUFDL0QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBLE1BQU0scURBQUksYUFBYSxPQUFPLFNBQVMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUJBQXVCO0FBQ25DO0FBQ0EsTUFBTSxxREFBSSxhQUFhLE9BQU8sU0FBUyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0EsTUFBTSxxREFBSSxhQUFhLE9BQU8sU0FBUyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQSxNQUFNLHFEQUFJLGFBQWEsY0FBYztBQUNyQyxRQUFRLFdBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0scURBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4QkFBOEI7QUFDMUM7QUFDQSxNQUFNLHFEQUFJLGFBQWEsT0FBTyx1QkFBdUIsb0JBQW9CO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBLE1BQU0scURBQUksYUFBYSxPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBLE1BQU0scURBQUksYUFBYSxPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdGQUE4QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQSxNQUFNLHFEQUFJLGFBQWEsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnRkFBOEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBLE1BQU0scURBQUksYUFBYSxPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkRBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLDZDQUE2QyxrQkFBa0I7QUFDL0Qsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQixFQUFFLHFFQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU0sMkRBQWEsc0JBQXNCO0FBQ3BELFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxnRUFBZ0UsUUFBUTtBQUN4RSxjQUFjLGVBQWU7QUFDN0IsbUJBQW1CLG1FQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG1CQUFtQix3REFBVTtBQUM3QixtQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFEQUFJLGFBQWEsT0FBTztBQUM5QixRQUFRLFVBQVU7QUFDbEIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVUsSUFBSSxjQUFjLFVBQVUsWUFBWTtBQUNuRTtBQUNBO0FBQ0EsRUFBRSxhQUFhO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsZ0JBQWdCLDhEQUFZLFlBQVk7QUFDeEM7QUFDQTtBQUNBLHNDQUFzQyx1QkFBdUI7QUFDN0QsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM0QztBQUNOO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CLFlBQVksc0NBQXNDO0FBQ2xEO0FBQ0E7QUFDQSx5REFBeUQsZUFBZTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVSxHQUFHLFVBQVUsR0FBRyxRQUFRO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsVUFBVSxRQUFRLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxREFBYSxDQUFDLDZDQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDBDQUEwQyx1Q0FBdUM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBSzBCO0FBQzFCLDZEQUFXO0FBV1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2xlYXJuLXJsLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL25vZGUvZGlzdC9pbmRleC5qcz9jMmQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IHsgZGV0ZWN0RHVwZXMgfSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuXG4vLyBzcmMvdmVyc2lvbi50c1xudmFyIFBLR19OQU1FID0gXCJAbGl2ZWJsb2Nrcy9ub2RlXCI7XG52YXIgUEtHX1ZFUlNJT04gPSBcIjIuMjIuMFwiO1xudmFyIFBLR19GT1JNQVQgPSBcImVzbVwiO1xuXG4vLyBzcmMvY2xpZW50LnRzXG5pbXBvcnQge1xuICBjaGVja0JvdW5kcyxcbiAgQ2xpZW50TXNnQ29kZSxcbiAgY29udmVydFRvQ29tbWVudERhdGEsXG4gIGNvbnZlcnRUb0NvbW1lbnRVc2VyUmVhY3Rpb24sXG4gIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YSxcbiAgY29udmVydFRvVGhyZWFkRGF0YSxcbiAgY3JlYXRlTWFuYWdlZFBvb2wsXG4gIGNyZWF0ZVVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyxcbiAgTGl2ZU9iamVjdCxcbiAgbWFrZUFib3J0Q29udHJvbGxlcixcbiAgb2JqZWN0VG9RdWVyeSxcbiAgdHJ5UGFyc2VKc29uLFxuICB1cmwgYXMgdXJsMixcbiAgdXJsam9pblxufSBmcm9tIFwiQGxpdmVibG9ja3MvY29yZVwiO1xuXG4vLyBzcmMvbGliL2l0ZXJ0b29scy50c1xuYXN5bmMgZnVuY3Rpb24gYXN5bmNDb25zdW1lKGl0ZXJhYmxlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgaXRlcmFibGUpIHtcbiAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuYXN5bmMgZnVuY3Rpb24gcnVuQ29uY3VycmVudGx5KGl0ZXJhYmxlLCBmbiwgY29uY3VycmVuY3kpIHtcbiAgY29uc3QgcXVldWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgaXRlcmFibGUpIHtcbiAgICBpZiAocXVldWUuc2l6ZSA+PSBjb25jdXJyZW5jeSkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5yYWNlKHF1ZXVlKTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmbihpdGVtKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHF1ZXVlLmRlbGV0ZShwcm9taXNlKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICAgIHF1ZXVlLmFkZChwcm9taXNlKTtcbiAgfVxuICBpZiAocXVldWUuc2l6ZSA+IDApIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChxdWV1ZSk7XG4gIH1cbn1cblxuLy8gc3JjL2xpYi9uZGpzb24udHNcbnZhciBMaW5lU3RyZWFtID0gY2xhc3MgZXh0ZW5kcyBUcmFuc2Zvcm1TdHJlYW0ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgYnVmZmVyID0gXCJcIjtcbiAgICBzdXBlcih7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgYnVmZmVyICs9IGNodW5rO1xuICAgICAgICBpZiAoYnVmZmVyLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgY29uc3QgbGluZXMgPSBidWZmZXIuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaW5lc1tpXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShsaW5lc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZmZlciA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xudmFyIE5kSnNvblN0cmVhbSA9IGNsYXNzIGV4dGVuZHMgVHJhbnNmb3JtU3RyZWFtIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHJhbnNmb3JtKGxpbmUsIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UobGluZSk7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShqc29uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL1Nlc3Npb24udHNcbmltcG9ydCB7IHVybCB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jb3JlXCI7XG5cbi8vIHNyYy91dGlscy50c1xudmFyIERFRkFVTFRfQkFTRV9VUkwgPSBcImh0dHBzOi8vYXBpLmxpdmVibG9ja3MuaW9cIjtcbnZhciBWQUxJRF9LRVlfQ0hBUlNfUkVHRVggPSAvXltcXHctXSskLztcbmZ1bmN0aW9uIGdldEJhc2VVcmwoYmFzZVVybCkge1xuICBpZiAodHlwZW9mIGJhc2VVcmwgPT09IFwic3RyaW5nXCIgJiYgYmFzZVVybC5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xuICAgIHJldHVybiBiYXNlVXJsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBERUZBVUxUX0JBU0VfVVJMO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaFBvbHlmaWxsKCkge1xuICByZXR1cm4gdHlwZW9mIGdsb2JhbFRoaXMuZmV0Y2ggIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxUaGlzLmZldGNoIDogKGF3YWl0IGltcG9ydChcIm5vZGUtZmV0Y2hcIikpLmRlZmF1bHQ7XG59XG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gc3RhcnRzV2l0aCh2YWx1ZSwgcHJlZml4KSB7XG4gIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUuc3RhcnRzV2l0aChwcmVmaXgpO1xufVxuZnVuY3Rpb24gaXNOb25FbXB0eSh2YWx1ZSkge1xuICByZXR1cm4gaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA+IDA7XG59XG5mdW5jdGlvbiBhc3NlcnROb25FbXB0eSh2YWx1ZSwgZmllbGQpIHtcbiAgaWYgKCFpc05vbkVtcHR5KHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBmaWVsZCAnJHtmaWVsZH0nLiBQbGVhc2UgcHJvdmlkZSBhIG5vbi1lbXB0eSBzdHJpbmcuIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9hcGktcmVmZXJlbmNlL2xpdmVibG9ja3Mtbm9kZSNhdXRob3JpemVgXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0U2VjcmV0S2V5KHZhbHVlLCBmaWVsZCkge1xuICBpZiAoIXN0YXJ0c1dpdGgodmFsdWUsIFwic2tfXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgdmFsdWUgZm9yIGZpZWxkICcke2ZpZWxkfScuIFNlY3JldCBrZXlzIG11c3Qgc3RhcnQgd2l0aCAnc2tfJy4gUGxlYXNlIHByb3ZpZGUgdGhlIHNlY3JldCBrZXkgZnJvbSB5b3VyIExpdmVibG9ja3MgZGFzaGJvYXJkIGF0IGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kYXNoYm9hcmQvYXBpa2V5cy5gXG4gICAgKTtcbiAgfVxuICBpZiAoIVZBTElEX0tFWV9DSEFSU19SRUdFWC50ZXN0KHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIGNoYXJzIGZvdW5kIGluIGZpZWxkICcke2ZpZWxkfScuIFBsZWFzZSBjaGVjayB0aGF0IHlvdSBjb3JyZWN0bHkgY29waWVkIHRoZSBzZWNyZXQga2V5IGZyb20geW91ciBMaXZlYmxvY2tzIGRhc2hib2FyZCBhdCBodHRwczovL2xpdmVibG9ja3MuaW8vZGFzaGJvYXJkL2FwaWtleXMuYFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0YXR1c0NvZGUoc3RhdHVzQ29kZSkge1xuICBpZiAoc3RhdHVzQ29kZSA+PSAyMDAgJiYgc3RhdHVzQ29kZSA8IDMwMCkge1xuICAgIHJldHVybiAyMDA7XG4gIH0gZWxzZSBpZiAoc3RhdHVzQ29kZSA+PSA1MDApIHtcbiAgICByZXR1cm4gNTAzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiA0MDM7XG4gIH1cbn1cblxuLy8gc3JjL1Nlc3Npb24udHNcbnZhciBBTExfUEVSTUlTU0lPTlMgPSBPYmplY3QuZnJlZXplKFtcbiAgXCJyb29tOndyaXRlXCIsXG4gIFwicm9vbTpyZWFkXCIsXG4gIFwicm9vbTpwcmVzZW5jZTp3cml0ZVwiLFxuICBcImNvbW1lbnRzOndyaXRlXCIsXG4gIFwiY29tbWVudHM6cmVhZFwiXG5dKTtcbmZ1bmN0aW9uIGlzUGVybWlzc2lvbih2YWx1ZSkge1xuICByZXR1cm4gQUxMX1BFUk1JU1NJT05TLmluY2x1ZGVzKHZhbHVlKTtcbn1cbnZhciBNQVhfUEVSTVNfUEVSX1NFVCA9IDEwO1xudmFyIFJFQURfQUNDRVNTID0gT2JqZWN0LmZyZWV6ZShbXG4gIFwicm9vbTpyZWFkXCIsXG4gIFwicm9vbTpwcmVzZW5jZTp3cml0ZVwiLFxuICBcImNvbW1lbnRzOnJlYWRcIlxuXSk7XG52YXIgRlVMTF9BQ0NFU1MgPSBPYmplY3QuZnJlZXplKFtcInJvb206d3JpdGVcIiwgXCJjb21tZW50czp3cml0ZVwiXSk7XG52YXIgcm9vbVBhdHRlcm5SZWdleCA9IC9eKFsqXXxbXipdezEsMTI4fVsqXT8pJC87XG52YXIgU2Vzc2lvbiA9IGNsYXNzIHtcbiAgRlVMTF9BQ0NFU1MgPSBGVUxMX0FDQ0VTUztcbiAgUkVBRF9BQ0NFU1MgPSBSRUFEX0FDQ0VTUztcbiAgI3Bvc3RGbjtcbiAgI3VzZXJJZDtcbiAgI3VzZXJJbmZvO1xuICAjc2VhbGVkID0gZmFsc2U7XG4gICNwZXJtaXNzaW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3IocG9zdEZuLCB1c2VySWQsIHVzZXJJbmZvKSB7XG4gICAgYXNzZXJ0Tm9uRW1wdHkodXNlcklkLCBcInVzZXJJZFwiKTtcbiAgICB0aGlzLiNwb3N0Rm4gPSBwb3N0Rm47XG4gICAgdGhpcy4jdXNlcklkID0gdXNlcklkO1xuICAgIHRoaXMuI3VzZXJJbmZvID0gdXNlckluZm87XG4gIH1cbiAgI2dldE9yQ3JlYXRlKHJvb21JZCkge1xuICAgIGlmICh0aGlzLiNzZWFsZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW4gbm8gbG9uZ2VyIGNoYW5nZSB0aGVzZSBwZXJtaXNzaW9ucy5cIik7XG4gICAgfVxuICAgIGxldCBwZXJtcyA9IHRoaXMuI3Blcm1pc3Npb25zLmdldChyb29tSWQpO1xuICAgIGlmIChwZXJtcykge1xuICAgICAgcmV0dXJuIHBlcm1zO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy4jcGVybWlzc2lvbnMuc2l6ZSA+PSBNQVhfUEVSTVNfUEVSX1NFVCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJZb3UgY2Fubm90IGFkZCBwZXJtaXNzaW9ucyBmb3IgbW9yZSB0aGFuIDEwIHJvb21zIGluIGEgc2luZ2xlIHRva2VuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHBlcm1zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuI3Blcm1pc3Npb25zLnNldChyb29tSWQsIHBlcm1zKTtcbiAgICAgIHJldHVybiBwZXJtcztcbiAgICB9XG4gIH1cbiAgYWxsb3cocm9vbUlkT3JQYXR0ZXJuLCBuZXdQZXJtcykge1xuICAgIGlmICh0eXBlb2Ygcm9vbUlkT3JQYXR0ZXJuICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb29tIG5hbWUgb3IgcGF0dGVybiBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgIH1cbiAgICBpZiAoIXJvb21QYXR0ZXJuUmVnZXgudGVzdChyb29tSWRPclBhdHRlcm4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJvb20gbmFtZSBvciBwYXR0ZXJuXCIpO1xuICAgIH1cbiAgICBpZiAobmV3UGVybXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQZXJtaXNzaW9uIGxpc3QgY2Fubm90IGJlIGVtcHR5XCIpO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ1Blcm1zID0gdGhpcy4jZ2V0T3JDcmVhdGUocm9vbUlkT3JQYXR0ZXJuKTtcbiAgICBmb3IgKGNvbnN0IHBlcm0gb2YgbmV3UGVybXMpIHtcbiAgICAgIGlmICghaXNQZXJtaXNzaW9uKHBlcm0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IGEgdmFsaWQgcGVybWlzc2lvbjogJHtwZXJtfWApO1xuICAgICAgfVxuICAgICAgZXhpc3RpbmdQZXJtcy5hZGQocGVybSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgLSBGb3IgdW5pdCB0ZXN0cyBvbmx5ICovXG4gIGhhc1Blcm1pc3Npb25zKCkge1xuICAgIHJldHVybiB0aGlzLiNwZXJtaXNzaW9ucy5zaXplID4gMDtcbiAgfVxuICAvKiogQGludGVybmFsIC0gRm9yIHVuaXQgdGVzdHMgb25seSAqL1xuICBzZWFsKCkge1xuICAgIGlmICh0aGlzLiNzZWFsZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJZb3UgY2Fubm90IHJldXNlIFNlc3Npb24gaW5zdGFuY2VzLiBQbGVhc2UgY3JlYXRlIGEgbmV3IHNlc3Npb24gZXZlcnkgdGltZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy4jc2VhbGVkID0gdHJ1ZTtcbiAgfVxuICAvKiogQGludGVybmFsIC0gRm9yIHVuaXQgdGVzdHMgb25seSAqL1xuICBzZXJpYWxpemVQZXJtaXNzaW9ucygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgQXJyYXkuZnJvbSh0aGlzLiNwZXJtaXNzaW9ucy5lbnRyaWVzKCkpLm1hcCgoW3BhdCwgcGVybXNdKSA9PiBbXG4gICAgICAgIHBhdCxcbiAgICAgICAgQXJyYXkuZnJvbShwZXJtcylcbiAgICAgIF0pXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCB0aGlzIHRvIGF1dGhvcml6ZSB0aGUgc2Vzc2lvbiB0byBhY2Nlc3MgTGl2ZWJsb2Nrcy4gTm90ZSB0aGF0IHRoaXNcbiAgICogd2lsbCByZXR1cm4gYSBMaXZlYmxvY2tzIFwiYWNjZXNzIHRva2VuXCIuIEFueW9uZSB0aGF0IG9idGFpbnMgc3VjaCBhY2Nlc3NcbiAgICogdG9rZW4gd2lsbCBoYXZlIGFjY2VzcyB0byB0aGUgYWxsb3dlZCByZXNvdXJjZXMuXG4gICAqL1xuICBhc3luYyBhdXRob3JpemUoKSB7XG4gICAgdGhpcy5zZWFsKCk7XG4gICAgaWYgKCF0aGlzLmhhc1Blcm1pc3Npb25zKCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJBY2Nlc3MgdG9rZW5zIHdpdGhvdXQgYW55IHBlcm1pc3Npb24gd2lsbCBub3QgYmUgc3VwcG9ydGVkIHNvb24sIHlvdSBzaG91bGQgdXNlIHdpbGRjYXJkcyB3aGVuIHRoZSBjbGllbnQgcmVxdWVzdHMgYSB0b2tlbiBmb3IgcmVzb3VyY2VzIG91dHNpZGUgYSByb29tLiBTZWUgaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3MvZXJyb3JzL2xpdmVibG9ja3MtY2xpZW50L2FjY2Vzcy10b2tlbnMtbm90LWVub3VnaC1wZXJtaXNzaW9uc1wiXG4gICAgICApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuI3Bvc3RGbih1cmxgL3YyL2F1dGhvcml6ZS11c2VyYCwge1xuICAgICAgICAvLyBSZXF1aXJlZFxuICAgICAgICB1c2VySWQ6IHRoaXMuI3VzZXJJZCxcbiAgICAgICAgcGVybWlzc2lvbnM6IHRoaXMuc2VyaWFsaXplUGVybWlzc2lvbnMoKSxcbiAgICAgICAgLy8gT3B0aW9uYWwgbWV0YWRhdGFcbiAgICAgICAgdXNlckluZm86IHRoaXMuI3VzZXJJbmZvXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogbm9ybWFsaXplU3RhdHVzQ29kZShyZXNwLnN0YXR1cyksXG4gICAgICAgIGJvZHk6IGF3YWl0IHJlc3AudGV4dCgpXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IDUwMyxcbiAgICAgICAgYm9keTogJ0NhbGwgdG8gL3YyL2F1dGhvcml6ZS11c2VyIGZhaWxlZC4gU2VlIFwiZXJyb3JcIiBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLFxuICAgICAgICBlcnJvcjogZXJcbiAgICAgIH07XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvY2xpZW50LnRzXG52YXIgTGl2ZWJsb2NrcyA9IGNsYXNzIHtcbiAgI3NlY3JldDtcbiAgI2Jhc2VVcmw7XG4gIC8qKlxuICAgKiBJbnRlcmFjdCB3aXRoIHRoZSBMaXZlYmxvY2tzIEFQSSBmcm9tIHlvdXIgTm9kZS5qcyBiYWNrZW5kLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IG9wdGlvbnNfID0gb3B0aW9ucztcbiAgICBjb25zdCBzZWNyZXQgPSBvcHRpb25zXy5zZWNyZXQ7XG4gICAgYXNzZXJ0U2VjcmV0S2V5KHNlY3JldCwgXCJzZWNyZXRcIik7XG4gICAgdGhpcy4jc2VjcmV0ID0gc2VjcmV0O1xuICAgIHRoaXMuI2Jhc2VVcmwgPSBuZXcgVVJMKGdldEJhc2VVcmwob3B0aW9ucy5iYXNlVXJsKSk7XG4gIH1cbiAgYXN5bmMgI3Bvc3QocGF0aCwganNvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IHVybDMgPSB1cmxqb2luKHRoaXMuI2Jhc2VVcmwsIHBhdGgpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy4jc2VjcmV0fWAsXG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH07XG4gICAgY29uc3QgZmV0Y2ggPSBhd2FpdCBmZXRjaFBvbHlmaWxsKCk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsMywge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShqc29uKSxcbiAgICAgIHNpZ25hbDogb3B0aW9ucz8uc2lnbmFsXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBhc3luYyAjcHV0KHBhdGgsIGpzb24sIG9wdGlvbnMpIHtcbiAgICBjb25zdCB1cmwzID0gdXJsam9pbih0aGlzLiNiYXNlVXJsLCBwYXRoKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuI3NlY3JldH1gLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICB9O1xuICAgIGNvbnN0IGZldGNoID0gYXdhaXQgZmV0Y2hQb2x5ZmlsbCgpO1xuICAgIHJldHVybiBhd2FpdCBmZXRjaCh1cmwzLCB7XG4gICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoanNvbiksXG4gICAgICBzaWduYWw6IG9wdGlvbnM/LnNpZ25hbFxuICAgIH0pO1xuICB9XG4gIGFzeW5jICNwdXRCaW5hcnkocGF0aCwgYm9keSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdXJsMyA9IHVybGpvaW4odGhpcy4jYmFzZVVybCwgcGF0aCwgcGFyYW1zKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuI3NlY3JldH1gLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIlxuICAgIH07XG4gICAgY29uc3QgZmV0Y2ggPSBhd2FpdCBmZXRjaFBvbHlmaWxsKCk7XG4gICAgcmV0dXJuIGF3YWl0IGZldGNoKHVybDMsIHtcbiAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5LFxuICAgICAgc2lnbmFsOiBvcHRpb25zPy5zaWduYWxcbiAgICB9KTtcbiAgfVxuICBhc3luYyAjZGVsZXRlKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB1cmwzID0gdXJsam9pbih0aGlzLiNiYXNlVXJsLCBwYXRoKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuI3NlY3JldH1gXG4gICAgfTtcbiAgICBjb25zdCBmZXRjaCA9IGF3YWl0IGZldGNoUG9seWZpbGwoKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwzLCB7XG4gICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgc2lnbmFsOiBvcHRpb25zPy5zaWduYWxcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGFzeW5jICNnZXQocGF0aCwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdXJsMyA9IHVybGpvaW4odGhpcy4jYmFzZVVybCwgcGF0aCwgcGFyYW1zKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuI3NlY3JldH1gXG4gICAgfTtcbiAgICBjb25zdCBmZXRjaCA9IGF3YWl0IGZldGNoUG9seWZpbGwoKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwzLCB7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgc2lnbmFsOiBvcHRpb25zPy5zaWduYWxcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQXV0aGVudGljYXRpb25cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAvKipcbiAgICogUHJlcGFyZXMgYSBuZXcgc2Vzc2lvbiB0byBhdXRob3JpemUgYSB1c2VyIHRvIGFjY2VzcyBMaXZlYmxvY2tzLlxuICAgKlxuICAgKiBJTVBPUlRBTlQ6XG4gICAqIEFsd2F5cyBtYWtlIHN1cmUgdGhhdCB5b3UgdHJ1c3QgdGhlIHVzZXIgbWFraW5nIHRoZSByZXF1ZXN0IHRvIHlvdXJcbiAgICogYmFja2VuZCBiZWZvcmUgY2FsbGluZyAucHJlcGFyZVNlc3Npb24oKSFcbiAgICpcbiAgICogQHBhcmFtIHVzZXJJZCBUZWxsIExpdmVibG9ja3MgdGhlIHVzZXIgSUQgb2YgdGhlIHVzZXIgdG8gYXV0aG9yaXplLiBNdXN0XG4gICAqIHVuaXF1ZWx5IGlkZW50aWZ5IHRoZSB1c2VyIGFjY291bnQgaW4geW91ciBzeXN0ZW0uIFRoZSB1bmlxdWVuZXNzIG9mIHRoaXNcbiAgICogdmFsdWUgd2lsbCBkZXRlcm1pbmUgaG93IG1hbnkgTUFVcyB3aWxsIGJlIGNvdW50ZWQvYmlsbGVkLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucy51c2VySW5mbyBDdXN0b20gbWV0YWRhdGEgdG8gYXR0YWNoIHRvIHRoaXMgdXNlci4gRGF0YSB5b3VcbiAgICogYWRkIGhlcmUgd2lsbCBiZSB2aXNpYmxlIHRvIGFsbCBvdGhlciBjbGllbnRzIGluIHRoZSByb29tLCB0aHJvdWdoIHRoZVxuICAgKiBgb3RoZXIuaW5mb2AgcHJvcGVydHkuXG4gICAqXG4gICAqL1xuICBwcmVwYXJlU2Vzc2lvbih1c2VySWQsIC4uLnJlc3QpIHtcbiAgICBjb25zdCBvcHRpb25zID0gcmVzdFswXTtcbiAgICByZXR1cm4gbmV3IFNlc3Npb24odGhpcy4jcG9zdC5iaW5kKHRoaXMpLCB1c2VySWQsIG9wdGlvbnM/LnVzZXJJbmZvKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCB0aGlzIHRvIGF1dGhlbnRpY2F0ZSB0aGUgdXNlciBhcyBhbiBhY3RvciB5b3Ugd2FudCB0byBhbGxvdyB0byB1c2VcbiAgICogTGl2ZWJsb2Nrcy5cbiAgICpcbiAgICogWW91IHNob3VsZCB1c2UgdGhpcyBtZXRob2Qgb25seSBpZiB5b3Ugd2FudCB0byBtYW5hZ2UgeW91ciBwZXJtaXNzaW9uc1xuICAgKiB0aHJvdWdoIHRoZSBMaXZlYmxvY2tzIFBlcm1pc3Npb25zIEFQSS4gVGhpcyBtZXRob2QgaXMgbW9yZSBjb21wbGljYXRlZCB0b1xuICAgKiBzZXQgdXAsIGJ1dCBhbGxvd3MgZm9yIGZpbmVyLWdyYWluZWQgc3BlY2lmaWNhdGlvbiBvZiBwZXJtaXNzaW9ucy5cbiAgICpcbiAgICogQ2FsbGluZyBgLmlkZW50aWZ5VXNlcigpYCBvbmx5IGxldHMgeW91IHNlY3VyZWx5IGlkZW50aWZ5IGEgdXNlciAoYW5kIHdoYXRcbiAgICogZ3JvdXBzIHRoZXkgYmVsb25nIHRvKS4gV2hhdCBwZXJtaXNzaW9ucyB0aGlzIHVzZXIgd2lsbCBlbmQgdXAgaGF2aW5nIGlzXG4gICAqIGRldGVybWluZWQgYnkgd2hhdGV2ZXIgcGVybWlzc2lvbnMgeW91IGFzc2lnbiB0aGUgdXNlci9ncm91cCBpbiB5b3VyXG4gICAqIExpdmVibG9ja3MgYWNjb3VudCwgdGhyb3VnaCB0aGUgUGVybWlzc2lvbnMgQVBJOlxuICAgKiBodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9yb29tcy9wZXJtaXNzaW9uc1xuICAgKlxuICAgKiBJTVBPUlRBTlQ6XG4gICAqIEFsd2F5cyB2ZXJpZnkgdGhhdCB5b3UgdHJ1c3QgdGhlIHVzZXIgbWFraW5nIHRoZSByZXF1ZXN0IGJlZm9yZSBjYWxsaW5nXG4gICAqIC5pZGVudGlmeVVzZXIoKSFcbiAgICpcbiAgICogQHBhcmFtIGlkZW50aXR5IFRlbGwgTGl2ZWJsb2NrcyB0aGUgdXNlciBJRCBvZiB0aGUgdXNlciB0byBhdXRoZW50aWNhdGUuXG4gICAqIE11c3QgdW5pcXVlbHkgaWRlbnRpZnkgdGhlIHVzZXIgYWNjb3VudCBpbiB5b3VyIHN5c3RlbS4gVGhlIHVuaXF1ZW5lc3Mgb2ZcbiAgICogdGhpcyB2YWx1ZSB3aWxsIGRldGVybWluZSBob3cgbWFueSBNQVVzIHdpbGwgYmUgY291bnRlZC9iaWxsZWQuXG4gICAqXG4gICAqIElmIHlvdSBhbHNvIHdhbnQgdG8gYXNzaWduIHdoaWNoIGdyb3VwcyB0aGlzIHVzZXIgYmVsb25ncyB0bywgdXNlIHRoZVxuICAgKiBvYmplY3QgZm9ybSBhbmQgc3BlY2lmeSB0aGUgYGdyb3VwSWRzYCBwcm9wZXJ0eS4gVGhvc2UgYGdyb3VwSWRzYCBzaG91bGRcbiAgICogbWF0Y2ggdGhlIGdyb3VwSWRzIHlvdSBhc3NpZ25lZCBwZXJtaXNzaW9ucyB0byB2aWEgdGhlIExpdmVibG9ja3NcbiAgICogUGVybWlzc2lvbnMgQVBJLCBzZWVcbiAgICogaHR0cHM6Ly9saXZlYmxvY2tzLmlvL2RvY3Mvcm9vbXMvcGVybWlzc2lvbnMjcGVybWlzc2lvbnMtbGV2ZWxzLWdyb3Vwcy1hY2Nlc3Nlcy1leGFtcGxlXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLnVzZXJJbmZvIEN1c3RvbSBtZXRhZGF0YSB0byBhdHRhY2ggdG8gdGhpcyB1c2VyLiBEYXRhIHlvdVxuICAgKiBhZGQgaGVyZSB3aWxsIGJlIHZpc2libGUgdG8gYWxsIG90aGVyIGNsaWVudHMgaW4gdGhlIHJvb20sIHRocm91Z2ggdGhlXG4gICAqIGBvdGhlci5pbmZvYCBwcm9wZXJ0eS5cbiAgICovXG4gIC8vIFRoZXNlIGZpZWxkcyBkZWZpbmUgdGhlIHNlY3VyaXR5IGlkZW50aXR5IG9mIHRoZSB1c2VyLiBXaGF0ZXZlciB5b3UgcGFzcyBpbiBoZXJlIHdpbGwgZGVmaW5lIHdoaWNoXG4gIGFzeW5jIGlkZW50aWZ5VXNlcihpZGVudGl0eSwgLi4ucmVzdCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSByZXN0WzBdO1xuICAgIGNvbnN0IHBhdGggPSB1cmwyYC92Mi9pZGVudGlmeS11c2VyYDtcbiAgICBjb25zdCB1c2VySWQgPSB0eXBlb2YgaWRlbnRpdHkgPT09IFwic3RyaW5nXCIgPyBpZGVudGl0eSA6IGlkZW50aXR5LnVzZXJJZDtcbiAgICBjb25zdCBncm91cElkcyA9IHR5cGVvZiBpZGVudGl0eSA9PT0gXCJzdHJpbmdcIiA/IHZvaWQgMCA6IGlkZW50aXR5Lmdyb3VwSWRzO1xuICAgIGFzc2VydE5vbkVtcHR5KHVzZXJJZCwgXCJ1c2VySWRcIik7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLiNwb3N0KHBhdGgsIHtcbiAgICAgICAgdXNlcklkLFxuICAgICAgICBncm91cElkcyxcbiAgICAgICAgLy8gT3B0aW9uYWwgbWV0YWRhdGFcbiAgICAgICAgdXNlckluZm86IG9wdGlvbnM/LnVzZXJJbmZvXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogbm9ybWFsaXplU3RhdHVzQ29kZShyZXNwLnN0YXR1cyksXG4gICAgICAgIGJvZHk6IGF3YWl0IHJlc3AudGV4dCgpXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IDUwMyxcbiAgICAgICAgYm9keTogYENhbGwgdG8gJHt1cmxqb2luKFxuICAgICAgICAgIHRoaXMuI2Jhc2VVcmwsXG4gICAgICAgICAgcGF0aFxuICAgICAgICApfSBmYWlsZWQuIFNlZSBcImVycm9yXCIgZm9yIG1vcmUgaW5mb3JtYXRpb24uYCxcbiAgICAgICAgZXJyb3I6IGVyXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIFJvb21cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgeW91ciByb29tcy4gVGhlIHJvb21zIGFyZSByZXR1cm5lZCBzb3J0ZWQgYnkgY3JlYXRpb24gZGF0ZSwgZnJvbSBuZXdlc3QgdG8gb2xkZXN0LiBZb3UgY2FuIGZpbHRlciByb29tcyBieSBtZXRhZGF0YSwgdXNlcnMgYWNjZXNzZXMgYW5kIGdyb3VwcyBhY2Nlc3Nlcy5cbiAgICogQHBhcmFtIHBhcmFtcy5saW1pdCAob3B0aW9uYWwpIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiByb29tcyB0byBiZSByZXR1cm5lZC4gVGhlIGxpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIGRlZmF1bHRzIHRvIDIwLlxuICAgKiBAcGFyYW0gcGFyYW1zLnN0YXJ0aW5nQWZ0ZXIgKG9wdGlvbmFsKSBBIGN1cnNvciB1c2VkIGZvciBwYWdpbmF0aW9uLiBZb3UgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSByZXNwb25zZSBvZiB0aGUgcHJldmlvdXMgcGFnZS5cbiAgICogQHBhcmFtIHBhcmFtcy51c2VySWQgKG9wdGlvbmFsKSBBIGZpbHRlciBvbiB1c2VycyBhY2Nlc3Nlcy5cbiAgICogQHBhcmFtIHBhcmFtcy5tZXRhZGF0YSAob3B0aW9uYWwpIEEgZmlsdGVyIG9uIG1ldGFkYXRhLiBNdWx0aXBsZSBtZXRhZGF0YSBrZXlzIGNhbiBiZSB1c2VkIHRvIGZpbHRlciByb29tcy5cbiAgICogQHBhcmFtIHBhcmFtcy5ncm91cElkcyAob3B0aW9uYWwpIEEgZmlsdGVyIG9uIGdyb3VwcyBhY2Nlc3Nlcy4gTXVsdGlwbGUgZ3JvdXBzIGNhbiBiZSB1c2VkLlxuICAgKiBAcGFyYW0gcGFyYW1zLnF1ZXJ5IChvcHRpb25hbCkgQSBxdWVyeSB0byBmaWx0ZXIgcm9vbXMgYnkuIEl0IGlzIGJhc2VkIG9uIG91ciBxdWVyeSBsYW5ndWFnZS4gWW91IGNhbiBmaWx0ZXIgYnkgbWV0YWRhdGEgYW5kIHJvb20gSUQuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIEEgbGlzdCBvZiByb29tcy5cbiAgICovXG4gIGFzeW5jIGdldFJvb21zKHBhcmFtcyA9IHt9LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcGF0aCA9IHVybDJgL3YyL3Jvb21zYDtcbiAgICBsZXQgcXVlcnk7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMucXVlcnkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHF1ZXJ5ID0gcGFyYW1zLnF1ZXJ5O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcy5xdWVyeSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgcXVlcnkgPSBvYmplY3RUb1F1ZXJ5KHBhcmFtcy5xdWVyeSk7XG4gICAgfVxuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0ge1xuICAgICAgbGltaXQ6IHBhcmFtcy5saW1pdCxcbiAgICAgIHN0YXJ0aW5nQWZ0ZXI6IHBhcmFtcy5zdGFydGluZ0FmdGVyLFxuICAgICAgdXNlcklkOiBwYXJhbXMudXNlcklkLFxuICAgICAgZ3JvdXBJZHM6IHBhcmFtcy5ncm91cElkcyA/IHBhcmFtcy5ncm91cElkcy5qb2luKFwiLFwiKSA6IHZvaWQgMCxcbiAgICAgIC8vIFwiRmxhdHRlblwiIHttZXRhZGF0YToge2ZvbzogXCJiYXJcIn19IHRvIHtcIm1ldGFkYXRhLmZvb1wiOiBcImJhclwifVxuICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBPYmplY3QuZW50cmllcyhwYXJhbXMubWV0YWRhdGEgPz8ge30pLm1hcCgoW2tleSwgdmFsXSkgPT4gW1xuICAgICAgICAgIGBtZXRhZGF0YS4ke2tleX1gLFxuICAgICAgICAgIHZhbFxuICAgICAgICBdKVxuICAgICAgKSxcbiAgICAgIHF1ZXJ5XG4gICAgfTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNnZXQocGF0aCwgcXVlcnlQYXJhbXMsIG9wdGlvbnMpO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgICBjb25zdCBwYWdlID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBjb25zdCByb29tcyA9IHBhZ2UuZGF0YS5tYXAoKHJvb20pID0+IHtcbiAgICAgIGNvbnN0IGxhc3RDb25uZWN0aW9uQXQgPSByb29tLmxhc3RDb25uZWN0aW9uQXQgPyBuZXcgRGF0ZShyb29tLmxhc3RDb25uZWN0aW9uQXQpIDogdm9pZCAwO1xuICAgICAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUocm9vbS5jcmVhdGVkQXQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucm9vbSxcbiAgICAgICAgY3JlYXRlZEF0LFxuICAgICAgICBsYXN0Q29ubmVjdGlvbkF0XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5wYWdlLFxuICAgICAgZGF0YTogcm9vbXNcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIGFsbCByb29tcyB0aGF0IG1hdGNoIHRoZSBnaXZlbiBjcml0ZXJpYS5cbiAgICpcbiAgICogVGhlIGRpZmZlcmVuY2Ugd2l0aCAuZ2V0Um9vbXMoKSBpcyB0aGF0IHBhZ2luYXRpb24gd2lsbCBoYXBwZW5cbiAgICogYXV0b21hdGljYWxseSB1bmRlciB0aGUgaG9vZCwgdXNpbmcgdGhlIGdpdmVuIGBwYWdlU2l6ZWAuXG4gICAqXG4gICAqIEBwYXJhbSBjcml0ZXJpYS51c2VySWQgKG9wdGlvbmFsKSBBIGZpbHRlciBvbiB1c2VycyBhY2Nlc3Nlcy5cbiAgICogQHBhcmFtIGNyaXRlcmlhLmdyb3VwSWRzIChvcHRpb25hbCkgQSBmaWx0ZXIgb24gZ3JvdXBzIGFjY2Vzc2VzLiBNdWx0aXBsZSBncm91cHMgY2FuIGJlIHVzZWQuXG4gICAqIEBwYXJhbSBjcml0ZXJpYS5xdWVyeS5yb29tSWQgKG9wdGlvbmFsKSBBIGZpbHRlciBieSByb29tIElELlxuICAgKiBAcGFyYW0gY3JpdGVyaWEucXVlcnkubWV0YWRhdGEgKG9wdGlvbmFsKSBBIGZpbHRlciBieSBtZXRhZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMucGFnZVNpemUgKG9wdGlvbmFsKSBUaGUgcGFnZSBzaXplIHRvIHVzZSBmb3IgZWFjaCByZXF1ZXN0LlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgYXN5bmMgKml0ZXJSb29tcyhjcml0ZXJpYSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgc2lnbmFsIH0gPSBvcHRpb25zID8/IHt9O1xuICAgIGNvbnN0IHBhZ2VTaXplID0gY2hlY2tCb3VuZHMoXCJwYWdlU2l6ZVwiLCBvcHRpb25zPy5wYWdlU2l6ZSA/PyA0MCwgMjApO1xuICAgIGxldCBjdXJzb3IgPSB2b2lkIDA7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHsgbmV4dEN1cnNvciwgZGF0YSB9ID0gYXdhaXQgdGhpcy5nZXRSb29tcyhcbiAgICAgICAgeyAuLi5jcml0ZXJpYSwgc3RhcnRpbmdBZnRlcjogY3Vyc29yLCBsaW1pdDogcGFnZVNpemUgfSxcbiAgICAgICAgeyBzaWduYWwgfVxuICAgICAgKTtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBkYXRhKSB7XG4gICAgICAgIHlpZWxkIGl0ZW07XG4gICAgICB9XG4gICAgICBpZiAoIW5leHRDdXJzb3IpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjdXJzb3IgPSBuZXh0Q3Vyc29yO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyByb29tIHdpdGggdGhlIGdpdmVuIGlkLlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byBjcmVhdGUuXG4gICAqIEBwYXJhbSBwYXJhbXMuZGVmYXVsdEFjY2Vzc2VzIFRoZSBkZWZhdWx0IGFjY2Vzc2VzIGZvciB0aGUgcm9vbS5cbiAgICogQHBhcmFtIHBhcmFtcy5ncm91cHNBY2Nlc3NlcyAob3B0aW9uYWwpIFRoZSBncm91cCBhY2Nlc3NlcyBmb3IgdGhlIHJvb20uIENhbiBjb250YWluIGEgbWF4aW11bSBvZiAxMDAgZW50cmllcy4gS2V5IGxlbmd0aCBoYXMgYSBsaW1pdCBvZiA0MCBjaGFyYWN0ZXJzLlxuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJzQWNjZXNzZXMgKG9wdGlvbmFsKSBUaGUgdXNlciBhY2Nlc3NlcyBmb3IgdGhlIHJvb20uIENhbiBjb250YWluIGEgbWF4aW11bSBvZiAxMDAgZW50cmllcy4gS2V5IGxlbmd0aCBoYXMgYSBsaW1pdCBvZiA0MCBjaGFyYWN0ZXJzLlxuICAgKiBAcGFyYW0gcGFyYW1zLm1ldGFkYXRhIChvcHRpb25hbCkgVGhlIG1ldGFkYXRhIGZvciB0aGUgcm9vbS4gU3VwcG9ydHMgdXB0byBhIG1heGltdW0gb2YgNTAgZW50cmllcy4gS2V5IGxlbmd0aCBoYXMgYSBsaW1pdCBvZiA0MCBjaGFyYWN0ZXJzLiBWYWx1ZSBsZW5ndGggaGFzIGEgbGltaXQgb2YgMjU2IGNoYXJhY3RlcnMuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHJvb20uXG4gICAqL1xuICBhc3luYyBjcmVhdGVSb29tKHJvb21JZCwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBkZWZhdWx0QWNjZXNzZXMsIGdyb3Vwc0FjY2Vzc2VzLCB1c2Vyc0FjY2Vzc2VzLCBtZXRhZGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI3Bvc3QoXG4gICAgICB1cmwyYC92Mi9yb29tc2AsXG4gICAgICB7XG4gICAgICAgIGlkOiByb29tSWQsXG4gICAgICAgIGRlZmF1bHRBY2Nlc3NlcyxcbiAgICAgICAgZ3JvdXBzQWNjZXNzZXMsXG4gICAgICAgIHVzZXJzQWNjZXNzZXMsXG4gICAgICAgIG1ldGFkYXRhXG4gICAgICB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGNvbnN0IGxhc3RDb25uZWN0aW9uQXQgPSBkYXRhLmxhc3RDb25uZWN0aW9uQXQgPyBuZXcgRGF0ZShkYXRhLmxhc3RDb25uZWN0aW9uQXQpIDogdm9pZCAwO1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIGxhc3RDb25uZWN0aW9uQXQsXG4gICAgICBjcmVhdGVkQXRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcm9vbSB3aXRoIHRoZSBnaXZlbiBpZCwgb3IgY3JlYXRlcyBvbmUgd2l0aCB0aGUgZ2l2ZW4gY3JlYXRpb25cbiAgICogb3B0aW9ucyBpZiBpdCBkb2Vzbid0IGV4aXN0IHlldC5cbiAgICpcbiAgICogQHBhcmFtIHJvb21JZCBUaGUgaWQgb2YgdGhlIHJvb20uXG4gICAqIEBwYXJhbSBwYXJhbXMuZGVmYXVsdEFjY2Vzc2VzIFRoZSBkZWZhdWx0IGFjY2Vzc2VzIGZvciB0aGUgcm9vbSBpZiB0aGUgcm9vbSB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSBwYXJhbXMuZ3JvdXBzQWNjZXNzZXMgKG9wdGlvbmFsKSBUaGUgZ3JvdXAgYWNjZXNzZXMgZm9yIHRoZSByb29tIGlmIHRoZSByb29tIHdpbGwgYmUgY3JlYXRlZC4gQ2FuIGNvbnRhaW4gYSBtYXhpbXVtIG9mIDEwMCBlbnRyaWVzLiBLZXkgbGVuZ3RoIGhhcyBhIGxpbWl0IG9mIDQwIGNoYXJhY3RlcnMuXG4gICAqIEBwYXJhbSBwYXJhbXMudXNlcnNBY2Nlc3NlcyAob3B0aW9uYWwpIFRoZSB1c2VyIGFjY2Vzc2VzIGZvciB0aGUgcm9vbSBpZiB0aGUgcm9vbSB3aWxsIGJlIGNyZWF0ZWQuIENhbiBjb250YWluIGEgbWF4aW11bSBvZiAxMDAgZW50cmllcy4gS2V5IGxlbmd0aCBoYXMgYSBsaW1pdCBvZiA0MCBjaGFyYWN0ZXJzLlxuICAgKiBAcGFyYW0gcGFyYW1zLm1ldGFkYXRhIChvcHRpb25hbCkgVGhlIG1ldGFkYXRhIGZvciB0aGUgcm9vbSBpZiB0aGUgcm9vbSB3aWxsIGJlIGNyZWF0ZWQuIFN1cHBvcnRzIHVwdG8gYSBtYXhpbXVtIG9mIDUwIGVudHJpZXMuIEtleSBsZW5ndGggaGFzIGEgbGltaXQgb2YgNDAgY2hhcmFjdGVycy4gVmFsdWUgbGVuZ3RoIGhhcyBhIGxpbWl0IG9mIDI1NiBjaGFyYWN0ZXJzLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBUaGUgcm9vbS5cbiAgICovXG4gIGFzeW5jIGdldE9yQ3JlYXRlUm9vbShyb29tSWQsIHBhcmFtcywgb3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jcmVhdGVSb29tKHJvb21JZCwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBMaXZlYmxvY2tzRXJyb3IgJiYgZXJyLnN0YXR1cyA9PT0gNDA5KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFJvb20ocm9vbUlkLCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgb3IgY3JlYXRlcyBhIG5ldyByb29tIHdpdGggdGhlIGdpdmVuIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIHVwZGF0ZSBvciBjcmVhdGUuXG4gICAqIEBwYXJhbSBwYXJhbXMuZGVmYXVsdEFjY2Vzc2VzIFRoZSBkZWZhdWx0IGFjY2Vzc2VzIGZvciB0aGUgcm9vbS5cbiAgICogQHBhcmFtIHBhcmFtcy5ncm91cHNBY2Nlc3NlcyAob3B0aW9uYWwpIFRoZSBncm91cCBhY2Nlc3NlcyBmb3IgdGhlIHJvb20uIENhbiBjb250YWluIGEgbWF4aW11bSBvZiAxMDAgZW50cmllcy4gS2V5IGxlbmd0aCBoYXMgYSBsaW1pdCBvZiA0MCBjaGFyYWN0ZXJzLlxuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJzQWNjZXNzZXMgKG9wdGlvbmFsKSBUaGUgdXNlciBhY2Nlc3NlcyBmb3IgdGhlIHJvb20uIENhbiBjb250YWluIGEgbWF4aW11bSBvZiAxMDAgZW50cmllcy4gS2V5IGxlbmd0aCBoYXMgYSBsaW1pdCBvZiA0MCBjaGFyYWN0ZXJzLlxuICAgKiBAcGFyYW0gcGFyYW1zLm1ldGFkYXRhIChvcHRpb25hbCkgVGhlIG1ldGFkYXRhIGZvciB0aGUgcm9vbS4gU3VwcG9ydHMgdXB0byBhIG1heGltdW0gb2YgNTAgZW50cmllcy4gS2V5IGxlbmd0aCBoYXMgYSBsaW1pdCBvZiA0MCBjaGFyYWN0ZXJzLiBWYWx1ZSBsZW5ndGggaGFzIGEgbGltaXQgb2YgMjU2IGNoYXJhY3RlcnMuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIFRoZSByb29tLlxuICAgKi9cbiAgYXN5bmMgdXBzZXJ0Um9vbShyb29tSWQsIHBhcmFtcywgb3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jcmVhdGVSb29tKHJvb21JZCwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBMaXZlYmxvY2tzRXJyb3IgJiYgZXJyLnN0YXR1cyA9PT0gNDA5KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnVwZGF0ZVJvb20ocm9vbUlkLCBwYXJhbXMsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHJvb20gd2l0aCB0aGUgZ2l2ZW4gaWQuXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIHJldHVybi5cbiAgICogQHJldHVybnMgVGhlIHJvb20gd2l0aCB0aGUgZ2l2ZW4gaWQuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBhc3luYyBnZXRSb29tKHJvb21JZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI2dldCh1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH1gLCB2b2lkIDAsIG9wdGlvbnMpO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBjb25zdCBsYXN0Q29ubmVjdGlvbkF0ID0gZGF0YS5sYXN0Q29ubmVjdGlvbkF0ID8gbmV3IERhdGUoZGF0YS5sYXN0Q29ubmVjdGlvbkF0KSA6IHZvaWQgMDtcbiAgICBjb25zdCBjcmVhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLmNyZWF0ZWRBdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBsYXN0Q29ubmVjdGlvbkF0XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBzcGVjaWZpYyBwcm9wZXJ0aWVzIG9mIGEgcm9vbS4gSXTigJlzIG5vdCBuZWNlc3NhcnkgdG8gcHJvdmlkZSB0aGUgZW50aXJlIHJvb23igJlzIGluZm9ybWF0aW9uLlxuICAgKiBTZXR0aW5nIGEgcHJvcGVydHkgdG8gYG51bGxgIG1lYW5zIHRvIGRlbGV0ZSB0aGlzIHByb3BlcnR5LlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSBwYXJhbXMuZGVmYXVsdEFjY2Vzc2VzIChvcHRpb25hbCkgVGhlIGRlZmF1bHQgYWNjZXNzZXMgZm9yIHRoZSByb29tLlxuICAgKiBAcGFyYW0gcGFyYW1zLmdyb3Vwc0FjY2Vzc2VzIChvcHRpb25hbCkgVGhlIGdyb3VwIGFjY2Vzc2VzIGZvciB0aGUgcm9vbS4gQ2FuIGNvbnRhaW4gYSBtYXhpbXVtIG9mIDEwMCBlbnRyaWVzLiBLZXkgbGVuZ3RoIGhhcyBhIGxpbWl0IG9mIDQwIGNoYXJhY3RlcnMuXG4gICAqIEBwYXJhbSBwYXJhbXMudXNlcnNBY2Nlc3NlcyAob3B0aW9uYWwpIFRoZSB1c2VyIGFjY2Vzc2VzIGZvciB0aGUgcm9vbS4gQ2FuIGNvbnRhaW4gYSBtYXhpbXVtIG9mIDEwMCBlbnRyaWVzLiBLZXkgbGVuZ3RoIGhhcyBhIGxpbWl0IG9mIDQwIGNoYXJhY3RlcnMuXG4gICAqIEBwYXJhbSBwYXJhbXMubWV0YWRhdGEgKG9wdGlvbmFsKSBUaGUgbWV0YWRhdGEgZm9yIHRoZSByb29tLiBTdXBwb3J0cyB1cHRvIGEgbWF4aW11bSBvZiA1MCBlbnRyaWVzLiBLZXkgbGVuZ3RoIGhhcyBhIGxpbWl0IG9mIDQwIGNoYXJhY3RlcnMuIFZhbHVlIGxlbmd0aCBoYXMgYSBsaW1pdCBvZiAyNTYgY2hhcmFjdGVycy5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgcm9vbS5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZVJvb20ocm9vbUlkLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGRlZmF1bHRBY2Nlc3NlcywgZ3JvdXBzQWNjZXNzZXMsIHVzZXJzQWNjZXNzZXMsIG1ldGFkYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jcG9zdChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfWAsXG4gICAgICB7XG4gICAgICAgIGRlZmF1bHRBY2Nlc3NlcyxcbiAgICAgICAgZ3JvdXBzQWNjZXNzZXMsXG4gICAgICAgIHVzZXJzQWNjZXNzZXMsXG4gICAgICAgIG1ldGFkYXRhXG4gICAgICB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGNvbnN0IGxhc3RDb25uZWN0aW9uQXQgPSBkYXRhLmxhc3RDb25uZWN0aW9uQXQgPyBuZXcgRGF0ZShkYXRhLmxhc3RDb25uZWN0aW9uQXQpIDogdm9pZCAwO1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIGxhc3RDb25uZWN0aW9uQXQsXG4gICAgICBjcmVhdGVkQXRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEgcm9vbSB3aXRoIHRoZSBnaXZlbiBpZC4gQSBkZWxldGVkIHJvb20gaXMgbm8gbG9uZ2VyIGFjY2Vzc2libGUgZnJvbSB0aGUgQVBJIG9yIHRoZSBkYXNoYm9hcmQgYW5kIGl0IGNhbm5vdCBiZSByZXN0b3JlZC5cbiAgICogQHBhcmFtIHJvb21JZCBUaGUgaWQgb2YgdGhlIHJvb20gdG8gZGVsZXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlUm9vbShyb29tSWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNkZWxldGUodXJsMmAvdjIvcm9vbXMvJHtyb29tSWR9YCwgb3B0aW9ucyk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiB1c2VycyBjdXJyZW50bHkgcHJlc2VudCBpbiB0aGUgcmVxdWVzdGVkIHJvb20uIEZvciBiZXR0ZXIgcGVyZm9ybWFuY2UsIHdlIHJlY29tbWFuZCB0byBjYWxsIHRoaXMgZW5kcG9pbnQgZXZlcnkgMTAgc2Vjb25kcyBtYXhpbXVtLiBEdXBsaWNhdGVzIGNhbiBoYXBwZW4gaWYgYSB1c2VyIGlzIGluIHRoZSByZXF1ZXN0ZWQgcm9vbSB3aXRoIG11bHRpcGxlIGJyb3dzZXIgdGFicyBvcGVuZWQuXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIGdldCB0aGUgdXNlcnMgZnJvbS5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgQSBsaXN0IG9mIHVzZXJzIGN1cnJlbnRseSBwcmVzZW50IGluIHRoZSByZXF1ZXN0ZWQgcm9vbS5cbiAgICovXG4gIGFzeW5jIGdldEFjdGl2ZVVzZXJzKHJvb21JZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI2dldChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS9hY3RpdmVfdXNlcnNgLFxuICAgICAgdm9pZCAwLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBCb2FkY2FzdHMgYW4gZXZlbnQgdG8gYSByb29tIHdpdGhvdXQgaGF2aW5nIHRvIGNvbm5lY3QgdG8gaXQgdmlhIHRoZSBjbGllbnQgZnJvbSBAbGl2ZWJsb2Nrcy9jbGllbnQuIFRoZSBjb25uZWN0aW9uSWQgcGFzc2VkIHRvIGV2ZW50IGxpc3RlbmVycyBpcyAtMSB3aGVuIHVzaW5nIHRoaXMgQVBJLlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byBicm9hZGNhc3QgdGhlIGV2ZW50IHRvLlxuICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBicm9hZGNhc3QuIEl0IGNhbiBiZSBhbnkgSlNPTiBzZXJpYWxpemFibGUgdmFsdWUuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBhc3luYyBicm9hZGNhc3RFdmVudChyb29tSWQsIG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNwb3N0KFxuICAgICAgdXJsMmAvdjIvcm9vbXMvJHtyb29tSWR9L2Jyb2FkY2FzdF9ldmVudGAsXG4gICAgICBtZXNzYWdlLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldFN0b3JhZ2VEb2N1bWVudChyb29tSWQsIGZvcm1hdCA9IFwicGxhaW4tbHNvblwiLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jZ2V0KFxuICAgICAgdXJsMmAvdjIvcm9vbXMvJHtyb29tSWR9L3N0b3JhZ2VgLFxuICAgICAgeyBmb3JtYXQgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxuICBhc3luYyAjcmVxdWVzdFN0b3JhZ2VNdXRhdGlvbihyb29tSWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy4jcG9zdChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS9yZXF1ZXN0LXN0b3JhZ2UtbXV0YXRpb25gLFxuICAgICAge30sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlc3Aub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlc3ApO1xuICAgIH1cbiAgICBpZiAocmVzcC5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSAhPT0gXCJhcHBsaWNhdGlvbi94LW5kanNvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHJlc3BvbnNlIGNvbnRlbnQgdHlwZVwiKTtcbiAgICB9XG4gICAgaWYgKHJlc3AuYm9keSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBudWxsIGJvZHkgaW4gcmVzcG9uc2VcIik7XG4gICAgfVxuICAgIGNvbnN0IHN0cmVhbSA9IHJlc3AuYm9keS5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSkucGlwZVRocm91Z2gobmV3IExpbmVTdHJlYW0oKSkucGlwZVRocm91Z2gobmV3IE5kSnNvblN0cmVhbSgpKTtcbiAgICBjb25zdCBpdGVyID0gc3RyZWFtW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgIGNvbnN0IHsgYWN0b3IgfSA9IGF3YWl0IGl0ZXIubmV4dCgpO1xuICAgIGNvbnN0IG5vZGVzID0gYXdhaXQgYXN5bmNDb25zdW1lKGl0ZXIpO1xuICAgIHJldHVybiB7IGFjdG9yLCBub2RlcyB9O1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIHJvb23igJlzIFN0b3JhZ2UuIFRoZSByb29tIG11c3QgYWxyZWFkeSBleGlzdCBhbmQgaGF2ZSBhbiBlbXB0eSBTdG9yYWdlLlxuICAgKiBDYWxsaW5nIHRoaXMgZW5kcG9pbnQgd2lsbCBkaXNjb25uZWN0IGFsbCB1c2VycyBmcm9tIHRoZSByb29tIGlmIHRoZXJlIGFyZSBhbnkuXG4gICAqXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIGluaXRpYWxpemUgdGhlIHN0b3JhZ2UgZnJvbS5cbiAgICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBpbml0aWFsaXplIHRoZSBzdG9yYWdlIHdpdGguXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIFRoZSBpbml0aWFsaXplZCBzdG9yYWdlIGRvY3VtZW50LiBJdCBpcyBvZiB0aGUgc2FtZSBmb3JtYXQgYXMgdGhlIG9uZSBwYXNzZWQgaW4uXG4gICAqL1xuICBhc3luYyBpbml0aWFsaXplU3RvcmFnZURvY3VtZW50KHJvb21JZCwgZG9jdW1lbnQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNwb3N0KFxuICAgICAgdXJsMmAvdjIvcm9vbXMvJHtyb29tSWR9L3N0b3JhZ2VgLFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYWxsIG9mIHRoZSByb29t4oCZcyBTdG9yYWdlIGRhdGEgYW5kIGRpc2Nvbm5lY3QgYWxsIHVzZXJzIGZyb20gdGhlIHJvb20gaWYgdGhlcmUgYXJlIGFueS4gTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgZGVsZXRlIHRoZSBZanMgZG9jdW1lbnQgaW4gdGhlIHJvb20gaWYgb25lIGV4aXN0cy5cbiAgICogQHBhcmFtIHJvb21JZCBUaGUgaWQgb2YgdGhlIHJvb20gdG8gZGVsZXRlIHRoZSBzdG9yYWdlIGZyb20uXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBhc3luYyBkZWxldGVTdG9yYWdlRG9jdW1lbnQocm9vbUlkLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jZGVsZXRlKHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS9zdG9yYWdlYCwgb3B0aW9ucyk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICB9XG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogWWpzXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByb29t4oCZcyBZanMgZG9jdW1lbnQuXG4gICAqIEBwYXJhbSByb29tSWQgVGhlIGlkIG9mIHRoZSByb29tIHRvIGdldCB0aGUgWWpzIGRvY3VtZW50IGZyb20uXG4gICAqIEBwYXJhbSBwYXJhbXMuZm9ybWF0IChvcHRpb25hbCkgSWYgdHJ1ZSwgWVRleHQgd2lsbCByZXR1cm4gZm9ybWF0dGluZy5cbiAgICogQHBhcmFtIHBhcmFtcy5rZXkgKG9wdGlvbmFsKSBJZiBwcm92aWRlZCwgcmV0dXJucyBvbmx5IGEgc2luZ2xlIGtleeKAmXMgdmFsdWUsIGUuZy4gZG9jLmdldChrZXkpLnRvSlNPTigpLlxuICAgKiBAcGFyYW0gcGFyYW1zLnR5cGUgKG9wdGlvbmFsKSBVc2VkIHdpdGgga2V5IHRvIG92ZXJyaWRlIHRoZSBpbmZlcnJlZCB0eXBlLCBpLmUuIFwieW1hcFwiIHdpbGwgcmV0dXJuIGRvYy5nZXQoa2V5LCBZLk1hcCkuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIEEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgcm9vbeKAmXMgWWpzIGRvY3VtZW50LlxuICAgKi9cbiAgYXN5bmMgZ2V0WWpzRG9jdW1lbnQocm9vbUlkLCBwYXJhbXMgPSB7fSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgZm9ybWF0LCBrZXksIHR5cGUgfSA9IHBhcmFtcztcbiAgICBjb25zdCBwYXRoID0gdXJsMmB2Mi9yb29tcy8ke3Jvb21JZH0veWRvY2A7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jZ2V0KFxuICAgICAgcGF0aCxcbiAgICAgIHsgZm9ybWF0dGluZzogZm9ybWF0ID8gXCJ0cnVlXCIgOiB2b2lkIDAsIGtleSwgdHlwZSB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kIGEgWWpzIGJpbmFyeSB1cGRhdGUgdG8gdGhlIHJvb23igJlzIFlqcyBkb2N1bWVudC4gWW91IGNhbiB1c2UgdGhpcyBlbmRwb2ludCB0byBpbml0aWFsaXplIFlqcyBkYXRhIGZvciB0aGUgcm9vbSBvciB0byB1cGRhdGUgdGhlIHJvb23igJlzIFlqcyBkb2N1bWVudC5cbiAgICogQHBhcmFtIHJvb21JZCBUaGUgaWQgb2YgdGhlIHJvb20gdG8gc2VuZCB0aGUgWWpzIGJpbmFyeSB1cGRhdGUgdG8uXG4gICAqIEBwYXJhbSB1cGRhdGUgVGhlIFlqcyB1cGRhdGUgdG8gc2VuZC4gVHlwaWNhbGx5IHRoZSByZXN1bHQgb2YgY2FsbGluZyBgWWpzLmVuY29kZVN0YXRlQXNVcGRhdGUoZG9jKWAuIFJlYWQgdGhlIFtZanMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLnlqcy5kZXYvYXBpL2RvY3VtZW50LXVwZGF0ZXMpIHRvIGxlYXJuIGhvdyB0byBjcmVhdGUgYSBiaW5hcnkgdXBkYXRlLlxuICAgKiBAcGFyYW0gcGFyYW1zLmd1aWQgKG9wdGlvbmFsKSBJZiBwcm92aWRlZCwgdGhlIGJpbmFyeSB1cGRhdGUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBZanMgc3ViZG9jdW1lbnQgd2l0aCB0aGUgZ2l2ZW4gZ3VpZC4gSWYgbm90IHByb3ZpZGVkLCB0aGUgYmluYXJ5IHVwZGF0ZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHJvb3QgWWpzIGRvY3VtZW50LlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgYXN5bmMgc2VuZFlqc0JpbmFyeVVwZGF0ZShyb29tSWQsIHVwZGF0ZSwgcGFyYW1zID0ge30sIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNwdXRCaW5hcnkoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0veWRvY2AsXG4gICAgICB1cGRhdGUsXG4gICAgICB7IGd1aWQ6IHBhcmFtcy5ndWlkIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvb23igJlzIFlqcyBkb2N1bWVudCBlbmNvZGVkIGFzIGEgc2luZ2xlIGJpbmFyeSB1cGRhdGUuIFRoaXMgY2FuIGJlIHVzZWQgYnkgWS5hcHBseVVwZGF0ZShyZXNwb25zZUJvZHkpIHRvIGdldCBhIGNvcHkgb2YgdGhlIGRvY3VtZW50IGluIHlvdXIgYmFja2VuZC5cbiAgICogU2VlIFtZanMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLnlqcy5kZXYvYXBpL2RvY3VtZW50LXVwZGF0ZXMpIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHdvcmtpbmcgd2l0aCB1cGRhdGVzLlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byBnZXQgdGhlIFlqcyBkb2N1bWVudCBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLmd1aWQgKG9wdGlvbmFsKSBJZiBwcm92aWRlZCwgcmV0dXJucyB0aGUgYmluYXJ5IHVwZGF0ZSBvZiB0aGUgWWpzIHN1YmRvY3VtZW50IHdpdGggdGhlIGdpdmVuIGd1aWQuIElmIG5vdCBwcm92aWRlZCwgcmV0dXJucyB0aGUgYmluYXJ5IHVwZGF0ZSBvZiB0aGUgcm9vdCBZanMgZG9jdW1lbnQuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIFRoZSByb29t4oCZcyBZanMgZG9jdW1lbnQgZW5jb2RlZCBhcyBhIHNpbmdsZSBiaW5hcnkgdXBkYXRlLlxuICAgKi9cbiAgYXN5bmMgZ2V0WWpzRG9jdW1lbnRBc0JpbmFyeVVwZGF0ZShyb29tSWQsIHBhcmFtcyA9IHt9LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jZ2V0KFxuICAgICAgdXJsMmAvdjIvcm9vbXMvJHtyb29tSWR9L3lkb2MtYmluYXJ5YCxcbiAgICAgIHsgZ3VpZDogcGFyYW1zLmd1aWQgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLmFycmF5QnVmZmVyKCk7XG4gIH1cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBTY2hlbWEgVmFsaWRhdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHNjaGVtYSB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBsYXRlciB0byBlbmZvcmNlIGEgcm9vbeKAmXMgU3RvcmFnZSBkYXRhIHN0cnVjdHVyZS5cbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgdXNlZCB0byByZWZlcmVuY2UgdGhlIHNjaGVtYS4gTXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgd2l0aCBsZXNzIHRoYW4gNjUgY2hhcmFjdGVycyBhbmQgb25seSBjb250YWluIGxvd2VyY2FzZSBsZXR0ZXJzLCBudW1iZXJzIGFuZCBkYXNoZXNcbiAgICogQHBhcmFtIGJvZHkgVGhlIGV4YWN0IGFsbG93ZWQgc2hhcGUgb2YgZGF0YSBpbiB0aGUgcm9vbS4gSXQgaXMgYSBtdWx0aS1saW5lIHN0cmluZyB3cml0dGVuIGluIHRoZSBbTGl2ZWJsb2NrcyBzY2hlbWEgc3ludGF4XShodHRwczovL2xpdmVibG9ja3MuaW8vZG9jcy9wbGF0Zm9ybS9zY2hlbWEtdmFsaWRhdGlvbi9zeW50YXgpLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBzY2hlbWEuXG4gICAqL1xuICBhc3luYyBjcmVhdGVTY2hlbWEobmFtZSwgYm9keSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI3Bvc3QodXJsMmAvdjIvc2NoZW1hc2AsIHsgbmFtZSwgYm9keSB9LCBvcHRpb25zKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICAgIGNvbnN0IHVwZGF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEudXBkYXRlZEF0KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIHVwZGF0ZWRBdFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzY2hlbWEgYnkgaXRzIGlkLlxuICAgKiBAcGFyYW0gc2NoZW1hSWQgSWQgb2YgdGhlIHNjaGVtYSAtIHRoaXMgaXMgdGhlIGNvbWJpbmF0aW9uIG9mIHRoZSBzY2hlbWEgbmFtZSBhbmQgdmVyc2lvbiBvZiB0aGUgc2NoZW1hIHRvIHVwZGF0ZS4gRm9yIGV4YW1wbGUsIGBteS1zY2hlbWFAMWAuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIFRoZSBzY2hlbWEgd2l0aCB0aGUgZ2l2ZW4gaWQuXG4gICAqL1xuICBhc3luYyBnZXRTY2hlbWEoc2NoZW1hSWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNnZXQoXG4gICAgICB1cmwyYC92Mi9zY2hlbWFzLyR7c2NoZW1hSWR9YCxcbiAgICAgIHZvaWQgMCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBjb25zdCBjcmVhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLmNyZWF0ZWRBdCk7XG4gICAgY29uc3QgdXBkYXRlZEF0ID0gbmV3IERhdGUoZGF0YS51cGRhdGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgdXBkYXRlZEF0XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYm9keSBmb3IgdGhlIHNjaGVtYS4gQSBzY2hlbWEgY2FuIG9ubHkgYmUgdXBkYXRlZCBpZiBpdCBpcyBub3QgdXNlZCBieSBhbnkgcm9vbS5cbiAgICogQHBhcmFtIHNjaGVtYUlkIElkIG9mIHRoZSBzY2hlbWEgLSB0aGlzIGlzIHRoZSBjb21iaW5hdGlvbiBvZiB0aGUgc2NoZW1hIG5hbWUgYW5kIHZlcnNpb24gb2YgdGhlIHNjaGVtYSB0byB1cGRhdGUuIEZvciBleGFtcGxlLCBgbXktc2NoZW1hQDFgLlxuICAgKiBAcGFyYW0gYm9keSBUaGUgZXhhY3QgYWxsb3dlZCBzaGFwZSBvZiBkYXRhIGluIHRoZSByb29tLiBJdCBpcyBhIG11bHRpLWxpbmUgc3RyaW5nIHdyaXR0ZW4gaW4gdGhlIFtMaXZlYmxvY2tzIHNjaGVtYSBzeW50YXhdKGh0dHBzOi8vbGl2ZWJsb2Nrcy5pby9kb2NzL3BsYXRmb3JtL3NjaGVtYS12YWxpZGF0aW9uL3N5bnRheCkuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIHNjaGVtYS4gVGhlIHZlcnNpb24gb2YgdGhlIHNjaGVtYSB3aWxsIGJlIGluY3JlbWVudGVkLlxuICAgKi9cbiAgYXN5bmMgdXBkYXRlU2NoZW1hKHNjaGVtYUlkLCBib2R5LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jcHV0KFxuICAgICAgdXJsMmAvdjIvc2NoZW1hcy8ke3NjaGVtYUlkfWAsXG4gICAgICB7IGJvZHkgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBjb25zdCBjcmVhdGVkQXQgPSBuZXcgRGF0ZShkYXRhLmNyZWF0ZWRBdCk7XG4gICAgY29uc3QgdXBkYXRlZEF0ID0gbmV3IERhdGUoZGF0YS51cGRhdGVkQXQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgdXBkYXRlZEF0XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhIHNjaGVtYSBieSBpdHMgaWQuIEEgc2NoZW1hIGNhbiBvbmx5IGJlIGRlbGV0ZWQgaWYgaXQgaXMgbm90IHVzZWQgYnkgYW55IHJvb20uXG4gICAqIEBwYXJhbSBzY2hlbWFJZCBJZCBvZiB0aGUgc2NoZW1hIC0gdGhpcyBpcyB0aGUgY29tYmluYXRpb24gb2YgdGhlIHNjaGVtYSBuYW1lIGFuZCB2ZXJzaW9uIG9mIHRoZSBzY2hlbWEgdG8gdXBkYXRlLiBGb3IgZXhhbXBsZSwgYG15LXNjaGVtYUAxYC5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZVNjaGVtYShzY2hlbWFJZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI2RlbGV0ZSh1cmwyYC92Mi9zY2hlbWFzLyR7c2NoZW1hSWR9YCwgb3B0aW9ucyk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzY2hlbWEgYXR0YWNoZWQgdG8gYSByb29tLlxuICAgKiBAcGFyYW0gcm9vbUlkIFRoZSBpZCBvZiB0aGUgcm9vbSB0byBnZXQgdGhlIHNjaGVtYSBmcm9tLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgZ2V0U2NoZW1hQnlSb29tSWQocm9vbUlkLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jZ2V0KFxuICAgICAgdXJsMmAvdjIvcm9vbXMvJHtyb29tSWR9L3NjaGVtYWAsXG4gICAgICB2b2lkIDAsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgY29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpO1xuICAgIGNvbnN0IHVwZGF0ZWRBdCA9IG5ldyBEYXRlKGRhdGEudXBkYXRlZEF0KTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIHVwZGF0ZWRBdFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEF0dGFjaGVzIGEgc2NoZW1hIHRvIGEgcm9vbSwgYW5kIGluc3RhbnRseSBlbmFibGVzIHJ1bnRpbWUgc2NoZW1hIHZhbGlkYXRpb24gZm9yIHRoZSByb29tLlxuICAgKiBJZiB0aGUgY3VycmVudCBjb250ZW50cyBvZiB0aGUgcm9vbeKAmXMgU3RvcmFnZSBkbyBub3QgbWF0Y2ggdGhlIHNjaGVtYSwgYXR0YWNoaW5nIHdpbGwgZmFpbCBhbmQgdGhlIGVycm9yIG1lc3NhZ2Ugd2lsbCBnaXZlIGRldGFpbHMgb24gd2h5IHRoZSBzY2hlbWEgZmFpbGVkIHRvIGF0dGFjaC5cbiAgICogQHBhcmFtIHJvb21JZCBUaGUgaWQgb2YgdGhlIHJvb20gdG8gYXR0YWNoIHRoZSBzY2hlbWEgdG8uXG4gICAqIEBwYXJhbSBzY2hlbWFJZCBJZCBvZiB0aGUgc2NoZW1hIC0gdGhpcyBpcyB0aGUgY29tYmluYXRpb24gb2YgdGhlIHNjaGVtYSBuYW1lIGFuZCB2ZXJzaW9uIG9mIHRoZSBzY2hlbWEgdG8gdXBkYXRlLiBGb3IgZXhhbXBsZSwgYG15LXNjaGVtYUAxYC5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIHNjaGVtYSBpZCBhcyBKU09OLlxuICAgKi9cbiAgYXN5bmMgYXR0YWNoU2NoZW1hVG9Sb29tKHJvb21JZCwgc2NoZW1hSWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNwb3N0KFxuICAgICAgdXJsMmAvdjIvcm9vbXMvJHtyb29tSWR9L3NjaGVtYWAsXG4gICAgICB7IHNjaGVtYTogc2NoZW1hSWQgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgfVxuICAvKipcbiAgICogRGV0YWNoZXMgYSBzY2hlbWEgZnJvbSBhIHJvb20sIGFuZCBkaXNhYmxlcyBydW50aW1lIHNjaGVtYSB2YWxpZGF0aW9uIGZvciB0aGUgcm9vbS5cbiAgICogQHBhcmFtIHJvb21JZCBUaGUgaWQgb2YgdGhlIHJvb20gdG8gZGV0YWNoIHRoZSBzY2hlbWEgZnJvbS5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGFzeW5jIGRldGFjaFNjaGVtYUZyb21Sb29tKHJvb21JZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI2RlbGV0ZSh1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vc2NoZW1hYCwgb3B0aW9ucyk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICB9XG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ29tbWVudHNcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAvKipcbiAgICogR2V0cyBhbGwgdGhlIHRocmVhZHMgaW4gYSByb29tLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBnZXQgdGhlIHRocmVhZHMgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy5xdWVyeSBUaGUgcXVlcnkgdG8gZmlsdGVyIHRocmVhZHMgYnkuIEl0IGlzIGJhc2VkIG9uIG91ciBxdWVyeSBsYW5ndWFnZSBhbmQgY2FuIGZpbHRlciBieSBtZXRhZGF0YS5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgQSBsaXN0IG9mIHRocmVhZHMuXG4gICAqL1xuICBhc3luYyBnZXRUaHJlYWRzKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgcm9vbUlkIH0gPSBwYXJhbXM7XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGlmICh0eXBlb2YgcGFyYW1zLnF1ZXJ5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBxdWVyeSA9IHBhcmFtcy5xdWVyeTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMucXVlcnkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHF1ZXJ5ID0gb2JqZWN0VG9RdWVyeShwYXJhbXMucXVlcnkpO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNnZXQoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vdGhyZWFkc2AsXG4gICAgICB7IHF1ZXJ5IH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBkYXRhLm1hcCgodGhyZWFkKSA9PiBjb252ZXJ0VG9UaHJlYWREYXRhKHRocmVhZCkpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhIHRocmVhZC5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gZ2V0IHRoZSB0aHJlYWQgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElELlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBBIHRocmVhZC5cbiAgICovXG4gIGFzeW5jIGdldFRocmVhZChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHJvb21JZCwgdGhyZWFkSWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNnZXQoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vdGhyZWFkcy8ke3RocmVhZElkfWAsXG4gICAgICB2b2lkIDAsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRUb1RocmVhZERhdGEoYXdhaXQgcmVzLmpzb24oKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSB0aHJlYWQncyBwYXJ0aWNpcGFudHMuXG4gICAqXG4gICAqIFBhcnRpY2lwYW50cyBhcmUgdXNlcnMgd2hvIGhhdmUgY29tbWVudGVkIG9uIHRoZSB0aHJlYWRcbiAgICogb3IgdXNlcnMgYW5kIGdyb3VwcyB0aGF0IGhhdmUgYmVlbiBtZW50aW9uZWQgaW4gYSBjb21tZW50LlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBnZXQgdGhlIHRocmVhZCBwYXJ0aWNpcGFudHMgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIGdldCB0aGUgcGFydGljaXBhbnRzIGZyb20uXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIGFuIGFycmF5IG9mIHBhcnRpY2lwYW50IElEcy5cbiAgICovXG4gIGFzeW5jIGdldFRocmVhZFBhcnRpY2lwYW50cyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHJvb21JZCwgdGhyZWFkSWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNnZXQoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vdGhyZWFkcy8ke3RocmVhZElkfS9wYXJ0aWNpcGFudHNgLFxuICAgICAgdm9pZCAwLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgdGhyZWFkJ3MgY29tbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gZ2V0IHRoZSBjb21tZW50IGZyb20uXG4gICAqIEBwYXJhbSBwYXJhbXMudGhyZWFkSWQgVGhlIHRocmVhZCBJRCB0byBnZXQgdGhlIGNvbW1lbnQgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy5jb21tZW50SWQgVGhlIGNvbW1lbnQgSUQuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIEEgY29tbWVudC5cbiAgICovXG4gIGFzeW5jIGdldENvbW1lbnQocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyByb29tSWQsIHRocmVhZElkLCBjb21tZW50SWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNnZXQoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vdGhyZWFkcy8ke3RocmVhZElkfS9jb21tZW50cy8ke2NvbW1lbnRJZH1gLFxuICAgICAgdm9pZCAwLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50RGF0YShhd2FpdCByZXMuanNvbigpKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvbW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMucm9vbUlkIFRoZSByb29tIElEIHRvIGNyZWF0ZSB0aGUgY29tbWVudCBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIGNyZWF0ZSB0aGUgY29tbWVudCBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLnVzZXJJZCBUaGUgdXNlciBJRCBvZiB0aGUgdXNlciB3aG8gaXMgc2V0IHRvIGNyZWF0ZSB0aGUgY29tbWVudC5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLmNyZWF0ZWRBdCAob3B0aW9uYWwpIFRoZSBkYXRlIHRoZSBjb21tZW50IGlzIHNldCB0byBiZSBjcmVhdGVkLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEuYm9keSBUaGUgYm9keSBvZiB0aGUgY29tbWVudC5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgY29tbWVudC5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZUNvbW1lbnQocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyByb29tSWQsIHRocmVhZElkLCBkYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jcG9zdChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L2NvbW1lbnRzYCxcbiAgICAgIHtcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgY3JlYXRlZEF0OiBkYXRhLmNyZWF0ZWRBdD8udG9JU09TdHJpbmcoKVxuICAgICAgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudERhdGEoYXdhaXQgcmVzLmpzb24oKSk7XG4gIH1cbiAgLyoqXG4gICAqIEVkaXRzIGEgY29tbWVudC5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gZWRpdCB0aGUgY29tbWVudCBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIGVkaXQgdGhlIGNvbW1lbnQgaW4uXG4gICAqIEBwYXJhbSBwYXJhbXMuY29tbWVudElkIFRoZSBjb21tZW50IElEIHRvIGVkaXQuXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YS5ib2R5IFRoZSBib2R5IG9mIHRoZSBjb21tZW50LlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEuZWRpdGVkQXQgKG9wdGlvbmFsKSBUaGUgZGF0ZSB0aGUgY29tbWVudCB3YXMgZWRpdGVkLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBUaGUgZWRpdGVkIGNvbW1lbnQuXG4gICAqL1xuICBhc3luYyBlZGl0Q29tbWVudChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHJvb21JZCwgdGhyZWFkSWQsIGNvbW1lbnRJZCwgZGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI3Bvc3QoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vdGhyZWFkcy8ke3RocmVhZElkfS9jb21tZW50cy8ke2NvbW1lbnRJZH1gLFxuICAgICAgeyAuLi5kYXRhLCBlZGl0ZWRBdDogZGF0YS5lZGl0ZWRBdD8udG9JU09TdHJpbmcoKSB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0VG9Db21tZW50RGF0YShhd2FpdCByZXMuanNvbigpKTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhIGNvbW1lbnQuIERlbGV0ZXMgYSBjb21tZW50LiBJZiB0aGVyZSBhcmUgbm8gcmVtYWluaW5nIGNvbW1lbnRzIGluIHRoZSB0aHJlYWQsIHRoZSB0aHJlYWQgaXMgYWxzbyBkZWxldGVkLlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBkZWxldGUgdGhlIGNvbW1lbnQgaW4uXG4gICAqIEBwYXJhbSBwYXJhbXMudGhyZWFkSWQgVGhlIHRocmVhZCBJRCB0byBkZWxldGUgdGhlIGNvbW1lbnQgaW4uXG4gICAqIEBwYXJhbSBwYXJhbXMuY29tbWVudElkIFRoZSBjb21tZW50IElEIHRvIGRlbGV0ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZUNvbW1lbnQocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyByb29tSWQsIHRocmVhZElkLCBjb21tZW50SWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNkZWxldGUoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vdGhyZWFkcy8ke3RocmVhZElkfS9jb21tZW50cy8ke2NvbW1lbnRJZH1gLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHRocmVhZC4gVGhlIHRocmVhZCB3aWxsIGJlIGNyZWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbW1lbnQgYXMgaXRzIGZpcnN0IGNvbW1lbnQuXG4gICAqIElmIHRoZSB0aHJlYWQgYWxyZWFkeSBleGlzdHMsIGEgYExpdmVibG9ja3NFcnJvcmAgd2lsbCBiZSB0aHJvd24gd2l0aCBzdGF0dXMgY29kZSA0MDkuXG4gICAqIEBwYXJhbSBwYXJhbXMucm9vbUlkIFRoZSByb29tIElEIHRvIGNyZWF0ZSB0aGUgdGhyZWFkIGluLlxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZC5tZXRhZGF0YSAob3B0aW9uYWwpIFRoZSBtZXRhZGF0YSBmb3IgdGhlIHRocmVhZC4gU3VwcG9ydHMgdXB0byBhIG1heGltdW0gb2YgMTAgZW50cmllcy4gVmFsdWUgbXVzdCBiZSBhIHN0cmluZywgYm9vbGVhbiBvciBudW1iZXJcbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWQuY29tbWVudC51c2VySWQgVGhlIHVzZXIgSUQgb2YgdGhlIHVzZXIgd2hvIGNyZWF0ZWQgdGhlIGNvbW1lbnQuXG4gICAqIEBwYXJhbSBwYXJhbXMudGhyZWFkLmNvbW1lbnQuY3JlYXRlZEF0IChvcHRpb25hbCkgVGhlIGRhdGUgdGhlIGNvbW1lbnQgd2FzIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSBwYXJhbXMudGhyZWFkLmNvbW1lbnQuYm9keSBUaGUgYm9keSBvZiB0aGUgY29tbWVudC5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgdGhyZWFkLiBUaGUgdGhyZWFkIHdpbGwgYmUgY3JlYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQgY29tbWVudCBhcyBpdHMgZmlyc3QgY29tbWVudC5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVRocmVhZChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHJvb21JZCwgZGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI3Bvc3QoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vdGhyZWFkc2AsXG4gICAgICB7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIGNvbW1lbnQ6IHtcbiAgICAgICAgICAuLi5kYXRhLmNvbW1lbnQsXG4gICAgICAgICAgY3JlYXRlZEF0OiBkYXRhLmNvbW1lbnQuY3JlYXRlZEF0Py50b0lTT1N0cmluZygpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRUb1RocmVhZERhdGEoYXdhaXQgcmVzLmpzb24oKSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSB0aHJlYWQgYW5kIGFsbCBvZiBpdHMgY29tbWVudHMuXG4gICAqIEBwYXJhbSBwYXJhbXMucm9vbUlkIFRoZSByb29tIElEIHRvIGRlbGV0ZSB0aGUgdGhyZWFkIGluLlxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZElkIFRoZSB0aHJlYWQgSUQgdG8gZGVsZXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlVGhyZWFkKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCB0aHJlYWRJZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI2RlbGV0ZShcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9YCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTWFyayBhIHRocmVhZCBhcyByZXNvbHZlZC5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgb2YgdGhlIHRocmVhZC5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIG1hcmsgYXMgcmVzb2x2ZWQuXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YS51c2VySWQgVGhlIHVzZXIgSUQgb2YgdGhlIHVzZXIgd2hvIG1hcmtlZCB0aGUgdGhyZWFkIGFzIHJlc29sdmVkLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBUaGUgdGhyZWFkIG1hcmtlZCBhcyByZXNvbHZlZC5cbiAgICovXG4gIGFzeW5jIG1hcmtUaHJlYWRBc1Jlc29sdmVkKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCB0aHJlYWRJZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI3Bvc3QoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vdGhyZWFkcy8ke3RocmVhZElkfS9tYXJrLWFzLXJlc29sdmVkYCxcbiAgICAgIHsgdXNlcklkOiBwYXJhbXMuZGF0YS51c2VySWQgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydFRvVGhyZWFkRGF0YShhd2FpdCByZXMuanNvbigpKTtcbiAgfVxuICAvKipcbiAgICogTWFyayBhIHRocmVhZCBhcyB1bnJlc29sdmVkLlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCBvZiB0aGUgdGhyZWFkLlxuICAgKiBAcGFyYW0gcGFyYW1zLnRocmVhZElkIFRoZSB0aHJlYWQgSUQgdG8gbWFyayBhcyB1bnJlc29sdmVkLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEudXNlcklkIFRoZSB1c2VyIElEIG9mIHRoZSB1c2VyIHdobyBtYXJrZWQgdGhlIHRocmVhZCBhcyB1bnJlc29sdmVkLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBUaGUgdGhyZWFkIG1hcmtlZCBhcyB1bnJlc29sdmVkLlxuICAgKi9cbiAgYXN5bmMgbWFya1RocmVhZEFzVW5yZXNvbHZlZChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHJvb21JZCwgdGhyZWFkSWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNwb3N0KFxuICAgICAgdXJsMmAvdjIvcm9vbXMvJHtyb29tSWR9L3RocmVhZHMvJHt0aHJlYWRJZH0vbWFyay1hcy11bnJlc29sdmVkYCxcbiAgICAgIHsgdXNlcklkOiBwYXJhbXMuZGF0YS51c2VySWQgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydFRvVGhyZWFkRGF0YShhd2FpdCByZXMuanNvbigpKTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbWV0YWRhdGEgb2YgdGhlIHNwZWNpZmllZCB0aHJlYWQgaW4gYSByb29tLlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byB1cGRhdGUgdGhlIHRocmVhZCBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLm1ldGFkYXRhIFRoZSBtZXRhZGF0YSBmb3IgdGhlIHRocmVhZC4gVmFsdWUgbXVzdCBiZSBhIHN0cmluZywgYm9vbGVhbiBvciBudW1iZXJcbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLnVzZXJJZCBUaGUgdXNlciBJRCBvZiB0aGUgdXNlciB3aG8gdXBkYXRlZCB0aGUgdGhyZWFkLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEudXBkYXRlZEF0IChvcHRpb25hbCkgVGhlIGRhdGUgdGhlIHRocmVhZCBpcyBzZXQgdG8gYmUgdXBkYXRlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgdGhyZWFkIG1ldGFkYXRhLlxuICAgKi9cbiAgYXN5bmMgZWRpdFRocmVhZE1ldGFkYXRhKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCB0aHJlYWRJZCwgZGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI3Bvc3QoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vdGhyZWFkcy8ke3RocmVhZElkfS9tZXRhZGF0YWAsXG4gICAgICB7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIHVwZGF0ZWRBdDogZGF0YS51cGRhdGVkQXQ/LnRvSVNPU3RyaW5nKClcbiAgICAgIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgY29tbWVudCByZWFjdGlvbiB0byBhIGNvbW1lbnQuXG4gICAqIEBwYXJhbSBwYXJhbXMucm9vbUlkIFRoZSByb29tIElEIHRvIGFkZCB0aGUgY29tbWVudCByZWFjdGlvbiBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy50aHJlYWRJZCBUaGUgdGhyZWFkIElEIHRvIGFkZCB0aGUgY29tbWVudCByZWFjdGlvbiBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy5jb21tZW50SWQgVGhlIGNvbW1lbnQgSUQgdG8gYWRkIHRoZSByZWFjdGlvbiBpbi5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLmVtb2ppIFRoZSAoZW1vamkpIHJlYWN0aW9uIHRvIGFkZC5cbiAgICogQHBhcmFtIHBhcmFtcy5kYXRhLnVzZXJJZCBUaGUgdXNlciBJRCBvZiB0aGUgdXNlciBhc3NvY2lhdGVkIHdpdGggdGhlIHJlYWN0aW9uLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEuY3JlYXRlZEF0IChvcHRpb25hbCkgVGhlIGRhdGUgdGhlIHJlYWN0aW9uIGlzIHNldCB0byBiZSBjcmVhdGVkLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBjb21tZW50IHJlYWN0aW9uLlxuICAgKi9cbiAgYXN5bmMgYWRkQ29tbWVudFJlYWN0aW9uKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgcm9vbUlkLCB0aHJlYWRJZCwgY29tbWVudElkLCBkYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jcG9zdChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L2NvbW1lbnRzLyR7Y29tbWVudElkfS9hZGQtcmVhY3Rpb25gLFxuICAgICAge1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBjcmVhdGVkQXQ6IGRhdGEuY3JlYXRlZEF0Py50b0lTT1N0cmluZygpXG4gICAgICB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWN0aW9uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4gY29udmVydFRvQ29tbWVudFVzZXJSZWFjdGlvbihyZWFjdGlvbik7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSByZWFjdGlvbiBmcm9tIGEgY29tbWVudC5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gcmVtb3ZlIHRoZSBjb21tZW50IHJlYWN0aW9uIGZyb20uXG4gICAqIEBwYXJhbSBwYXJhbXMudGhyZWFkSWQgVGhlIHRocmVhZCBJRCB0byByZW1vdmUgdGhlIGNvbW1lbnQgcmVhY3Rpb24gZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy5jb21tZW50SWQgVGhlIGNvbW1lbnQgSUQgdG8gcmVtb3ZlIHRoZSByZWFjdGlvbiBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEuZW1vamkgVGhlIChlbW9qaSkgcmVhY3Rpb24gdG8gcmVtb3ZlLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEudXNlcklkIFRoZSB1c2VyIElEIG9mIHRoZSB1c2VyIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVhY3Rpb24uXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YS5yZW1vdmVkQXQgKG9wdGlvbmFsKSBUaGUgZGF0ZSB0aGUgcmVhY3Rpb24gaXMgc2V0IHRvIGJlIHJlbW92ZWQuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBhc3luYyByZW1vdmVDb21tZW50UmVhY3Rpb24ocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyByb29tSWQsIHRocmVhZElkLCBkYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jcG9zdChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS90aHJlYWRzLyR7dGhyZWFkSWR9L2NvbW1lbnRzLyR7cGFyYW1zLmNvbW1lbnRJZH0vcmVtb3ZlLXJlYWN0aW9uYCxcbiAgICAgIHtcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgcmVtb3ZlZEF0OiBkYXRhLnJlbW92ZWRBdD8udG9JU09TdHJpbmcoKVxuICAgICAgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5ib3ggbm90aWZpY2F0aW9ucyBmb3IgYSB1c2VyLlxuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJJZCBUaGUgdXNlciBJRCB0byBnZXQgdGhlIGluYm94IG5vdGlmaWNhdGlvbnMgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy5pbmJveE5vdGlmaWNhdGlvbklkIFRoZSBJRCBvZiB0aGUgaW5ib3ggbm90aWZpY2F0aW9uIHRvIGdldC5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGFzeW5jIGdldEluYm94Tm90aWZpY2F0aW9uKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgdXNlcklkLCBpbmJveE5vdGlmaWNhdGlvbklkIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jZ2V0KFxuICAgICAgdXJsMmAvdjIvdXNlcnMvJHt1c2VySWR9L2luYm94LW5vdGlmaWNhdGlvbnMvJHtpbmJveE5vdGlmaWNhdGlvbklkfWAsXG4gICAgICB2b2lkIDAsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRUb0luYm94Tm90aWZpY2F0aW9uRGF0YShcbiAgICAgIGF3YWl0IHJlcy5qc29uKClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmJveCBub3RpZmljYXRpb25zIGZvciBhIHVzZXIuXG4gICAqIEBwYXJhbSBwYXJhbXMudXNlcklkIFRoZSB1c2VyIElEIHRvIGdldCB0aGUgaW5ib3ggbm90aWZpY2F0aW9ucyBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLnF1ZXJ5IFRoZSBxdWVyeSB0byBmaWx0ZXIgaW5ib3ggbm90aWZpY2F0aW9ucyBieS4gSXQgaXMgYmFzZWQgb24gb3VyIHF1ZXJ5IGxhbmd1YWdlIGFuZCBjYW4gZmlsdGVyIGJ5IHVucmVhZC5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGFzeW5jIGdldEluYm94Tm90aWZpY2F0aW9ucyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHVzZXJJZCB9ID0gcGFyYW1zO1xuICAgIGxldCBxdWVyeTtcbiAgICBpZiAodHlwZW9mIHBhcmFtcy5xdWVyeSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcXVlcnkgPSBwYXJhbXMucXVlcnk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zLnF1ZXJ5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBxdWVyeSA9IG9iamVjdFRvUXVlcnkocGFyYW1zLnF1ZXJ5KTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jZ2V0KFxuICAgICAgdXJsMmAvdjIvdXNlcnMvJHt1c2VySWR9L2luYm94LW5vdGlmaWNhdGlvbnNgLFxuICAgICAge1xuICAgICAgICBxdWVyeSxcbiAgICAgICAgbGltaXQ6IHBhcmFtcz8ubGltaXQsXG4gICAgICAgIHN0YXJ0aW5nQWZ0ZXI6IHBhcmFtcz8uc3RhcnRpbmdBZnRlclxuICAgICAgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgICBjb25zdCBwYWdlID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucGFnZSxcbiAgICAgIGRhdGE6IHBhZ2UuZGF0YS5tYXAoY29udmVydFRvSW5ib3hOb3RpZmljYXRpb25EYXRhKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgYWxsIGluYm94IG5vdGlmaWNhdGlvbnMgZm9yIGEgdXNlci5cbiAgICpcbiAgICogVGhlIGRpZmZlcmVuY2Ugd2l0aCAuZ2V0SW5ib3hOb3RpZmljYXRpb25zKCkgaXMgdGhhdCBwYWdpbmF0aW9uIHdpbGxcbiAgICogaGFwcGVuIGF1dG9tYXRpY2FsbHkgdW5kZXIgdGhlIGhvb2QsIHVzaW5nIHRoZSBnaXZlbiBgcGFnZVNpemVgLlxuICAgKlxuICAgKiBAcGFyYW0gY3JpdGVyaWEudXNlcklkIFRoZSB1c2VyIElEIHRvIGdldCB0aGUgaW5ib3ggbm90aWZpY2F0aW9ucyBmcm9tLlxuICAgKiBAcGFyYW0gY3JpdGVyaWEucXVlcnkgVGhlIHF1ZXJ5IHRvIGZpbHRlciBpbmJveCBub3RpZmljYXRpb25zIGJ5LiBJdCBpcyBiYXNlZCBvbiBvdXIgcXVlcnkgbGFuZ3VhZ2UgYW5kIGNhbiBmaWx0ZXIgYnkgdW5yZWFkLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5wYWdlU2l6ZSAob3B0aW9uYWwpIFRoZSBwYWdlIHNpemUgdG8gdXNlIGZvciBlYWNoIHJlcXVlc3QuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBhc3luYyAqaXRlckluYm94Tm90aWZpY2F0aW9ucyhjcml0ZXJpYSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgc2lnbmFsIH0gPSBvcHRpb25zID8/IHt9O1xuICAgIGNvbnN0IHBhZ2VTaXplID0gY2hlY2tCb3VuZHMoXCJwYWdlU2l6ZVwiLCBvcHRpb25zPy5wYWdlU2l6ZSA/PyA1MCwgMTApO1xuICAgIGxldCBjdXJzb3IgPSB2b2lkIDA7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHsgbmV4dEN1cnNvciwgZGF0YSB9ID0gYXdhaXQgdGhpcy5nZXRJbmJveE5vdGlmaWNhdGlvbnMoXG4gICAgICAgIHsgLi4uY3JpdGVyaWEsIHN0YXJ0aW5nQWZ0ZXI6IGN1cnNvciwgbGltaXQ6IHBhZ2VTaXplIH0sXG4gICAgICAgIHsgc2lnbmFsIH1cbiAgICAgICk7XG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZGF0YSkge1xuICAgICAgICB5aWVsZCBpdGVtO1xuICAgICAgfVxuICAgICAgaWYgKCFuZXh0Q3Vyc29yKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY3Vyc29yID0gbmV4dEN1cnNvcjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHVzZXIncyByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncy5cbiAgICogQHBhcmFtIHBhcmFtcy51c2VySWQgVGhlIHVzZXIgSUQgdG8gZ2V0IHRoZSByb29tIG5vdGlmaWNhdGlvbnMgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIHJvb20gSUQgdG8gZ2V0IHRoZSByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmcm9tLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgYXN5bmMgZ2V0Um9vbU5vdGlmaWNhdGlvblNldHRpbmdzKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgdXNlcklkLCByb29tSWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNnZXQoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vdXNlcnMvJHt1c2VySWR9L25vdGlmaWNhdGlvbi1zZXR0aW5nc2AsXG4gICAgICB2b2lkIDAsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlcy5qc29uKCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHVzZXIncyByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncy5cbiAgICogQHBhcmFtIHBhcmFtcy51c2VySWQgVGhlIHVzZXIgSUQgdG8gdXBkYXRlIHRoZSByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmb3IuXG4gICAqIEBwYXJhbSBwYXJhbXMucm9vbUlkIFRoZSByb29tIElEIHRvIHVwZGF0ZSB0aGUgcm9vbSBub3RpZmljYXRpb24gc2V0dGluZ3MgZm9yLlxuICAgKiBAcGFyYW0gcGFyYW1zLmRhdGEgVGhlIG5ldyByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmb3IgdGhlIHVzZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBhc3luYyB1cGRhdGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyB1c2VySWQsIHJvb21JZCwgZGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI3Bvc3QoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke3Jvb21JZH0vdXNlcnMvJHt1c2VySWR9L25vdGlmaWNhdGlvbi1zZXR0aW5nc2AsXG4gICAgICBkYXRhLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXMuanNvbigpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgdGhlIHVzZXIncyByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncy5cbiAgICogQHBhcmFtIHBhcmFtcy51c2VySWQgVGhlIHVzZXIgSUQgdG8gZGVsZXRlIHRoZSByb29tIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmcm9tLlxuICAgKiBAcGFyYW0gcGFyYW1zLnJvb21JZCBUaGUgcm9vbSBJRCB0byBkZWxldGUgdGhlIHJvb20gbm90aWZpY2F0aW9uIHNldHRpbmdzIGZyb20uXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBhc3luYyBkZWxldGVSb29tTm90aWZpY2F0aW9uU2V0dGluZ3MocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyB1c2VySWQsIHJvb21JZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI2RlbGV0ZShcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS91c2Vycy8ke3VzZXJJZH0vbm90aWZpY2F0aW9uLXNldHRpbmdzYCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlIGEgcm9vbSBJRC5cbiAgICogQHBhcmFtIHBhcmFtcy5yb29tSWQgVGhlIGN1cnJlbnQgSUQgb2YgdGhlIHJvb20uXG4gICAqIEBwYXJhbSBwYXJhbXMubmV3Um9vbUlkIFRoZSBuZXcgcm9vbSBJRC5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZVJvb21JZChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGN1cnJlbnRSb29tSWQsIG5ld1Jvb21JZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI3Bvc3QoXG4gICAgICB1cmwyYC92Mi9yb29tcy8ke2N1cnJlbnRSb29tSWR9L3VwZGF0ZS1yb29tLWlkYCxcbiAgICAgIHsgbmV3Um9vbUlkIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRhdGEsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGRhdGEuY3JlYXRlZEF0KSxcbiAgICAgIGxhc3RDb25uZWN0aW9uQXQ6IGRhdGEubGFzdENvbm5lY3Rpb25BdCA/IG5ldyBEYXRlKGRhdGEubGFzdENvbm5lY3Rpb25BdCkgOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIGFzeW5jIHRyaWdnZXJJbmJveE5vdGlmaWNhdGlvbihwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNwb3N0KFxuICAgICAgdXJsMmAvdjIvaW5ib3gtbm90aWZpY2F0aW9ucy90cmlnZ2VyYCxcbiAgICAgIHBhcmFtcyxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhbiBpbmJveCBub3RpZmljYXRpb24gZm9yIGEgdXNlci5cbiAgICogQHBhcmFtIHBhcmFtcy51c2VySWQgVGhlIHVzZXIgSUQgZm9yIHdoaWNoIHRvIGRlbGV0ZSB0aGUgaW5ib3ggbm90aWZpY2F0aW9uLlxuICAgKiBAcGFyYW0gcGFyYW1zLmluYm94Tm90aWZpY2F0aW9uSWQgVGhlIElEIG9mIHRoZSBpbmJveCBub3RpZmljYXRpb24gdG8gZGVsZXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlSW5ib3hOb3RpZmljYXRpb24ocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyB1c2VySWQsIGluYm94Tm90aWZpY2F0aW9uSWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNkZWxldGUoXG4gICAgICB1cmwyYC92Mi91c2Vycy8ke3VzZXJJZH0vaW5ib3gtbm90aWZpY2F0aW9ucy8ke2luYm94Tm90aWZpY2F0aW9uSWR9YCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVsZXRlcyBhbGwgaW5ib3ggbm90aWZpY2F0aW9ucyBmb3IgYSB1c2VyLlxuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJJZCBUaGUgdXNlciBJRCBmb3Igd2hpY2ggdG8gZGVsZXRlIGFsbCB0aGUgaW5ib3ggbm90aWZpY2F0aW9ucy5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2lnbmFsIChvcHRpb25hbCkgQW4gYWJvcnQgc2lnbmFsIHRvIGNhbmNlbCB0aGUgcmVxdWVzdC5cbiAgICovXG4gIGFzeW5jIGRlbGV0ZUFsbEluYm94Tm90aWZpY2F0aW9ucyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHVzZXJJZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI2RlbGV0ZShcbiAgICAgIHVybDJgL3YyL3VzZXJzLyR7dXNlcklkfS9pbmJveC1ub3RpZmljYXRpb25zYCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0IG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmb3IgYSB1c2VyIGZvciBhIHByb2plY3QuXG4gICAqIEBwYXJhbSBwYXJhbXMudXNlcklkIFRoZSB1c2VyIElEIHRvIGdldCB0aGUgbm90aWZpY2F0aW9ucyBzZXR0aW5ncyBmb3IuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBhc3luYyBnZXROb3RpZmljYXRpb25TZXR0aW5ncyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHVzZXJJZCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI2dldChcbiAgICAgIHVybDJgL3YyL3VzZXJzLyR7dXNlcklkfS9ub3RpZmljYXRpb24tc2V0dGluZ3NgLFxuICAgICAgdm9pZCAwLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IGF3YWl0IExpdmVibG9ja3NFcnJvci5mcm9tKHJlcyk7XG4gICAgfVxuICAgIGNvbnN0IHBsYWluU2V0dGluZ3MgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGNvbnN0IHNldHRpbmdzID0gY3JlYXRlVXNlck5vdGlmaWNhdGlvblNldHRpbmdzKHBsYWluU2V0dGluZ3MpO1xuICAgIHJldHVybiBzZXR0aW5ncztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSB1c2VyJ3Mgbm90aWZpY2F0aW9uIHNldHRpbmdzLlxuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJJZCBUaGUgdXNlciBJRCB0byB1cGRhdGUgdGhlIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmb3IuXG4gICAqIEBwYXJhbSBwYXJhbXMuZGF0YSBUaGUgbmV3IG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmb3IgdGhlIHVzZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zLnNpZ25hbCAob3B0aW9uYWwpIEFuIGFib3J0IHNpZ25hbCB0byBjYW5jZWwgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBhc3luYyB1cGRhdGVOb3RpZmljYXRpb25TZXR0aW5ncyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHVzZXJJZCwgZGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuI3Bvc3QoXG4gICAgICB1cmwyYC92Mi91c2Vycy8ke3VzZXJJZH0vbm90aWZpY2F0aW9uLXNldHRpbmdzYCxcbiAgICAgIGRhdGEsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gICAgY29uc3QgcGxhaW5TZXR0aW5ncyA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBjcmVhdGVVc2VyTm90aWZpY2F0aW9uU2V0dGluZ3MocGxhaW5TZXR0aW5ncyk7XG4gICAgcmV0dXJuIHNldHRpbmdzO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgdGhlIHVzZXIncyBub3RpZmljYXRpb24gc2V0dGluZ3NcbiAgICogQHBhcmFtIHBhcmFtcy51c2VySWQgVGhlIHVzZXIgSUQgdG8gdXBkYXRlIHRoZSBub3RpZmljYXRpb24gc2V0dGluZ3MgZm9yLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaWduYWwgKG9wdGlvbmFsKSBBbiBhYm9ydCBzaWduYWwgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlTm90aWZpY2F0aW9uU2V0dGluZ3MocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyB1c2VySWQgfSA9IHBhcmFtcztcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLiNkZWxldGUoXG4gICAgICB1cmwyYC92Mi91c2Vycy8ke3VzZXJJZH0vbm90aWZpY2F0aW9uLXNldHRpbmdzYCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBhd2FpdCBMaXZlYmxvY2tzRXJyb3IuZnJvbShyZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IFN0b3JhZ2UgY29udGVudHMgZm9yIHRoZSBnaXZlbiByb29tIElEIGFuZCBjYWxscyB0aGVcbiAgICogcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24sIGluIHdoaWNoIHlvdSBjYW4gbXV0YXRlIHRoZSBTdG9yYWdlIGNvbnRlbnRzXG4gICAqIGF0IHdpbGwuXG4gICAqXG4gICAqIElmIHlvdSBuZWVkIHRvIHJ1biB0aGUgc2FtZSBtdXRhdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcm9vbXMsIHByZWZlciB1c2luZ1xuICAgKiBgLm1hc3NNdXRhdGVTdG9yYWdlKClgIGluc3RlYWQgb2YgbG9vcGluZyBvdmVyIHJvb20gSURzIHlvdXJzZWxmLlxuICAgKi9cbiAgYXN5bmMgbXV0YXRlU3RvcmFnZShyb29tSWQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuI19tdXRhdGVPbmVSb29tKHJvb21JZCwgdm9pZCAwLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgU3RvcmFnZSBjb250ZW50cyBmb3IgZWFjaCByb29tIHRoYXQgbWF0Y2hlcyB0aGUgZ2l2ZW5cbiAgICogY3JpdGVyaWEgYW5kIGNhbGxzIHRoZSBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbiwgaW4gd2hpY2ggeW91IGNhbiBtdXRhdGVcbiAgICogdGhlIFN0b3JhZ2UgY29udGVudHMgYXQgd2lsbC5cbiAgICpcbiAgICogWW91IGNhbiB1c2UgdGhlIGBjcml0ZXJpYWAgcGFyYW1ldGVyIHRvIHNlbGVjdCB3aGljaCByb29tcyB0byBwcm9jZXNzIGJ5XG4gICAqIHRoZWlyIG1ldGFkYXRhLiBJZiB5b3UgcGFzcyBge31gIChlbXB0eSBvYmplY3QpLCBhbGwgcm9vbXMgd2lsbCBiZVxuICAgKiBzZWxlY3RlZCBhbmQgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIGV4ZWN1dGUgbXV0YXRpb25zIGluIHBhcmFsbGVsLCB1c2luZyB0aGUgc3BlY2lmaWVkXG4gICAqIGBjb25jdXJyZW5jeWAgdmFsdWUuIElmIHlvdSB3aGljaCB0byBydW4gdGhlIG11dGF0aW9ucyBzZXJpYWxseSwgc2V0XG4gICAqIGBjb25jdXJyZW5jeWAgdG8gMS5cbiAgICovXG4gIGFzeW5jIG1hc3NNdXRhdGVTdG9yYWdlKGNyaXRlcmlhLCBjYWxsYmFjaywgbWFzc09wdGlvbnMpIHtcbiAgICBjb25zdCBjb25jdXJyZW5jeSA9IGNoZWNrQm91bmRzKFxuICAgICAgXCJjb25jdXJyZW5jeVwiLFxuICAgICAgbWFzc09wdGlvbnM/LmNvbmN1cnJlbmN5ID8/IDgsXG4gICAgICAxLFxuICAgICAgMjBcbiAgICApO1xuICAgIGNvbnN0IHBhZ2VTaXplID0gTWF0aC5tYXgoMjAsIGNvbmN1cnJlbmN5ICogNCk7XG4gICAgY29uc3QgeyBzaWduYWwgfSA9IG1hc3NPcHRpb25zID8/IHt9O1xuICAgIGNvbnN0IHJvb21zID0gdGhpcy5pdGVyUm9vbXMoY3JpdGVyaWEsIHsgcGFnZVNpemUsIHNpZ25hbCB9KTtcbiAgICBjb25zdCBvcHRpb25zID0geyBzaWduYWwgfTtcbiAgICBhd2FpdCBydW5Db25jdXJyZW50bHkoXG4gICAgICByb29tcyxcbiAgICAgIChyb29tRGF0YSkgPT4gdGhpcy4jX211dGF0ZU9uZVJvb20ocm9vbURhdGEuaWQsIHJvb21EYXRhLCBjYWxsYmFjaywgb3B0aW9ucyksXG4gICAgICBjb25jdXJyZW5jeVxuICAgICk7XG4gIH1cbiAgYXN5bmMgI19tdXRhdGVPbmVSb29tKHJvb21JZCwgcm9vbSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWJvdW5jZUludGVydmFsID0gMjAwO1xuICAgIGNvbnN0IHsgc2lnbmFsLCBhYm9ydCB9ID0gbWFrZUFib3J0Q29udHJvbGxlcihvcHRpb25zPy5zaWduYWwpO1xuICAgIGxldCBvcHNCdWZmZXIgPSBbXTtcbiAgICBsZXQgb3V0c3RhbmRpbmdGbHVzaCQgPSB2b2lkIDA7XG4gICAgbGV0IGxhc3RGbHVzaCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IGZsdXNoSWZOZWVkZWQgPSAoZm9yY2UpID0+IHtcbiAgICAgIGlmIChvcHNCdWZmZXIubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAob3V0c3RhbmRpbmdGbHVzaCQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBpZiAoIShmb3JjZSB8fCBub3cgLSBsYXN0Rmx1c2ggPiBkZWJvdW5jZUludGVydmFsKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsYXN0Rmx1c2ggPSBub3c7XG4gICAgICBjb25zdCBvcHMgPSBvcHNCdWZmZXI7XG4gICAgICBvcHNCdWZmZXIgPSBbXTtcbiAgICAgIG91dHN0YW5kaW5nRmx1c2gkID0gdGhpcy4jc2VuZE1lc3NhZ2UoXG4gICAgICAgIHJvb21JZCxcbiAgICAgICAgW3sgdHlwZTogQ2xpZW50TXNnQ29kZS5VUERBVEVfU1RPUkFHRSwgb3BzIH1dLFxuICAgICAgICB7IHNpZ25hbCB9XG4gICAgICApLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgYWJvcnQoZXJyKTtcbiAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBvdXRzdGFuZGluZ0ZsdXNoJCA9IHZvaWQgMDtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLiNyZXF1ZXN0U3RvcmFnZU11dGF0aW9uKHJvb21JZCwgeyBzaWduYWwgfSk7XG4gICAgICBjb25zdCB7IGFjdG9yLCBub2RlcyB9ID0gcmVzcDtcbiAgICAgIGNvbnN0IHBvb2wgPSBjcmVhdGVNYW5hZ2VkUG9vbChyb29tSWQsIHtcbiAgICAgICAgZ2V0Q3VycmVudENvbm5lY3Rpb25JZDogKCkgPT4gYWN0b3IsXG4gICAgICAgIG9uRGlzcGF0Y2g6IChvcHMsIF9yZXZlcnNlLCBfc3RvcmFnZVVwZGF0ZXMpID0+IHtcbiAgICAgICAgICBpZiAob3BzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgICAgICAgICBvcHNCdWZmZXIucHVzaChvcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoSWZOZWVkZWQoXG4gICAgICAgICAgICAvKiBmb3JjZSAqL1xuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJvb3QgPSBMaXZlT2JqZWN0Ll9mcm9tSXRlbXMobm9kZXMsIHBvb2wpO1xuICAgICAgY29uc3QgY2FsbGJhY2skID0gY2FsbGJhY2soeyByb29tLCByb290IH0pO1xuICAgICAgZmx1c2hJZk5lZWRlZChcbiAgICAgICAgLyogZm9yY2UgKi9cbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICAgIGF3YWl0IGNhbGxiYWNrJDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBhYm9ydCgpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgYXdhaXQgb3V0c3RhbmRpbmdGbHVzaCQ7XG4gICAgICBmbHVzaElmTmVlZGVkKFxuICAgICAgICAvKiBmb3JjZSAqL1xuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgICAgYXdhaXQgb3V0c3RhbmRpbmdGbHVzaCQ7XG4gICAgfVxuICB9XG4gIGFzeW5jICNzZW5kTWVzc2FnZShyb29tSWQsIG1lc3NhZ2VzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy4jcG9zdChcbiAgICAgIHVybDJgL3YyL3Jvb21zLyR7cm9vbUlkfS9zZW5kLW1lc3NhZ2VgLFxuICAgICAgeyBtZXNzYWdlcyB9LFxuICAgICAgeyBzaWduYWw6IG9wdGlvbnM/LnNpZ25hbCB9XG4gICAgKTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgYXdhaXQgTGl2ZWJsb2Nrc0Vycm9yLmZyb20ocmVzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgTGl2ZWJsb2Nrc0Vycm9yID0gY2xhc3MgX0xpdmVibG9ja3NFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgc3RhdHVzO1xuICBkZXRhaWxzO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIGRldGFpbHMpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIkxpdmVibG9ja3NFcnJvclwiO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgbGV0IG1zZyA9IGAke3RoaXMubmFtZX06ICR7dGhpcy5tZXNzYWdlfSAoc3RhdHVzICR7dGhpcy5zdGF0dXN9KWA7XG4gICAgaWYgKHRoaXMuZGV0YWlscykge1xuICAgICAgbXNnICs9IGBcbiR7dGhpcy5kZXRhaWxzfWA7XG4gICAgfVxuICAgIHJldHVybiBtc2c7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb20ocmVzKSB7XG4gICAgY29uc3QgRkFMTEJBQ0sgPSBcIkFuIGVycm9yIGhhcHBlbmVkIHdpdGhvdXQgYW4gZXJyb3IgbWVzc2FnZVwiO1xuICAgIGxldCB0ZXh0O1xuICAgIHRyeSB7XG4gICAgICB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRleHQgPSBGQUxMQkFDSztcbiAgICB9XG4gICAgY29uc3Qgb2JqID0gdHJ5UGFyc2VKc29uKHRleHQpID8/IHsgbWVzc2FnZTogdGV4dCB9O1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBvYmoubWVzc2FnZSB8fCBGQUxMQkFDSztcbiAgICBjb25zdCBkZXRhaWxzID0gW1xuICAgICAgb2JqLnN1Z2dlc3Rpb24gPyBgU3VnZ2VzdGlvbjogJHtTdHJpbmcob2JqLnN1Z2dlc3Rpb24pfWAgOiB2b2lkIDAsXG4gICAgICBvYmouZG9jcyA/IGBTZWUgYWxzbzogJHtTdHJpbmcob2JqLmRvY3MpfWAgOiB2b2lkIDBcbiAgICBdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiXFxuXCIpIHx8IHZvaWQgMDtcbiAgICByZXR1cm4gbmV3IF9MaXZlYmxvY2tzRXJyb3IobWVzc2FnZSwgcmVzLnN0YXR1cywgZGV0YWlscyk7XG4gIH1cbn07XG5cbi8vIHNyYy93ZWJob29rcy50c1xuaW1wb3J0ICogYXMgYmFzZTY0IGZyb20gXCJAc3RhYmxlbGliL2Jhc2U2NFwiO1xuaW1wb3J0ICogYXMgc2hhMjU2IGZyb20gXCJmYXN0LXNoYTI1NlwiO1xudmFyIFdlYmhvb2tIYW5kbGVyID0gY2xhc3MgX1dlYmhvb2tIYW5kbGVyIHtcbiAgI3NlY3JldEJ1ZmZlcjtcbiAgc3RhdGljICNzZWNyZXRQcmVmaXggPSBcIndoc2VjX1wiO1xuICBjb25zdHJ1Y3RvcihzZWNyZXQpIHtcbiAgICBpZiAoIXNlY3JldCkgdGhyb3cgbmV3IEVycm9yKFwiU2VjcmV0IGlzIHJlcXVpcmVkXCIpO1xuICAgIGlmICh0eXBlb2Ygc2VjcmV0ICE9PSBcInN0cmluZ1wiKSB0aHJvdyBuZXcgRXJyb3IoXCJTZWNyZXQgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICBpZiAoc2VjcmV0LnN0YXJ0c1dpdGgoX1dlYmhvb2tIYW5kbGVyLiNzZWNyZXRQcmVmaXgpID09PSBmYWxzZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VjcmV0LCBtdXN0IHN0YXJ0IHdpdGggd2hzZWNfXCIpO1xuICAgIGNvbnN0IHNlY3JldEtleSA9IHNlY3JldC5zbGljZShfV2ViaG9va0hhbmRsZXIuI3NlY3JldFByZWZpeC5sZW5ndGgpO1xuICAgIHRoaXMuI3NlY3JldEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHNlY3JldEtleSwgXCJiYXNlNjRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFZlcmlmaWVzIGEgd2ViaG9vayByZXF1ZXN0IGFuZCByZXR1cm5zIHRoZSBldmVudFxuICAgKi9cbiAgdmVyaWZ5UmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgY29uc3QgeyBoZWFkZXJzLCByYXdCb2R5IH0gPSByZXF1ZXN0O1xuICAgIGNvbnN0IHsgd2ViaG9va0lkLCB0aW1lc3RhbXAsIHJhd1NpZ25hdHVyZXMgfSA9IHRoaXMuI3ZlcmlmeUhlYWRlcnMoaGVhZGVycyk7XG4gICAgaWYgKHR5cGVvZiByYXdCb2R5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHJhd0JvZHkgZmllbGQsIG11c3QgYmUgYSBzdHJpbmcsIGdvdCBcIiR7dHlwZW9mIHJhd0JvZHl9XCIgaW5zdGVhZC4gSXQgaXMgbGlrZWx5IHRoYXQgeW91IG5lZWQgdG8gSlNPTi5zdHJpbmdpZnkgdGhlIGJvZHkgYmVmb3JlIHBhc3NpbmcgaXQuYFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy4jdmVyaWZ5VGltZXN0YW1wKHRpbWVzdGFtcCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gdGhpcy4jc2lnbihgJHt3ZWJob29rSWR9LiR7dGltZXN0YW1wfS4ke3Jhd0JvZHl9YCk7XG4gICAgY29uc3QgZXhwZWN0ZWRTaWduYXR1cmVzID0gcmF3U2lnbmF0dXJlcy5zcGxpdChcIiBcIikubWFwKChyYXdTaWduYXR1cmUpID0+IHtcbiAgICAgIGNvbnN0IFssIHBhcnNlZFNpZ25hdHVyZV0gPSByYXdTaWduYXR1cmUuc3BsaXQoXCIsXCIpO1xuICAgICAgcmV0dXJuIHBhcnNlZFNpZ25hdHVyZTtcbiAgICB9KS5maWx0ZXIoaXNOb3RVbmRlZmluZWQpO1xuICAgIGlmIChleHBlY3RlZFNpZ25hdHVyZXMuaW5jbHVkZXMoc2lnbmF0dXJlKSA9PT0gZmFsc2UpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIHNpZ25hdHVyZSwgZXhwZWN0ZWQgb25lIG9mICR7ZXhwZWN0ZWRTaWduYXR1cmVzLmpvaW4oXG4gICAgICAgICAgXCIsIFwiXG4gICAgICAgICl9LCBnb3QgJHtzaWduYXR1cmV9YFxuICAgICAgKTtcbiAgICBjb25zdCBldmVudCA9IEpTT04ucGFyc2UocmF3Qm9keSk7XG4gICAgdGhpcy4jdmVyaWZ5V2ViaG9va0V2ZW50VHlwZShldmVudCk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIC8qKlxuICAgKiBWZXJpZmllcyB0aGUgaGVhZGVycyBhbmQgcmV0dXJucyB0aGUgd2ViaG9va0lkLCB0aW1lc3RhbXAgYW5kIHJhd1NpZ25hdHVyZXNcbiAgICovXG4gICN2ZXJpZnlIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICBjb25zdCB1c2luZ05hdGl2ZUhlYWRlcnMgPSB0eXBlb2YgSGVhZGVycyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycztcbiAgICBjb25zdCBub3JtYWxpemVkSGVhZGVycyA9IHVzaW5nTmF0aXZlSGVhZGVycyA/IE9iamVjdC5mcm9tRW50cmllcyhoZWFkZXJzKSA6IGhlYWRlcnM7XG4gICAgY29uc3Qgc2FuaXRpemVkSGVhZGVycyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKG5vcm1hbGl6ZWRIZWFkZXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHNhbml0aXplZEhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gbm9ybWFsaXplZEhlYWRlcnNba2V5XTtcbiAgICB9KTtcbiAgICBjb25zdCB3ZWJob29rSWQgPSBzYW5pdGl6ZWRIZWFkZXJzW1wid2ViaG9vay1pZFwiXTtcbiAgICBpZiAodHlwZW9mIHdlYmhvb2tJZCAhPT0gXCJzdHJpbmdcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgd2ViaG9vay1pZCBoZWFkZXJcIik7XG4gICAgY29uc3QgdGltZXN0YW1wID0gc2FuaXRpemVkSGVhZGVyc1tcIndlYmhvb2stdGltZXN0YW1wXCJdO1xuICAgIGlmICh0eXBlb2YgdGltZXN0YW1wICE9PSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB3ZWJob29rLXRpbWVzdGFtcCBoZWFkZXJcIik7XG4gICAgY29uc3QgcmF3U2lnbmF0dXJlcyA9IHNhbml0aXplZEhlYWRlcnNbXCJ3ZWJob29rLXNpZ25hdHVyZVwiXTtcbiAgICBpZiAodHlwZW9mIHJhd1NpZ25hdHVyZXMgIT09IFwic3RyaW5nXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHdlYmhvb2stc2lnbmF0dXJlIGhlYWRlclwiKTtcbiAgICByZXR1cm4geyB3ZWJob29rSWQsIHRpbWVzdGFtcCwgcmF3U2lnbmF0dXJlcyB9O1xuICB9XG4gIC8qKlxuICAgKiBTaWducyB0aGUgY29udGVudCB3aXRoIHRoZSBzZWNyZXRcbiAgICogQHBhcmFtIGNvbnRlbnRcbiAgICogQHJldHVybnMgYHN0cmluZ2BcbiAgICovXG4gICNzaWduKGNvbnRlbnQpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3QgdG9TaWduID0gZW5jb2Rlci5lbmNvZGUoY29udGVudCk7XG4gICAgcmV0dXJuIGJhc2U2NC5lbmNvZGUoc2hhMjU2LmhtYWModGhpcy4jc2VjcmV0QnVmZmVyLCB0b1NpZ24pKTtcbiAgfVxuICAvKipcbiAgICogVmVyaWZpZXMgdGhhdCB0aGUgdGltZXN0YW1wIGlzIG5vdCB0b28gb2xkIG9yIGluIHRoZSBmdXR1cmVcbiAgICovXG4gICN2ZXJpZnlUaW1lc3RhbXAodGltZXN0YW1wSGVhZGVyKSB7XG4gICAgY29uc3Qgbm93ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKTtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBwYXJzZUludCh0aW1lc3RhbXBIZWFkZXIsIDEwKTtcbiAgICBpZiAoaXNOYU4odGltZXN0YW1wKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0aW1lc3RhbXBcIik7XG4gICAgfVxuICAgIGlmICh0aW1lc3RhbXAgPCBub3cgLSBXRUJIT09LX1RPTEVSQU5DRV9JTl9TRUNPTkRTKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaW1lc3RhbXAgdG9vIG9sZFwiKTtcbiAgICB9XG4gICAgaWYgKHRpbWVzdGFtcCA+IG5vdyArIFdFQkhPT0tfVE9MRVJBTkNFX0lOX1NFQ09ORFMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRpbWVzdGFtcCBpbiB0aGUgZnV0dXJlXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRW5zdXJlcyB0aGF0IHRoZSBldmVudCBpcyBhIGtub3duIGV2ZW50IHR5cGVcbiAgICogb3IgdGhyb3dzIGFuZCBwcm9tcHRzIHRoZSB1c2VyIHRvIHVwZ3JhZGUgdG8gYSBoaWdoZXIgdmVyc2lvbiBvZiBAbGl2ZWJsb2Nrcy9ub2RlXG4gICAqL1xuICAjdmVyaWZ5V2ViaG9va0V2ZW50VHlwZShldmVudCkge1xuICAgIGlmIChldmVudCAmJiBldmVudC50eXBlICYmIFtcbiAgICAgIFwic3RvcmFnZVVwZGF0ZWRcIixcbiAgICAgIFwidXNlckVudGVyZWRcIixcbiAgICAgIFwidXNlckxlZnRcIixcbiAgICAgIFwicm9vbUNyZWF0ZWRcIixcbiAgICAgIFwicm9vbURlbGV0ZWRcIixcbiAgICAgIFwiY29tbWVudENyZWF0ZWRcIixcbiAgICAgIFwiY29tbWVudEVkaXRlZFwiLFxuICAgICAgXCJjb21tZW50RGVsZXRlZFwiLFxuICAgICAgXCJjb21tZW50UmVhY3Rpb25BZGRlZFwiLFxuICAgICAgXCJjb21tZW50UmVhY3Rpb25SZW1vdmVkXCIsXG4gICAgICBcInRocmVhZE1ldGFkYXRhVXBkYXRlZFwiLFxuICAgICAgXCJ0aHJlYWRDcmVhdGVkXCIsXG4gICAgICBcInRocmVhZERlbGV0ZWRcIixcbiAgICAgIFwieWRvY1VwZGF0ZWRcIixcbiAgICAgIFwibm90aWZpY2F0aW9uXCIsXG4gICAgICBcInRocmVhZE1hcmtlZEFzUmVzb2x2ZWRcIixcbiAgICAgIFwidGhyZWFkTWFya2VkQXNVbnJlc29sdmVkXCJcbiAgICBdLmluY2x1ZGVzKGV2ZW50LnR5cGUpKSB7XG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJub3RpZmljYXRpb25cIikge1xuICAgICAgICBjb25zdCBub3RpZmljYXRpb24gPSBldmVudDtcbiAgICAgICAgaWYgKG5vdGlmaWNhdGlvbi5kYXRhLmtpbmQgPT09IFwidGhyZWFkXCIgfHwgbm90aWZpY2F0aW9uLmRhdGEua2luZCA9PT0gXCJ0ZXh0TWVudGlvblwiIHx8IGlzQ3VzdG9tS2luZChub3RpZmljYXRpb24uZGF0YS5raW5kKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVW5rbm93biBub3RpZmljYXRpb24ga2luZDogJHtKU09OLnN0cmluZ2lmeShub3RpZmljYXRpb24uZGF0YS5raW5kKX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlVua25vd24gZXZlbnQgdHlwZSwgcGxlYXNlIHVwZ3JhZGUgdG8gYSBoaWdoZXIgdmVyc2lvbiBvZiBAbGl2ZWJsb2Nrcy9ub2RlXCJcbiAgICApO1xuICB9XG59O1xudmFyIFdFQkhPT0tfVE9MRVJBTkNFX0lOX1NFQ09ORFMgPSA1ICogNjA7XG52YXIgaXNOb3RVbmRlZmluZWQgPSAodmFsdWUpID0+IHZhbHVlICE9PSB2b2lkIDA7XG52YXIgaXNDdXN0b21LaW5kID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUuc3RhcnRzV2l0aChcIiRcIik7XG59O1xuZnVuY3Rpb24gaXNUaHJlYWROb3RpZmljYXRpb25FdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQudHlwZSA9PT0gXCJub3RpZmljYXRpb25cIiAmJiBldmVudC5kYXRhLmtpbmQgPT09IFwidGhyZWFkXCI7XG59XG5mdW5jdGlvbiBpc1RleHRNZW50aW9uTm90aWZpY2F0aW9uRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUgPT09IFwibm90aWZpY2F0aW9uXCIgJiYgZXZlbnQuZGF0YS5raW5kID09PSBcInRleHRNZW50aW9uXCI7XG59XG5mdW5jdGlvbiBpc0N1c3RvbU5vdGlmaWNhdGlvbkV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50eXBlID09PSBcIm5vdGlmaWNhdGlvblwiICYmIGlzQ3VzdG9tS2luZChldmVudC5kYXRhLmtpbmQpO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7XG4gIGdldE1lbnRpb25lZElkc0Zyb21Db21tZW50Qm9keSxcbiAgaXNOb3RpZmljYXRpb25DaGFubmVsRW5hYmxlZCxcbiAgc3RyaW5naWZ5Q29tbWVudEJvZHlcbn0gZnJvbSBcIkBsaXZlYmxvY2tzL2NvcmVcIjtcbmRldGVjdER1cGVzKFBLR19OQU1FLCBQS0dfVkVSU0lPTiwgUEtHX0ZPUk1BVCk7XG5leHBvcnQge1xuICBMaXZlYmxvY2tzLFxuICBMaXZlYmxvY2tzRXJyb3IsXG4gIFdlYmhvb2tIYW5kbGVyLFxuICBnZXRNZW50aW9uZWRJZHNGcm9tQ29tbWVudEJvZHksXG4gIGlzQ3VzdG9tTm90aWZpY2F0aW9uRXZlbnQsXG4gIGlzTm90aWZpY2F0aW9uQ2hhbm5lbEVuYWJsZWQsXG4gIGlzVGV4dE1lbnRpb25Ob3RpZmljYXRpb25FdmVudCxcbiAgaXNUaHJlYWROb3RpZmljYXRpb25FdmVudCxcbiAgc3RyaW5naWZ5Q29tbWVudEJvZHlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@liveblocks/node/dist/index.js\n");

/***/ })

};
;